[{"path":"https://bioRgeo.github.io/bioregion/articles/a1_install_binary_files.html","id":"run-install_binaries","dir":"Articles","previous_headings":"","what":"1. Run install_binaries()","title":"1. Installation of the binary files","text":"function install_binaries run prior using netclu_infomap, Cpp version netclu_louvain netclu_oslom follows. function three parameters. binpath indicating path folder host bin folder containing binary files. default, binary files installed R’s temporary directory (binpath = \"tempdir\"). case bin folder automatically removed end R session. Alternatively, binary files can installed bioregion’s package folder (binpath = \"pkgfolder\"). folder can chosen case PLEASE MAKE SURE update binpath argument netclu_infomap, netclu_louvain netclu_oslom accordingly. Note case, case, download_only can set TRUE (first step executed), must ensure files necessary permissions executed programs otherwise. third parameter infomap_version indicating Infomap version(s) install. Infomap version 2.1.0, 2.6.0, 2.7.1 2.8.0 available now. installation binary files divided six steps: Download bin.zip Unzip bin.zip binpath Check permissions, try change automatically propose iterative process change manually Test Infomap running properly Test Louvain running properly Test OSLOM running properly function designed help change permissions third step. Subsequently, binary files Infomap, Louvain, OSLOM tested, file check.txt added folder bin/INFOMAP/X.X.X, bin/LOUVAIN bin/OSLOM inform package netclu_infomap, netclu_louvain netclu_oslom can used without issues. However, may happen (particularly macOS) function fails automatically manually assist changing permissions. case, set argument download_only TRUE download bin.zip folder myfolder choice (different tempdir pkgfolder) can manually change permissions . Note ; package able test binary files running netclu_infomap, netclu_louvain netclu_oslom (.e., check.txt added folders…). bypass automatic check using functions, use argument check_install = FALSE, without guarantee success.","code":"install_binaries(binpath = \"tempdir\" ,                  download_only =  FALSE,                  infomap_version = c(\"2.1.0\",                                       \"2.6.0\",                                      \"2.7.1\",                                      \"2.8.0\")) ## ## 1. Download bin.zip ## ## The folder has been successfully downloaded to /tmp/RtmpfS9jTX. ## ## 2. Unzip folder ## ## The folder has been successfully unzipped in /tmp/RtmpfS9jTX. ## ## 3. Check permissions ## ## Permission to execute /tmp/RtmpfS9jTX/bin/INFOMAP/2.1.0/infomap_omp_lin as program: denied. ## Permission to execute /tmp/RtmpfS9jTX/bin/INFOMAP/2.1.0/infomap_noomp_lin as program: denied. ## Permission to execute /tmp/RtmpfS9jTX/bin/INFOMAP/2.6.0/infomap_omp_lin as program: denied. ## Permission to execute /tmp/RtmpfS9jTX/bin/INFOMAP/2.6.0/infomap_noomp_lin as program: denied. ## Permission to execute /tmp/RtmpfS9jTX/bin/INFOMAP/2.7.1/infomap_omp_lin as program: denied. ## Permission to execute /tmp/RtmpfS9jTX/bin/INFOMAP/2.7.1/infomap_noomp_lin as program: denied. ## Permission to execute /tmp/RtmpfS9jTX/bin/INFOMAP/2.8.0/infomap_omp_lin as program: denied. ## Permission to execute /tmp/RtmpfS9jTX/bin/INFOMAP/2.8.0/infomap_noomp_lin as program: denied. ## Permission to execute /tmp/RtmpfS9jTX/bin/LOUVAIN/convert_lin as program: denied. ## Permission to execute /tmp/RtmpfS9jTX/bin/LOUVAIN/louvain_lin as program: denied. ## Permission to execute /tmp/RtmpfS9jTX/bin/OSLOM/oslom_dir_lin as program: denied. ## Permission to execute /tmp/RtmpfS9jTX/bin/OSLOM/oslom_undir_lin as program: denied. ## ## Try to change permissions automatically ## ## Automatic change of permission succeed, /tmp/RtmpfS9jTX/bin/INFOMAP/2.1.0/infomap_omp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpfS9jTX/bin/INFOMAP/2.1.0/infomap_noomp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpfS9jTX/bin/INFOMAP/2.6.0/infomap_omp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpfS9jTX/bin/INFOMAP/2.6.0/infomap_noomp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpfS9jTX/bin/INFOMAP/2.7.1/infomap_omp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpfS9jTX/bin/INFOMAP/2.7.1/infomap_noomp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpfS9jTX/bin/INFOMAP/2.8.0/infomap_omp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpfS9jTX/bin/INFOMAP/2.8.0/infomap_noomp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpfS9jTX/bin/LOUVAIN/convert_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpfS9jTX/bin/LOUVAIN/louvain_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpfS9jTX/bin/OSLOM/oslom_dir_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpfS9jTX/bin/OSLOM/oslom_undir_lin can now be executed as progam. ## ## 4. Test Infomap ## ## Congratulations, you successfully install the 2.1.0 OpenMP version of Infomap! ## Congratulations, you successfully install the 2.6.0 OpenMP version of Infomap! ## Congratulations, you successfully install the 2.7.1 OpenMP version of Infomap! ## Congratulations, you successfully install the 2.8.0 OpenMP version of Infomap! ## ## 5. Test Louvain ## ## Congratulations, you successfully install the version 0.3 of Louvain! ## ## 6. Test OSLOM ## ## Congratulations, you successfully install the version 2.5 of OSLOM! install_binaries(binpath = \"myfolder\" ,                  download_only =  TRUE,                  infomap_version = c(\"2.1.0\",                                       \"2.6.0\",                                      \"2.7.1\",                                      \"2.8.0\"))  comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_infomap(net,                       binpath = \"myfolder\",                       check_install = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a1_install_binary_files.html","id":"known-issues","dir":"Articles","previous_headings":"","what":"2. Known issues","title":"1. Installation of the binary files","text":"OpenMP versions Infomap require libomp-dev Ubuntu (sudo apt-get install libomp-dev) libomp macOS (install Homebrew run brew install libomp).","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a2_matrix_and_network_formats.html","id":"load-data","dir":"Articles","previous_headings":"","what":"1. Load data","title":"2. Matrix and network formats","text":"bioregion’s package contains example dataset spatial distribution Mediterranean vegetation. dataset analyzed article contains abundance 3,697 species 715 sites. dataset composed three files, vegedf data.frame 460,878 rows 3 columns (Site, Species Abundance), vegemat co-occurrence matrix containing information gathered matrix 715 rows 3,697 columns, vegesf spatial object containing geometry 715 sites.","code":"data(vegedf) head(vegedf) ##   Site Species Abundance ## 1   35   10017         1 ## 2   35   10024        18 ## 3   35   10034         1 ## 4   35   10035         1 ## 5   35   10056         2 ## 6   35   10080         3 dim(vegedf) ## [1] 460878      3 sum(!duplicated(vegedf[,1])) ## [1] 715 sum(!duplicated(vegedf[,2])) ## [1] 3697 data(vegemat) vegemat[1:10,1:10] ##     Species ## Site 10001 10002 10003 10004 10005 10006 10007 10008 10009 10010 ##   35     0     0     0     0     0     0     0     0     0     0 ##   36     2     0     0     0     0     0     1    12     0     0 ##   37     0     0     0     0     0     0     0     0     0     0 ##   38     0     0     0     0     0     0     0     0     0     0 ##   39     5     0     0     0     0     0     0     2     0     0 ##   84     0     0     0     0     0     0     0     0     0     0 ##   85     3     0     0     0     0     0     1     7     0     0 ##   86     0     0     0     2     0     0     2    22     0     0 ##   87    16     0     0     0     0     0     2    54     0     0 ##   88   228     0     0     0     0     0     0     5     0     0 dim(vegemat) ## [1]  715 3697"},{"path":"https://bioRgeo.github.io/bioregion/articles/a2_matrix_and_network_formats.html","id":"from-matrix-to-network","dir":"Articles","previous_headings":"","what":"2. From matrix to network","title":"2. Matrix and network formats","text":"function mat_to_net transforms co-occurrence matrix vegemat network represented data.frame (vegedf case). weight = TRUE third column added values contained matrix. line network format, two first columns named Node1 Node2 default. remove_zeroes = TRUE pairs nodes weight equal 0 removed output.","code":"net <- mat_to_net(vegemat, weight = TRUE, remove_zeroes = FALSE) head(net) ##   Node1 Node2 Weight ## 1    35 10001      0 ## 2    35 10002      0 ## 3    35 10003      0 ## 4    35 10004      0 ## 5    35 10005      0 ## 6    35 10006      0 dim(net) ## [1] 2643355       3 net <- mat_to_net(vegemat, weight = TRUE, remove_zeroes = TRUE) head(net) ##    Node1 Node2 Weight ## 17    35 10017      1 ## 24    35 10024     18 ## 34    35 10034      1 ## 35    35 10035      1 ## 56    35 10056      2 ## 80    35 10080      3 dim(net) ## [1] 460878      3"},{"path":"https://bioRgeo.github.io/bioregion/articles/a2_matrix_and_network_formats.html","id":"from-network-to-matrix","dir":"Articles","previous_headings":"","what":"3. From network to matrix","title":"2. Matrix and network formats","text":"function net_to_mat opposite. transforms network represented two- three-columns data.frame (vegedf) co-occurrence matrix (vegemat case). squared = TRUE squared matrix generated, rownames colnames correspond concatenation without duplicates two first columns data.frame. argument missing_value defines value assign pairs nodes present input network. default value 0 numeric value can used. Finally, squared = TRUE possible get symmetrical matrix output (symmetrical = TRUE). case resulting squared matrix symmetrical, except symmetrical pairs nodes already present input network (35 <-> 36) example .","code":"mat <- net_to_mat(vegedf, weight = TRUE, squared = FALSE, symmetrical = FALSE, missing_value = 0) mat[1:5,1:5] ##    10017 10024 10034 10035 10056 ## 35     1    18     1     1     2 ## 36   252    57    72    19    75 ## 37    66     1    13    23    43 ## 38    17     1     5    89    27 ## 39    17    17    34     3     8 dim(mat) ## [1]  715 3697 mat <- net_to_mat(vegedf, weight = TRUE, squared = TRUE, symmetrical = FALSE, missing_value = 0) mat[1:5,1:5] ##    35 36 37 38 39 ## 35  0  0  0  0  0 ## 36  0  0  0  0  0 ## 37  0  0  0  0  0 ## 38  0  0  0  0  0 ## 39  0  0  0  0  0 dim(mat) ## [1] 4412 4412 temp <- data.frame(Site=c(\"35\",\"36\",\"36\",\"38\",\"39\"), Species=c(\"36\",\"35\",\"37\",\"37\",\"39\"), Abundance=c(1,2,3,4,0)) net <- rbind(temp,vegedf) mat <- net_to_mat(net, weight = TRUE, squared = TRUE, symmetrical = FALSE, missing_value = -1) mat[1:5,1:5] ##    35 36 38 39 37 ## 35 -1  1 -1 -1 -1 ## 36  2 -1 -1 -1  3 ## 38 -1 -1 -1 -1  4 ## 39 -1 -1 -1  0 -1 ## 37 -1 -1 -1 -1 -1 mat <- net_to_mat(net, weight = TRUE, squared = TRUE, symmetrical = TRUE, missing_value = 0) mat[1:5,1:5] ##    35 36 38 39 37 ## 35  0  1  0  0  0 ## 36  2  0  0  0  3 ## 38  0  0  0  0  4 ## 39  0  0  0  0  0 ## 37  0  3  4  0  0"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"compute-pairwise-similarity-metrics","dir":"Articles","previous_headings":"","what":"1. Compute pairwise similarity metrics","title":"3. Pairwise similarity/dissimilarity metrics","text":"function similarity computes well-known customized pairwise similarity metrics based co-occurrence matrix, vegemat. example , Simpson similarity index computed pair sites. resulting data.frame stored bioregion.pairwise object, contains Simpson similarity metric pair sites. function similarity can handle three types metrics: metrics based abc, metrics based ABC, one metric based Euclidean distance. first kind metrics Jaccard, turnover component Jaccard (Baselga, 2012), Simpson Sørensen based presence data \\(\\) number species shared pair sites, \\(b\\) species present first site \\(c\\) species present second site. \\[\\displaystyle Jaccard = 1 - \\frac{b + c}{+ b + c}\\] \\[\\displaystyle Jaccardturn = 1 - \\frac{2 \\cdot min(b, c)}{+ 2 \\cdot min(b, c)}\\] \\[\\displaystyle Sorensen = 1 - \\frac{b + c}{2 \\cdot + b + c}\\] \\[\\displaystyle Simpson = 1 - \\frac{min(b, c)}{+ min(b, c)}\\] Two methods can used compute abc based metrics. first method based matrix product (performed tcrossprod function R package Matrix). method fast greedy memory… second method based three loops function coded C++ largely inspired bcdist function R package ecodist (version 2.0.7). less efficient matrix product allows handle co-occurrence matrix large number sites /species. second kind metrics Bray-Curtis turnover component Bray-Curtis (Baselga, 2012) based abundance data \\(\\) sum lesser values common species shared pair sites. \\(B\\) \\(C\\) total number specimens counted sites minus \\(\\). three loops function available ABC based metrics. \\[\\displaystyle Bray = 1 - \\frac{B + C}{2 \\cdot + B + C}\\] \\[\\displaystyle Brayturn = 1 - \\frac{min(B, C)}{+ min(B, C)}\\] main advantage similarity function compute return several metrics, allow computation customized metric formula argument include possibility returning quantities \\(\\), \\(b\\) \\(c\\) /\\(\\), \\(B\\) \\(C\\). feature particularly interesting compute similarity metrics large co-occurrence matrix. also possible compute Euclidean similarity pair sites following equation: \\[\\displaystyle Euclidean = \\frac{1}{1 + d_{ij}}\\] \\(d_{ij}\\) Euclidean distance site \\(\\) site \\(j\\) terms species composition.","code":"sim <- similarity(vegemat,                    metric = \"Simpson\",                    formula = NULL,                    method = \"prodmat\") sim[1:10,] ## Data.frame of similarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  3697  ##  - Number of rows:  255255  ##  - Number of similarity metrics:  1  ##  ##  ##    Site1 Site2   Simpson ## 2     35    36 0.9767442 ## 3     35    37 0.9689922 ## 4     35    38 0.9457364 ## 5     35    39 0.9457364 ## 6     35    84 0.2790698 ## 7     35    85 0.9147287 ## 8     35    86 1.0000000 ## 9     35    87 0.9922481 ## 10    35    88 0.9844961 ## 11    35    89 0.6821705 sim <- similarity(vegemat,                    metric = c(\"abc\",\"ABC\",\"Simpson\",\"Bray\"),                    formula = c(\"1 - pmin(b,c) / (a + pmin(b,c))\", \"1 - (B + C) / (2*A + B + C)\")) sim[1:10,] ## Data.frame of similarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  3697  ##  - Number of rows:  255255  ##  - Number of similarity metrics:  4  ##  ##  ##    Site1 Site2   Simpson       Bray   a  b   c   A   B     C ## 2     35    36 0.9767442 0.01901485 126  3 741 420   3 43333 ## 3     35    37 0.9689922 0.03745203 125  4 534 366  57 18756 ## 4     35    38 0.9457364 0.04025289 122  7 440 347  76 16471 ## 5     35    39 0.9457364 0.09754761 122  7 501 356  67  6520 ## 6     35    84 0.2790698 0.18757921  36 93 177  74 349   292 ## 7     35    85 0.9147287 0.13256181 118 11 614 378  45  4902 ## 8     35    86 1.0000000 0.02663928 129  0 753 415   8 30319 ## 9     35    87 0.9922481 0.02332663 128  1 909 406  17 33981 ## 10    35    88 0.9844961 0.02198536 127  2 812 395  28 35115 ## 11    35    89 0.6821705 0.15954416  88 41 177 196 227  1838 ##    1 - pmin(b,c) / (a + pmin(b,c)) 1 - (B + C) / (2*A + B + C) ## 2                        0.9767442                  0.01901485 ## 3                        0.9689922                  0.03745203 ## 4                        0.9457364                  0.04025289 ## 5                        0.9457364                  0.09754761 ## 6                        0.2790698                  0.18757921 ## 7                        0.9147287                  0.13256181 ## 8                        1.0000000                  0.02663928 ## 9                        0.9922481                  0.02332663 ## 10                       0.9844961                  0.02198536 ## 11                       0.6821705                  0.15954416"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"compute-pairwise-dissimilarity-metrics","dir":"Articles","previous_headings":"","what":"2. Compute pairwise dissimilarity metrics","title":"3. Pairwise similarity/dissimilarity metrics","text":"dissimilarity function similar, sole exception computes dissimilarity version available metrics. corresponds 1 minus similarity metrics, except Euclidean dissimilarity, corresponds Euclidean distance (.e. \\(d_{ij}\\)).","code":"dissim <- dissimilarity(vegemat,                          metric = \"Sorensen\",                          formula = \"(b + c) / (2*a + b + c)\") dissim[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  3697  ##  - Number of rows:  255255  ##  - Number of dissimilarity metrics:  2  ##  ##  ##    Site1 Site2  Sorensen (b + c) / (2*a + b + c) ## 2     35    36 0.7469880               0.7469880 ## 3     35    37 0.6827411               0.6827411 ## 4     35    38 0.6468886               0.6468886 ## 5     35    39 0.6755319               0.6755319 ## 6     35    84 0.7894737               0.7894737 ## 7     35    85 0.7259001               0.7259001 ## 8     35    86 0.7448071               0.7448071 ## 9     35    87 0.7804460               0.7804460 ## 10    35    88 0.7621723               0.7621723 ## 11    35    89 0.5532995               0.5532995"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"from-similarity-to-dissimilarity-and-vice-versa","dir":"Articles","previous_headings":"","what":"3. From similarity to dissimilarity (and vice versa)","title":"3. Pairwise similarity/dissimilarity metrics","text":"functions similarity_to_dissimilarity dissimilarity_to_similarity can used switch easily switch similarity dissimilarity metrics.","code":"sim1 <- similarity(vegemat,                    metric = c(\"abc\",\"Sorensen\"),                    formula = \"1 - (b + c) / (2*a + b + c)\") sim1[1:10,] ## Data.frame of similarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  3697  ##  - Number of rows:  255255  ##  - Number of similarity metrics:  2  ##  ##  ##    Site1 Site2  Sorensen   a  b   c 1 - (b + c) / (2*a + b + c) ## 2     35    36 0.2530120 126  3 741                   0.2530120 ## 3     35    37 0.3172589 125  4 534                   0.3172589 ## 4     35    38 0.3531114 122  7 440                   0.3531114 ## 5     35    39 0.3244681 122  7 501                   0.3244681 ## 6     35    84 0.2105263  36 93 177                   0.2105263 ## 7     35    85 0.2740999 118 11 614                   0.2740999 ## 8     35    86 0.2551929 129  0 753                   0.2551929 ## 9     35    87 0.2195540 128  1 909                   0.2195540 ## 10    35    88 0.2378277 127  2 812                   0.2378277 ## 11    35    89 0.4467005  88 41 177                   0.4467005 dissim1 <- dissimilarity(vegemat,                           metric = c(\"abc\",\"Sorensen\"),                           formula = \"(b + c) / (2*a + b + c)\") dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  3697  ##  - Number of rows:  255255  ##  - Number of dissimilarity metrics:  2  ##  ##  ##    Site1 Site2  Sorensen   a  b   c (b + c) / (2*a + b + c) ## 2     35    36 0.7469880 126  3 741               0.7469880 ## 3     35    37 0.6827411 125  4 534               0.6827411 ## 4     35    38 0.6468886 122  7 440               0.6468886 ## 5     35    39 0.6755319 122  7 501               0.6755319 ## 6     35    84 0.7894737  36 93 177               0.7894737 ## 7     35    85 0.7259001 118 11 614               0.7259001 ## 8     35    86 0.7448071 129  0 753               0.7448071 ## 9     35    87 0.7804460 128  1 909               0.7804460 ## 10    35    88 0.7621723 127  2 812               0.7621723 ## 11    35    89 0.5532995  88 41 177               0.5532995 dissim2 <- similarity_to_dissimilarity(sim1) dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  3697  ##  - Number of rows:  255255  ##  - Number of dissimilarity metrics:  2  ##  ##  ##    Site1 Site2  Sorensen   a  b   c 1 - (b + c) / (2*a + b + c) ## 2     35    36 0.7469880 126  3 741                   0.7469880 ## 3     35    37 0.6827411 125  4 534                   0.6827411 ## 4     35    38 0.6468886 122  7 440                   0.6468886 ## 5     35    39 0.6755319 122  7 501                   0.6755319 ## 6     35    84 0.7894737  36 93 177                   0.7894737 ## 7     35    85 0.7259001 118 11 614                   0.7259001 ## 8     35    86 0.7448071 129  0 753                   0.7448071 ## 9     35    87 0.7804460 128  1 909                   0.7804460 ## 10    35    88 0.7621723 127  2 812                   0.7621723 ## 11    35    89 0.5532995  88 41 177                   0.5532995 sim2 <- dissimilarity_to_similarity(dissim1) sim2[1:10,] ## Data.frame of similarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  3697  ##  - Number of rows:  255255  ##  - Number of similarity metrics:  2  ##  ##  ##    Site1 Site2  Sorensen   a  b   c (b + c) / (2*a + b + c) ## 2     35    36 0.2530120 126  3 741               0.2530120 ## 3     35    37 0.3172589 125  4 534               0.3172589 ## 4     35    38 0.3531114 122  7 440               0.3531114 ## 5     35    39 0.3244681 122  7 501               0.3244681 ## 6     35    84 0.2105263  36 93 177               0.2105263 ## 7     35    85 0.2740999 118 11 614               0.2740999 ## 8     35    86 0.2551929 129  0 753               0.2551929 ## 9     35    87 0.2195540 128  1 909               0.2195540 ## 10    35    88 0.2378277 127  2 812               0.2378277 ## 11    35    89 0.4467005  88 41 177               0.4467005"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"comparison-with-other-r-packages","dir":"Articles","previous_headings":"","what":"4. Comparison with other R packages","title":"3. Pairwise similarity/dissimilarity metrics","text":"bioregion R package allows computation similarity, dissimilarity, distance, \\(\\beta\\)-diversity metrics based (site-species) co-occurrence matrix. section, focus several functions provided packages adespatial, betapart, ecodist, vegan. table displays main differences packages terms dissimilarity metric computation. bioregion package one allows computation several metrics returned data.frame network format. also supports use custom formulas based , b, c, , B C components. flexibility also available vegan via designdist function. bioregion also allows computation , b, c, , B C components. Users can choose extract none components, three abc components, three ABC components, six components. components (abc ABC separately) can also accessed adespatial using beta.div.comp function, betapart using betapart.core betapart.core.abund. Finally, vegan package, via designdist function, also allows extraction , b, c, , B C components separately.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"basic-comparison-jaccard-and-bray-curtis","dir":"Articles","previous_headings":"4. Comparison with other R packages","what":"4.1 Basic comparison (Jaccard and Bray-Curtis)","title":"3. Pairwise similarity/dissimilarity metrics","text":"first present basic comparison computation two well-known metrics, Jaccard Bray-Curtis, based small co-occurrence matrix.","code":"nbsite <- 100 nbsp <- 200  set.seed(1) comat <- matrix(runif(nbsite*nbsp), nbsite, nbsp) rownames(comat) <- paste0(\"s\", 1:nbsite) colnames(comat) <- paste0(\"sp\", 1:nbsp)  comatbin <- comat comatbin[comat > 0.7] <- 1 comatbin[comat <= 0.7] <- 0"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"jaccard","dir":"Articles","previous_headings":"4. Comparison with other R packages > 4.1 Basic comparison (Jaccard and Bray-Curtis)","what":"4.1.1 Jaccard","title":"3. Pairwise similarity/dissimilarity metrics","text":"propose comparison computation time generating Jaccard dissimilarity matrix based comatbin defined . noted output beta.div dissimilarityrequires additional step obtain dissimilarity matrix. Specifically, beta.div returns root mean square desired quantity, shown , dissimilarity outputs metric network (data.frame) format, supports computation multiple metrics. beta.pair function used betapart package. Two functions, distance bcdist, used ecodist package. also use two available functions, vegdist designdist, vegan package. ensuring functions return dissimilarity matrix, proceed comparison computation times. small example, functions vegan outperform others terms computation time. followed bcdist beta.pair. dissimilarity function performs slightly slower, partly due additional reformatting step (matrix network back). distance beta.div functions rank significantly lower terms speed.","code":"dissim <- list()  comp_j <- microbenchmark(      adespatial = { d <- beta.div(comatbin,                                 method = \"jaccard\",                                samp = FALSE,                                nperm = 1,                                save.D = TRUE)    d <- as.matrix(d$D)   d <- d*d   dissim$adespatial <- d},      betapart = { d <- beta.pair(comatbin,                                index.family = \"jaccard\")   d <- as.matrix(d$beta.jac)   dissim$betapart <- d},      bioregion = { d <- dissimilarity(comatbin,                                     metric = \"Jaccard\")   d <- net_to_mat(d,                      weight = TRUE,                   squared = TRUE,                   symmetrical = TRUE)   dissim$bioregion <- d },      ecodist_dist = { d <- distance(comatbin,                                   method = \"jaccard\")   d <- as.matrix(d)   dissim$ecodist_dist <- d },      ecodist_bcdist = { d <- bcdist(comatbin)   d <- as.matrix(d)   dissim$ecodist_bcdist <- d },      vegan_veg = { d <- vegdist(comatbin,                              method = \"jaccard\")   d <- as.matrix(d)   dissim$vegan_veg <- d },      vegan_design = { d <- designdist(comatbin,                                    method = \"(A+B-2*J)/(A+B-J)\",                                    terms = \"binary\")   d <- as.matrix(d)   dissim$vegan_design <- d },      times = 10 ) all_identical <- all(   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$betapart, digits=4)),   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$bioregion, digits=4)),   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$ecodist_dist , digits=4)),   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$ecodist_bcdist , digits=4)),   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$vegan_veg, digits=4)),   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$vegan_design, digits=4)) ) print(all_identical) ## [1] TRUE comp_j ## Unit: milliseconds ##            expr        min         lq       mean     median         uq ##      adespatial 296.907517 301.191539 303.669074 302.905555 306.693846 ##        betapart   1.646856   1.738056   1.860855   1.833875   1.947107 ##       bioregion  10.368505  14.583478  16.241807  15.541331  16.484408 ##    ecodist_dist 126.396853 154.946897 182.794995 159.099537 160.471044 ##  ecodist_bcdist   3.333437   3.578403   3.573953   3.607333   3.634498 ##       vegan_veg   1.234306   1.306480   1.913195   2.259786   2.266623 ##    vegan_design   1.229527   1.269692   1.358859   1.307752   1.350753 ##         max neval ##  312.393411    10 ##    2.238521    10 ##   28.268157    10 ##  451.054210    10 ##    3.647012    10 ##    2.293633    10 ##    1.819378    10"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"bray-curtis","dir":"Articles","previous_headings":"4. Comparison with other R packages > 4.1 Basic comparison (Jaccard and Bray-Curtis)","what":"4.1.2 Bray-Curtis","title":"3. Pairwise similarity/dissimilarity metrics","text":"present similar example using Bray-Curtis dissimilarity metric, based comat defined . ensuring functions return dissimilarity matrix, proceed comparison computation times. functions vegan continue outperform others. followed bcdist, dissimilarity function remains slightly slower. distance beta.div functions, joined beta.pair.abund, rank significantly lower terms computation speed.","code":"dissim <- list()  comp_bc <- microbenchmark(      adespatial = { d <- beta.div(comat,                                 method = \"percentdiff\",                                samp = FALSE,                                nperm = 1,                                save.D = TRUE)    d <- as.matrix(d$D)   d <- d*d   dissim$adespatial <- d},      betapart = { d <- beta.pair.abund(comat,                                      index.family = \"bray\")   d <- as.matrix(d$beta.bray)   dissim$betapart <- d},      bioregion = { d <- dissimilarity(comatbin,                                     metric = \"Bray\")   d <- net_to_mat(d,                      weight = TRUE,                   squared = TRUE,                   symmetrical = TRUE)   dissim$bioregion <- d },      ecodist_dist = { d <- distance(comat,                                   method = \"bray-curtis\")   d <- as.matrix(d)   dissim$ecodist_dist <- d },      ecodist_bcdist = { d <- bcdist(comat)   d <- as.matrix(d)   dissim$ecodist_bcdist <- d },      vegan_veg = { d <- vegdist(comatbin,                              method = \"bray\")   d <- as.matrix(d)   dissim$vegan_veg <- d },      vegan_design = { d <- designdist(comat,                                    method = \"(A+B-2*J)/(A+B)\",                                    terms = \"minimum\")   d <- as.matrix(d)   dissim$vegan_design <- d },      times = 10 ) all_identical <- all(   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$betapart, digits=4)),   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$bioregion, digits=4)),   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$ecodist_dist , digits=4)),   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$ecodist_bcdist , digits=4)),   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$vegan_veg, digits=4)),   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$vegan_design, digits=4)) ) print(all_identical) ## [1] TRUE comp_bc ## Unit: milliseconds ##            expr        min         lq       mean     median         uq ##      adespatial 303.054479 308.817152 313.616185 313.379052 319.856370 ##        betapart 308.624221 317.729418 331.919490 322.274576 353.055727 ##       bioregion  10.220709  10.455448  12.824535  10.806178  13.920990 ##    ecodist_dist  90.074153 100.321251 137.441729 103.288494 121.522038 ##  ecodist_bcdist   5.992372   6.000507   6.104524   6.091192   6.187287 ##       vegan_veg   1.208658   1.258190   1.661187   1.307848   2.260311 ##    vegan_design   1.227864   1.278277   1.417045   1.378019   1.612872 ##         max neval ##  322.466455    10 ##  362.776623    10 ##   25.601576    10 ##  409.272133    10 ##    6.296760    10 ##    2.265902    10 ##    1.649060    10"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"systematic-comparison-jaccard-and-bray-curtis","dir":"Articles","previous_headings":"4. Comparison with other R packages","what":"4.2 Systematic comparison (Jaccard and Bray-Curtis)","title":"3. Pairwise similarity/dissimilarity metrics","text":"differences computation times become noticeable (site-species) co-occurrence matrix objects significant size. better understand computation times matrices, perform similar experiment using subset functions (beta.pair beta.pair.abund, dissimilarity, bcdist, vegdist, designdist) datasets varying numbers sites species. plot shows results obtained Jaccard dissimilarity metric based 16 combinations numbers sites species (chosen among 500, 1000, 2000, 5000), averaged three replications. also include results single simulation 10,000 sites species. similar plot showing results obtained Bray-Curtis dissimilarity metric available . case, results based single simulation 10,000 sites species exclude beta.pair.abund took much time compute.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"importing-pairwise-dissimilarity-metrics-from-other-packages-into-bioregion","dir":"Articles","previous_headings":"","what":"5. Importing pairwise (dis)similarity metrics from other packages into bioregion","title":"3. Pairwise similarity/dissimilarity metrics","text":"enable conversion (dis)similarity metrics stored base R objects outputs packages bioregion.pairwise object compatible bioregion package, developed as_bioregion_pairwise() function. function can take input matrix, dist object, list also outputs 10 functions provided packages adespatial, betapart, ecodist vegan described .","code":"dissim1 <- dissimilarity(vegemat,                           metric = \"Euclidean\") dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  3697  ##  - Number of rows:  255255  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2 Euclidean ## 2     35    36 3262.6011 ## 3     35    37 1378.7897 ## 4     35    38 1275.4031 ## 5     35    39  485.7993 ## 6     35    84   66.2948 ## 7     35    85  354.5885 ## 8     35    86 2311.7883 ## 9     35    87 2039.7632 ## 10    35    88 2239.1117 ## 11    35    89  226.8237 dissim2 <- as_bioregion_pairwise(dist(vegemat),                                  metric_name = \"Euclidean\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  NA  ##  - Number of rows:  255255  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2 Euclidean ## 2     35    36 3262.6011 ## 3     35    37 1378.7897 ## 4     35    38 1275.4031 ## 5     35    39  485.7993 ## 6     35    84   66.2948 ## 7     35    85  354.5885 ## 8     35    86 2311.7883 ## 9     35    87 2039.7632 ## 10    35    88 2239.1117 ## 11    35    89  226.8237"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"adespatialbeta-div","dir":"Articles","previous_headings":"5. Importing pairwise (dis)similarity metrics from other packages into bioregion","what":"5.1 adespatial::beta.div","title":"3. Pairwise similarity/dissimilarity metrics","text":"","code":"dissim1 <- dissimilarity(comat,                           metric = \"Euclidean\") dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  200  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2 Euclidean ## 2     s1    s2  5.663259 ## 3     s1    s3  6.174723 ## 4     s1    s4  6.273630 ## 5     s1    s5  6.143276 ## 6     s1    s6  5.545510 ## 7     s1    s7  6.024138 ## 8     s1    s8  6.124431 ## 9     s1    s9  5.548479 ## 10    s1   s10  6.362439 ## 11    s1   s11  6.001393 dissim2 <- as_bioregion_pairwise(beta.div(comat,                                           method = \"euclidean\",                                           save.D = TRUE),                                  pkg = \"adespatial\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2 euclidean ## 2     s1    s2  5.663259 ## 3     s1    s3  6.174723 ## 4     s1    s4  6.273630 ## 5     s1    s5  6.143276 ## 6     s1    s6  5.545510 ## 7     s1    s7  6.024138 ## 8     s1    s8  6.124431 ## 9     s1    s9  5.548479 ## 10    s1   s10  6.362439 ## 11    s1   s11  6.001393"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"adespatialbeta-div-comp","dir":"Articles","previous_headings":"5. Importing pairwise (dis)similarity metrics from other packages into bioregion","what":"5.2 adespatial::beta.div.comp","title":"3. Pairwise similarity/dissimilarity metrics","text":"","code":"dissim1 <- dissimilarity(comatbin,                           metric = c(\"Jaccard\",\"abc\")) dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  200  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2   Jaccard  a  b  c ## 2     s1    s2 0.7708333 22 37 37 ## 3     s1    s3 0.8666667 14 45 46 ## 4     s1    s4 0.8679245 14 45 47 ## 5     s1    s5 0.8543689 15 44 44 ## 6     s1    s6 0.7843137 22 37 43 ## 7     s1    s7 0.8392857 18 41 53 ## 8     s1    s8 0.8256881 19 40 50 ## 9     s1    s9 0.8105263 18 41 36 ## 10    s1   s10 0.8842105 11 48 36 ## 11    s1   s11 0.8666667 14 45 46 dissim2 <- as_bioregion_pairwise(beta.div.comp(comatbin,                                                save.abc = TRUE),                                  pkg = \"adespatial\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2 Podani family, Jaccard  a  b  c ## 2     s1    s2              0.7708333 22 37 37 ## 3     s1    s3              0.8666667 14 45 46 ## 4     s1    s4              0.8679245 14 45 47 ## 5     s1    s5              0.8543689 15 44 44 ## 6     s1    s6              0.7843137 22 37 43 ## 7     s1    s7              0.8392857 18 41 53 ## 8     s1    s8              0.8256881 19 40 50 ## 9     s1    s9              0.8105263 18 41 36 ## 10    s1   s10              0.8842105 11 48 36 ## 11    s1   s11              0.8666667 14 45 46"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"betapartbeta-pair","dir":"Articles","previous_headings":"5. Importing pairwise (dis)similarity metrics from other packages into bioregion","what":"5.3 betapart::beta.pair","title":"3. Pairwise similarity/dissimilarity metrics","text":"","code":"dissim1 <- dissimilarity(comatbin,                           metric = c(\"Jaccard\",\"Jaccardturn\")) dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  200  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  2  ##  ##  ##    Site1 Site2   Jaccard Jaccardturn ## 2     s1    s2 0.7708333   0.7708333 ## 3     s1    s3 0.8666667   0.8653846 ## 4     s1    s4 0.8679245   0.8653846 ## 5     s1    s5 0.8543689   0.8543689 ## 6     s1    s6 0.7843137   0.7708333 ## 7     s1    s7 0.8392857   0.8200000 ## 8     s1    s8 0.8256881   0.8080808 ## 9     s1    s9 0.8105263   0.8000000 ## 10    s1   s10 0.8842105   0.8674699 ## 11    s1   s11 0.8666667   0.8653846 dissim2 <- as_bioregion_pairwise(beta.pair(comatbin,                                            index.family = \"jaccard\"),                                  pkg = \"betapart\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  3  ##  ##  ##    Site1 Site2  beta.jtu    beta.jne  beta.jac ## 2     s1    s2 0.7708333 0.000000000 0.7708333 ## 3     s1    s3 0.8653846 0.001282051 0.8666667 ## 4     s1    s4 0.8653846 0.002539913 0.8679245 ## 5     s1    s5 0.8543689 0.000000000 0.8543689 ## 6     s1    s6 0.7708333 0.013480392 0.7843137 ## 7     s1    s7 0.8200000 0.019285714 0.8392857 ## 8     s1    s8 0.8080808 0.017607265 0.8256881 ## 9     s1    s9 0.8000000 0.010526316 0.8105263 ## 10    s1   s10 0.8674699 0.016740647 0.8842105 ## 11    s1   s11 0.8653846 0.001282051 0.8666667"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"betapartbeta-pair-abund","dir":"Articles","previous_headings":"5. Importing pairwise (dis)similarity metrics from other packages into bioregion","what":"5.4 betapart::beta.pair.abund","title":"3. Pairwise similarity/dissimilarity metrics","text":"","code":"dissim1 <- dissimilarity(comat,                           metric = c(\"Brayturn\",\"Bray\")) dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  200  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  2  ##  ##  ##    Site1 Site2      Bray  Brayturn ## 1     s1    s2 0.3109486 0.2907499 ## 2     s1    s3 0.3551275 0.3484112 ## 3     s1    s4 0.3662292 0.3527945 ## 4     s1    s5 0.3644193 0.3607606 ## 5     s1    s6 0.3053786 0.3002943 ## 6     s1    s7 0.3455313 0.3324551 ## 7     s1    s8 0.3469113 0.3299002 ## 8     s1    s9 0.3184678 0.3143748 ## 9     s1   s10 0.4017243 0.3617546 ## 10    s1   s11 0.3523224 0.3505070 dissim2 <- as_bioregion_pairwise(beta.pair.abund(comat,                                                  index.family = \"bray\"),                                  pkg = \"betapart\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  3  ##  ##  ##    Site1 Site2 beta.bray.bal beta.bray.gra beta.bray ## 2     s1    s2     0.2907499   0.020198660 0.3109486 ## 3     s1    s3     0.3484112   0.006716346 0.3551275 ## 4     s1    s4     0.3527945   0.013434676 0.3662292 ## 5     s1    s5     0.3607606   0.003658700 0.3644193 ## 6     s1    s6     0.3002943   0.005084275 0.3053786 ## 7     s1    s7     0.3324551   0.013076199 0.3455313 ## 8     s1    s8     0.3299002   0.017011065 0.3469113 ## 9     s1    s9     0.3143748   0.004093053 0.3184678 ## 10    s1   s10     0.3617546   0.039969771 0.4017243 ## 11    s1   s11     0.3505070   0.001815369 0.3523224"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"betapartbetapart-core","dir":"Articles","previous_headings":"5. Importing pairwise (dis)similarity metrics from other packages into bioregion","what":"5.5 betapart::betapart.core","title":"3. Pairwise similarity/dissimilarity metrics","text":"","code":"dissim1 <- dissimilarity(comatbin,                           metric = \"abc\",                          formula = c(\"pmin(b,c)\",\"pmax(b,c)\",\"b+c\")) dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  200  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  3  ##  ##  ##    Site1 Site2  a  b  c pmin(b,c) pmax(b,c) b+c ## 2     s1    s2 22 37 37        37        37  74 ## 3     s1    s3 14 45 46        45        46  91 ## 4     s1    s4 14 45 47        45        47  92 ## 5     s1    s5 15 44 44        44        44  88 ## 6     s1    s6 22 37 43        37        43  80 ## 7     s1    s7 18 41 53        41        53  94 ## 8     s1    s8 19 40 50        40        50  90 ## 9     s1    s9 18 41 36        36        41  77 ## 10    s1   s10 11 48 36        36        48  84 ## 11    s1   s11 14 45 46        45        46  91 dissim2 <- as_bioregion_pairwise(betapart.core(comatbin),                                  pkg = \"betapart\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  3  ##  ##  ##    Site1 Site2  a  b  c min(b,c) max(b,c) sum(b,c) ## 2     s1    s2 22 37 37       37       37       74 ## 3     s1    s3 14 45 46       45       46       91 ## 4     s1    s4 14 45 47       45       47       92 ## 5     s1    s5 15 44 44       44       44       88 ## 6     s1    s6 22 37 43       37       43       80 ## 7     s1    s7 18 41 53       41       53       94 ## 8     s1    s8 19 40 50       40       50       90 ## 9     s1    s9 18 41 36       36       41       77 ## 10    s1   s10 11 48 36       36       48       84 ## 11    s1   s11 14 45 46       45       46       91"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"betapartbetapart-core-abund","dir":"Articles","previous_headings":"5. Importing pairwise (dis)similarity metrics from other packages into bioregion","what":"5.6 betapart::betapart.core.abund","title":"3. Pairwise similarity/dissimilarity metrics","text":"","code":"dissim1 <- dissimilarity(comat,                           metric = \"ABC\",                          formula = c(\"pmin(B,C)\",\"pmax(B,C)\",\"B+C\")) dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  200  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  3  ##  ##  ##    Site1 Site2        A        B        C pmin(B,C) pmax(B,C)      B+C ## 2     s1    s2 70.62846 28.95342 34.79166  28.95342  34.79166 63.74508 ## 3     s1    s3 64.88645 34.69544 36.76973  34.69544  36.76973 71.46517 ## 4     s1    s4 64.44994 35.13194 39.35382  35.13194  39.35382 74.48576 ## 5     s1    s5 62.93214 36.64975 35.51632  35.51632  36.64975 72.16607 ## 6     s1    s6 69.67801 29.90388 31.36165  29.90388  31.36165 61.26553 ## 7     s1    s7 66.47538 33.10650 37.08577  33.10650  37.08577 70.19227 ## 8     s1    s8 66.72980 32.85209 38.03973  32.85209  38.03973 70.89181 ## 9     s1    s9 67.46550 32.11639 30.93447  30.93447  32.11639 63.05086 ## 10    s1   s10 56.06630 43.51559 31.77812  31.77812  43.51559 75.29371 ## 11    s1   s11 64.31719 35.26470 34.70958  34.70958  35.26470 69.97427 dissim2 <- as_bioregion_pairwise(betapart.core.abund(comat),                                  pkg = \"betapart\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  3  ##  ##  ##    Site1 Site2        A min(B,C) max(B,C) sum(B,C) ## 2     s1    s2 70.62846 28.95342 34.79166 63.74508 ## 3     s1    s3 64.88645 34.69544 36.76973 71.46517 ## 4     s1    s4 64.44994 35.13194 39.35382 74.48576 ## 5     s1    s5 62.93214 35.51632 36.64975 72.16607 ## 6     s1    s6 69.67801 29.90388 31.36165 61.26553 ## 7     s1    s7 66.47538 33.10650 37.08577 70.19227 ## 8     s1    s8 66.72980 32.85209 38.03973 70.89181 ## 9     s1    s9 67.46550 30.93447 32.11639 63.05086 ## 10    s1   s10 56.06630 31.77812 43.51559 75.29371 ## 11    s1   s11 64.31719 34.70958 35.26470 69.97427"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"ecodistdistance","dir":"Articles","previous_headings":"5. Importing pairwise (dis)similarity metrics from other packages into bioregion","what":"5.7 ecodist::distance","title":"3. Pairwise similarity/dissimilarity metrics","text":"","code":"dissim1 <- dissimilarity(comatbin,                           metric = \"Jaccard\") dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  200  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2   Jaccard ## 2     s1    s2 0.7708333 ## 3     s1    s3 0.8666667 ## 4     s1    s4 0.8679245 ## 5     s1    s5 0.8543689 ## 6     s1    s6 0.7843137 ## 7     s1    s7 0.8392857 ## 8     s1    s8 0.8256881 ## 9     s1    s9 0.8105263 ## 10    s1   s10 0.8842105 ## 11    s1   s11 0.8666667 dissim2 <- as_bioregion_pairwise(distance(comatbin,                                           method=\"jaccard\"),                                  pkg = \"ecodist\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2   jaccard ## 2     s1    s2 0.7708333 ## 3     s1    s3 0.8666667 ## 4     s1    s4 0.8679245 ## 5     s1    s5 0.8543689 ## 6     s1    s6 0.7843137 ## 7     s1    s7 0.8392857 ## 8     s1    s8 0.8256881 ## 9     s1    s9 0.8105263 ## 10    s1   s10 0.8842105 ## 11    s1   s11 0.8666667"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"ecodistbcdist","dir":"Articles","previous_headings":"5. Importing pairwise (dis)similarity metrics from other packages into bioregion","what":"5.8 ecodist::bcdist","title":"3. Pairwise similarity/dissimilarity metrics","text":"","code":"dissim1 <- dissimilarity(comat,                           metric = \"Bray\") dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  200  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2      Bray ## 1     s1    s2 0.3109486 ## 2     s1    s3 0.3551275 ## 3     s1    s4 0.3662292 ## 4     s1    s5 0.3644193 ## 5     s1    s6 0.3053786 ## 6     s1    s7 0.3455313 ## 7     s1    s8 0.3469113 ## 8     s1    s9 0.3184678 ## 9     s1   s10 0.4017243 ## 10    s1   s11 0.3523224 dissim2 <- as_bioregion_pairwise(bcdist(comat),                                  pkg = \"ecodist\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2 bray-curtis ## 2     s1    s2   0.3109486 ## 3     s1    s3   0.3551275 ## 4     s1    s4   0.3662292 ## 5     s1    s5   0.3644193 ## 6     s1    s6   0.3053786 ## 7     s1    s7   0.3455313 ## 8     s1    s8   0.3469113 ## 9     s1    s9   0.3184678 ## 10    s1   s10   0.4017243 ## 11    s1   s11   0.3523224"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"veganvegdist","dir":"Articles","previous_headings":"5. Importing pairwise (dis)similarity metrics from other packages into bioregion","what":"5.9 vegan::vegdist","title":"3. Pairwise similarity/dissimilarity metrics","text":"","code":"dissim1 <- dissimilarity(comatbin,                           metric = \"Jaccard\") dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  200  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2   Jaccard ## 2     s1    s2 0.7708333 ## 3     s1    s3 0.8666667 ## 4     s1    s4 0.8679245 ## 5     s1    s5 0.8543689 ## 6     s1    s6 0.7843137 ## 7     s1    s7 0.8392857 ## 8     s1    s8 0.8256881 ## 9     s1    s9 0.8105263 ## 10    s1   s10 0.8842105 ## 11    s1   s11 0.8666667 dissim2 <- as_bioregion_pairwise(vegdist(comatbin,                                          method=\"jaccard\"),                                  pkg = \"vegan\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2   jaccard ## 2     s1    s2 0.7708333 ## 3     s1    s3 0.8666667 ## 4     s1    s4 0.8679245 ## 5     s1    s5 0.8543689 ## 6     s1    s6 0.7843137 ## 7     s1    s7 0.8392857 ## 8     s1    s8 0.8256881 ## 9     s1    s9 0.8105263 ## 10    s1   s10 0.8842105 ## 11    s1   s11 0.8666667"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"vegandesigndist","dir":"Articles","previous_headings":"5. Importing pairwise (dis)similarity metrics from other packages into bioregion","what":"5.10 vegan::designdist","title":"3. Pairwise similarity/dissimilarity metrics","text":"","code":"dissim1 <- dissimilarity(comat,                           metric = \"Bray\",                          formula = \"(B + C) / (2*A + B + C)\") dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  200  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  2  ##  ##  ##    Site1 Site2      Bray (B + C) / (2*A + B + C) ## 1     s1    s2 0.3109486               0.3109486 ## 2     s1    s3 0.3551275               0.3551275 ## 3     s1    s4 0.3662292               0.3662292 ## 4     s1    s5 0.3644193               0.3644193 ## 5     s1    s6 0.3053786               0.3053786 ## 6     s1    s7 0.3455313               0.3455313 ## 7     s1    s8 0.3469113               0.3469113 ## 8     s1    s9 0.3184678               0.3184678 ## 9     s1   s10 0.4017243               0.4017243 ## 10    s1   s11 0.3523224               0.3523224 dissim2 <- as_bioregion_pairwise(designdist(comat,                                             method = \"(A+B-2*J)/(A+B)\",                                             terms = \"minimum\"),                                  pkg = \"vegan\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2 minimum (A+B-2*J)/(A+B) ## 2     s1    s2               0.3109486 ## 3     s1    s3               0.3551275 ## 4     s1    s4               0.3662292 ## 5     s1    s5               0.3644193 ## 6     s1    s6               0.3053786 ## 7     s1    s7               0.3455313 ## 8     s1    s8               0.3469113 ## 9     s1    s9               0.3184678 ## 10    s1   s10               0.4017243 ## 11    s1   s11               0.3523224"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"combine-and-enrich-dissimilarity-objects","dir":"Articles","previous_headings":"","what":"6. Combine and enrich (dis)similarity objects","title":"3. Pairwise similarity/dissimilarity metrics","text":"also possible use function bind_pairwise() combine two bioregion.pairwise objects /compute new pairwise metrics based columns object(s). function particularly useful deriving new metrics components \\(\\), \\(b\\), \\(c\\), /\\(\\), \\(B\\), \\(C\\), especially components required significant computation time.","code":"dissim1 <- dissimilarity(comat,                           metric = c(\"ABC\",\"Bray\"),                          formula = \"(B + C) / (2*A + B + C)\")  dissim2 <- as_bioregion_pairwise(designdist(comat,                                             method = \"(A+B-2*J)/(A+B)\",                                             terms = \"minimum\"),                                  pkg = \"vegan\")  dissim <- bind_pairwise(primary_metrics = dissim1,                                      secondary_metrics = dissim2,                                      new_metrics = c(\"(B + C) / (2*A + B + C)\",                                                      \"Bray*Bray\"))  dissim[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  5  ##  ##  ##    Site1 Site2      Bray        A        B        C (B + C) / (2*A + B + C) ## 1     s1    s2 0.3109486 70.62846 28.95342 34.79166               0.3109486 ## 2     s1    s3 0.3551275 64.88645 34.69544 36.76973               0.3551275 ## 3     s1    s4 0.3662292 64.44994 35.13194 39.35382               0.3662292 ## 4     s1    s5 0.3644193 62.93214 36.64975 35.51632               0.3644193 ## 5     s1    s6 0.3053786 69.67801 29.90388 31.36165               0.3053786 ## 6     s1    s7 0.3455313 66.47538 33.10650 37.08577               0.3455313 ## 7     s1    s8 0.3469113 66.72980 32.85209 38.03973               0.3469113 ## 8     s1    s9 0.3184678 67.46550 32.11639 30.93447               0.3184678 ## 9     s1   s10 0.4017243 56.06630 43.51559 31.77812               0.4017243 ## 10    s1   s11 0.3523224 64.31719 35.26470 34.70958               0.3523224 ##    minimum (A+B-2*J)/(A+B) (B + C) / (2*A + B + C)  Bray*Bray ## 1                0.3109486               0.3109486 0.09668901 ## 2                0.3551275               0.3551275 0.12611554 ## 3                0.3662292               0.3662292 0.13412382 ## 4                0.3644193               0.3644193 0.13280139 ## 5                0.3053786               0.3053786 0.09325609 ## 6                0.3455313               0.3455313 0.11939186 ## 7                0.3469113               0.3469113 0.12034745 ## 8                0.3184678               0.3184678 0.10142177 ## 9                0.4017243               0.4017243 0.16138245 ## 10               0.3523224               0.3523224 0.12413106"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"compute-dissimilarity-indices-from-input-data","dir":"Articles","previous_headings":"","what":"1. Compute dissimilarity indices from input data","title":"4.1 Hierarchical clustering","text":"initiate hierarchical clustering procedure, need provide pairwise distances sites. pairwise distances sites can obtained running dissimilarity() species-site matrix, presence-absence abundance matrix. example , use vegetation dataset package compute distance metrics. going compute \\(\\beta_{sim}\\) diversity metric, presence-absence dissimilarity index. formula follows: \\(\\beta_{sim} = min(b, c) / (+min(b, c))\\) number species shared sites; b number species occurring first site; c number species occurring second site. typically choose metric bioregionalization, turnover component Sorensen index (Baselga, 2012) (nutshell, tells us sites different distinct species), less dependent species richness Jaccard turnover (Leprieur & Oikonomou, 2014). Alternatively, given abundance data , also use Bray-Curtis turnover index (Baselga, 2013). choice distance metric important outcome clustering procedure, recommend choose carefully depending research question. default, Simpson index computed, options available metric argument dissimilarity(). Furthermore, users can also write formula compute index want argument formula, see ?dissimilarity(). now ready start hierarchical clustering procedure object dissim just created. Alternatively, can also use types objects hclu_hierarclust(), distance matrix object (class dist) data.frame crafting (make sure read required format carefully ?hclu_hierarclust).","code":"library(\"bioregion\")  # Work with the vegetation dataset we include in the package data(vegemat)  # This is an abundance matrix where sites are in rows and species in columns vegemat[1:10, 1:10] ##     Species ## Site 10001 10002 10003 10004 10005 10006 10007 10008 10009 10010 ##   35     0     0     0     0     0     0     0     0     0     0 ##   36     2     0     0     0     0     0     1    12     0     0 ##   37     0     0     0     0     0     0     0     0     0     0 ##   38     0     0     0     0     0     0     0     0     0     0 ##   39     5     0     0     0     0     0     0     2     0     0 ##   84     0     0     0     0     0     0     0     0     0     0 ##   85     3     0     0     0     0     0     1     7     0     0 ##   86     0     0     0     2     0     0     2    22     0     0 ##   87    16     0     0     0     0     0     2    54     0     0 ##   88   228     0     0     0     0     0     0     5     0     0 dissim <- dissimilarity(vegemat)  head(dissim) ## Data.frame of dissimilarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  3697  ##  - Number of rows:  255255  ##  - Number of dissimilarity metrics:  1  ##  ##  ##   Site1 Site2    Simpson ## 2    35    36 0.02325581 ## 3    35    37 0.03100775 ## 4    35    38 0.05426357 ## 5    35    39 0.05426357 ## 6    35    84 0.72093023 ## 7    35    85 0.08527132"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"hierarchical-clustering-with-basic-parameters","dir":"Articles","previous_headings":"","what":"2. Hierarchical clustering with basic parameters","title":"4.1 Hierarchical clustering","text":"Hierarchical clustering, associated hierarchical tree, can constructed two ways: - agglomerative, sites initially assigned bioregion progressively grouped together - divisive, sites initially belong unique bioregion progressively divided different bioregions Subsections 2.1 2.3 detail functioning agglomerative hierarchical clustering, sub-section 2.4. illustrates divisive method.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"basic-usage","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters","what":"2.1 Basic usage","title":"4.1 Hierarchical clustering","text":"basic use function follows: function gives us information proceeds. Notably, talks randomization dissimilarity matrix - important feature hierarchical clustering strongly influenced order sites distance matrix. Therefore, default, function performs randomization order sites distance matrix 30 trials (information randomization section). also tells us built consensus tree based iterative hierarchical consensus algorithm, found tree cophenetic correlation coefficient 0.69. can see type name object console see information: last line tells us clustering procedure incomplete: tree built, yet cut - clusters object yet. cut tree, can use cut_tree() function: , asked 3 clusters, algorithm automatically finds height 3 clusters found (h = 0.562). type name object console, gives us results clustering: 1 partition: partition clustering result. cut tree , 1 partition moment 4 clusters: number clusters partition. asked 3, obtained 3, good. Sometimes, however, get number clusters asked - case outcome indicated. height cut 0.562: height cut can obtain 4 clusters tree. can make quick plot partitioned tree  Let’s see looks like map:  Now, hierarchical tree, cutting (= 1 partition) oversimplifies result tree. cut multiple times? example, make deep, intermediate, shallow cuts tree, likewise Ficetola et al. (2017), allow us see broad- fine-scale relationships among sites tree. can specify, e.g. 4, 10 20 clusters:  can also see directly console hierarchical structure tree, info cluster, using convenient summary() function. However, may useful choose heights cut, rather number clusters. , example, cut tree heights 0.4 (shallow cut), 0.5 (intermediate cut) 0.6 (deep cut):  plot easy read large number sites. can rather extract information directly object: result, can read deep cut partition (h = 0.6) clusters, intermediate cut partition (h = 0.5) 6 clusters shallow cut partition (h = 0.4) 23 clusters. Let’s look hierarchical structure clusters summary(): maps look like:  next section see default settings chose , see find optimal numbers clusters.","code":"tree1 <- hclu_hierarclust(dissim) ## Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. ##  ## Final tree has a 0.6863 cophenetic correlation coefficient with the initial dissimilarity matrix tree1 ## Clustering results for algorithm : hclu_hierarclust  ##  (hierarchical clustering based on a dissimilarity matrix) ##  - Number of sites:  715  ##  - Name of dissimilarity metric:  Simpson  ##  - Tree construction method:  average  ##  - Randomization of the dissimilarity matrix:  yes, number of trials 100  ##  - Method to compute the final tree:  Iterative hierarchical consensus tree  ##  - Cophenetic correlation coefficient:  0.686  ## Clustering procedure incomplete - no clusters yet # Ask for 3 clusters tree1 <- cut_tree(tree1,                   n_clust = 3) ## Determining the cut height to reach 3 groups... ## --> 0.5625 tree1 ## Clustering results for algorithm : hclu_hierarclust  ##  (hierarchical clustering based on a dissimilarity matrix) ##  - Number of sites:  715  ##  - Name of dissimilarity metric:  Simpson  ##  - Tree construction method:  average  ##  - Randomization of the dissimilarity matrix:  yes, number of trials 100  ##  - Method to compute the final tree:  Iterative hierarchical consensus tree  ##  - Cophenetic correlation coefficient:  0.686  ##  - Number of clusters requested by the user:  3  ## Clustering results: ##  - Number of partitions:  1  ##  - Number of clusters:  3  ##  - Height of cut of the hierarchical tree: 0.562 # We reduced the size of text labels with cex = .2, because there are too many sites plot(tree1, cex = .2) data(vegesf) library(sf) ## Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE map_bioregions(tree1$clusters[, c(\"ID\", \"K_3\")], vegesf) # Ask for 4, 10 and 20 clusters tree1 <- cut_tree(tree1,                   n_clust = c(2, 3, 12)) ## Determining the cut height to reach 2 groups... ## --> 0.625 ## Determining the cut height to reach 3 groups... ## --> 0.5625 ## Determining the cut height to reach 12 groups... ## --> 0.4453125 plot(tree1, cex = .2) summary(tree1) ##  ## Summary of clustering results ## ============================= ##  ## Algorithm:  hclu_hierarclust  ## Number of sites:  715  ## Number of bioregionalizations:  3  ## Hierarchical clustering: Yes ##  ## Bioregionalization 1: K_2 ## -------------------------  ## Total clusters:  2  ## Top 2 clusters by size: ##   Cluster 1: 528 items ##   Cluster 2: 187 items ##  ## Bioregionalization 2: K_3 ## -------------------------  ## Total clusters:  3  ## Top 3 clusters by size: ##   Cluster 1: 528 items ##   Cluster 3: 114 items ##   Cluster 2: 73 items ##  ## Bioregionalization 3: K_12 ## --------------------------  ## Total clusters:  12  ## Top 10 clusters by size: ##   Cluster 2: 361 items ##   Cluster 4: 112 items ##   Cluster 6: 99 items ##   Cluster 3: 55 items ##   Cluster 1: 52 items ##   Cluster 7: 15 items ##   Cluster 5: 14 items ##   Cluster 11: 2 items ##   Cluster 8: 2 items ##   Cluster 10: 1 items ##   ... and 2 more cluster(s) ##  ## Hierarchical structure ## ====================== ##  ## 1 (n=528) ## └─1 (n=528) ##   ├─1 (n=52) ##   ├─11 (n=2) ##   ├─12 (n=1) ##   ├─2 (n=361) ##   └─4 (n=112) ##  ## 2 (n=187) ## ├─2 (n=73) ## │ ├─3 (n=55) ## │ ├─7 (n=15) ## │ ├─8 (n=2) ## │ └─9 (n=1) ## └─3 (n=114) ##   ├─10 (n=1) ##   ├─5 (n=14) ##   └─6 (n=99) tree1 <- cut_tree(tree1,                   cut_height = c(.4, .5, .6))  plot(tree1, cex = .2) tree1 ## Clustering results for algorithm : hclu_hierarclust  ##  (hierarchical clustering based on a dissimilarity matrix) ##  - Number of sites:  715  ##  - Name of dissimilarity metric:  Simpson  ##  - Tree construction method:  average  ##  - Randomization of the dissimilarity matrix:  yes, number of trials 100  ##  - Method to compute the final tree:  Iterative hierarchical consensus tree  ##  - Cophenetic correlation coefficient:  0.686  ##  - Heights of cut requested by the user:  0.4 0.5 0.6  ## Clustering results: ##  - Number of partitions:  3  ##  - Partitions are hierarchical ##  - Number of clusters:  2 6 23  ##  - Height of cut of the hierarchical tree: 0.6 0.5 0.4 summary(tree1) ##  ## Summary of clustering results ## ============================= ##  ## Algorithm:  hclu_hierarclust  ## Number of sites:  715  ## Number of bioregionalizations:  3  ## Hierarchical clustering: Yes ##  ## Bioregionalization 1: K_2 ## -------------------------  ## Total clusters:  2  ## Top 2 clusters by size: ##   Cluster 1: 528 items ##   Cluster 2: 187 items ##  ## Bioregionalization 2: K_6 ## -------------------------  ## Total clusters:  6  ## Top 6 clusters by size: ##   Cluster 2: 476 items ##   Cluster 4: 113 items ##   Cluster 3: 72 items ##   Cluster 1: 52 items ##   Cluster 5: 1 items ##   Cluster 6: 1 items ##  ## Bioregionalization 3: K_23 ## --------------------------  ## Total clusters:  23  ## Top 10 clusters by size: ##   Cluster 4: 285 items ##   Cluster 15: 100 items ##   Cluster 10: 99 items ##   Cluster 2: 68 items ##   Cluster 5: 50 items ##   Cluster 1: 48 items ##   Cluster 8: 14 items ##   Cluster 11: 13 items ##   Cluster 6: 12 items ##   Cluster 9: 6 items ##   ... and 13 more cluster(s) ##  ## Hierarchical structure ## ====================== ##  ## 1 (n=528) ## ├─1 (n=52) ## │ ├─1 (n=48) ## │ └─3 (n=4) ## └─2 (n=476) ##   ├─15 (n=100) ##   ├─19 (n=2) ##   ├─2 (n=68) ##   ├─22 (n=1) ##   ├─23 (n=1) ##   ├─4 (n=285) ##   ├─6 (n=12) ##   ├─7 (n=1) ##   └─9 (n=6) ##  ## 2 (n=187) ## ├─3 (n=72) ## │ ├─11 (n=13) ## │ ├─12 (n=2) ## │ ├─14 (n=3) ## │ ├─16 (n=1) ## │ ├─17 (n=1) ## │ ├─20 (n=1) ## │ ├─21 (n=1) ## │ └─5 (n=50) ## ├─4 (n=113) ## │ ├─10 (n=99) ## │ └─8 (n=14) ## ├─5 (n=1) ## │ └─13 (n=1) ## └─6 (n=1) ##   └─18 (n=1) for(i in 2:ncol(tree1$clusters)){   map_bioregions(tree1$clusters[, c(1, i)], vegesf) }"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"exploring-the-outputs","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters","what":"2.2 Exploring the outputs","title":"4.1 Hierarchical clustering","text":"explore object, can use str() see object structure: show different slots object, can access . example, want access clusters slot, type tree1$clusters. name: name method using args: arguments selected tree inputs: mostly internal use package, provides info nature input data methods algorithm: slot contains detailed information hierarchical clustering. example, can access raw tree , hclust format. access , can type tree1$algorithm$final.tree clusters: data.frame containing partitions. first column sites, columns partitions. cluster_info: small data.frame help link requests clusters data.frame. content varies depending choices; example, case, looks like : shows name partition (corresponding column names tree1$clusters), number clusters partition, cut height initially requested.","code":"str(tree1) ## List of 6 ##  $ name        : chr \"hclu_hierarclust\" ##  $ args        :List of 15 ##   ..$ index              : chr \"Simpson\" ##   ..$ method             : chr \"average\" ##   ..$ randomize          : logi TRUE ##   ..$ n_runs             : num 100 ##   ..$ optimal_tree_method: chr \"iterative_consensus_tree\" ##   ..$ keep_trials        : chr \"no\" ##   ..$ n_clust            : NULL ##   ..$ cut_height         : num [1:3] 0.4 0.5 0.6 ##   ..$ find_h             : logi TRUE ##   ..$ h_max              : num 1 ##   ..$ h_min              : num 0 ##   ..$ consensus_p        : num 0.5 ##   ..$ show_hierarchy     : logi FALSE ##   ..$ verbose            : logi TRUE ##   ..$ dynamic_tree_cut   : logi FALSE ##  $ inputs      :List of 9 ##   ..$ bipartite      : logi FALSE ##   ..$ weight         : logi TRUE ##   ..$ pairwise       : logi TRUE ##   ..$ pairwise_metric: chr \"Simpson\" ##   ..$ dissimilarity  : logi TRUE ##   ..$ nb_sites       : int 715 ##   ..$ data_type      : chr \"occurrence\" ##   ..$ node_type      : chr \"site\" ##   ..$ hierarchical   : logi TRUE ##  $ algorithm   :List of 6 ##   ..$ final.tree         :List of 5 ##   .. ..- attr(*, \"class\")= chr \"hclust\" ##   ..$ final.tree.coph.cor: num 0.686 ##   ..$ final.tree.msd     : num 0.023 ##   ..$ trials             : chr \"Trials not stored in output\" ##   ..$ output_n_clust     : Named int [1:3] 2 6 23 ##   .. ..- attr(*, \"names\")= chr [1:3] \"h_0.6\" \"h_0.5\" \"h_0.4\" ##   ..$ output_cut_height  : num [1:3] 0.6 0.5 0.4 ##  $ clusters    :'data.frame':    715 obs. of  4 variables: ##   ..$ ID  : chr [1:715] \"1003\" \"1004\" \"1005\" \"1006\" ... ##   ..$ K_2 : chr [1:715] \"1\" \"1\" \"1\" \"1\" ... ##   ..$ K_6 : chr [1:715] \"1\" \"1\" \"1\" \"1\" ... ##   ..$ K_23: chr [1:715] \"1\" \"1\" \"1\" \"1\" ... ##  $ cluster_info:'data.frame':    3 obs. of  3 variables: ##   ..$ partition_name      : chr [1:3] \"K_2\" \"K_6\" \"K_23\" ##   ..$ n_clust             : int [1:3] 2 6 23 ##   ..$ requested_cut_height: num [1:3] 0.6 0.5 0.4 ##  - attr(*, \"class\")= chr [1:2] \"bioregion.clusters\" \"list\" tree1$cluster_info ##       partition_name n_clust requested_cut_height ## h_0.6            K_2       2                  0.6 ## h_0.5            K_6       6                  0.5 ## h_0.4           K_23      23                  0.4"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"randomization","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters > 2.3 Explanation of the default settings and how to change them","what":"2.3.1 Randomization of the distance matrix","title":"4.1 Hierarchical clustering","text":"order sites distance matrix influences outcome hierarchical tree. Let’s see example:  tree looks like matrix randomized. Now let’s randomize regenerate tree:  See tree looks different? problematic means outcome heavily influenced order sites distance matrix. address issue, developed iterative algorithm reconstruct entire tree top bottom, selecting branch majority decision among multiple randomizations distance matrix (100 times default, can increased). method called Iterative Hierarchical Consensus Tree (argument optimal_tree_method = \"iterative_consensus_tree\", default value) ensures obtain consensus tree find majority decision branch tree. tree produced method generally better topology individual tree. estimate performance topology cophenetic correlation coefficient, correlation initial distance \\(\\beta_{sim}\\) among sites cophenetic distance, distance sites connected tree. tells us representative tree initial distance matrix. Although method performs better available method, comes computing cost: needs randomize distance matrix multiple times branching tree. Therefore, recommend using obtain robust tree - patient case. Otherwise, need fast look good tree, can simply select single best tree among multiple randomization trials. never good Iterative Hierarchical Consensus Tree, best choice fast exploration. , choose optimal_tree_method = \"best\". select tree best represents distance matrix; .e., one highest cophenetic correlation coefficient among trials. Let’s see example optimal_tree_method = \"best\". can also ask function keep individual trees exploration keep_trials = \"\" (including, trial, randomized matrix, associated tree, metrics tree). default, keep_trials = \"\" keep_trials = \"metrics\" can used keep metrics associated tree. Another possible approach build simple consensus tree among trials. However, generally recommend constructing consensus tree, topology simple consensus trees can problematic lot ties distance matrix. Let’s see action : See cophenetic correlation coefficient consensus tree terrible compared IHCT best tree ? consensus tree almost correlation initial distance matrix. topology terribly wrong, see tree looks like:  Booo, just large rake, tree!!!","code":"# Compute the tree without randomizing the distance matrix tree2 <- hclu_hierarclust(dissim,                           randomize = FALSE) ## Output tree has a 0.6849 cophenetic correlation coefficient with the initial ##                    dissimilarity matrix plot(tree2, cex = .1) # This line randomizes the order of rows in the distance matrix dissim_random <- dissim[sample(1:nrow(dissim)), ]  # Recompute the tree tree3 <- hclu_hierarclust(dissim_random,                           randomize = FALSE) ## Output tree has a 0.6778 cophenetic correlation coefficient with the initial ##                    dissimilarity matrix plot(tree3, cex = .1) tree_best <- hclu_hierarclust(dissim_random,                               randomize = TRUE,                               optimal_tree_method = \"best\",                               keep_trials = \"all\") ## Randomizing the dissimilarity matrix with 100 trials ##  -- range of cophenetic correlation coefficients among trials: 0.6669 - 0.6974 ##  ## Final tree has a 0.6974 cophenetic correlation coefficient with the initial dissimilarity matrix tree_consensus <- hclu_hierarclust(dissim_random,                                    randomize = TRUE,                                    optimal_tree_method = \"consensus\",                                    keep_trials = \"no\") ## Randomizing the dissimilarity matrix with 100 trials ##  ## Final tree has a 0.202 cophenetic correlation coefficient with the initial dissimilarity matrix plot(tree_consensus)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"tree-construction-algorithm","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters > 2.3 Explanation of the default settings and how to change them","what":"2.3.2 Tree construction algorithm","title":"4.1 Hierarchical clustering","text":"default, function uses UPGMA method (Unweighted Pair Group Method Arithmetic Mean) recommended bioregionalization better performance approaches (Kreft & Jetz, 2010). can change method changing argument method; methods implemented stats::hclust() available. Note current height distances methods method = \"ward.D\" method = \"ward.D2\" may differ calculations stats::hclust(), due iterative nature algorithm. addition, using method method = \"single\" much slower approaches, yet implemented workaround make faster (hesitate contact us need faster implementation idea make run faster).","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"cutting-the-tree","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters > 2.3 Explanation of the default settings and how to change them","what":"2.3.3 Cutting the tree","title":"4.1 Hierarchical clustering","text":"three ways cutting tree: Specify expected number clusters: can request specific number clusters (n_clust = 5 example). can also request multiple partitions, number clusters (n_clust = c(5, 10, 15)) example. Note: specify number clusters, function search associated height cut automatically; can disable parameter find_h = FALSE. search h value h_max (default 1) h_min (default 0). arguments can adjusted working indices whose values range 0 1. Specify height cut: can request height want cut tree (e.g., cut_height = 0.5). can also request multiple partitions, cut height (cut_height = c(0.4, 0.5, 0.6)) example. Use dynamic tree cut method: Rather cutting entire tree , alternative approach consists cutting individual branches different heights. method can requested using dynamic_tree_cut = TRUE, based dynamicTreeCut R package.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"id_2-4-","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters","what":"2.4. Divisive clustering","title":"4.1 Hierarchical clustering","text":"agglomerative hierarchical clustering previous subsections followed bottom-approach, divisive clustering follows top-approach. means first step clustering, sites belong bioregion, sites iteratively divided different bioregions sites belong unique bioregion. Divisive clustering following DIvisive ANAlysis (DIANA) clustering algorithm described (Kaufman & Rousseeuw, 2009). step, algorithm splits largest cluster identifying dissimilar observation (.e. site) putting sites closer dissimilar observation ‘old party’ group splinter group. result large cluster split two clusters. function hclu_diana performs Diana divisive clustering.","code":"# Compute the tree with the Diana algorithm tree_diana <- hclu_diana(dissim) ## Output tree has a 0.41 cophenetic correlation coefficient with the initial dissimilarity matrix plot(tree_diana)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"optimaln","dir":"Articles","previous_headings":"","what":"3. How to find an optimal number of clusters?","title":"4.1 Hierarchical clustering","text":"Step 1. Build tree hclu_hierarclust() Step 2. Explore range partitions, minimum (e.g., starting 2 clusters) maximum (e.g. \\(n-1\\) clusters \\(n\\) number sites). Step 3. Calculate one several metrics partition, used basis evaluation plots. Step 4. Search one several optimal number(s) clusters using evaluation plots. Different criteria can applied identify optimal number(s) clusters. Step 5. Export optimal partitions cluster object.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"a-practical-example","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters?","what":"3.1 A practical example","title":"4.1 Hierarchical clustering","text":"example compute evaluation metric used Holt et al. (2013), compares total dissimilarity distance matrix (sum distances) inter-cluster dissimilarity (sum distances clusters). choose optimal number clusters elbow evaluation plot.   allergic lines code, also simply recut tree identified optimal number cut-offs cut_tree().","code":"data(vegemat)  # Calculate dissimilarities dissim <- dissimilarity(vegemat)  # Step 1 & 2. Compute the tree and cut it into many different partitions tree4 <- hclu_hierarclust(dissim,                           n_clust = 2:100) ## Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. ##  ## Final tree has a 0.6842 cophenetic correlation coefficient with the initial dissimilarity matrix ## Warning in cut_tree(outputs, n_clust = n_clust, cut_height = cut_height, : The ## requested number of cluster could not be found for k = 4. Closest number found: ## 5 ## Warning in cut_tree(outputs, n_clust = n_clust, cut_height = cut_height, : The ## requested number of cluster could not be found for k = 67. Closest number ## found: 66 # Step 3. Calculate the same evaluation metric as Holt et al. 2013 eval_tree4 <- bioregionalization_metrics(   tree4,    dissimilarity = dissim, # Provide distances to compute the metrics   eval_metric = \"pc_distance\") ## Computing similarity-based metrics... ##   - pc_distance OK # Step 4. Find the optimal number of clusters opti_n_tree4 <- find_optimal_n(eval_tree4) ## Number of bioregionalizations: 99 ## Searching for potential optimal number(s) of clusters based on the elbow method ##    * elbow found at: ## pc_distance 19 ## Plotting results... opti_n_tree4 ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  elbow  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 19 # Step 5. Extract the optimal number of clusters # We get the name of the correct partition in the next line K_name <- opti_n_tree4$evaluation_df$K[opti_n_tree4$evaluation_df$optimal_n_pc_distance] # Look at the site-cluster table head(tree4$clusters[, c(\"ID\", K_name)]) ##        ID K_19 ## 1003 1003    1 ## 1004 1004    1 ## 1005 1005    1 ## 1006 1006    1 ## 1007 1007    1 ## 1008 1008    1 # Make a map of the clusters data(\"vegesf\") library(\"sf\") map_bioregions(tree4$clusters[, c(\"ID\", K_name)], vegesf)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"evaluation-metrics","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters?","what":"3.2 Evaluation metrics","title":"4.1 Hierarchical clustering","text":"Currently, four evaluation metrics available package: pc_distance: \\(\\sum{-cluster\\beta_{sim }} / \\sum{\\beta_{sim}}\\) metric metric computed Holt et al. (2013). anosim: statistic used Analysis Similarities, suggested Castro-Insua et al. (2018). compares -cluster dissimilarities within-cluster dissimilarities. based difference mean ranks groups within groups following formula: \\(R=(r_B-r_W)/(N(N-1)/4)\\) \\(r_B\\) \\(r_W\\) average ranks within clusters respectively, \\(N\\) total number sites. avg_endemism: average percentage endemism clusters (Kreft & Jetz, 2010). calculated follows: \\(End_{mean} = \\frac{\\sum_{=1}^K E_i / S_i}{K}\\) \\(E_i\\) number endemic species cluster \\(\\), \\(S_i\\) number species cluster \\(\\), \\(K\\) maximum number clusters. tot_endemism: total endemism across clusters (Kreft & Jetz, 2010). calculated follows: \\(End_{tot} = E / C\\) \\(E\\) total number endemic species (.e., species occurring one cluster) \\(C\\) number non- endemic species. Important note able calculate pc_distance anosim, need provide dissimilarity object argument dissimilarity. addition, able calculate avg_endemism tot_endemism, need provide species-site network argument net (don’t panick species x site matrix! function make conversion). Let’s see practice. Depending size dataset, computing endemism-based metrics can take .","code":"# Calculate pc_distance and anosim bioregionalization_metrics(tree4,                             dissimilarity = dissim,                             eval_metric = c(\"pc_distance\", \"anosim\")) ## Computing similarity-based metrics... ##   - pc_distance OK ##   - anosim OK ## Partition metrics: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Requested metric(s):  pc_distance anosim  ##  - Metric summary: ##      pc_distance    anosim ## Min    0.4982831 0.6968281 ## Mean   0.8950634 0.8029604 ## Max    0.9823024 0.8669999 ##  ## Access the data.frame of metrics with your_object$evaluation_df # Calculate avg_endemism and tot_endemism # I have an abundance matrix, I need to convert it into network format first: vegenet <- mat_to_net(vegemat)  bioregionalization_metrics(tree4,                             net = vegenet,                             eval_metric = c(\"avg_endemism\", \"tot_endemism\")) ## Computing composition-based metrics... ##   - avg_endemism OK ##   - tot_endemism OK ## Partition metrics: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Requested metric(s):  avg_endemism tot_endemism  ##  - Metric summary: ##      avg_endemism tot_endemism ## Min   0.001177433   0.04895862 ## Mean  0.008144637   0.08297200 ## Max   0.181513150   0.31539086 ##  ## Access the data.frame of metrics with your_object$evaluation_df ## Details of endemism % for each bioregionalization are available in ##         your_object$endemism_results"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"criteria-to-choose-an-optimal-number-of-clusters","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters?","what":"3.2 Criteria to choose an optimal number of clusters","title":"4.1 Hierarchical clustering","text":"Choosing optimal number clusters long-standing issue literature, absolute objective answer question. plethora methods proposed years, best approach tackle issue probably compare results multiple approaches make informed decision. bioregion package, implemented several methods specifically suited bioregionalization analysis. example, standard criterion used identifying optimal number clusters elbow method, default criterion find_optimal_n(). However, recommend moving beyond paradigm single optimal number clusters, likely oversimplification hierarchy tree. recommend considering multiple cuts tree, provide several methods : identifying large steps curve using multiple cutoffs. Additionally, implement approaches, using maximum minimum value metrics, finding break points curve segmented model. look different methods, compute evaluation metrics store eval_tree4:","code":"vegenet <- mat_to_net(vegemat) eval_tree4 <- bioregionalization_metrics(tree4,                                           dissimilarity = dissim,                                           net = vegenet,                                           eval_metric = c(\"pc_distance\", \"anosim\",                                                          \"avg_endemism\", \"tot_endemism\")) ## Computing similarity-based metrics... ##   - pc_distance OK ##   - anosim OK ## Computing composition-based metrics... ##   - avg_endemism OK ##   - tot_endemism OK"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"elbow-method","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.1 Elbow method","title":"4.1 Hierarchical clustering","text":"elbow method consists find ‘elbow’ form metric-cluster relationship. method typically work metrics L-shaped form (typically, pc_distance endemism metrics), metrics (e.g. form anosim necessarily follow L-shape). rationale behind elbow method find cutoff metric values stop increasing significantly, adding new clusters provide much significant improvement metric. elbow method default method find_optimal_n(). parameters adjust . curve elbow-shaped, may give spurious results.   example , optimal number clusters varies depending metric, minimum 9 maximum 24. final choice depends metric preferences respect metrics, objectives clustering. Alternatively, two cut-offs used, deep cut-based endemism metrics e.g. value 9, shallow cutoff based pc_distance, 19.","code":"find_optimal_n(eval_tree4) ## Number of bioregionalizations: 99 ## Searching for potential optimal number(s) of clusters based on the elbow method ##    * elbow found at: ## pc_distance 19 ## anosim 24 ## avg_endemism 9 ## tot_endemism 12 ## Warning in find_optimal_n(eval_tree4): The elbow method is likely not suitable ## for the ANOSIM metric. You should rather look for leaps in the curve (see ## criterion = 'increasing_step' or decreasing_step) ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  pc_distance anosim avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  elbow  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 19 ## anosim - 24 ## avg_endemism - 9 ## tot_endemism - 12"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"step-method","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.2 Step method","title":"4.1 Hierarchical clustering","text":"step method consists identifying largest “steps” metrics, .e., largest increases decreases value metric. , function calculates successive differences metrics partitions. keep largest positive differences (increasing_step) negative differences (decreasing_step). increasing_step increasing metrics (pc_distance) decreasing_step decreasing metrics (avg_endemism tot_endemism). anosim values can either increase decrease depending dataset, explore ways. default, function selects top 1% steps:   However, can adjust two different ways. First, choose number steps select, e.g. select largest 3 steps, use step_levels = 3:  Note steps generally correspond large jumps tree, like approach fits well hierarchical nature tree. Second, can set quantile steps select, e.g. select 5% largest steps set quantile 0.95 (step_quantile = 0.95):  Finally, question may arise cluster number select large step occurs. example, largest step occurs partitions 4 5 clusters, keep partition 4 clusters, partition 5 clusters? default, function keeps partition \\(N + 1\\) (5 clusters example ). can change setting step_round_above = FALSE:","code":"find_optimal_n(eval_tree4,                metrics_to_use = c(\"anosim\", \"pc_distance\"),                criterion = \"increasing_step\") ## Number of bioregionalizations: 99 ## Searching for potential optimal number(s) of clusters based on the increasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  anosim pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  increasing_step  ##    (step quantile chosen:  0.99  (i.e., only the top 1 %  increase  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## anosim - 19 ## pc_distance - 12 find_optimal_n(eval_tree4,                metrics_to_use = c(\"avg_endemism\", \"tot_endemism\"),                criterion = \"decreasing_step\") ## Number of bioregionalizations: 99 ## Searching for potential optimal number(s) of clusters based on the decreasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  decreasing_step  ##    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## avg_endemism - 5 ## tot_endemism - 5 find_optimal_n(eval_tree4,                metrics_to_use = c(\"anosim\", \"pc_distance\"),                criterion = \"increasing_step\",                step_levels = 3) ## Number of bioregionalizations: 99 ## Searching for potential optimal number(s) of clusters based on the increasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  anosim pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  increasing_step  ##    (step quantile chosen:  0.99  (i.e., only the top 1 %  increase  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## anosim - 5 12 19 ## pc_distance - 5 12 19 find_optimal_n(eval_tree4,                metrics_to_use = c(\"anosim\", \"pc_distance\"),                criterion = \"increasing_step\",                step_quantile = 0.95) ## Number of bioregionalizations: 99 ## Searching for potential optimal number(s) of clusters based on the increasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  anosim pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  increasing_step  ##    (step quantile chosen:  0.95  (i.e., only the top 5 %  increase  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## anosim - 5 12 19 24 93 ## pc_distance - 3 5 12 19 68 find_optimal_n(eval_tree4,                metrics_to_use = c(\"avg_endemism\", \"tot_endemism\"),                criterion = \"decreasing_step\",                step_round_above = FALSE) ## Number of bioregionalizations: 99 ## Searching for potential optimal number(s) of clusters based on the decreasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  decreasing_step  ##    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## avg_endemism - 3 ## tot_endemism - 3"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"cutting-at-different-cut-off-values","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.3 Cutting at different cut-off values","title":"4.1 Hierarchical clustering","text":"idea method select specific metric values number clusters used. example, study, Holt et al. (2013) used different cutoffs pc_distance find global biogeographic regions: 0.90, 0.95, 0.99, 0.999. higher value, -diversity explained, also clusters . Therefore, choice trade-total -diversity explained number clusters. Eventually, choice values depends different factors: geographic scope study. global scale study can use large cutoffs like Holt et al. (2013) end reasonable number clusters, whereas regional local scale studies less endemism taxa shared among clusters, values high, cutoffs explored, 0.5 0.75. characteristics study increase decrease degree endemism among clusters: dispersal capacities taxonomic group, connectivity/barriers study area, etc. Use lower cutoffs large number widespread species, use higher cutoffs high degrees endemism. Using abundance phylogenetic data compute -diversity metrics may allow better distinguish clusters, turn allow use higher cutoffs. example, case, regional-scale study vegetation, can use three cutoffs: 0.6 (deep cutoff), 0.8 (intermediate cutoff), 0.9 (shallow cutoff).","code":"find_optimal_n(eval_tree4,                metrics_to_use = \"pc_distance\",                criterion = \"cutoff\",                metric_cutoffs = c(.6, .8, .9)) ## Number of bioregionalizations: 99 ## Searching for potential optimal number(s) of clusters based on the cutoff method ##  - Cutoff method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  cutoff  ##    --> cutoff(s) chosen:  0.6 0.8 0.9  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 5 12 29"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"cutting-at-the-maximum-or-minimum-metric-value","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.4 Cutting at the maximum or minimum metric value","title":"4.1 Hierarchical clustering","text":"criterion finds maximum (criterion = \"max\") minimum (criterion = \"min\") value metric list partitions selects corresponding partition. criterion can interesting case anosim, probably much less useful metrics implemented package.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"finding-break-points-in-the-curve","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.5 Finding break points in the curve","title":"4.1 Hierarchical clustering","text":"criterion consists applying segmented regression model formula evaluation metric ~ number clusters. user can define number breaks identified curve. Note model likely require minimum number points find appropriate number clusters. example , make 100 cuts tree enough values.  can ask higher number breaks: 2 breaks  3 breaks  Increasing number breaks can useful situations , example, non-linear silhouettes metric ~ n clusters.","code":"tree5 <- cut_tree(tree4,                   cut_height = seq(0, max(tree4$algorithm$final.tree$height),                                     length = 100))   eval_tree5 <- bioregionalization_metrics(tree5,                                           dissimilarity = dissim,                                           net = vegenet,                                           eval_metric = c(\"pc_distance\", \"anosim\",                                                          \"avg_endemism\", \"tot_endemism\")) ## Computing similarity-based metrics... ##   - pc_distance OK ##   - anosim OK ## Computing composition-based metrics... ##   - avg_endemism OK ##   - tot_endemism OK find_optimal_n(eval_tree5,                criterion = \"breakpoints\") ## Number of bioregionalizations: 100 ## Searching for potential optimal number(s) of clusters based on the breakpoints method ## Exact break point not in the list of bioregionalizations: finding the closest bioregionalization... ## Plotting results... ##    (the red line is the prediction from the segmented regression) ## Warning: Removed 1 row containing missing values or values outside the scale range ## (`geom_line()`). ## Search for an optimal number of clusters: ##  - 100  partition(s) evaluated ##  - Range of clusters explored: from  1  to  701  ##  - Evaluated metric(s):  pc_distance anosim avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  breakpoints  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 16 ## anosim - 111 ## avg_endemism - 2 ## tot_endemism - 2 find_optimal_n(eval_tree5,                criterion = \"breakpoints\",                n_breakpoints = 2) ## Number of bioregionalizations: 100 ## Searching for potential optimal number(s) of clusters based on the breakpoints method ## Exact break point not in the list of bioregionalizations: finding the closest bioregionalization... ## Plotting results... ##    (the red line is the prediction from the segmented regression) ## Warning: Removed 1 row containing missing values or values outside the scale range ## (`geom_line()`). ## Search for an optimal number of clusters: ##  - 100  partition(s) evaluated ##  - Range of clusters explored: from  1  to  701  ##  - Evaluated metric(s):  pc_distance anosim avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  breakpoints  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 13 92 ## anosim - 25 183 ## avg_endemism - 2 16 ## tot_endemism - 2 92 find_optimal_n(eval_tree5,                criterion = \"breakpoints\",                n_breakpoints = 3) ## Number of bioregionalizations: 100 ## Searching for potential optimal number(s) of clusters based on the breakpoints method ## Exact break point not in the list of bioregionalizations: finding the closest bioregionalization... ## Plotting results... ##    (the red line is the prediction from the segmented regression) ## Warning: Removed 1 row containing missing values or values outside the scale range ## (`geom_line()`). ## Search for an optimal number of clusters: ##  - 100  partition(s) evaluated ##  - Range of clusters explored: from  1  to  701  ##  - Evaluated metric(s):  pc_distance anosim avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  breakpoints  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 2 16 100 ## anosim - 25 183 566 ## avg_endemism - 2 13 56 ## tot_endemism - 2 14 111"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"optics-as-a-semi-hierarchical-clustering-approach","dir":"Articles","previous_headings":"","what":"4. OPTICS as a semi-hierarchical clustering approach","title":"4.1 Hierarchical clustering","text":"OPTICS (Ordering Points Identify Clustering Structure) semi-hierarchical clustering approach orders points datasets closest points become neighbors, calculates ‘reachability’ distance point, extracts clusters reachability distance hierarchical manner. However, hierarchical nature clusters directly provided algorithm tree-like output. Hence, users explore ‘reachability plot’ understand hierarchical nature OPTICS clusters, read related publication understand method (Hahsler et al., 2019). run optics algorithm, use hclu_optics() function:","code":"data(vegemat)  # Calculate dissimilarities dissim <- dissimilarity(vegemat)  clust1 <- hclu_optics(dissim)  clust1 ## Clustering results for algorithm : hclu_optics  ##  - Number of sites:  715  ## Clustering results: ##  - Number of partitions:  1  ##  - Number of clusters:  9"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"dissimilarity-indices","dir":"Articles","previous_headings":"","what":"1. Dissimilarity indices","title":"4.2 Non-hierarchical clustering","text":"Pairwise distances sites can obtained running dissimilarity() site-species matrix. example , use fish dataset package compute distance metrics. going compute \\(\\beta_{sim}\\) diversity metric, presence-absence dissimilarity index. formula follows:\\(\\beta_{sim} = min(b, c) / (+min(b, c))\\) number species shared sites; b number species occurring first site; c number species occurring second site. typically choose metric bioregionalization, turnover component Sorensen index (Baselga, 2012) (nutshell, tells us sites different distinct species), less dependence species richness Jaccard turnover (Leprieur & Oikonomou, 2014).  choice distance metric important outcome clustering procedure, recommend choose carefully depending research question. default, Simpson index computed, options available metric argument dissimilarity(). Furthermore, users can also write formula compute index wish argument formula, see ?dissimilarity(). now ready start non-hierarchical clustering procedure object dissim just created. Alternatively, can also use types objects distance matrix object (class dist) data.frame crafting (make sure read required format carefully explained help function).","code":"library(\"bioregion\") data(\"fishmat\")  # It is a presence/absence matrix with sites in rows and species in columns fishmat[1:3, 1:3] ##          Abramis brama Alburnus alburnus Barbatula barbatula ## Aa                   1                 1                   1 ## Abula                0                 0                   0 ## Acheloos             0                 0                   0 dissim <- dissimilarity(fishmat, metric = \"Simpson\")  dissim[1:3, ] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  338  ##  - Total number of species:  195  ##  - Number of rows:  56953  ##  - Number of dissimilarity metrics:  1  ##  ##  ##   Site1    Site2   Simpson ## 2    Aa    Abula 0.3333333 ## 3    Aa Acheloos 1.0000000 ## 4    Aa    Adige 0.7692308"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"centroid-based-clustering","dir":"Articles","previous_headings":"","what":"2. Centroid-based clustering","title":"4.2 Non-hierarchical clustering","text":"core idea algorithms place points cluster central-point closest. central-point can either centroid cluster, .e. mean x y coordinates points belonging cluster, medoid. medoid centrally located data point cluster, words least dissimilar point points cluster. objective minimize sum squared distances points assigned centroids/medoids.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"kmeans","dir":"Articles","previous_headings":"2. Centroid-based clustering","what":"2.1. Kmeans","title":"4.2 Non-hierarchical clustering","text":"K-means clustering perhaps famous method non-hierarchical clustering. uses centroids clusters. algorithm usually follows iterative framework : initialization step creates k centroids random placements. every point, Euclidean distance centroids calculated. point assigned nearest centroid. points assigned centroid form cluster. clusters formed, new centroids cluster calculated taking mean x y coordinates points belonging cluster. re-assignment step calculates new centroids based membership cluster. Steps 2 3 repeated solution converges, .e. centroid positions longer change. Finding optimal solution K-means computationally intensive implementation rely efficient heuristic algorithms quickly converge local optimum. Side-note k-means algorithm can become ‘stuck’ local optima. Repeating clustering algorithm adding noise data can help evaluate robustness solution. function compute K-means clustering bioregion nhclu_kmeans(). illustrate functions works example applied dissimilarity matrix calculated . chose 3 clusters. steps come arguments can tweaked. Specifically, iter_max determines maximum number iterations allowed (.e. many times steps described run) nstart specifies many random sets n_clust selected starting points.  Several heuristic algorithms can also used along K-means method can parameterized using algorithm argument. default, algorithm Hartigan-Wong (Hartigan & Wong (1979)) used. Let’s start setting iter_max nstart 1. asking one iteration , function displays message saying algorithm converge. therefore need increase value iter_max. Like functions bioregion package, class object specific package (bioregion.clusters) contains several parts. clusters assigned site accessible $clusters part output: , see 142 sites assigned cluster 1, 93 cluster 2 103 cluster 3. assignment can change depending two main arguments functions, iter_max nstart. shown , distribution sites among three clusters appears quite homogeneous three examples discrepancies emerge. Overall, increasing iter_max nstart increases chances convergence algorithm also increases computation time.","code":"ex_kmeans <- nhclu_kmeans(dissim, index = \"Simpson\", n_clust = 3, iter_max = 1,                           nstart = 1, algorithm = \"Hartigan-Wong\") ex_kmeans <- nhclu_kmeans(dissim, index = \"Simpson\", n_clust = 3, iter_max = 3,                           nstart = 1, algorithm = \"Hartigan-Wong\") ex_kmeans$clusters[1:3, ] ##                ID K_3 ## Aa             Aa   3 ## Abula       Abula   1 ## Acheloos Acheloos   2 table(ex_kmeans$clusters$K_3) ##  ##   1   2   3  ## 142  93 103 ex_kmeans2 <- nhclu_kmeans(dissim, index = \"Simpson\", n_clust = 3,                            iter_max = 100, nstart = 1,                            algorithm = \"Hartigan-Wong\")  ex_kmeans3 <- nhclu_kmeans(dissim, index = \"Simpson\", n_clust = 3,                            iter_max = 3, nstart = 100,                            algorithm = \"Hartigan-Wong\") table(ex_kmeans$clusters$K_3, ex_kmeans2$clusters$K_3) ##     ##       1   2   3 ##   1   1  12 129 ##   2  77  16   0 ##   3   0   9  94 table(ex_kmeans$clusters$K_3, ex_kmeans3$clusters$K_3) ##     ##       1   2   3 ##   1 111  29   2 ##   2   0   0  93 ##   3   0 102   1"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"section22","dir":"Articles","previous_headings":"2. Centroid-based clustering","what":"2.2. K-medoids","title":"4.2 Non-hierarchical clustering","text":"Instead using mean cluster, medoid can also used partition data points. comparison centroid used K-means, medoid less sensitive outliers data. partitions can also use types distances rely Euclidean distance . Several heuristics exist solve K-medoids problem, famous ones Partition Around Medoids (PAM), extensions CLARA CLARANS.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"partitioning-around-medoids-pam","dir":"Articles","previous_headings":"2. Centroid-based clustering > 2.2. K-medoids","what":"2.2.1. Partitioning Around Medoids (PAM)","title":"4.2 Non-hierarchical clustering","text":"PAM fast heuristic find solution k-medoids problem. k clusters, decomposes following steps:  1. Randomly pick k points initial medoids Assign point nearest medoid x Calculate objective function (sum dissimilarities points nearest medoids) Randomly select point y Swap x y swap reduces objective function Repeat 3-6 change nhclu_pam() function, several arguments tweak. number clusters n_clust defined well number starting positions medoids nstart. Several variants PAM algorithm available can changed argument variant (see cluster::pam() details). 2 clusters, see 258 sites assigned cluster 1 80 cluster 2.","code":"ex_pam <- nhclu_pam(dissim, index = \"Simpson\", n_clust = 2:25, nstart = 1,                     variant = \"faster\", cluster_only = FALSE) table(ex_pam$clusters$K_2) ##  ##   1   2  ## 258  80"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"clustering-large-applications-clara","dir":"Articles","previous_headings":"2. Centroid-based clustering > 2.2. K-medoids","what":"2.2.2. Clustering Large Applications (CLARA)","title":"4.2 Non-hierarchical clustering","text":"CLARA (Clustering Large Applications, (Kaufman Rousseeuw 1990)) extension k-medoids (PAM) methods deal data containing large number objects (several thousand observations) order reduce computational time RAM storage problem. achieved using sampling approach.","code":"ex_clara <- nhclu_clara(dissim, index = \"Simpson\",                         n_clust = 5,                         maxiter = 0L, initializer = \"LAB\", fasttol = 1,                         numsamples = 5L, sampling = 0.25, independent = FALSE,                         seed = 123456789L) table(ex_clara$clusters$K_5) ##  ##   1   2   3   4   5  ## 241  21  16  50  10"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"clustering-large-applications-based-on-randomized-search-clarans","dir":"Articles","previous_headings":"2. Centroid-based clustering > 2.2. K-medoids","what":"2.2.3. Clustering Large Applications based on RANdomized Search (CLARANS)","title":"4.2 Non-hierarchical clustering","text":"CLARANS (Clustering Large Applications based RANdomized Search, (Ng Han 2002)) extension k-medoids (PAM) methods combined CLARA algorithm.","code":"ex_clarans <- nhclu_clarans(dissim, index = \"Simpson\",                         n_clust = 5,                         numlocal = 2L, maxneighbor = 0.025,                         seed = 123456789L) table(ex_clara$clusters$K_5) ##  ##   1   2   3   4   5  ## 241  21  16  50  10"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"density-based-clustering","dir":"Articles","previous_headings":"","what":"3. Density-based clustering","title":"4.2 Non-hierarchical clustering","text":"Density-based clustering another type non-hierarchical clustering. connects areas high density clusters. allows arbitrary-shaped distributions long dense areas can connected. algorithms can however difficulty data varying densities high dimensions.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"dbscan","dir":"Articles","previous_headings":"3. Density-based clustering","what":"3.1. DBSCAN","title":"4.2 Non-hierarchical clustering","text":"Density-based Spatial Clustering Applications Noise (DBSCAN) (Hahsler et al. (2019)) famous density-based clustering approach.  operates locating points dataset surrounded significant number points. points regarded part dense zone, algorithm next attempt extend region encompass cluster’s points. DBSCAN uses two following parameters: Epsilon (eps): maximum distance two points considered neighboring points (belonging cluster). Minimum Points (minPts): minimum number neighboring points given point needs considered core data point. includes point . example, minimum number points set 4, given point needs 3 neighboring data points considered core data point. minimum number points meet epsilon distance requirement considered cluster. set two parameters, algorithm works like : Decide value eps minPts. point: Calculate distance points. distance less equal eps mark point neighbor x. point gets neighboring count greater equal minPts, mark core point visited. core point, already assigned cluster create new cluster. Recursively find neighboring points assign cluster core point. Continue steps unvisited points covered. algorithm can called function nhclu_dbscan(). user define two arguments presented , minPts eps, function provide knee curve helping search optimal eps value.  , see can set eps 1. set parameters, get one cluster. decrease eps value increase minPts, can get clusters.","code":"ex_dbscan <- nhclu_dbscan(dissim, index = \"Simpson\", minPts = NULL, eps = NULL,                           plot = TRUE) ## Trying to find a knee in the curve to search for an optimal eps value... ##        NOTE: this automatic identification of the knee may not work properly ##        if the curve has knees and elbows. Please adjust eps manually by ##        inspecting the curve, identifying a knee as follows: ##  ##                            / ##                  curve    / ##               ___________/  <- knee ##   elbow ->   / ##             / ##            / ex_dbscan2 <- nhclu_dbscan(dissim, index = \"Simpson\", minPts = NULL, eps = 1,                            plot = FALSE) table(ex_dbscan2$clusters$K_1) ##  ##   1  ## 338 ex_dbscan3 <- nhclu_dbscan(dissim, index = \"Simpson\", minPts = 4, eps = 0.5,                            plot = FALSE)  table(ex_dbscan3$clusters$K_2) ## < table of extent 0 >"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"section4","dir":"Articles","previous_headings":"","what":"4. Affinity propagation","title":"4.2 Non-hierarchical clustering","text":"algorithm based paper Frey & Dueck (2007) relies R package apcluster Unlike previous algorithms vignette, algorithm associated function use similarity matrix.","code":"# Similarity matrix sim <- dissimilarity_to_similarity(dissim)  # Algorithm clust1 <- nhclu_affprop(sim)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"section5","dir":"Articles","previous_headings":"","what":"5. Optimal number of clusters","title":"4.2 Non-hierarchical clustering","text":"Previous methods help determining optimal number bioregions structuring site-species matrix. purpose, can combine functions bioregionalization_metrics() find_optimal_n(). bioregionalization_metrics() calcultes several metrics based previous clustering attempts. *Note two metrics tot_endemism avg_endemism, also need provide site-species matrix. bioregionalization_metrics() function calculated partitioning metrics, can call find_optimal_n() get optimal number clusters.  Based metric selected, optimal number clusters can vary.","code":"bioregionalization_metrics(ex_pam, dissimilarity = dissim,                            eval_metric = \"pc_distance\") ## Partition metrics: ##  - 24  partition(s) evaluated ##  - Range of clusters explored: from  2  to  25  ##  - Requested metric(s):  pc_distance  ##  - Metric summary: ##      pc_distance ## Min    0.5464742 ## Mean   0.8022971 ## Max    0.8949633 ##  ## Access the data.frame of metrics with your_object$evaluation_df a <- bioregionalization_metrics(ex_pam, dissimilarity = dissim, net = fishdf,                                 species_col = \"Species\", site_col = \"Site\",                                 eval_metric = c(\"tot_endemism\", \"avg_endemism\",                                                 \"pc_distance\", \"anosim\")) find_optimal_n(a) ## Number of bioregionalizations: 24 ## Searching for potential optimal number(s) of clusters based on the elbow method ##    * elbow found at: ## tot_endemism 4 ## avg_endemism 4 ## pc_distance 7 ## anosim 2 ## Plotting results... ## Search for an optimal number of clusters: ##  - 24  partition(s) evaluated ##  - Range of clusters explored: from  2  to  25  ##  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  elbow  ##  - Optimal partition(s) of clusters for each metric: ## tot_endemism - 4 ## avg_endemism - 4 ## pc_distance - 7 ## anosim - 2"},{"path":[]},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"input-data","dir":"Articles","previous_headings":"1 Introduction","what":"1.1 Input data","title":"4.3 Network clustering","text":"network algorithms work network format, .e. data.frame 3 columns: sites, species abundance given species given site. type object can obtained site x species matrix use mat_to_net(). vignette, directly load network format distribution fish European basins. network algorithms work similarity matrix pair sites.","code":"library(\"bioregion\") data(\"fishdf\") data(\"fishmat\") fish_simil <- similarity(fishmat, metric = \"Simpson\")"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"main-arguments","dir":"Articles","previous_headings":"1 Introduction","what":"1.2 Main arguments","title":"4.3 Network clustering","text":"algorithms presented specific parameters can tweaked arguments common functions. Among common arguments following: * weight boolean indicating weights considered * index name number column use weight. default, third column name network data.frame used * site_col name number column site nodes (.e. primary nodes). * species_col = name number column species nodes (.e. feature nodes) * return_node_type character indicating types nodes (“sites”, “species” “”) returned output (keep_nodes_type=“” default). * algorithm_in_output boolean indicating original output communities returned output (see Value). three algorithms relying executable binary files, following arguments needed: * delete_temp boolean indicating temporary folder removed * path_temp character indicating path temporary folder * binpath character indicating path bin folder","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"binary-files","dir":"Articles","previous_headings":"","what":"2. Binary files","title":"4.3 Network clustering","text":"","code":"install_binaries(binpath = \"tempdir\", infomap_version = c(\"2.1.0\", \"2.6.0\"))"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"infomap","dir":"Articles","previous_headings":"2. Binary files","what":"2.1 Infomap","title":"4.3 Network clustering","text":"Rosvall & Bergstrom (2008) nbmod penalize solutions differ number (0 default preferred number modules). markovtime scales link flow change cost moving modules, higher values results fewer modules (default 1). seed random number generator (NULL random default) numtrials number trials picking best solution. twolevel boolean indicating algorithm optimize two-level partition network (default multi-level). show_hierarchy boolean specifying hierarchy community identifiable outputs (FALSE default).","code":"set.seed(1) ex_infomap <- netclu_infomap(fish_simil,                              weight = TRUE,                              index = names(fish_simil)[3],                              nbmod = 0,                              markovtime = 1,                              seed = NULL,                              numtrials = 1,                              twolevel = FALSE,                              show_hierarchy = FALSE,                              directed = FALSE,                              bipartite_version = FALSE,                              bipartite = FALSE,                              site_col = 1,                              species_col = 2,                              return_node_type = \"both\",                              version = \"2.6.0\",                              binpath = \"tempdir\",                              path_temp = \"infomap_temp\",                              delete_temp = TRUE)  table(ex_infomap$clusters$K_5) ##  ##   1   2   3   4   5  ## 290  14  23   9   2"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"oslom","dir":"Articles","previous_headings":"2. Binary files","what":"2.2 OSLOM","title":"4.3 Network clustering","text":"OSLOM stands Order Statistics Local Optimization Method. Similarity-based algorithm. Lancichinetti et al. (2011) reassign string indicating nodes belonging several community reassign method used (see Note). * r number runs first hierarchical level (10 default). * hr number runs higher hierarchical level (50 default, 0 interested hierarchies). * seed random number generator (NULL random default). * t p-value, default value 0.10, increase value get modules. * cp kind resolution parameter used decide taking modules union (default value 0.5, bigger value leads bigger clusters).","code":"set.seed(1) ex_oslom <- netclu_oslom(fish_simil,                          weight = TRUE,                          index = names(fish_simil)[3],                          reassign = \"no\",                          r = 10,                          hr = 50,                          seed = NULL,                          t = 0.1,                          cp = 0.5,                          directed = FALSE,                          bipartite = FALSE,                          site_col = 1,                          species_col = 2,                          return_node_type = \"both\",                          binpath = \"tempdir\",                          path_temp = \"oslom_temp\",                          delete_temp = TRUE)  table(ex_oslom$clusters$K_338)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"louvain","dir":"Articles","previous_headings":"2. Binary files","what":"2.3 Louvain","title":"4.3 Network clustering","text":"Blondel et al. (2008) q quality function used compute partition graph (modularity chosen default, see Details). c parameter Owsinski-Zadrozny quality function (0 1, 0.5 chosen default) k kappa_min value Shi-Malik quality function (must > 0, 1 chosen default)","code":"set.seed(1) ex_louvain <- netclu_louvain(fishdf,                              weight = TRUE,                              index = names(fishdf)[3],                              lang = \"cpp\",                              q = 0,                              c = 0.5,                              k = 1,                              bipartite = FALSE,                              site_col = 1,                              species_col = 2,                              return_node_type = \"both\",                              binpath = \"tempdir\",                              path_temp = \"louvain_temp\",                              delete_temp = TRUE,                              algorithm_in_output = TRUE) table(ex_louvain$clusters$K_23) ## < table of extent 0 >"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"fastgreedy","dir":"Articles","previous_headings":"3. Functions from the igraph package","what":"3.1 Fastgreedy","title":"4.3 Network clustering","text":"Clauset et al. (2004)","code":"set.seed(1) ex_greedy <- netclu_greedy(fishdf,                            weight = TRUE,                            index = names(fishdf)[3],                            bipartite = FALSE,                            site_col = 1,                            species_col = 2,                            return_node_type = \"both\",                            algorithm_in_output = TRUE) table(ex_greedy$clusters$K_5) ##  ##   1   2   3   4   5  ## 138  61 144 132  58"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"label-propagation","dir":"Articles","previous_headings":"3. Functions from the igraph package","what":"3.2 Label propagation","title":"4.3 Network clustering","text":"Raghavan et al. (2007)","code":"set.seed(1) ex_labelprop <- netclu_labelprop(fishdf,                                  weight = TRUE,                                  index = names(fishdf)[3],                                  bipartite = FALSE,                                  site_col = 1,                                  species_col = 2,                                  return_node_type = \"both\",                                  algorithm_in_output = TRUE) table(ex_labelprop$clusters$K_11) ## < table of extent 0 >"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"leiden-algorithm","dir":"Articles","previous_headings":"3. Functions from the igraph package","what":"3.3 Leiden algorithm","title":"4.3 Network clustering","text":"Traag et al. (2019)","code":"set.seed(1) ex_leiden <- netclu_leiden(fishdf,                            weight = TRUE,                            index = names(fishdf)[3],                            objective_function = \"CPM\",                            resolution_parameter = 1,                            beta = 0.01,                            n_iterations = 2,                            vertex_weights = NULL,                            bipartite = TRUE,                            site_col = 1,                            species_col = 2,                            return_node_type = \"both\",                            algorithm_in_output = TRUE) length(unique(ex_leiden$clusters$K_505)) ## [1] 0"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"leading-eigenvector","dir":"Articles","previous_headings":"3. Functions from the igraph package","what":"3.4 Leading eigenvector","title":"4.3 Network clustering","text":"Newman (2006)","code":"set.seed(1) ex_leadingeigen <- netclu_leadingeigen(fishdf,                                        weight = TRUE,                                        index = names(fishdf)[3],                                        bipartite = FALSE,                                        site_col = 1,                                        species_col = 2,                                        return_node_type = \"both\",                                        algorithm_in_output = TRUE) table(ex_leadingeigen$clusters$K_17) ## < table of extent 0 >"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"walktrap","dir":"Articles","previous_headings":"3. Functions from the igraph package","what":"3.5 Walktrap","title":"4.3 Network clustering","text":"Pons & Latapy (2005)","code":"set.seed(1) ex_walktrap <- netclu_walktrap(fishdf,                                weight = TRUE,                                index = names(fishdf)[3],                                steps = 4,                                bipartite = FALSE,                                site_col = 1,                                species_col = 2,                                return_node_type = \"both\",                                algorithm_in_output = TRUE) table(ex_walktrap$clusters$K_14) ##  ##   1  10  11  12  13  14   2   3   4   5   6   7   8   9  ##  11  47  10   2   6  17  84   5  37  16   5 270   4  19"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"beckett","dir":"Articles","previous_headings":"4 Function from the bipartite package","what":"4.1 Beckett","title":"4.3 Network clustering","text":"Update QuanBiMo algorithm developed Dormann & Strauss (2014). Beckett (2016)","code":"set.seed(1) ex_beckett <- netclu_beckett(fishdf,                              weight = TRUE,                              index = names(fishdf)[3],                              site_col = 1,                              species_col = 2,                              return_node_type = \"both\",                              forceLPA = TRUE,                              algorithm_in_output = TRUE) ex_beckett$clusters$K_23 ##   [1] \"4\"  \"1\"  \"2\"  \"3\"  \"4\"  \"4\"  \"3\"  \"3\"  \"16\" \"13\" \"1\"  \"1\"  \"8\"  \"1\"  \"16\" ##  [16] \"5\"  \"4\"  \"3\"  \"4\"  \"8\"  \"4\"  \"1\"  \"4\"  \"4\"  \"5\"  \"4\"  \"4\"  \"1\"  \"13\" \"1\"  ##  [31] \"4\"  \"3\"  \"1\"  \"3\"  \"4\"  \"4\"  \"4\"  \"4\"  \"3\"  \"3\"  \"4\"  \"3\"  \"1\"  \"5\"  \"3\"  ##  [46] \"3\"  \"6\"  \"4\"  \"3\"  \"4\"  \"1\"  \"4\"  \"1\"  \"4\"  \"4\"  \"4\"  \"7\"  \"8\"  \"4\"  \"9\"  ##  [61] \"4\"  \"4\"  \"4\"  \"4\"  \"10\" \"10\" \"1\"  \"4\"  \"5\"  \"1\"  \"5\"  \"4\"  \"8\"  \"8\"  \"4\"  ##  [76] \"1\"  \"3\"  \"1\"  \"16\" \"13\" \"12\" \"1\"  \"22\" \"4\"  \"3\"  \"1\"  \"3\"  \"1\"  \"13\" \"4\"  ##  [91] \"4\"  \"8\"  \"4\"  \"8\"  \"15\" \"15\" \"15\" \"15\" \"4\"  \"1\"  \"8\"  \"4\"  \"1\"  \"8\"  \"4\"  ## [106] \"8\"  \"4\"  \"1\"  \"1\"  \"4\"  \"1\"  \"15\" \"1\"  \"1\"  \"5\"  \"1\"  \"16\" \"8\"  \"1\"  \"1\"  ## [121] \"1\"  \"13\" \"1\"  \"8\"  \"1\"  \"8\"  \"17\" \"18\" \"1\"  \"1\"  \"1\"  \"8\"  \"1\"  \"19\" \"1\"  ## [136] \"1\"  \"8\"  \"4\"  \"4\"  \"4\"  \"4\"  \"5\"  \"4\"  \"1\"  \"1\"  \"1\"  \"4\"  \"4\"  \"5\"  \"5\"  ## [151] \"3\"  \"8\"  \"1\"  \"11\" \"1\"  \"4\"  \"1\"  \"1\"  \"1\"  \"1\"  \"13\" \"16\" \"4\"  \"1\"  \"1\"  ## [166] \"1\"  \"1\"  \"1\"  \"1\"  \"3\"  \"8\"  \"5\"  \"5\"  \"20\" \"5\"  \"4\"  \"3\"  \"1\"  \"4\"  \"1\"  ## [181] \"4\"  \"1\"  \"6\"  \"1\"  \"13\" \"3\"  \"8\"  \"8\"  \"4\"  \"3\"  \"1\"  \"8\"  \"1\"  \"4\"  \"8\"  ## [196] \"1\"  \"3\"  \"4\"  \"1\"  \"4\"  \"8\"  \"4\"  \"1\"  \"1\"  \"4\"  \"1\"  \"16\" \"1\"  \"4\"  \"8\"  ## [211] \"1\"  \"3\"  \"15\" \"1\"  \"1\"  \"16\" \"13\" \"1\"  \"3\"  \"1\"  \"1\"  \"1\"  \"3\"  \"1\"  \"21\" ## [226] \"1\"  \"4\"  \"1\"  \"1\"  \"1\"  \"1\"  \"1\"  \"4\"  \"1\"  \"1\"  \"1\"  \"8\"  \"4\"  \"4\"  \"4\"  ## [241] \"1\"  \"22\" \"1\"  \"1\"  \"1\"  \"4\"  \"1\"  \"5\"  \"1\"  \"4\"  \"1\"  \"1\"  \"1\"  \"8\"  \"15\" ## [256] \"4\"  \"1\"  \"4\"  \"4\"  \"1\"  \"4\"  \"4\"  \"4\"  \"8\"  \"3\"  \"4\"  \"8\"  \"3\"  \"4\"  \"1\"  ## [271] \"1\"  \"13\" \"1\"  \"4\"  \"22\" \"1\"  \"1\"  \"3\"  \"3\"  \"5\"  \"5\"  \"4\"  \"4\"  \"1\"  \"4\"  ## [286] \"4\"  \"4\"  \"4\"  \"3\"  \"11\" \"4\"  \"3\"  \"4\"  \"1\"  \"1\"  \"1\"  \"1\"  \"8\"  \"4\"  \"4\"  ## [301] \"4\"  \"4\"  \"3\"  \"1\"  \"5\"  \"1\"  \"1\"  \"4\"  \"5\"  \"8\"  \"1\"  \"1\"  \"1\"  \"1\"  \"1\"  ## [316] \"5\"  \"1\"  \"4\"  \"1\"  \"1\"  \"14\" \"10\" \"8\"  \"4\"  \"1\"  \"4\"  \"4\"  \"4\"  \"4\"  \"3\"  ## [331] \"1\"  \"1\"  \"5\"  \"4\"  \"8\"  \"8\"  \"4\"  \"23\" \"4\"  \"4\"  \"4\"  \"8\"  \"8\"  \"1\"  \"4\"  ## [346] \"4\"  \"4\"  \"13\" \"1\"  \"4\"  \"4\"  \"1\"  \"16\" \"16\" \"2\"  \"16\" \"2\"  \"2\"  \"2\"  \"16\" ## [361] \"2\"  \"16\" \"3\"  \"4\"  \"3\"  \"3\"  \"3\"  \"3\"  \"3\"  \"3\"  \"3\"  \"3\"  \"4\"  \"5\"  \"4\"  ## [376] \"4\"  \"3\"  \"3\"  \"12\" \"16\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" ## [391] \"13\" \"13\" \"13\" \"8\"  \"8\"  \"16\" \"16\" \"5\"  \"20\" \"15\" \"5\"  \"5\"  \"4\"  \"3\"  \"3\"  ## [406] \"8\"  \"15\" \"5\"  \"5\"  \"5\"  \"5\"  \"5\"  \"5\"  \"13\" \"8\"  \"13\" \"9\"  \"3\"  \"3\"  \"3\"  ## [421] \"5\"  \"6\"  \"19\" \"6\"  \"6\"  \"7\"  \"7\"  \"7\"  \"7\"  \"7\"  \"8\"  \"7\"  \"7\"  \"7\"  \"7\"  ## [436] \"21\" \"21\" \"7\"  \"21\" \"7\"  \"7\"  \"7\"  \"7\"  \"7\"  \"7\"  \"8\"  \"10\" \"8\"  \"10\" \"9\"  ## [451] \"9\"  \"9\"  \"9\"  \"10\" \"9\"  \"9\"  \"8\"  \"10\" \"22\" \"9\"  \"9\"  \"9\"  \"10\" \"9\"  \"8\"  ## [466] \"10\" \"9\"  \"9\"  \"4\"  \"10\" \"10\" \"8\"  \"10\" \"10\" \"15\" \"5\"  \"5\"  \"11\" \"11\" \"15\" ## [481] \"13\" \"13\" \"22\" \"22\" \"13\" \"22\" \"12\" \"12\" \"22\" \"13\" \"13\" \"15\" \"15\" \"14\" \"15\" ## [496] \"15\" \"15\" \"15\" \"15\" \"5\"  \"16\" \"17\" \"18\" \"18\" \"18\" \"18\" \"23\" \"19\" \"19\" \"13\" ## [511] \"20\" \"13\" \"22\" \"13\" \"13\" \"13\" \"3\"  \"21\" \"21\" \"21\" \"21\" \"21\" \"21\" \"4\"  \"22\" ## [526] \"22\" \"5\"  \"22\" \"22\" \"22\" \"5\"  \"10\" \"23\""},{"path":[]},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_4_microbenchmark.html","id":"vegemat","dir":"Articles","previous_headings":"1. Datasets","what":"1.1. Vegemat","title":"4.4 Microbenchmark","text":"first dataset comes available bioregion analyzed article. contains abundance 3,697 plant species distributed 715 sites French Mediterranean area. dataset use two following files: vegedf data.frame 460,878 rows 3 columns (Site, Species Abundance) vegemat co-occurrence matrix containing information gathered matrix 715 rows 3,697 columns.","code":"data(\"vegedf\") data(\"vegemat\")  vegemat_dissim <- dissimilarity(vegemat,  metric = c(\"abc\", \"Simpson\")) vegemat_df <- mat_to_net(vegemat, weight = TRUE, remove_zeroes = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_4_microbenchmark.html","id":"european-fish","dir":"Articles","previous_headings":"1. Datasets","what":"1.2. European fish","title":"4.4 Microbenchmark","text":"second dataset also comes available bioregion contains distribution 195 freshwater fish distributed basins Europe.","code":"data(\"fishmat\") fishdissim <- dissimilarity(fishmat, metric = \"all\") data(\"fishdf\")"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_4_microbenchmark.html","id":"aravo","dir":"Articles","previous_headings":"1. Datasets","what":"1.3. Aravo","title":"4.4 Microbenchmark","text":"third dataset, called aravo, retrieved package ade4. contains distribution 82 alpine plants 75 sites distributed French Alps.","code":"data(\"aravo\") aravo <- as.matrix(aravo$spe) dim(aravo) ## [1] 75 82 ara_dissim <- dissimilarity(aravo, metric = \"all\")  ara_df <- mat_to_net(aravo, weight = TRUE, remove_zeroes = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_4_microbenchmark.html","id":"microbenchmark","dir":"Articles","previous_headings":"","what":"2. Microbenchmark","title":"4.4 Microbenchmark","text":"assess time needed clustering algorithm three datasets loaded . Plotting results.   OSLOM Beckett slow, ran far Vegetation data.","code":"install_binaries()  mbm <- suppressMessages(   microbenchmark(     # aravo     ara_nhclu_dbscan = nhclu_dbscan(dissimilarity = ara_dissim,                                     index = \"Simpson\", plot = FALSE),     ara_nhclu_kmeans = nhclu_kmeans(ara_dissim, n_clust = 2:10,                                     index = \"Simpson\"),     ara_nhclu_pam = nhclu_pam(ara_dissim, n_clust = 2:10, index = \"Simpson\"),     ara_hclu_hierarclust = hclu_hierarclust(dissimilarity = ara_dissim,                                             n_clust = 5,                                             optimal_tree_method = \"best\"),     ara_hclu_optics = hclu_optics(ara_dissim, index = \"Simpson\"),     ara_netclu_beckett = netclu_beckett(ara_df),     ara_netclu_greedy = netclu_greedy(ara_df),     ara_netclu_labelprop = netclu_labelprop(ara_df),     ara_netclu_leadingeigen = netclu_leadingeigen(ara_df),     ara_netclu_oslom = netclu_oslom(ara_df),     ara_netclu_walktrap = netclu_walktrap(ara_df),     ara_netclu_infomap = netclu_infomap(ara_df),     ara_netclu_louvain = netclu_louvain(ara_df),          # fish vertebrates     fish_nhclu_dbscan = nhclu_dbscan(dissimilarity = fishdissim,                                      index = \"Simpson\", plot = FALSE),     fish_nhclu_kmeans = nhclu_kmeans(fishdissim, n_clust = 2:10,                                      index = \"Simpson\"),     fish_nhclu_pam = nhclu_pam(fishdissim, n_clust = 2:10, index = \"Simpson\"),     fish_hclu_hierarclust = hclu_hierarclust(dissimilarity = fishdissim,                                              n_clust = 5,                                              optimal_tree_method = \"best\"),     fish_hclu_optics = hclu_optics(fishdissim, index = \"Simpson\"),     fish_netclu_beckett = netclu_beckett(fishdf),     fish_netclu_greedy = netclu_greedy(fishdf),     fish_netclu_labelprop = netclu_labelprop(fishdf),     fish_netclu_leadingeigen = netclu_leadingeigen(fishdf),     fish_netclu_oslom = netclu_oslom(fishdf),     fish_netclu_walktrap = netclu_walktrap(fishdf),     fish_netclu_infomap = netclu_infomap(fishdf),     fish_netclu_louvain = netclu_louvain(fishdf),          # vegetation     veg_nhclu_dbscan = nhclu_dbscan(dissimilarity = vegemat_dissim,                                     index = \"Simpson\", plot = FALSE),     veg_nhclu_kmeans = nhclu_kmeans(vegemat_dissim, n_clust = 2:10,                                     index = \"Simpson\"),     veg_nhclu_pam = nhclu_pam(vegemat_dissim, n_clust = 2:10,                               index = \"Simpson\"),     veg_hclu_hierarclust = hclu_hierarclust(dissimilarity = vegemat_dissim,                                             n_clust = 5,                                             optimal_tree_method = \"best\"),     veg_hclu_optics = hclu_optics(vegemat_dissim, index = \"Simpson\"),     # veg_netclu_beckett = netclu_beckett(vegemat_df),     veg_netclu_greedy = netclu_greedy(vegemat_df),     veg_netclu_labelprop = netclu_labelprop(vegemat_df),     veg_netclu_leadingeigen = netclu_leadingeigen(vegemat_df),     # veg_netclu_oslom = netclu_oslom(vegemat_df),     veg_netclu_walktrap = netclu_walktrap(vegemat_df),     veg_netclu_infomap = netclu_infomap(vegemat_df),     veg_netclu_louvain = netclu_louvain(vegemat_df),          times = 2))  mbm_plot <- data.frame(mbm) mbm_plot$expr <- as.character(mbm_plot$expr) mbm_plot$dataset <- ifelse(   grepl(\"ara_\", mbm_plot$expr),   paste0(\"Aravo (\", nrow(aravo) * ncol(aravo), \" cells)\"),   ifelse(grepl(\"fish\", mbm_plot$expr),          paste0(\"Fish (\", nrow(fishmat) * ncol(fishmat), \" cells)\"),          paste0(\"Vegetation (\", nrow(vegemat) * ncol(vegemat), \" cells)\")))  mbm_plot$algorithm <- gsub( \".*_\", \"\", mbm_plot$expr)  # Time in minutes mbm_plot$time_min <- mbm_plot$time / 60e9 # Time in seconds mbm_plot$time_sec <- mbm_plot$time / 1e9 ggplot(mbm_plot[which(mbm_plot$dataset == \"Aravo (6150 cells)\"), ],        aes(reorder(algorithm, time_sec), time_sec)) +   geom_boxplot(aes(color = reorder(algorithm, time_sec),                    fill = reorder(algorithm, time_sec)), show.legend = FALSE) +   scale_color_viridis_d(\"Algorithm\") +   scale_fill_viridis_d(\"Algorithm\") +   labs(title = \"Aravo (6,510 cells)\", x = \"\", y = \"Time (seconds)\") +   theme_classic() +   theme(panel.border = element_rect(fill = NA),         axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) ggplot(mbm_plot[which(mbm_plot$dataset == \"Fish (65910 cells)\"), ],        aes(reorder(algorithm, time_sec), time_sec)) +   geom_boxplot(aes(color = reorder(algorithm, time_sec),                    fill = reorder(algorithm, time_sec)), show.legend = FALSE) +   scale_color_viridis_d(\"Algorithm\") +   scale_fill_viridis_d(\"Algorithm\") +   labs(title = \"European fish (65,910 cells)\",        x = \"\", y = \"Time (seconds)\") +   theme_classic() +   theme(panel.border = element_rect(fill = NA),         axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) ggplot(mbm_plot[which(mbm_plot$dataset == \"Vegetation (2643355 cells)\"), ],        aes(reorder(algorithm, time_min), time_min)) +   geom_boxplot(aes(color = reorder(algorithm, time_min),                    fill = reorder(algorithm, time_min)), show.legend = FALSE) +   scale_color_viridis_d(\"Algorithm\") +   scale_fill_viridis_d(\"Algorithm\") +   labs(title = \"Vegetation (2,643,355 cells)\", x = \"\", y = \"Time (minutes)\") +   theme_classic() +   theme(panel.border = element_rect(fill = NA),         axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"data","dir":"Articles","previous_headings":"","what":"1. Data","title":"5.1 Visualization","text":"vignette, rely dataset describing distribution vascular plants Mediterranean part France. first load matrix format dataset, computes dissimilarity matrix also load data.frame format data. Since aim plotting result, also need object vegesf linking site dataset geometry. also import world coastlines, available rnaturalearth R package.","code":"data(vegemat) vegedissim <- dissimilarity(vegemat, metric = \"all\") data(vegedf) data(vegesf) world <- rnaturalearth::ne_coastline(returnclass = \"sf\", scale = \"medium\") # Align the CRS of both objects vegesf <- st_transform(vegesf, crs = st_crs(world))"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"plots","dir":"Articles","previous_headings":"","what":"2. Plots","title":"5.1 Visualization","text":"section, show three ways plot results.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"map_bioregions","dir":"Articles","previous_headings":"2. Plots","what":"2.1 map_bioregions()","title":"5.1 Visualization","text":"first possibility use function map_bioregions() package. function can directly provide plot site colored according cluster belong .  Let’s take example K-means clustering, number clusters set 3. map_bioregions() function can now simply takes object fish_nhclu_kmeans, bioregion.clusters class, spatial distribution sites, stored fishsf.","code":"set.seed(1) vege_nhclu_kmeans <- nhclu_kmeans(vegedissim, n_clust = 3, index = \"Simpson\") map_bioregions(vege_nhclu_kmeans, geometry = vegesf, plot = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"color-palettes-with-bioregion_colors","dir":"Articles","previous_headings":"2. Plots","what":"2.2 Color palettes with bioregion_colors()","title":"5.1 Visualization","text":"bioregion_colors() function designed define manage consistent color palettes across visualizations. function assigns fixed colors bioregions ensures colors remain consistent across different types plots. bioregion color figures (maps, summary plots, networks, etc.)","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"available-color-palettes","dir":"Articles","previous_headings":"2. Plots > 2.2 Color palettes with bioregion_colors()","what":"Available color palettes","title":"5.1 Visualization","text":"function uses qualitative color palettes rcartocolor package. Let’s explore examples different palettes:","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"example-1-vivid-palette-default","dir":"Articles","previous_headings":"2. Plots > 2.2 Color palettes with bioregion_colors() > Available color palettes","what":"Example 1: Vivid palette (default)","title":"5.1 Visualization","text":"Note vege_kmeans_vivid identical vege_kmeans two new slots: * colors: small data.frame summarising color assigned bioregion * clusters_colors: data.frame identical clusters slot, content modified include colors","code":"# Apply the Vivid palette (default) vege_kmeans_vivid <- bioregion_colors(vege_nhclu_kmeans,                                        palette = \"Vivid\",                                       cluster_ordering = \"n_sites\")  # View the color assignments vege_kmeans_vivid$colors ## $K_3 ##   cluster   color ## 1       1 #E58606 ## 2       3 #5D69B1 ## 3       2 #A5AA99 # Map with Vivid colors map_bioregions(vege_kmeans_vivid, geometry = vegesf, plot = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"example-2-bold-palette","dir":"Articles","previous_headings":"2. Plots > 2.2 Color palettes with bioregion_colors() > Available color palettes","what":"Example 2: Bold palette","title":"5.1 Visualization","text":"","code":"# Apply the Bold palette vege_kmeans_bold <- bioregion_colors(vege_nhclu_kmeans,                                       palette = \"Bold\",                                      cluster_ordering = \"n_sites\")  # View the color assignments vege_kmeans_bold$colors ## $K_3 ##   cluster   color ## 1       1 #7F3C8D ## 2       3 #11A579 ## 3       2 #A5AA99 # Map with Bold colors map_bioregions(vege_kmeans_bold, geometry = vegesf, plot = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"example-3-safe-palette","dir":"Articles","previous_headings":"2. Plots > 2.2 Color palettes with bioregion_colors() > Available color palettes","what":"Example 3: Safe palette","title":"5.1 Visualization","text":"Safe palette designed colorblind-friendly.","code":"# Apply the Safe palette vege_kmeans_safe <- bioregion_colors(vege_nhclu_kmeans,                                        palette = \"Safe\",                                       cluster_ordering = \"n_sites\")  # View the color assignments vege_kmeans_safe$colors ## $K_3 ##   cluster   color ## 1       1 #88CCEE ## 2       3 #CC6677 ## 3       2 #888888 # Map with Safe colors map_bioregions(vege_kmeans_safe, geometry = vegesf, plot = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"using-consistent-colors-across-different-plot-types","dir":"Articles","previous_headings":"2. Plots > 2.2 Color palettes with bioregion_colors()","what":"Using consistent colors across different plot types","title":"5.1 Visualization","text":"’ve assigned colors bioregions, can use consistently across visualizations. ’s example creating summary bar chart showing number sites per bioregion colors map:  Colors bar chart match exactly map. makes easier readers connect spatial patterns summary statistics. color scheme can also applied exporting networks Gephi (see section 3.3 “Network node attributes colors”). exportGDF() function automatically uses colors defined bioregion_colors(), ensuring consistency maps network visualizations.","code":"# Use the colored cluster object (e.g., with Vivid palette) # Extract cluster assignments clusters_df <- vege_kmeans_vivid$clusters  # Count number of sites per bioregion bioregion_summary <- clusters_df %>%   group_by(K_3) %>%   summarise(n_sites = n()) %>%   arrange(desc(n_sites)) # Another simpler option: dplyr::count(clusters_df, K_3)  # Extract colors for plotting colors_df_K3 <- vege_kmeans_vivid$colors[[1]]  # First (and only) partition color_vector <- setNames(colors_df_K3$color, colors_df_K3$cluster)  # Create bar plot with matching colors ggplot(bioregion_summary, aes(x = reorder(K_3, -n_sites),                                 y = n_sites,                                 fill = K_3)) +   geom_col() +   scale_fill_manual(values = color_vector) +   labs(title = \"Number of sites per bioregion\",        x = \"Bioregion\",        y = \"Number of sites\") +   theme_minimal() +   theme(legend.position = \"none\")"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"custom-plot","dir":"Articles","previous_headings":"2. Plots","what":"2.3 Custom plot","title":"5.1 Visualization","text":"want customize plot simply rely default option, map_bioregions() gives possibility extract site well geometry cluster number. purpose, can set arguments like chunk :","code":"custom <- map_bioregions(vege_nhclu_kmeans, geometry = vegesf,                          write_clusters = TRUE, plot = FALSE) custom ## Simple feature collection with 715 features and 2 fields ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 1.686171 ymin: 42.29604 xmax: 7.798711 ymax: 45.13742 ## Geodetic CRS:  WGS 84 ## First 10 features: ##    ID K_3                       geometry ## 1  35   2 POLYGON ((6.098099 45.13742... ## 2  36   2 POLYGON ((6.22521 45.13381,... ## 3  37   2 POLYGON ((6.352304 45.13007... ## 4  38   2 POLYGON ((6.47938 45.12617,... ## 5  39   2 POLYGON ((6.606438 45.12213... ## 6  84   2 POLYGON ((6.093117 45.04745... ## 7  85   2 POLYGON ((6.220024 45.04385... ## 8  86   2 POLYGON ((6.346914 45.04011... ## 9  87   2 POLYGON ((6.473786 45.03622... ## 10 88   2 POLYGON ((6.600641 45.03219... # Crop world coastlines to the extent of the sf object of interest europe <- sf::st_crop(world, sf::st_bbox(custom))  # Plot ggplot(custom) +   geom_sf(aes(fill = K_3), show.legend = FALSE) +   geom_sf(data = europe) +   scale_fill_viridis_d() +   labs(title = \"Kmeans with 3 clusters\") +   theme_void()"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"plot-with-facets","dir":"Articles","previous_headings":"2. Plots","what":"2.4 Plot with facets","title":"5.1 Visualization","text":"Finally, can interested plotting several bioregionalizations . purpose, can build single data.frame gathering bioregions obtained distinct algorithms take advantage facets implemented ggplot2. first compute bioregionalizations dataset using algorithms. can now make single data.frame extra-column indicating algorithm used. now convert data.frame long-format data.frame. now add back geometry extra column make object spatial. Now long-format spatial data.frame, can take advantage facets implemented ggplot2.  can refine map : * reordering 3 bioregions follow order * add background Mediterranean sea mainland * crop cells mainland * adjust labels","code":"# Hierarchical clustering set.seed(1) vege_hclu_hierarclust <- hclu_hierarclust(dissimilarity = vegedissim,                                           index = names(vegedissim)[6],                                           method = \"mcquitty\", n_clust = 3,                                           optimal_tree_method = \"best\") vege_hclu_hierarclust$cluster_info ##   partition_name n_clust requested_n_clust output_cut_height ## 1            K_3       3                 3             0.625 # Walktrap network bioregionalization vegesim <- dissimilarity_to_similarity(vegedissim) set.seed(1) vege_netclu_walktrap <- netclu_walktrap(vegesim,                                         index = names(vegesim)[6]) vege_netclu_walktrap$cluster_info # 3 ##     partition_name n_clust ## K_3            K_3       3 vege_kmeans <- vege_nhclu_kmeans$clusters colnames(vege_kmeans)<- c(\"ID\", \"NHCLU_KMEANS\") vege_hieraclust <- vege_hclu_hierarclust$clusters colnames(vege_hieraclust)<- c(\"ID\", \"HCLU_HIERARCLUST\") vege_walktrap <- vege_netclu_walktrap$clusters colnames(vege_walktrap)<- c(\"ID\", \"NETCLU_Walktrap\")  all_clusters <- dplyr::left_join(vege_kmeans, vege_hieraclust, by = \"ID\") all_clusters <- dplyr::left_join(all_clusters, vege_walktrap, by = \"ID\") all_long <- tidyr::pivot_longer(data = all_clusters,                                 cols = dplyr::contains(\"_\"),                                 names_to = \"Algorithm\",                                 values_to = \"Clusters\") all_long <- as.data.frame(all_long) all_long_sf <- dplyr::left_join(all_long,                                 vegesf[, c(\"ID\", \"geometry\")],                                 by = \"ID\") all_long_sf <- sf::st_as_sf(all_long_sf) ggplot(all_long_sf) +   geom_sf(aes(color = Clusters, fill = Clusters)) +   geom_sf(data = europe, fill = \"gray80\") +   scale_color_viridis_d() +   scale_fill_viridis_d() +   theme_void() +   facet_wrap(~ Algorithm) world_countries <- rnaturalearth::ne_countries(scale = \"medium\",                                                returnclass = \"sf\")  # Background box xmin <- st_bbox(world)[[\"xmin\"]]; xmax <- st_bbox(world)[[\"xmax\"]] ymin <- st_bbox(world)[[\"ymin\"]]; ymax <- st_bbox(world)[[\"ymax\"]] bb <- sf::st_union(sf::st_make_grid(st_bbox(c(xmin = xmin,                                               xmax = xmax,                                               ymax = ymax,                                               ymin = ymin),                                             crs = st_crs(4326)),                                     n = 100))  # Crop world coastlines to the extent of the sf object of interest vegesf <- st_transform(vegesf, crs = st_crs(world)) larger_bbox <- sf::st_bbox(vegesf) larger_bbox[[1]] <- 1.5 larger_bbox[[2]] <- 42.15 larger_bbox[[3]] <- 8.1 larger_bbox[[4]] <- 45.3  europe <- sf::st_crop(world, larger_bbox) sf_use_s2(FALSE) europe_countries <- sf::st_crop(world_countries, larger_bbox) europe_bb <- sf::st_crop(bb, larger_bbox)  plot_basis <- ggplot(europe) +   geom_sf(data = europe_bb, fill = \"aliceblue\") +   geom_sf(data = europe_countries, fill = \"ivory\", color = \"gray50\") +   theme_void()  # Reordering bioregions all_long_sf$bioregion <- all_long_sf$Clusters  all_long_sf[which(all_long_sf$Algorithm == \"NHCLU_KMEANS\" &                     all_long_sf$Clusters == \"2\"), ]$bioregion <- \"3\" all_long_sf[which(all_long_sf$Algorithm == \"NHCLU_KMEANS\" &                     all_long_sf$Clusters == \"3\"), ]$bioregion <- \"2\"  all_long_sf[which(all_long_sf$Algorithm == \"NETCLU_Walktrap\" &                     all_long_sf$Clusters == \"1\"), ]$bioregion <- \"2\" all_long_sf[which(all_long_sf$Algorithm == \"NETCLU_Walktrap\" &                     all_long_sf$Clusters == \"2\"), ]$bioregion <- \"3\" all_long_sf[which(all_long_sf$Algorithm == \"NETCLU_Walktrap\" &                     all_long_sf$Clusters == \"3\"), ]$bioregion <- \"1\"  # More readable labels for algorithms all_long_sf$Algo <-   ifelse(all_long_sf$Algorithm == \"NHCLU_KMEANS\", \"K-Means\",          ifelse(all_long_sf$Algorithm == \"NHCLU_PAM\", \"PAM\",                 ifelse(all_long_sf$Algorithm == \"HCLU_HIERARCLUST\",                        \"Hierarchical Clustering\", \"Walktrap\")))  # Cropping with borders of France all_long_sf_france <-   st_intersection(all_long_sf,                   europe_countries[which(europe_countries$sovereignt == \"France\"), ])  # Plot final_plot <- plot_basis +   geom_sf(data = all_long_sf_france,           aes(color = bioregion, fill = bioregion), show.legend = TRUE) +   geom_sf(data = st_union(all_long_sf_france), fill = \"NA\", color = \"gray50\") +   geom_sf(data = europe, fill = \"gray50\", linewidth = 0.1) +   scale_color_viridis_d(\"Bioregion\", option = \"magma\", direction = -1) +   scale_fill_viridis_d(\"Bioregion\", option = \"magma\", direction = -1) +   theme_void() +   theme(legend.position = \"bottom\") +   facet_wrap(~ Algo) final_plot"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"exporting-networks-to-gephi","dir":"Articles","previous_headings":"","what":"3. Exporting networks to Gephi","title":"5.1 Visualization","text":"addition visualizing bioregions maps, may want visualize network structure data using specialized network visualization software like Gephi. exportGDF function allows export data GDF (Graph Data Format), can directly imported Gephi. examples, use fish dataset provides clearer network structure easier visualize:","code":"# Load the fish dataset data(fishdf) data(fishmat)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"basic-network-export","dir":"Articles","previous_headings":"3. Exporting networks to Gephi","what":"3.1 Basic network export","title":"5.1 Visualization","text":"Let’s start creating simple bipartite network fish data exporting without weights colors: creates GDF file nodes (sites species) edges (interactions) can opened Gephi. fish dataset contains 2703 site-species interactions across 338 sites 195 species.","code":"# Export the entire bipartite (site-species) fish network to GDF format  exportGDF(fishdf,           col1 = \"Site\",           col2 = \"Species\",           file = \"fish_network_basic.gdf\")"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"unipartite-network-with-edge-weights","dir":"Articles","previous_headings":"3. Exporting networks to Gephi","what":"3.2 Unipartite network with edge weights","title":"5.1 Visualization","text":"addition bipartite networks, can create unipartite networks sites connected based shared species richness. Edge weights represent number species shared pairs sites: creates unipartite network nodes sites edges represent Jaccard similarity index. edge weight indicates similar pair sites. Gephi, weights can used size edges influence layout algorithms, helping visualize sites similar fish communities.","code":"# Create a site-to-site network based on shared species # First, convert the matrix to a dissimilarity object fish_dissim_jac <- dissimilarity(fishmat, metric = \"Jaccard\")  # Convert dissimilarity to similarity (shared species proportion) # Jaccard similarity = 1 - Jaccard dissimilarity # This is because links in a network represent similarity, not dissimilarity fish_sim <- dissimilarity_to_similarity(fish_dissim_jac)  # Remove all links with weight 0 BEFORE exporting to GDF fish_sim <- filter(fish_sim, Jaccard > 0)  # Remove zero similarity links  # Export the unipartite network with shared species as weights exportGDF(fish_sim,           col1 = \"Site1\",           col2 = \"Site2\",           weight = \"Jaccard\",           file = \"fish_network_unipartite_weighted.gdf\")"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"network-with-node-attributes-and-colors","dir":"Articles","previous_headings":"3. Exporting networks to Gephi","what":"3.3 Network with node attributes and colors","title":"5.1 Visualization","text":"create sophisticated visualizations, can add node attributes colors. example, can color sites according bioregion assignment:","code":"# Install binaries if not already installed install_binaries(binpath = \"tempdir\")  # Run a bipartite network clustering analysis fish_netclu <- netclu_infomap(fishdf, # Run Infomap on the bipartite network                              weight = FALSE, # Do not use weights (no abundance here) for clustering                              binpath = \"tempdir\", # Path to the Infomap binary                              numtrials = 100, # Number of trials for Infomap                              show_hierarchy = TRUE, # Show hierarchical levels                              bipartite = TRUE, # This is a bipartite network                              bipartite_version = FALSE, # Use standard Infomap, not bipartite version                              # Because in our experience the standard version produces better results even                              # for bipartite biogeographical networks                              site_col = \"Site\", # Column name for sites                              species_col = \"Species\", # Column name for species                              seed = 123) # Set seed for reproducibility  fish_netclu <- bioregion_colors(fish_nhclu, # Assign colors to bioregions                                    palette = \"Vivid\", # Color palette from rcartocolor                                    cluster_ordering = \"n_both\") # Order clusters by total size (sites + species)  # Let's make the map for the first bioregionalization map_bioregions(fish_netclu, geometry = fishsf,                 partition = 1)  # Export the first bioregionalization to GDF with colors and attributes exportGDF(fishdf,            col1 = \"Site\",            col2 = \"Species\",           bioregions = fish_netclu,           file = \"fish_network_colored.gdf\") # Note: the first bioregionalization is exported by default, but you  # can specify another one with the 'cluster_column' argument"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"visualizing-in-gephi","dir":"Articles","previous_headings":"3. Exporting networks to Gephi","what":"3.4 Visualizing in Gephi","title":"5.1 Visualization","text":"exported network GDF format, can visualize Gephi: Open Gephi go File > Open select GDF file nodes (sites species) edges (occurrences ) Edge weights representing abundance (specified) Node colors indicating bioregions sites (specified) Node attributes bioregion node type (specified) Layout: Apply ForceAtlas 2 algorithm arrange nodes Node colors already set based bioregions Adjust node sizes based degree (= occurrence/richness example ) attributes Now, spend time Gephi make look gorgeous ;)","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"terminology-clarification","dir":"Articles","previous_headings":"","what":"1. Terminology clarification","title":"5.2 Summary metrics","text":"bioregion focused bioregionalization, .e. clustering geographical areas basis species data. However, several cases species can also become part clustering (example, bipartite network clustering), poses terminology issues. conceptually accurate, chosen name species clusters ‘chorotypes’: Bioregion: group sites similar species composition, identified clustering analysis. Bioregions geographic units. Chorotype: group species similar distributions within study area. Chorotypes biological units. generally corresponds concept “regional chorotype” sensu (Baroni Urbani et al., 1978), clarified (Fattorini, 2015). Note clustering worldwide ranges, concept becomes “global chorotypes” (see (Fattorini, 2015) details).","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"bipartite-network-clustering","dir":"Articles","previous_headings":"1. Terminology clarification > Possible cases of chorotypes","what":"Bipartite network clustering","title":"5.2 Summary metrics","text":"bipartite network clustering, sites species assigned clusters (network modules). species assigned cluster 1 belongs bioregion sites assigned cluster 1. use term chorotype refer set species assigned given bioregion, important understand : bipartite clustering, bioregion ID = chorotype ID. two perspectives network partition: bioregion refers sites cluster, chorotype refers species cluster.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"site-only-clustering-with-post-hoc-species-assignment","dir":"Articles","previous_headings":"1. Terminology clarification > Possible cases of chorotypes","what":"Site-only clustering with post-hoc species assignment","title":"5.2 Summary metrics","text":"Species can secondarily assigned bioregions based metrics maximum specificity IndVal. , chorotype refers group species strongly associated given bioregion. Unlike bipartite clustering, assignment derived rather intrinsic clustering algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"species-only-clustering","dir":"Articles","previous_headings":"1. Terminology clarification > Possible cases of chorotypes","what":"Species-only clustering","title":"5.2 Summary metrics","text":"clustering species directly (e.g., distributional similarity), resulting groups true chorotypes regional sense (Fattorini, 2015): species similar distributions within study area.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"example-data","dir":"Articles","previous_headings":"","what":"2. Example data","title":"5.2 Summary metrics","text":"use vegetation dataset included bioregion.","code":"data(\"vegedf\") data(\"vegemat\")  # Calculation of (dis)similarity matrices vegedissim <- dissimilarity(vegemat, metric = c(\"Simpson\")) vegesim <- dissimilarity_to_similarity(vegedissim)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"bioregionalization","dir":"Articles","previous_headings":"","what":"3. Bioregionalization","title":"5.2 Summary metrics","text":"use three bioregionalization algorithms visualization vignette, .e., non-hierarchical, hierarchical, network bioregionalizations. addition, include network bioregionalization algorithm based bipartite network, assigns clusters sites species. chose three bioregions non-hierarchical hierarchical bioregionalizations.","code":"# Non hierarchical bioregionalization vege_nhclu <- nhclu_kmeans(vegedissim,                             n_clust = 3,                             index = \"Simpson\",                            seed = 1) vege_nhclu$cluster_info ##     partition_name n_clust ## K_3            K_3       3 # Hierarchical bioregionalization set.seed(1) vege_hclu <- hclu_hierarclust(dissimilarity = vegedissim,                               index = \"Simpson\",                               method = \"average\",                                n_clust = 3,                               optimal_tree_method = \"best\",                               verbose = FALSE) vege_hclu$cluster_info ##   partition_name n_clust requested_n_clust output_cut_height ## 1            K_3       3                 3            0.5625 # Network bioregionalization set.seed(1) vege_netclu <- netclu_walktrap(vegesim,                                index = \"Simpson\") vege_netclu$cluster_info ##     partition_name n_clust ## K_3            K_3       3 # Bipartite network bioregionalization install_binaries(verbose = FALSE) vege_netclubip <- netclu_infomap(vegedf,                                  seed = 1,                                   bipartite = TRUE) vege_netclubip$cluster_info ##     partition_name n_clust ## K_8            K_8       8"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"metric-components","dir":"Articles","previous_headings":"","what":"4. Metric components","title":"5.2 Summary metrics","text":"diving specific metrics, can understand core terms using simple example. Consider study area 4 sites 4 species, sites assigned 2 bioregions.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"species-derived-metrics","dir":"Articles","previous_headings":"4. Metric components","what":"4.1 Species-derived metrics","title":"5.2 Summary metrics","text":"following diagram shows site-species matrix sites grouped bioregion. Marginal sums give us core terms needed compute metrics:","code":"Species                    sp1   sp2   sp3   sp4      n_b                   ┌─────┬─────┬─────┬─────┐           Site A │  1  │  1  │  ·  │  ·  │      B1   ───────┼─────┼─────┼─────┼─────┤     2           Site B │  1  │  1  │  1  │  ·  │  Bioregion ══════╪═════╪═════╪═════╪═════╪══════           Site C │  ·  │  1  │  1  │  1  │      B2   ───────┼─────┼─────┼─────┼─────┤     2           Site D │  ·  │  ·  │  1  │  1  │                  └─────┴─────┴─────┴─────┘                         n_sb            sp1   sp2   sp3   sp4     n_b    (per bioregion) ┌─────┬─────┬─────┬─────┐               B1   │  2  │  2  │  1  │  0  │   2                    ├─────┼─────┼─────┼─────┤               B2   │  0  │  1  │  2  │  2  │   2                    └─────┴─────┴─────┴─────┘      n_s (total)      2     3     3     2      n = 4      K_s (# bioreg)   1     2     2     1      K = 2"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"examples-of-calculations","dir":"Articles","previous_headings":"4. Metric components > 4.1 Species-derived metrics","what":"Examples of calculations","title":"5.2 Summary metrics","text":"\\(n_{sb}\\) table, species-per-bioregion metrics follow directly: Specificity (fraction species’ occurrences bioregion): \\[A_{sp1,B1} = \\frac{n_{sp1,B1}}{n_{sp1}} = \\frac{2}{2} = 1.00 \\quad \\text{(sp1 exclusive B1)}\\] \\[A_{sp2,B1} = \\frac{n_{sp2,B1}}{n_{sp2}} = \\frac{2}{3} = 0.67 \\quad \\text{(sp2 mostly B1)}\\] Fidelity (fraction bioregion’s sites species): \\[B_{sp2,B1} = \\frac{n_{sp2,B1}}{n_{B1}} = \\frac{2}{2} = 1.00 \\quad \\text{(sp2 B1 sites)}\\] \\[B_{sp3,B1} = \\frac{n_{sp3,B1}}{n_{B1}} = \\frac{1}{2} = 0.50 \\quad \\text{(sp3 half B1)}\\] IndVal (indicator value = Specificity × Fidelity): \\[IndVal_{sp1,B1} = 1.00 \\times 1.00 = 1.00 \\quad \\text{(perfect indicator B1)}\\] \\[IndVal_{sp2,B1} = 0.67 \\times 1.00 = 0.67\\]","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"site-derived-metrics","dir":"Articles","previous_headings":"4. Metric components","what":"4.2 Site-derived metrics","title":"5.2 Summary metrics","text":"following diagram shows site-species matrix, now species grouped cluster (chorotype). compute many species cluster occur site: NOTE: bipartite clustering, bioregion chorotypes can exact clusters. Nevertheless, use different terms avoid confusion calculation metrics.","code":"Chorotypes                          ┌─── C1 ───┐ ┌─── C2 ───┐                           sp1   sp2   sp3   sp4                         ┌─────┬─────┬─────┬─────┐                  Site A │  1  │  1  │  ·  │  ·  │  2                         ├─────┼─────┼─────┼─────┤    Sites         Site B │  1  │  1  │  1  │  ·  │  3                         ├─────┼─────┼─────┼─────┤                  Site C │  ·  │  1  │  1  │  1  │  3                         ├─────┼─────┼─────┼─────┤                  Site D │  ·  │  ·  │  1  │  1  │  2                         └─────┴─────┴─────┴─────┘                   n_c          2           2         n = 4                           n_gc                C1      C2          n_g      (per cluster)     ┌───────┬───────┐                 Site A │   2   │   0   │        2                        ├───────┼───────┤                 Site B │   2   │   1   │        3                        ├───────┼───────┤                 Site C │   1   │   2   │        3                        ├───────┼───────┤                 Site D │   0   │   2   │        2                        └───────┴───────┘      n_c                   2       2           n = 4"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"examples-of-calculations-1","dir":"Articles","previous_headings":"4. Metric components > 4.2 Site-derived metrics","what":"Examples of calculations","title":"5.2 Summary metrics","text":"Specificity Site C1 (fraction site’s species belonging C1): \\[A_{,C1} = \\frac{n_{,C1}}{n_A} = \\frac{2}{2} = 1.00 \\quad \\text{(Site C1 species)}\\] Specificity Site B C1: \\[A_{B,C1} = \\frac{n_{B,C1}}{n_B} = \\frac{2}{3} = 0.67 \\quad \\text{(Site B mostly C1 species)}\\] Fidelity Site C1 (fraction C1 species present Site ): \\[B_{,C1} = \\frac{n_{,C1}}{n_C1} = \\frac{2}{2} = 1.00 \\quad \\text{(Site C1 species)}\\] Fidelity Site C C1: \\[B_{C,C1} = \\frac{n_{C,C1}}{n_{C1}} = \\frac{1}{2} = 0.50 \\quad \\text{(Site C half C1 species)}\\]","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"metrics-in-bioregionalizationclustering","dir":"Articles","previous_headings":"5. List of site/species metrics included in the package","what":"Metrics in bioregionalization/clustering","title":"5.2 Summary metrics","text":"metrics summarize entity distributed across clusters, rather relation individual cluster.","code":""},{"path":[]},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"usage","dir":"Articles","previous_headings":"","what":"6. Usage","title":"5.2 Summary metrics","text":"section demonstrates use site_species_metrics() metrics computed sites species. possible bipartite network clustering, sites species receive clusters simultaneously. example, use bipartite network bioregionalization section 3, sites species assigned clusters. compute available metrics sites species. Typing name object console calls print(), provides concise overview output, including settings used, preview available metrics, instructions accessing data. can also run summary() oçn object quickly see statistical summary output table, including number rows summary statistics numeric columns. can see also displays top sites species IndVal convenient quick look clustering structure. can also use str() display internal structure object, showing settings dimensions column types data frame component.","code":"all_metrics <- site_species_metrics(   bioregionalization = vege_netclubip,   bioregion_metrics = c(\"Specificity\", \"NSpecificity\", \"Fidelity\",                          \"IndVal\", \"NIndVal\", \"Rho\", \"CoreTerms\",                         \"Richness\", \"Rich_Endemics\", \"Prop_Endemics\",                         \"MeanSim\", \"SdSim\"), # You can also simply write \"all\"   bioregionalization_metrics = c(\"P\", \"Silhouette\"),   data_type = \"both\",   cluster_on = \"both\",   comat = vegemat,   similarity = vegesim,   index = \"Simpson\",   verbose = FALSE) all_metrics ## Site and species metrics ## ======================== ##  ## Settings: ##  - Number of partitions: 1  ##  - Clusters based on: sites and species  ##  - Clustering data type: abundance  ##  - Metric data type: occurrence and abundance  ##  ## Computed metrics: ##  - Per-cluster co-occurrence metrics (occurrence): Specificity, NSpecificity, Fidelity, IndVal, NIndVal, Rho, CoreTerms  ##  - Per-cluster co-occurrence metrics (abundance): Specificity, NSpecificity, Fidelity, IndVal, NIndVal, Rho, CoreTerms  ##  - Per-cluster richness & endemism metrics: Richness, Rich_Endemics, Prop_Endemics  ##  - Per-cluster similarity-based metrics: MeanSim, SdSim  ##  - Bioregionalization co-occurrence metrics (occurrence): P  ##  - Bioregionalization co-occurrence metrics (abundance): P  ##  - Bioregionalization similarity-based metrics: Silhouette  ##  ## Data preview: ## $species_bioregions (29576 rows x 20 cols): ##  Species Bioregion n_sb n_s n_b Specificity_occ NSpecificity_occ Fidelity_occ ##    10017         1  392 551 515           0.711            0.148        0.761 ##    10017         2   86 551  92           0.156            0.182        0.935 ##    10017         3   68 551  75           0.123            0.176        0.907 ##  IndVal_occ NIndVal_occ Rho_occ w_sb   w_s     w_b Specificity_abund ##       0.542       0.113  -0.965 4545 10660 2831323             0.426 ##       0.146       0.170   4.009 5349 10660 1136829             0.502 ##       0.112       0.160   2.960  733 10660  137186             0.069 ##  NSpecificity_abund Fidelity_abund IndVal_abund NIndVal_abund Rho_abund ##               0.082          0.002        0.325         0.063    -9.237 ##               0.542          0.005        0.469         0.507    15.718 ##               0.091          0.005        0.062         0.083    -1.663 ## # ... with 29573 more rows ##  ## $species_bioregionalization (3697 rows x 3 cols): ##  Species P_occ P_abund ##    10017 0.454   0.562 ##    10024 0.463   0.504 ##    10034 0.493   0.264 ## # ... with 3694 more rows ##  ## $site_chorotypes (5720 rows x 20 cols): ##  Site Chorotypes n_gc n_g  n_c Specificity_occ NSpecificity_occ Fidelity_occ ##    35          1    1 129 2219           0.008            0.003        0.000 ##    35          2  121 129  873           0.938            0.892        0.139 ##    35          3    7 129  430           0.054            0.105        0.016 ##  IndVal_occ NIndVal_occ Rho_occ w_gc w_g     w_c Specificity_abund ##       0.000       0.000 -13.981    1 423 2873216             0.002 ##       0.130       0.124  19.103  411 423 1149003             0.972 ##       0.001       0.002  -2.237   11 423  103264             0.026 ##  NSpecificity_abund Fidelity_abund IndVal_abund NIndVal_abund Rho_abund ##               0.001              0        0.000         0.000    -7.973 ##               0.948              0        0.135         0.131    11.313 ##               0.051              0        0.000         0.001    -1.840 ## # ... with 5717 more rows ##  ## $site_chorological (715 rows x 3 cols): ##  Site P_occ P_abund ##    35 0.117   0.055 ##    36 0.465   0.199 ##    37 0.350   0.082 ## # ... with 712 more rows ##  ## $site_bioregions (5720 rows x 7 cols): ##  Site Bioregion Richness Rich_Endemics Prop_Endemics MeanSim SdSim ##    35         1      129             0         0.000   0.116 0.123 ##    35         2      129             2         0.016   0.809 0.179 ##    35         3      129             0         0.000   0.264 0.189 ## # ... with 5717 more rows ##  ## $site_bioregionalization (715 rows x 2 cols): ##  Site Silhouette ##    35      0.540 ##    36      0.379 ##    37      0.511 ## # ... with 712 more rows ##  ## Access data with: ##   your_object$species_bioregions ##   your_object$species_bioregionalization ##   your_object$site_chorotypes ##   your_object$site_chorological ##   your_object$site_bioregions ##   your_object$site_bioregionalization summary(all_metrics) ##  ## Summary of site and species metrics ## =================================== ##  ## Settings: ##  - Number of partitions: 1  ##  - Cluster based on: sites and species  ##  - Clustering data type: abundance  ##  - Metric data type: occurrence and abundance  ##  ## Partition 1: Single partition (8 bioregions, 8 chorotypes) ## ----------------------------------------------------------  ##  ## Species-per-bioregion metrics ($species_bioregions): ##              Metric      Min      Mean        Median         Max ##                n_sb    0.000     0.000     0.0000000     500.000 ##                 n_s    1.000    72.000    72.0000000     671.000 ##                 n_b    1.000    15.000    15.0000000     515.000 ##     Specificity_occ    0.000     0.000     0.0000000       1.000 ##    NSpecificity_occ    0.000     0.000     0.0000000       1.000 ##        Fidelity_occ    0.000     0.000     0.0000000       1.000 ##          IndVal_occ    0.000     0.000     0.0000000       0.844 ##         NIndVal_occ    0.000     0.000     0.0000000       0.996 ##             Rho_occ  -18.940    -0.335    -0.3346268      24.233 ##                w_sb    0.000     0.000     0.0000000   22716.000 ##                 w_s    1.000   422.000   422.0000000   27353.000 ##                 w_b 5558.000 55402.000 55402.0000000 2831323.000 ##   Specificity_abund    0.000     0.000     0.0000000       1.000 ##  NSpecificity_abund    0.000     0.000     0.0000000       1.000 ##      Fidelity_abund    0.000     0.000     0.0000000       0.161 ##        IndVal_abund    0.000     0.000     0.0000000       0.973 ##       NIndVal_abund    0.000     0.000     0.0000000       1.000 ##           Rho_abund  -12.483    -0.239    -0.2393045      26.693 ##  ## Top species by IndVal_occ: ##   1. 12553 (Bioregion 2): 0.844 ##   2. 12749 (Bioregion 1): 0.841 ##   3. 11513 (Bioregion 1): 0.841 ##   4. 11285 (Bioregion 2): 0.838 ##   5. 13550 (Bioregion 2): 0.837 ##  ## Species summary metrics ($species_bioregionalization): ##   Metric Min  Mean Median   Max ##    P_occ   0 0.269  0.246 0.719 ##  P_abund   0 0.216  0.159 0.739 ##  ## Site-per-chorotype metrics ($site_chorotypes): ##              Metric      Min       Mean    Median         Max ##                n_gc    0.000     80.573     1.000    1091.000 ##                 n_g    1.000    644.585   673.000    1221.000 ##                 n_c    3.000    462.125    76.500    2219.000 ##     Specificity_occ    0.000      0.125     0.002       1.000 ##    NSpecificity_occ    0.000      0.125     0.028       1.000 ##        Fidelity_occ    0.000      0.091     0.015       1.000 ##          IndVal_occ    0.000      0.032     0.000       0.524 ##         NIndVal_occ    0.000      0.033     0.000       0.661 ##             Rho_occ  -27.165     -0.927    -1.144      39.347 ##                w_gc    0.000    741.633     3.000   38926.000 ##                 w_g    1.000   5933.064  4012.000   43753.000 ##                 w_c 2942.000 530267.625 50655.500 2873216.000 ##   Specificity_abund    0.000      0.125     0.001       1.000 ##  NSpecificity_abund    0.000      0.125     0.010       1.000 ##      Fidelity_abund    0.000      0.001     0.000       0.496 ##        IndVal_abund    0.000      0.034     0.000       0.701 ##       NIndVal_abund    0.000      0.036     0.000       0.991 ##           Rho_abund  -20.999     -0.462    -0.777      43.653 ##  ## Top sites by IndVal_occ: ##   1. 238 (Chorotype 2): 0.524 ##   2. 433 (Chorotype 2): 0.522 ##   3. 286 (Chorotype 2): 0.497 ##   4. 86 (Chorotype 2): 0.488 ##   5. 384 (Chorotype 2): 0.482 ##  ## Site chorological summary metrics ($site_chorological): ##   Metric Min  Mean Median   Max ##    P_occ   0 0.294  0.244 0.668 ##  P_abund   0 0.254  0.196 0.668 ##  ## Site-per-bioregion metrics ($site_bioregions): ##         Metric Min    Mean  Median      Max ##       Richness   1 644.585 673.000 1221.000 ##  Rich_Endemics   0   1.185   0.000   71.000 ##  Prop_Endemics   0   0.002   0.000    0.156 ##        MeanSim   0   0.439   0.452    1.000 ##          SdSim   0   0.059   0.037    0.500 ##  ## Site summary metrics ($site_bioregionalization): ##      Metric Min  Mean Median   Max ##  Silhouette  -1 -0.02 -0.029 0.789 str(all_metrics) ## bioregion.site.species.metrics object ##  - Partitions: 1  ##  - Cluster based on: sites and species  ##  - Clustering data type: abundance  ##  - Metric data type: occurrence and abundance  ##  - Per-cluster co-occurrence metrics (occurrence): Specificity, NSpecificity, Fidelity, IndVal, NIndVal, Rho, CoreTerms  ##  - Per-cluster co-occurrence metrics (abundance): Specificity, NSpecificity, Fidelity, IndVal, NIndVal, Rho, CoreTerms  ##  - Per-cluster richness & endemism metrics: Richness, Rich_Endemics, Prop_Endemics  ##  - Per-cluster similarity-based metrics: MeanSim, SdSim  ##  - Bioregionalization co-occurrence metrics (occurrence): P  ##  - Bioregionalization co-occurrence metrics (abundance): P  ##  - Bioregionalization similarity-based metrics: Silhouette  ##  ## List of 6 ##  $ species_bioregions        :'data.frame':  29576 obs. of  20 variables: ##   ..$ Species           : chr [1:29576] \"10017\" \"10017\" \"10017\" \"10017\" ... ##   ..$ Bioregion         : chr [1:29576] \"1\" \"2\" \"3\" \"4\" ... ##   ..$ n_sb              : num [1:29576] 392 86 68 1 2 1 0 1 153 74 ... ##   ..$ n_s               : num [1:29576] 551 551 551 551 551 551 551 551 232 232 ... ##   ..$ n_b               : int [1:29576] 515 92 75 26 4 1 1 1 515 92 ... ##   ..$ Specificity_occ   : num [1:29576] 0.71143 0.15608 0.12341 0.00181 0.00363 ... ##   ..$ NSpecificity_occ  : num [1:29576] 0.14806 0.18183 0.17636 0.00748 0.09726 ... ##   ..$ Fidelity_occ      : num [1:29576] 0.7612 0.9348 0.9067 0.0385 0.5 ... ##   ..$ IndVal_occ        : num [1:29576] 5.42e-01 1.46e-01 1.12e-01 6.98e-05 1.81e-03 ... ##   ..$ NIndVal_occ       : num [1:29576] 0.112695 0.169968 0.159897 0.000288 0.048628 ... ##   ..$ Rho_occ           : num [1:29576] -0.965 4.009 2.96 -9.04 -1.29 ... ##   ..$ w_sb              : int [1:29576] 4545 5349 733 1 2 18 0 12 3781 3549 ... ##   ..$ w_s               : int [1:29576] 10660 10660 10660 10660 10660 10660 10660 10660 7361 7361 ... ##   ..$ w_b               : int [1:29576] 2831323 1136829 137186 83829 26975 12303 8138 5558 2831323 1136829 ... ##   ..$ Specificity_abund : num [1:29576] 4.26e-01 5.02e-01 6.88e-02 9.38e-05 1.88e-04 ... ##   ..$ NSpecificity_abund: num [1:29576] 0.082265 0.541967 0.091103 0.000359 0.004661 ... ##   ..$ Fidelity_abund    : num [1:29576] 1.61e-03 4.71e-03 5.34e-03 1.19e-05 7.41e-05 ... ##   ..$ IndVal_abund      : num [1:29576] 3.25e-01 4.69e-01 6.23e-02 3.61e-06 9.38e-05 ... ##   ..$ NIndVal_abund     : num [1:29576] 6.26e-02 5.07e-01 8.26e-02 1.38e-05 2.33e-03 ... ##   ..$ Rho_abund         : num [1:29576] -9.24 15.72 -1.66 -2.73 -1.02 ... ##  $ species_bioregionalization:'data.frame':  3697 obs. of  3 variables: ##   ..$ Species: chr [1:3697] \"10017\" \"10024\" \"10034\" \"10035\" ... ##   ..$ P_occ  : num [1:3697] 0.4542 0.4631 0.4929 0.0588 0.3132 ... ##   ..$ P_abund: num [1:3697] 0.5617 0.5037 0.26396 0.00308 0.05098 ... ##  $ site_chorotypes           :'data.frame':  5720 obs. of  20 variables: ##   ..$ Site              : chr [1:5720] \"35\" \"35\" \"35\" \"35\" ... ##   ..$ Chorotypes        : chr [1:5720] \"1\" \"2\" \"3\" \"4\" ... ##   ..$ n_gc              : num [1:5720] 1 121 7 0 0 0 0 0 241 585 ... ##   ..$ n_g               : num [1:5720] 129 129 129 129 129 129 129 129 867 867 ... ##   ..$ n_c               : int [1:5720] 2219 873 430 137 16 16 3 3 2219 873 ... ##   ..$ Specificity_occ   : num [1:5720] 0.00775 0.93798 0.05426 0 0 ... ##   ..$ NSpecificity_occ  : num [1:5720] 0.0029 0.8923 0.1048 0 0 ... ##   ..$ Fidelity_occ      : num [1:5720] 0.000451 0.138603 0.016279 0 0 ... ##   ..$ IndVal_occ        : num [1:5720] 3.49e-06 1.30e-01 8.83e-04 0.00 0.00 ... ##   ..$ NIndVal_occ       : num [1:5720] 1.31e-06 1.24e-01 1.71e-03 0.00 0.00 ... ##   ..$ Rho_occ           : num [1:5720] -13.981 19.103 -2.237 -2.268 -0.762 ... ##   ..$ w_gc              : int [1:5720] 1 411 11 0 0 0 0 0 4139 38926 ... ##   ..$ w_g               : int [1:5720] 423 423 423 423 423 423 423 423 43753 43753 ... ##   ..$ w_c               : int [1:5720] 2873216 1149003 103264 85285 16026 9049 3356 2942 2873216 1149003 ... ##   ..$ Specificity_abund : num [1:5720] 0.00236 0.97163 0.026 0 0 ... ##   ..$ NSpecificity_abund: num [1:5720] 0.000907 0.947603 0.05149 0 0 ... ##   ..$ Fidelity_abund    : num [1:5720] 3.48e-07 3.58e-04 1.07e-04 0.00 0.00 ... ##   ..$ IndVal_abund      : num [1:5720] 1.07e-06 1.35e-01 4.23e-04 0.00 0.00 ... ##   ..$ NIndVal_abund     : num [1:5720] 4.09e-07 1.31e-01 8.38e-04 0.00 0.00 ... ##   ..$ Rho_abund         : num [1:5720] -7.973 11.313 -1.84 -1.282 -0.431 ... ##  $ site_chorological         :'data.frame':  715 obs. of  3 variables: ##   ..$ Site   : chr [1:715] \"35\" \"36\" \"37\" \"38\" ... ##   ..$ P_occ  : num [1:715] 0.117 0.465 0.35 0.293 0.387 ... ##   ..$ P_abund: num [1:715] 0.0553 0.1993 0.0825 0.0694 0.1883 ... ##  $ site_bioregions           :'data.frame':  5720 obs. of  7 variables: ##   ..$ Site         : chr [1:5720] \"35\" \"35\" \"35\" \"35\" ... ##   ..$ Bioregion    : chr [1:5720] \"1\" \"2\" \"3\" \"4\" ... ##   ..$ Richness     : num [1:5720] 129 129 129 129 129 129 129 129 867 867 ... ##   ..$ Rich_Endemics: num [1:5720] 0 2 0 0 0 0 0 0 0 43 ... ##   ..$ Prop_Endemics: num [1:5720] 0 0.0155 0 0 0 ... ##   ..$ MeanSim      : num [1:5720] 0.1156 0.8088 0.2635 0.0143 0.0291 ... ##   ..$ SdSim        : num [1:5720] 0.12299 0.17917 0.18876 0.01273 0.00742 ... ##  $ site_bioregionalization   :'data.frame':  715 obs. of  2 variables: ##   ..$ Site      : chr [1:715] \"35\" \"36\" \"37\" \"38\" ... ##   ..$ Silhouette: num [1:715] 0.54 0.379 0.511 0.541 0.433 ... ##  - attr(*, \"n_partitions\")= num 1 ##  - attr(*, \"cluster_on\")= chr \"both\" ##  - attr(*, \"clustering_data_type\")= chr \"abundance\" ##  - attr(*, \"index_data_type\")= chr \"both\" ##  - attr(*, \"has_similarity\")= logi TRUE ##  - attr(*, \"has_comat\")= logi TRUE ##  - attr(*, \"bioregion_metrics_occ\")= chr [1:7] \"Specificity\" \"NSpecificity\" \"Fidelity\" \"IndVal\" ... ##  - attr(*, \"bioregion_metrics_abd\")= chr [1:7] \"Specificity\" \"NSpecificity\" \"Fidelity\" \"IndVal\" ... ##  - attr(*, \"bioregionalization_metrics_occ\")= chr \"P\" ##  - attr(*, \"bioregionalization_metrics_abd\")= chr \"P\" ##  - attr(*, \"similarity_metrics\")= chr [1:6] \"Richness\" \"Rich_Endemics\" \"Prop_Endemics\" \"MeanSim\" ... ##  - attr(*, \"class\")= chr [1:2] \"bioregion.site.species.metrics\" \"list\""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"species-per-bioregion-metrics","dir":"Articles","previous_headings":"7. Metrics per cluster","what":"7.1 Species-per-bioregion metrics","title":"5.2 Summary metrics","text":"metrics computed sites clusters (.e., cluster_on = \"site\" (\"\")). following example, compute metrics (bioregion_metrics = c(\"Specificity\", \"NSpecificity\", \"Fidelity\", \"IndVal\", \"NIndVal\", \"Rho\", \"CoreTerms\")). compute metrics, need provide comat.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"co-occurrence-metrics-occurrence-version","dir":"Articles","previous_headings":"7. Metrics per cluster > 7.1 Species-per-bioregion metrics","what":"7.1.1 Co-occurrence metrics: occurrence version","title":"5.2 Summary metrics","text":"occurrence metrics computed data_type = \"occurrence\". default, function detect type data used clustering. However, parameter can overriden users, occurrence metrics can calculated abundance clustering, vice-versa. Users can also specify data_type = \"\" want obtain versions co-occurrence metrics.","code":"nsb <- site_species_metrics(bioregionalization = vege_nhclu,                             bioregion_metrics = c(\"Specificity\", \"NSpecificity\",                                                   \"Fidelity\", \"IndVal\", \"NIndVal\",                                                   \"Rho\",                                                    \"CoreTerms\"),                             bioregionalization_metrics = NULL,                             data_type = \"occurrence\",                             cluster_on = \"site\",                             comat = vegemat,                             similarity = NULL,                             index = NULL, # Name of similarity column                             verbose = FALSE)  nsb ## Site and species metrics ## ======================== ##  ## Settings: ##  - Number of partitions: 1  ##  - Clusters based on: site  ##  - Clustering data type: occurrence  ##  - Metric data type: occurrence  ##  ## Computed metrics: ##  - Per-cluster co-occurrence metrics (occurrence): Specificity, NSpecificity, Fidelity, IndVal, NIndVal, Rho, CoreTerms  ##  ## Data preview: ## $species_bioregions (11091 rows x 11 cols): ##  Species Bioregion n_sb n_s n_b Specificity_occ NSpecificity_occ Fidelity_occ ##    10001         1   27 254 358           0.106            0.056        0.075 ##    10001         2   97 254 150           0.382            0.479        0.647 ##    10001         3  130 254 207           0.512            0.465        0.628 ##  IndVal_occ NIndVal_occ Rho_occ ##       0.008       0.004 -15.645 ##       0.247       0.310   8.384 ##       0.321       0.292   9.722 ## # ... with 11088 more rows ##  ## Access data with: ##   your_object$species_bioregions"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"specificity-occurrence","dir":"Articles","previous_headings":"7. Metrics per cluster > 7.1 Species-per-bioregion metrics > 7.1.1 Co-occurrence metrics: occurrence version","what":"Specificity (occurrence)","title":"5.2 Summary metrics","text":"specificity \\(A_{sb}\\) species \\(s\\) bioregion \\(b\\) (De Cáceres & Legendre, 2009) defined \\[A_{sb} = \\frac{n_{sb}}{n_s}\\] measures fraction occurrences species \\(s\\) belong bioregion \\(b\\). therefore reflects uniqueness species particular bioregion.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"nspecificity-occurrence","dir":"Articles","previous_headings":"7. Metrics per cluster > 7.1 Species-per-bioregion metrics > 7.1.1 Co-occurrence metrics: occurrence version","what":"NSpecificity (occurrence)","title":"5.2 Summary metrics","text":"normalized version accounts size bioregion also available, defined (De Cáceres & Legendre, 2009): \\[\\bar{}_{sb} = \\frac{n_{sb}/n_b}{\\sum_{k=1}^K n_{sk}/n_k}\\] corresponds normalized specificity value adjusts differences bioregion size.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"fidelity-occurrence","dir":"Articles","previous_headings":"7. Metrics per cluster > 7.1 Species-per-bioregion metrics > 7.1.1 Co-occurrence metrics: occurrence version","what":"Fidelity (occurrence)","title":"5.2 Summary metrics","text":"fidelity \\(B_{sb}\\) species \\(s\\) bioregion \\(b\\) (De Cáceres & Legendre, 2009) defined \\[B_{sb} = \\frac{n_{sb}}{n_b}\\] measures fraction sites bioregion \\(b\\) species \\(s\\) present. therefore reflects frequency occurrence species within bioregion.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"indval-occurrence","dir":"Articles","previous_headings":"7. Metrics per cluster > 7.1 Species-per-bioregion metrics > 7.1.1 Co-occurrence metrics: occurrence version","what":"IndVal (occurrence)","title":"5.2 Summary metrics","text":"indicator value \\(IndVal_{sb}\\) species \\(s\\) bioregion \\(b\\) can defined product specificity fidelity (De Cáceres & Legendre, 2009): \\[IndVal_{sb} = A_{sb} \\times B_{sb}\\] index quantifies strength association species bioregion combining specificity (uniqueness bioregion) fidelity (consistency occurrence within bioregion). High IndVal values identify species frequent restricted single bioregion, making good indicators region.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"nindval-occurrence","dir":"Articles","previous_headings":"7. Metrics per cluster > 7.1 Species-per-bioregion metrics > 7.1.1 Co-occurrence metrics: occurrence version","what":"NIndVal (occurrence)","title":"5.2 Summary metrics","text":"normalized version indicator value also available: \\[\\bar{IndVal}_{sb} = \\bar{}_{sb} \\times B_{sb}\\] normalization adjusts differences bioregion size, allowing comparable indicator values across regions unequal sampling effort extent.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"rho-occurrence","dir":"Articles","previous_headings":"7. Metrics per cluster > 7.1 Species-per-bioregion metrics > 7.1.1 Co-occurrence metrics: occurrence version","what":"Rho (occurrence)","title":"5.2 Summary metrics","text":"contribution index \\(\\rho\\) can also calculated following (Lenormand et al., 2019): \\[\\rho_{sb} = \\frac{n_{sb} - n_s\\frac{n_b}{n}}{\\sqrt{\\frac{n_b(n - n_b)}{n - 1} \\frac{n_s}{n}(1 - \\frac{n_s}{n}) }}\\] index measures deviation observed number occurrences species \\(s\\) bioregion \\(b\\) expected value random association, providing standardized measure contribution bioregional structure.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"co-occurrence-metrics-abundance-version","dir":"Articles","previous_headings":"7. Metrics per cluster > 7.1 Species-per-bioregion metrics","what":"Co-occurrence metrics: abundance version","title":"5.2 Summary metrics","text":"occurrence metrics computed data_type = \"occurrence\". default, function detect type data used clustering. However, parameter can overriden users, occurrence metrics can calculated abundance clustering, vice-versa. abundance version metrics can also computed data_type = \"abundance\" (data_type = \"\"). case core terms associated metrics : \\(w_{sb}\\) sum abundances species s sites bioregion b. \\(w_s\\) total abundance species s. \\(w_b\\) total abundance species present sites bioregion b.","code":"wsb <- site_species_metrics(bioregionalization = vege_nhclu,                             bioregion_metrics = c(\"Specificity\", \"NSpecificity\",                                                   \"Fidelity\",                                                   \"IndVal\", \"NIndVal\",                                                   \"Rho\",                                                   \"CoreTerms\"),                             bioregionalization_metrics = NULL,                             data_type = \"abundance\",                             cluster_on = \"site\",                             comat = vegemat,                             similarity = NULL, # Name of similarity column                             index = NULL,                             verbose = FALSE)  wsb ## Site and species metrics ## ======================== ##  ## Settings: ##  - Number of partitions: 1  ##  - Clusters based on: site  ##  - Clustering data type: occurrence  ##  - Metric data type: abundance  ##  ## Computed metrics: ##  - Per-cluster co-occurrence metrics (abundance): Specificity, NSpecificity, Fidelity, IndVal, NIndVal, Rho, CoreTerms  ##  ## Data preview: ## $species_bioregions (11091 rows x 11 cols): ##  Species Bioregion w_sb  w_s     w_b Specificity_abund NSpecificity_abund ##    10001         1   85 6255 1889243             0.014              0.007 ##    10001         2 3037 6255 1081424             0.486              0.568 ##    10001         3 3133 6255 1271474             0.501              0.425 ##  Fidelity_abund IndVal_abund NIndVal_abund Rho_abund ##           0.000        0.001         0.001    -6.806 ##           0.003        0.314         0.368     4.731 ##           0.002        0.315         0.267     3.256 ## # ... with 11088 more rows ##  ## Access data with: ##   your_object$species_bioregions"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"specificity-abundance","dir":"Articles","previous_headings":"7. Metrics per cluster > 7.1 Species-per-bioregion metrics > Co-occurrence metrics: abundance version","what":"Specificity (abundance)","title":"5.2 Summary metrics","text":"\\[A_{sb} = \\frac{w_{sb}}{w_s}\\]","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"nspecificity-abundance","dir":"Articles","previous_headings":"7. Metrics per cluster > 7.1 Species-per-bioregion metrics > Co-occurrence metrics: abundance version","what":"NSpecificity (abundance)","title":"5.2 Summary metrics","text":"\\[\\bar{}_{sb} = \\frac{w_{sb}/n_b}{\\sum_{k=1}^K w_{sk}/n_k}\\]","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"fidelity-abundance","dir":"Articles","previous_headings":"7. Metrics per cluster > 7.1 Species-per-bioregion metrics > Co-occurrence metrics: abundance version","what":"Fidelity (abundance)","title":"5.2 Summary metrics","text":"\\[B_{sb} = \\frac{w_{sb}}{w_b}\\]","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"indval-abundance","dir":"Articles","previous_headings":"7. Metrics per cluster > 7.1 Species-per-bioregion metrics > Co-occurrence metrics: abundance version","what":"IndVal (abundance)","title":"5.2 Summary metrics","text":"\\[IndVal_{sb} = A_{sb} \\times \\frac{n_{sb}}{n_b}\\] Note fidelity based occurrence used (De Cáceres & Legendre, 2009).","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"nindval-abundance","dir":"Articles","previous_headings":"7. Metrics per cluster > 7.1 Species-per-bioregion metrics > Co-occurrence metrics: abundance version","what":"NIndVal (abundance)","title":"5.2 Summary metrics","text":"\\[\\bar{IndVal}_{sb} = \\bar{}_{sb} \\times \\frac{n_{sb}}{n_b}\\] Note fidelity based occurrence used (De Cáceres & Legendre, 2009).","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"rho-abundance","dir":"Articles","previous_headings":"7. Metrics per cluster > 7.1 Species-per-bioregion metrics > Co-occurrence metrics: abundance version","what":"Rho (abundance)","title":"5.2 Summary metrics","text":"\\[\\rho_{sb} = \\frac{\\mu_{sb} - \\mu_s}{\\sqrt{\\left(\\frac{n - n_b}{n-1}\\right) \\left(\\frac{{\\sigma_s}^2}{n_b}\\right)}}\\] \\(\\mu_{sb} = \\frac{w_{sb}}{n_b}\\) average abundance species \\(s\\) bioregion \\(b\\) (NSpecificity NIndVal) \\(\\mu_s = \\frac{w_s}{n}\\) average abundance species \\(s\\) \\(\\sigma_s\\) associated standard deviation.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"site-metrics","dir":"Articles","previous_headings":"7. Metrics per cluster","what":"7.2 Site metrics","title":"5.2 Summary metrics","text":"sites, two types metrics can computed, depending whether clustering based site species: clustering based sites (cluster_on = \"site\" (\"\")), richness similarity-based metrics can computed clustering based species (cluster_on = \"species\" (\"\")), can also compute metrics typically applied species level, affinity, fidelity, IndVal similar metrics. conceptual interpretation differs case.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"diversity-endemicity-site-metrics","dir":"Articles","previous_headings":"7. Metrics per cluster > 7.2 Site metrics","what":"7.2.1 Diversity & endemicity site metrics","title":"5.2 Summary metrics","text":"clusters assigned sites (bioregions), can compute basic diversity metrics: Richness = number species site Rich_Endemics = number species site endemic single region (.e., occur one bioregion) Prop_Endemics = proportion endemic species, .e. ratio Rich_Endemics Richness","code":"sim_metrics <- site_species_metrics(bioregionalization = vege_nhclu,                             bioregion_metrics = c(\"Richness\", \"Rich_Endemics\",                                                   \"Prop_Endemics\"),                             bioregionalization_metrics = NULL,                             data_type = \"occurrence\",                             cluster_on = \"site\",                             comat = vegemat,                             similarity = vegesim,                             index = \"Simpson\", # Name of similarity column                             verbose = FALSE)  sim_metrics ## Site and species metrics ## ======================== ##  ## Settings: ##  - Number of partitions: 1  ##  - Clusters based on: site  ##  - Clustering data type: occurrence  ##  ## Computed metrics: ##  - Per-cluster richness & endemism metrics: Richness, Rich_Endemics, Prop_Endemics  ##  ## Data preview: ## $site_bioregions (2145 rows x 5 cols): ##  Site Bioregion Richness Rich_Endemics Prop_Endemics ##    35         1      129             0         0.000 ##    35         2      129             2         0.016 ##    35         3      129             0         0.000 ## # ... with 2142 more rows ##  ## Access data with: ##   your_object$site_bioregions"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"similarity-based-site-metrics","dir":"Articles","previous_headings":"7. Metrics per cluster > 7.2 Site metrics","what":"7.2.2 Similarity-based site metrics","title":"5.2 Summary metrics","text":"compute similarity-based metrics sites, need provide site similarity matrix (vegesim). metrics include average similarity site sites bioregion (\\(MeanSim\\)) associated standard deviation (\\(SdSim\\)). computing average similarity, focal site included calculation bioregion.","code":"sim_metrics <- site_species_metrics(bioregionalization = vege_nhclu,                             bioregion_metrics = c(\"MeanSim\", \"SdSim\"),                             bioregionalization_metrics = NULL,                             data_type = \"occurrence\",                             cluster_on = \"site\",                             comat = vegemat,                             similarity = vegesim,                             index = \"Simpson\", # Name of similarity column                             verbose = FALSE)  sim_metrics ## Site and species metrics ## ======================== ##  ## Settings: ##  - Number of partitions: 1  ##  - Clusters based on: site  ##  - Clustering data type: occurrence  ##  ## Computed metrics: ##  - Per-cluster similarity-based metrics: MeanSim, SdSim  ##  ## Data preview: ## $site_bioregions (2145 rows x 4 cols): ##  Site Bioregion MeanSim SdSim ##    35         1   0.055 0.033 ##    35         2   0.554 0.340 ##    35         3   0.251 0.195 ## # ... with 2142 more rows ##  ## Access data with: ##   your_object$site_bioregions"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"meansim","dir":"Articles","previous_headings":"7. Metrics per cluster > 7.2 Site metrics > 7.2.2 Similarity-based site metrics","what":"MeanSim","title":"5.2 Summary metrics","text":"Let \\(g\\) site \\(b\\) bioregion sites \\(g' \\b\\), : \\[MeanSim_{gb} = \\frac{1}{n_b - \\delta_{g \\b}} \\sum_{g' \\b, g' \\neq g} sim_{gg'}\\] \\(sim_{gg'}\\) similarity sites \\(g\\) \\(g'\\), \\(n_b\\) number sites bioregion \\(b\\), \\(\\delta_{g \\b}\\) 1 site \\(g\\) belongs bioregion \\(b\\) (exclude ), 0 otherwise.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"sdsim","dir":"Articles","previous_headings":"7. Metrics per cluster > 7.2 Site metrics > 7.2.2 Similarity-based site metrics","what":"SdSim","title":"5.2 Summary metrics","text":"standard deviation similarities site \\(g\\) bioregion \\(b\\) : \\[SdSim_{gb} = \\sqrt{\\frac{1}{n_b - 1 - \\delta_{g \\b}} \\sum_{g' \\b, g' \\neq g} \\left( sim_{gg'} - MeanSim_{gb} \\right)^2}\\] \\(sim_{gg'}\\) similarity sites \\(g\\) \\(g'\\), \\(n_b\\) number sites bioregion \\(b\\), \\(\\delta_{g \\b}\\) 1 site \\(g\\) belongs bioregion \\(b\\) (exclude ), 0 otherwise.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"chorotypecluster-based-site-metrics","dir":"Articles","previous_headings":"7. Metrics per cluster > 7.2 Site metrics","what":"7.2.3 Chorotype/Cluster-based site metrics","title":"5.2 Summary metrics","text":"following example compute metrics sites, basis species clusters (cluster_on = \"species\").","code":"gc <- site_species_metrics(bioregionalization = vege_netclubip,                             bioregion_metrics = c(\"Specificity\", \"NSpecificity\",                                                   \"Fidelity\",                                                   \"IndVal\", \"NIndVal\",                                                   \"Rho\",                                                   \"CoreTerms\"),                             bioregionalization_metrics = \"P\",                             data_type = \"both\",                             cluster_on = \"species\",                             comat = vegemat,                             similarity = NULL,                             index = NULL,                             verbose = FALSE)  gc ## Site and species metrics ## ======================== ##  ## Settings: ##  - Number of partitions: 1  ##  - Clusters based on: species  ##  - Clustering data type: abundance  ##  - Metric data type: occurrence and abundance  ##  ## Computed metrics: ##  - Per-cluster co-occurrence metrics (occurrence): Specificity, NSpecificity, Fidelity, IndVal, NIndVal, Rho, CoreTerms  ##  - Per-cluster co-occurrence metrics (abundance): Specificity, NSpecificity, Fidelity, IndVal, NIndVal, Rho, CoreTerms  ##  - Bioregionalization co-occurrence metrics (occurrence): P  ##  - Bioregionalization co-occurrence metrics (abundance): P  ##  ## Data preview: ## $site_chorotypes (5720 rows x 20 cols): ##  Site Chorotypes n_gc n_g  n_c Specificity_occ NSpecificity_occ Fidelity_occ ##    35          1    1 129 2219           0.008            0.003        0.000 ##    35          2  121 129  873           0.938            0.892        0.139 ##    35          3    7 129  430           0.054            0.105        0.016 ##  IndVal_occ NIndVal_occ Rho_occ w_gc w_g     w_c Specificity_abund ##       0.000       0.000 -13.981    1 423 2873216             0.002 ##       0.130       0.124  19.103  411 423 1149003             0.972 ##       0.001       0.002  -2.237   11 423  103264             0.026 ##  NSpecificity_abund Fidelity_abund IndVal_abund NIndVal_abund Rho_abund ##               0.001              0        0.000         0.000    -7.973 ##               0.948              0        0.135         0.131    11.313 ##               0.051              0        0.000         0.001    -1.840 ## # ... with 5717 more rows ##  ## $site_chorological (715 rows x 3 cols): ##  Site P_occ P_abund ##    35 0.117   0.055 ##    36 0.465   0.199 ##    37 0.350   0.082 ## # ... with 712 more rows ##  ## Access data with: ##   your_object$site_chorotypes ##   your_object$site_chorological"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"site-metrics-1","dir":"Articles","previous_headings":"8. Metrics over the entire bioregionalization (i.e., over all clusters)","what":"8.1 Site metrics","title":"5.2 Summary metrics","text":"Based \\(MeanSim\\), possible derive aggregated metrics assess well site fits within assigned bioregion relative others. now, Silhouette index (Rousseeuw, 1987) proposed.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"silhouette","dir":"Articles","previous_headings":"8. Metrics over the entire bioregionalization (i.e., over all clusters) > 8.1 Site metrics","what":"Silhouette","title":"5.2 Summary metrics","text":"Silhouette index site \\(g\\) defined : \\[Silhouette_g = \\frac{a_g - b_g}{\\max(a_g, b_g)}\\] : \\(a_g\\) average similarity site \\(g\\) sites bioregion, \\(b_g\\) average similarity site \\(g\\) sites belonging nearest bioregion. index reflects strongly site associated assigned bioregion relative similar alternative bioregion, ranging -1, site may misassigned (.e., similar another bioregion ), 1, site well matched bioregion, around 0 site lies near boundary bioregions.","code":"sil_metrics <- site_species_metrics(bioregionalization = vege_nhclu,                             bioregion_metrics = NULL,                             bioregionalization_metrics = \"Silhouette\",                             data_type = \"occurrence\",                             cluster_on = \"site\",                             comat = vegemat,                             similarity = vegesim,                             index = \"Simpson\", # Name of similarity column                             verbose = FALSE)  sil_metrics ## Site and species metrics ## ======================== ##  ## Settings: ##  - Number of partitions: 1  ##  - Clusters based on: site  ##  - Clustering data type: occurrence  ##  ## Computed metrics: ##  - Bioregionalization similarity-based metrics: Silhouette  ##  ## Data preview: ## $site_bioregionalization (715 rows x 2 cols): ##  Site Silhouette ##    35      0.548 ##    36      0.308 ##    37      0.441 ## # ... with 712 more rows ##  ## Access data with: ##   your_object$site_bioregionalization"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"site-participation-coefficient","dir":"Articles","previous_headings":"8. Metrics over the entire bioregionalization (i.e., over all clusters) > 8.1 Site metrics","what":"Site participation coefficient","title":"5.2 Summary metrics","text":"can compute participation coefficient \\(P_s\\) species \\(s\\) bioregionalization described (Denelle et al., 2020), available occurrence abundance versions. metrics measure whether site species single region multiple regions - useful investigating transition zones (Leroy et al., 2019). ranging 0 1. Values close 0 indicate site species single chorotype (.e., transition zone), whereas values close 1 indicate site species evenely distributed across multiple chorotypes (.e., likely transition zone).","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"p-occurrence","dir":"Articles","previous_headings":"8. Metrics over the entire bioregionalization (i.e., over all clusters) > 8.1 Site metrics","what":"P (occurrence)","title":"5.2 Summary metrics","text":"\\[ P_s =  1 - \\sum_{k=1}^K \\left(\\frac{n_{sk}}{n_s}\\right)^2 \\]","code":"p_occ_site <- site_species_metrics(bioregionalization = vege_netclubip,                             bioregion_metrics = NULL,                             bioregionalization_metrics = \"P\",                             data_type = \"occurrence\",                             cluster_on = \"species\",                             comat = vegemat,                             similarity = NULL,                             index = \"Simpson\", # Name of similarity column                             verbose = FALSE)  p_occ_site ## Site and species metrics ## ======================== ##  ## Settings: ##  - Number of partitions: 1  ##  - Clusters based on: species  ##  - Clustering data type: abundance  ##  - Metric data type: occurrence  ##  ## Computed metrics: ##  - Bioregionalization co-occurrence metrics (occurrence): P  ##  ## Data preview: ## $site_chorological (715 rows x 2 cols): ##  Site P_occ ##    35 0.117 ##    36 0.465 ##    37 0.350 ## # ... with 712 more rows ##  ## Access data with: ##   your_object$site_chorological"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"p-abundance","dir":"Articles","previous_headings":"8. Metrics over the entire bioregionalization (i.e., over all clusters) > 8.1 Site metrics","what":"P (abundance)","title":"5.2 Summary metrics","text":"\\[ P_s =  1 - \\sum_{k=1}^K \\left(\\frac{w_{sk}}{w_s}\\right)^2 \\]","code":"p_ab_site <- site_species_metrics(bioregionalization = vege_netclubip,                             bioregion_metrics = NULL,                             bioregionalization_metrics = \"P\",                             data_type = \"abundance\",                             cluster_on = \"species\",                             comat = vegemat,                             similarity = NULL,                             index = \"Simpson\", # Name of similarity column                             verbose = FALSE)  p_ab_site ## Site and species metrics ## ======================== ##  ## Settings: ##  - Number of partitions: 1  ##  - Clusters based on: species  ##  - Clustering data type: abundance  ##  - Metric data type: abundance  ##  ## Computed metrics: ##  - Bioregionalization co-occurrence metrics (abundance): P  ##  ## Data preview: ## $site_chorological (715 rows x 2 cols): ##  Site P_abund ##    35   0.055 ##    36   0.199 ##    37   0.082 ## # ... with 712 more rows ##  ## Access data with: ##   your_object$site_chorological"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"species-metrics","dir":"Articles","previous_headings":"8. Metrics over the entire bioregionalization (i.e., over all clusters)","what":"8.2 Species metrics","title":"5.2 Summary metrics","text":"can compute participation coefficient \\(P_s\\) species \\(s\\) bioregionalization species well.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"p-occurrence-1","dir":"Articles","previous_headings":"8. Metrics over the entire bioregionalization (i.e., over all clusters) > 8.2 Species metrics","what":"P (occurrence)","title":"5.2 Summary metrics","text":"\\[ P_s =  1 - \\sum_{k=1}^K \\left(\\frac{n_{sk}}{n_s}\\right)^2 \\]","code":"p_occ_sp <- site_species_metrics(bioregionalization = vege_netclubip,                             bioregion_metrics = NULL,                             bioregionalization_metrics = \"P\",                             data_type = \"occurrence\",                             cluster_on = \"site\",                             comat = vegemat,                             similarity = NULL,                             index = \"Simpson\", # Name of similarity column                             verbose = FALSE)  p_occ_sp ## Site and species metrics ## ======================== ##  ## Settings: ##  - Number of partitions: 1  ##  - Clusters based on: site  ##  - Clustering data type: abundance  ##  - Metric data type: occurrence  ##  ## Computed metrics: ##  - Bioregionalization co-occurrence metrics (occurrence): P  ##  ## Data preview: ## $species_bioregionalization (3697 rows x 2 cols): ##  Species P_occ ##    10001 0.598 ##    10002 0.188 ##    10003 0.068 ## # ... with 3694 more rows ##  ## Access data with: ##   your_object$species_bioregionalization"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"p-abundance-1","dir":"Articles","previous_headings":"8. Metrics over the entire bioregionalization (i.e., over all clusters) > 8.2 Species metrics","what":"P (abundance)","title":"5.2 Summary metrics","text":"\\[ P_s =  1 - \\sum_{k=1}^K \\left(\\frac{w_{sk}}{w_s}\\right)^2 \\] metrics measure evenly species distributed among bioregions. ranging 0 1. Values close 0 indicate species largely restricted single bioregion, values close 1 indicate species evenly distributed across multiple bioregions. Calculations occurrence & abundance time:","code":"p_ab_sp <- site_species_metrics(bioregionalization = vege_netclubip,                             bioregion_metrics = NULL,                             bioregionalization_metrics = \"P\",                             data_type = \"abundance\",                             cluster_on = \"site\",                             comat = vegemat,                             similarity = NULL,                             index = \"Simpson\", # Name of similarity column                             verbose = FALSE)  p_ab_sp ## Site and species metrics ## ======================== ##  ## Settings: ##  - Number of partitions: 1  ##  - Clusters based on: site  ##  - Clustering data type: abundance  ##  - Metric data type: abundance  ##  ## Computed metrics: ##  - Bioregionalization co-occurrence metrics (abundance): P  ##  ## Data preview: ## $species_bioregionalization (3697 rows x 2 cols): ##  Species P_abund ##    10001   0.509 ##    10002   0.090 ##    10003   0.022 ## # ... with 3694 more rows ##  ## Access data with: ##   your_object$species_bioregionalization ps <- site_species_metrics(bioregionalization = vege_nhclu,                            bioregion_metrics = NULL,                             bioregionalization_metrics = \"P\",                             data_type = \"both\",                             cluster_on = \"site\",                             comat = vegemat,                             similarity = NULL,                             index = NULL,                             verbose = FALSE)  ps ## Site and species metrics ## ======================== ##  ## Settings: ##  - Number of partitions: 1  ##  - Clusters based on: site  ##  - Clustering data type: occurrence  ##  - Metric data type: occurrence and abundance  ##  ## Computed metrics: ##  - Bioregionalization co-occurrence metrics (occurrence): P  ##  - Bioregionalization co-occurrence metrics (abundance): P  ##  ## Data preview: ## $species_bioregionalization (3697 rows x 3 cols): ##  Species P_occ P_abund ##    10001 0.581   0.513 ##    10002 0.460   0.413 ##    10003 0.089   0.022 ## # ... with 3694 more rows ##  ## Access data with: ##   your_object$species_bioregionalization"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_summary_metrics.html","id":"bioregion-metrics-spatial-coherence","dir":"Articles","previous_headings":"","what":"9. Bioregion metrics & spatial coherence","title":"5.2 Summary metrics","text":"granularity bioregions, can calculate number sites contains number species present sites. number proportion endemic species also computed. Endemic species defined occurring sites assigned particular bioregion (.e., species occur one bioregion). use metric spatial coherence (Divíšek et al., 2016), except replace number pixels per bioregion area coherent part. spatial coherence expressed percentage, following formula: \\[SC_j = 100 \\times \\frac{LargestPatch_j}{Area_j}\\] \\(j\\) bioregion. example vegetation dataset. bioregion 4 almost constituted one homogeneous block, spatial coherence close 100 %.","code":"bioregion_summary <- bioregion_metrics(bioregionalization = vege_nhclu,                                        comat = vegemat) bioregion_summary ##   Bioregion Site_number Species_number Endemics Percentage_Endemic ## 1         2         150           2688      133           4.947917 ## 2         3         207           3090       58           1.877023 ## 3         1         358           2821      407          14.427508 # Spatial coherence vegedissim <- dissimilarity(vegemat) hclu <- nhclu_kmeans(dissimilarity = vegedissim, n_clust = 4) vegemap <- map_bioregions(hclu, vegesf, write_clusters = TRUE, plot = FALSE)  bioregion_metrics(bioregionalization = hclu, comat = vegemat, map = vegemap, col_bioregion = 2) ##   Bioregion Site_number Species_number Endemics Percentage_Endemic Coherence ## 1         2         128           2527       90           3.561535  49.21875 ## 2         1         169           2983       45           1.508548  56.21302 ## 3         4         298           2936       56           1.907357  98.99329 ## 4         3         120           2262       67           2.961981  79.16667 ggplot(vegemap) +   geom_sf(aes(fill = as.factor(K_4))) +   scale_fill_viridis_d(\"Bioregion\") +   theme_bw() +   theme(legend.position = \"bottom\")"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_compare_bioregionalizations.html","id":"data","dir":"Articles","previous_headings":"","what":"1. Data","title":"5.3 Compare bioregionalizations","text":"use vegetation dataset comes bioregion.","code":"data(\"vegedf\") data(\"vegemat\")  # Calculation of (dis)similarity matrices vegedissim <- dissimilarity(vegemat, metric = c(\"Simpson\")) vegesim <- dissimilarity_to_similarity(vegedissim)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_compare_bioregionalizations.html","id":"bioregionalization","dir":"Articles","previous_headings":"","what":"2. Bioregionalization","title":"5.3 Compare bioregionalizations","text":"use three bioregionalization algorithms visualization vignette, .e. non-hierarchical, hierarchical network bioregionalizations. chose 3 bioregions non-hierarchical hierarchical bioregionalizations.","code":"# Non hierarchical bioregionalization vege_nhclu_kmeans <- nhclu_kmeans(vegedissim, n_clust = 3, index = \"Simpson\") vege_nhclu_kmeans$cluster_info # 3 ##     partition_name n_clust ## K_3            K_3       3 # Hierarchical bioregionalization set.seed(1) vege_hclu_hierarclust <- hclu_hierarclust(dissimilarity = vegedissim,                                           method = \"mcquitty\", n_clust = 3,                                           optimal_tree_method = \"best\") vege_hclu_hierarclust$cluster_info # 3 ##   partition_name n_clust requested_n_clust output_cut_height ## 1            K_3       3                 3             0.625 # Network bioregionalization set.seed(1) vege_netclu_walktrap <- netclu_walktrap(vegesim,                                         index = names(vegesim)[3]) vege_netclu_walktrap$cluster_info # 3 ##     partition_name n_clust ## K_3            K_3       3"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_compare_bioregionalizations.html","id":"compare-the-bioregionalizations","dir":"Articles","previous_headings":"","what":"3. Compare the bioregionalizations","title":"5.3 Compare bioregionalizations","text":"comparing bioregionalizations, build common data.frame containing three distinct bioregionalizations. can now run function compare_bioregionalizations(). compare_bioregionalizations() produces several outputs : - look within bioregionalization sites assigned bioregions - compare different bioregionalizations analysing whether produce similar pairwise memberships Let’s first look pairwise membership within bioregionalization.","code":"comp <- dplyr::left_join(vege_hclu_hierarclust$clusters,                          vege_netclu_walktrap$clusters,                          by = \"ID\") colnames(comp) <- c(\"ID\", \"K_3_hclu\", \"K_3_netclu\") comp <- dplyr::left_join(comp,                          vege_nhclu_kmeans$clusters,                          by = \"ID\") colnames(comp) <- c(\"ID\", \"K_3_hclu\", \"K_3_netclu\", \"K_3_nhclu\")  head(comp) ##     ID K_3_hclu K_3_netclu K_3_nhclu ## 1  512        1          1         1 ## 2  799        1          3         1 ## 3  375        2          1         2 ## 4  476        2          1         2 ## 5  971        1          3         1 ## 6 1282        1          3         1 hclu_vs_netclu <- compare_bioregionalizations(   bioregionalizations = comp[, c(\"K_3_hclu\", \"K_3_netclu\", \"K_3_nhclu\")],   store_pairwise_membership = TRUE,   cor_frequency = TRUE,   store_confusion_matrix = TRUE)  str(hclu_vs_netclu) ## List of 7 ##  $ args                         :List of 4 ##   ..$ indices                  : chr [1:2] \"rand\" \"jaccard\" ##   ..$ cor_frequency            : logi TRUE ##   ..$ store_pairwise_membership: logi TRUE ##   ..$ store_confusion_matrix   : logi TRUE ##  $ inputs                       : Named int [1:2] 715 3 ##   ..- attr(*, \"names\")= chr [1:2] \"number_items\" \"number_bioregionalizations\" ##  $ pairwise_membership          : logi [1:255255, 1:3] TRUE FALSE FALSE TRUE TRUE TRUE ... ##   ..- attr(*, \"dimnames\")=List of 2 ##   .. ..$ : chr [1:255255] \"1_2\" \"1_3\" \"1_4\" \"1_5\" ... ##   .. ..$ : chr [1:3] \"K_3_hclu\" \"K_3_netclu\" \"K_3_nhclu\" ##  $ freq_item_pw_membership      : Named num [1:255255] 2 1 1 2 2 2 2 2 2 2 ... ##   ..- attr(*, \"names\")= chr [1:255255] \"1_2\" \"1_3\" \"1_4\" \"1_5\" ... ##  $ bioregionalization_freq_cor  : Named num [1:3] 0.851 0.737 0.893 ##   ..- attr(*, \"names\")= chr [1:3] \"K_3_hclu\" \"K_3_netclu\" \"K_3_nhclu\" ##  $ confusion_matrix             :List of 3 ##   ..$ K_3_hclu%K_3_netclu : Named int [1:4] 63316 41892 36800 113247 ##   .. ..- attr(*, \"names\")= chr [1:4] \"a\" \"b\" \"c\" \"d\" ##   ..$ K_3_hclu%K_3_nhclu  : Named int [1:4] 85543 19665 11248 138799 ##   .. ..- attr(*, \"names\")= chr [1:4] \"a\" \"b\" \"c\" \"d\" ##   ..$ K_3_netclu%K_3_nhclu: Named int [1:4] 66314 33802 30477 124662 ##   .. ..- attr(*, \"names\")= chr [1:4] \"a\" \"b\" \"c\" \"d\" ##  $ bioregionalization_comparison:'data.frame':   3 obs. of  3 variables: ##   ..$ bioregionalization_comparison: chr [1:3] \"K_3_hclu%K_3_netclu\" \"K_3_hclu%K_3_nhclu\" \"K_3_netclu%K_3_nhclu\" ##   ..$ rand                         : num [1:3] 0.692 0.879 0.748 ##   ..$ jaccard                      : num [1:3] 0.446 0.735 0.508 ##  - attr(*, \"class\")= chr [1:2] \"bioregion.bioregionalization.comparison\" \"list\""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_compare_bioregionalizations.html","id":"pairwise-membership","dir":"Articles","previous_headings":"3. Compare the bioregionalizations","what":"3.1 Pairwise membership","title":"5.3 Compare bioregionalizations","text":"number pairwise combinations \\(n\\) sites equals \\(n(n-1)/2\\). case, 715 sites, end 2.55255^{5} pairwise combinations. Pairwise memberships look pairs site whether assigned different bioregion. Let’s look sites 1 9 across different bioregionalization: can see sites 1 9 classified bioregion first two bioregionalizations, third one. $pairwise_membership output compare_bioregionalizations() shows TRUE/FALSE statement. number times pair sites clustered together (.e. sum rows table $pairwise_membership) available $freq_item_pw_membership output: sites 1 2 never classified bioregion across three bioregionalizations. Sites 1 9 classified bioregion two bioregionalizations. look total frequencies: see dominant situation sites never assigned bioregion.","code":"nrow(hclu_vs_netclu$pairwise_membership) == nrow(comp)*(nrow(comp)-1)/2 ## [1] TRUE comp[c(1, 9), ] ##    ID K_3_hclu K_3_netclu K_3_nhclu ## 1 512        1          1         1 ## 9 948        1          3         1 hclu_vs_netclu$pairwise_membership[8:10, ] ##      K_3_hclu K_3_netclu K_3_nhclu ## 1_9      TRUE      FALSE      TRUE ## 1_10     TRUE      FALSE      TRUE ## 1_11     TRUE      FALSE      TRUE hclu_vs_netclu$freq_item_pw_membership[c(1, 8)] ## 1_2 1_9  ##   2   2 table(hclu_vs_netclu$freq_item_pw_membership) ##  ##      0      1      2      3  ## 111723  41539  45403  56590"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_compare_bioregionalizations.html","id":"confusion-matrix","dir":"Articles","previous_headings":"3. Compare the bioregionalizations","what":"3.2 Confusion matrix","title":"5.3 Compare bioregionalizations","text":"confusion matrix allows compare different bioregionalizations looking similarity pairwise memberships. , function computes confusion matrix four elements: . \\(\\) number pairs sites grouped bioregionalization 1 bioregionalization 2 . \\(b\\) number pairs sites grouped bioregionalization 1 bioregionalization 2 . \\(c\\) number pairs sites grouped bioregionalization 1 grouped bioregionalization 2 . \\(d\\) number pairs sites grouped bioregionalization 1 & 2 Based confusion matrices, can compute range indices indicate agreement among bioregionalizations. now, implemented:Rand index \\((+d)/(+b+c+d)\\) Rand index measures agreement among bioregionalizations accounting pairs sites grouped, also pairs sites grouped.Jaccard index  \\(/(+b+c)\\) Jaccard index measures agreement among bioregionalizations accounting pairs sites grouped. two metrics complementary, Jaccard index tell bioregionalizations similar clustering structure, whereas Rand index tell bioregionalizations similar pairs items clustered together, also terms pairs sites clustered together. example, take two bioregionalizations never group together pairs sites. Jaccard index 0, whereas Rand index can > 0 due sites grouped together. Additional indices can manually computed users basis list confusion matrices. cases, users may interested finding bioregionalizations representative bioregionalizations find , can compare pairwise membership bioregionalization total frequency pairwise membership across bioregionalizations. correlation can requested cor_frequency = TRUE. third bioregionalization representative bioregionalizations.","code":"hclu_vs_netclu$confusion_matrix ## $`K_3_hclu%K_3_netclu` ##      a      b      c      d  ##  63316  41892  36800 113247  ##  ## $`K_3_hclu%K_3_nhclu` ##      a      b      c      d  ##  85543  19665  11248 138799  ##  ## $`K_3_netclu%K_3_nhclu` ##      a      b      c      d  ##  66314  33802  30477 124662 hclu_vs_netclu$bioregionalization_freq_cor ##   K_3_hclu K_3_netclu  K_3_nhclu  ##  0.8507872  0.7365956  0.8934004"},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"brief-introduction","dir":"Articles","previous_headings":"","what":"0. Brief introduction","title":"Tutorial for bioregion","text":"tutorial aims describing different features R package bioregion. main purpose bioregion‘s package propose transparent methodological framework compare bioregionalization methods. typical flow chart bioregions’ identification based site-species bipartite network co-occurrence matrix bioregion (Figure 1). workflow can divided four main steps: Preprocess data (matrix network formats) Compute similarity/dissimilarity metrics sites based species composition Run different algorithms identify different set bioregions Evaluate visualize results","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"install-binary-files","dir":"Articles","previous_headings":"","what":"1. Install binary files","title":"Tutorial for bioregion","text":"functions least part (listed ) require binary files run. netclu_infomap netclu_louvain (Cpp version) netclu_oslom Please check tutorial page get instructions regarding installation binary files.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"matrix-or-network-formats","dir":"Articles","previous_headings":"","what":"2. Matrix or network formats","title":"Tutorial for bioregion","text":"bioregion’s package takes input site-species information stored bipartite network co-occurrence matrix. Relying function mat_to_net net_to_mat , handles matrix network formats throughout workflow. Please look tutorial page better understand two functions work.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"pairwise-similaritydissimilarity-metrics","dir":"Articles","previous_headings":"","what":"3. Pairwise similarity/dissimilarity metrics","title":"Tutorial for bioregion","text":"functions similarity dissimilarity compute respectively pairwise similarity dissimilarity metrics based (site-species) co-occurrence matrix. resulting data.frame stored bioregion.pairwise object containing requested metrics pair sites. functions dissimilarity_to_similarity similarity_to_dissimilarity can used transform similarity object dissimilarity object vice versa. function as_bioregion_pairwise allows convert (dis)similarity matrix list matrices bioregion.pairwise object compatible bioregion package. input can come base R, dist objects, outputs packages. Please look tutorial page better understand functions work.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"bioregionalization-algorithms","dir":"Articles","previous_headings":"","what":"4. Bioregionalization algorithms","title":"Tutorial for bioregion","text":"bioregion R package gathers several methods allowing group sites species similar entities called bioregions. methods can lead several partitions sites species, .e. different bioregionalizations.  Bioregionalization methods can based hierarchical clustering algorithms, non-hierarchical clustering algorithms network algorithms.  functions package related three families produce output specific class, namely bioregion.clusters class.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"hierarchical-clustering","dir":"Articles","previous_headings":"4. Bioregionalization algorithms","what":"4.1 Hierarchical clustering","title":"Tutorial for bioregion","text":"functions relying hierarchical clustering start prefix hclu_. algorithms, bioregions placed dendrogram ranges two extremes: sites belong bioregion (top tree) sites belong different bioregion (bottom tree). See following tutorial page details.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"non-hierarchical-clustering","dir":"Articles","previous_headings":"4. Bioregionalization algorithms","what":"4.2 Non-hierarchical clustering","title":"Tutorial for bioregion","text":"functions relying hierarchical clustering start prefix nhclu_. algorithms, user needs predefine number clusters, although number can determined estimating optimal bioregionalization. See tutorial page details.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"network-clustering","dir":"Articles","previous_headings":"4. Bioregionalization algorithms","what":"4.3 Network clustering","title":"Tutorial for bioregion","text":"functions relying network clustering start prefix netclu_. Site-species matrices can seen (bipartite) networks nodes either sites species links occurrences species within sites. networks, modularity algorithms can applied, leading bioregionalization. following tutorial page details clustering functions relying network algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"microbenchmark","dir":"Articles","previous_headings":"4. Bioregionalization algorithms","what":"4.4 Microbenchmark","title":"Tutorial for bioregion","text":"different bioregionalization methods listed package rely less computationally intensive algorithms. following page estimates time required run method data sets different sizes.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"visualization","dir":"Articles","previous_headings":"","what":"5.1 Visualization","title":"Tutorial for bioregion","text":"sites geographic coordinates, bioregionalization can visualized function map_bioregions(). tutorial page details different ways plot bioregionalization.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"summary-metrics","dir":"Articles","previous_headings":"","what":"5.2 Summary metrics","title":"Tutorial for bioregion","text":"section, compute summary statistics different scales, either bioregion site species level. Related functions detailed page.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"compare-bioregionalizations","dir":"Articles","previous_headings":"","what":"5.3 Compare bioregionalizations","title":"Tutorial for bioregion","text":"section, look sites assigned bioregions within single bioregionalization also compare assignment across different bioregionalizations. following page illustrates .","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/citations.html","id":"section","dir":"Articles","previous_headings":"","what":"2025","title":"Citing articles","text":"Albouy C, Fopp F, Brun P, Descombes P, Altermatt F, Pellissier L & Csilléry K (2025) gbif.range: R package generate ecologically-informed species range maps occurrence data seamless GBIF integration. Authorea (review). Zhang B, Zhou M, Xie Z, Zhang L, Duan H, Yu J & J (2025) Updated Chorotypes Terrestrial Vertebrates Shed New Light Zoogeographical Regions China Integrative Zoology (early view). Renan M, Roll U, Grabovsky VI, Shenbrot GI & Krasnov BR (2025) Phylogenetic Regionalization Ectoparasites Hosts Using 2 Approaches: Case Study Fleas Rodent Hosts Mongolia. Parasitology (early view). Lampou , Skoulikidis N & Bonada N (2025) Biogeographical Regions Aegean Archipelago: Assessment Freshwater Macroinvertebrates Journal Biogeography 53, e70117. Lenormand M, Féret JB, Papuga G, Alleaume S & Luque S (2025) Coupling situ remote sensing data assess α- β-diversity biogeographic gradients. Ecography 2025, e07479. Cheng Z & Ma KY (2025) Historical Biogeography Penaeus Prawns (Crustacea: Decapoda: Penaeidae). Journal Biogeography 52, e70056. Souza Oliveira M, Lenormand M, Luque S, Zamora NA, Alleaume S, Aguilar Porras AC, Castillo MU, Chacón-Madrigal E, Delgado D, Hernández Sánchez LG, Ngo Bieng M-, Quesada RM, Solano GS & Zúñiga PM (2025) Unlocking tropical forest complexity: tree assemblages secondary forests boost biodiversity conservation. Ecology & Evolution 15, e72428. Noori S, Rödder D, Yusefi GH, Hawlitschek O, Wanke D, Husemann M & Rajaei H (2025) Biogeographic Patterns Iranian Lepidoptera: Framework Conservation. Diversity Distributions 31, e70010.","code":""},{"path":"https://bioRgeo.github.io/bioregion/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Maxime Lenormand. Author, maintainer. Boris Leroy. Author. Pierre Denelle. Author.","code":""},{"path":"https://bioRgeo.github.io/bioregion/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Denelle P, Leroy B & Lenormand M (2025) Bioregionalization analyses bioregion R package. Methods Ecology Evolution 16, 496-506.","code":"@Article{,   author = {{Denelle} and {P.} and {Leroy} and {B.} and {Lenormand} and {M.}},   title = {Bioregionalization analyses with the bioregion R package},   journal = {Methods in Ecology and Evolution},   year = {2025},   pages = {496-506},   volume = {16},   doi = {10.1111/2041-210X.14496}, }"},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"bioregion-","dir":"","previous_headings":"","what":"Comparison of Bioregionalization Methods","title":"Comparison of Bioregionalization Methods","text":"R package gathers comprehensive set algorithms perform bioregionalization analyses. Bioregionalization methods can based hierarchical clustering algorithms, non-hierarchical clustering algorithms network algorithms.","code":""},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"arrow_double_down-installation","dir":"","previous_headings":"","what":"⏬ Installation","title":"Comparison of Bioregionalization Methods","text":"package can installed following command line R session: CRAN GitHub","code":"install.packages(\"bioregion\") # install.packages(\"devtools\") devtools::install_github(\"bioRgeo/bioregion\")"},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"scroll-vignettes","dir":"","previous_headings":"","what":"📜 Vignettes","title":"Comparison of Bioregionalization Methods","text":"wrote several vignettes help using bioregion R package. Vignettes available following ones: 1. Installation executable binary files 2. Matrix network formats 3. Pairwise similarity/dissimilarity metrics 4.1 Hierarchical clustering 4.2 Non-hierarchical clustering 4.3 Network clustering 4.4 Microbenchmark 5.1 Visualization 5.2 Summary metrics 5.3 Compare bioregionalizations Alternatively, prefer view vignettes R, can install package build_vignettes = TRUE. aware vignettes can slow generate.","code":"remotes::install_github(\"bioRgeo/bioregion\",                         dependencies = TRUE,                          upgrade = \"ask\",                          build_vignettes = TRUE)  vignette(\"bioregion\")"},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"desktop_computer-functions","dir":"","previous_headings":"","what":"🖥️ Functions","title":"Comparison of Bioregionalization Methods","text":"overview functions data given .","code":""},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"bug-find-a-bug","dir":"","previous_headings":"","what":"🐛 Find a bug?","title":"Comparison of Bioregionalization Methods","text":"Thank finding . Head GitHub Issues tab let us know . Alternatively, can also send us e-mail. try get soon can!","code":""},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"references-and-dependencies","dir":"","previous_headings":"","what":"References and dependencies","title":"Comparison of Bioregionalization Methods","text":"bioregion depends ape, apcluster, bipartite, cluster, data.table, dbscan, dynamicTreeCut, fastcluster, fastkmedoids, ggplot2, grDevices, httr, igraph, mathjaxr, Matrix, phangorn, rcartocolor, Rdpack, rlang, rmarkdown, segmented,sf, stats, tidyr utils.","code":""},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Comparison of Bioregionalization Methods","text":"Denelle P, Leroy B & Lenormand M (2025) Bioregionalization analyses bioregion R package. Methods Ecology Evolution 16, 496-506.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/as_bioregion_pairwise.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a matrix or list of matrices to a bioregion (dis)similarity object — as_bioregion_pairwise","title":"Convert a matrix or list of matrices to a bioregion (dis)similarity object — as_bioregion_pairwise","text":"Converts (dis)similarity matrix list matrices bioregion.pairwise object compatible bioregion package. input can come base R, dist objects, outputs packages.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/as_bioregion_pairwise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a matrix or list of matrices to a bioregion (dis)similarity object — as_bioregion_pairwise","text":"","code":"as_bioregion_pairwise(   mat,   metric_name = NULL,   pkg = NULL,   is_similarity = FALSE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/as_bioregion_pairwise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a matrix or list of matrices to a bioregion (dis)similarity object — as_bioregion_pairwise","text":"mat matrix, dist object, list representing pairwise similarity dissimilarity values convert bioregion.pairwise object. function can also directly handle outputs R packages (see pkg argument). metric_name Optional character vector single character string specifying name (dis)similarity metric(s), appear column names output (see Note). pkg optional character string indicating name package mat generated (NULL default, see Details). Available options \"adespatial\", \"betapart\", \"ecodist\", \"vegan\". is_similarity logical value indicating whether input data represents similarity (TRUE) dissimilarity (FALSE).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/as_bioregion_pairwise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a matrix or list of matrices to a bioregion (dis)similarity object — as_bioregion_pairwise","text":"dissimilarity similarity object class bioregion.pairwise, compatible bioregion package.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/as_bioregion_pairwise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert a matrix or list of matrices to a bioregion (dis)similarity object — as_bioregion_pairwise","text":"function can directly handle outputs ten functions across four packages: adespatial: beta.div, beta.div.comp betapart: beta.pair, beta.pair.abund, betapart.core, betapart.core.abund ecodist: distance, bcdist vegan: vegdist, designdist See documentation packages information: https://cran.r-project.org/package=adespatial https://cran.r-project.org/package=betapart https://cran.r-project.org/package=ecodist https://cran.r-project.org/package=vegan","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/as_bioregion_pairwise.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert a matrix or list of matrices to a bioregion (dis)similarity object — as_bioregion_pairwise","text":"specific package specified (.e., pkg = NULL), site names based row names first matrix. row names NULL, generated automatically. mat named list, names used column names metric_name = NULL.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/as_bioregion_pairwise.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert a matrix or list of matrices to a bioregion (dis)similarity object — as_bioregion_pairwise","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/as_bioregion_pairwise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a matrix or list of matrices to a bioregion (dis)similarity object — as_bioregion_pairwise","text":"","code":"mat <- matrix(runif(100), 10, 10) rownames(mat) <- paste0(\"s\",1:10)  pair <- as_bioregion_pairwise(list(mat,mat,mat),                                metric_name = NULL,                               pkg = NULL,                               is_similarity = FALSE)                                pair #> Data.frame of dissimilarity between sites #>  - Total number of sites:  10  #>  - Total number of species:  NA  #>  - Number of rows:  45  #>  - Number of dissimilarity metrics:  3  #>  #>  #>    Site1 Site2    Metric1    Metric2    Metric3 #> 2     s1    s2 0.03424133 0.03424133 0.03424133 #> 3     s1    s3 0.73531960 0.73531960 0.73531960 #> 4     s1    s4 0.30083081 0.30083081 0.30083081 #> 5     s1    s5 0.64167935 0.64167935 0.64167935 #> 6     s1    s6 0.17467589 0.17467589 0.17467589 #> 7     s1    s7 0.57004495 0.57004495 0.57004495 #> 8     s1    s8 0.02806097 0.02806097 0.02806097 #> 9     s1    s9 0.26137136 0.26137136 0.26137136 #> 10    s1   s10 0.51855664 0.51855664 0.51855664 #> 13    s2    s3 0.19595673 0.19595673 0.19595673 #> 14    s2    s4 0.63646561 0.63646561 0.63646561 #> 15    s2    s5 0.66028435 0.66028435 0.66028435 #> 16    s2    s6 0.53157354 0.53157354 0.53157354 #> 17    s2    s7 0.33571908 0.33571908 0.33571908 #> 18    s2    s8 0.46598719 0.46598719 0.46598719 #> 19    s2    s9 0.29005016 0.29005016 0.29005016 #> 20    s2   s10 0.84612005 0.84612005 0.84612005 #> 24    s3    s4 0.47902455 0.47902455 0.47902455 #> 25    s3    s5 0.09602416 0.09602416 0.09602416 #> 26    s3    s6 0.49363702 0.49363702 0.49363702 #> 27    s3    s7 0.59626279 0.59626279 0.59626279 #> 28    s3    s8 0.39003139 0.39003139 0.39003139 #> 29    s3    s9 0.48007517 0.48007517 0.48007517 #> 30    s3   s10 0.71826972 0.71826972 0.71826972 #> 35    s4    s5 0.76560016 0.76560016 0.76560016 #> 36    s4    s6 0.77930863 0.77930863 0.77930863 #> 37    s4    s7 0.19151803 0.19151803 0.19151803 #> 38    s4    s8 0.02006522 0.02006522 0.02006522 #> 39    s4    s9 0.92000555 0.92000555 0.92000555 #> 40    s4   s10 0.24131402 0.24131402 0.24131402 #> 46    s5    s6 0.20417834 0.20417834 0.20417834 #> 47    s5    s7 0.94776394 0.94776394 0.94776394 #> 48    s5    s8 0.37697093 0.37697093 0.37697093 #> 49    s5    s9 0.40072018 0.40072018 0.40072018 #> 50    s5   s10 0.54704337 0.54704337 0.54704337 #> 57    s6    s7 0.54248041 0.54248041 0.54248041 #> 58    s6    s8 0.55991284 0.55991284 0.55991284 #> 59    s6    s9 0.21317271 0.21317271 0.21317271 #> 60    s6   s10 0.83480182 0.83480182 0.83480182 #> 68    s7    s8 0.85708359 0.85708359 0.85708359 #> 69    s7    s9 0.67176682 0.67176682 0.67176682 #> 70    s7   s10 0.02795603 0.02795603 0.02795603 #> 79    s8    s9 0.05861411 0.05861411 0.05861411 #> 80    s8   s10 0.46938430 0.46938430 0.46938430 #> 90    s9   s10 0.80568003 0.80568003 0.80568003"},{"path":"https://bioRgeo.github.io/bioregion/reference/betapart_to_bioregion.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert betapart dissimilarity to bioregion dissimilarity (DEPRECATED) — betapart_to_bioregion","title":"Convert betapart dissimilarity to bioregion dissimilarity (DEPRECATED) — betapart_to_bioregion","text":"function converts dissimilarity results produced betapart package (packages using betapart, phyloregion) dissimilarity object compatible bioregion package. function converts object types make compatible bioregion; modify beta-diversity values. function allows inclusion phylogenetic beta diversity compute bioregions bioregion.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/betapart_to_bioregion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert betapart dissimilarity to bioregion dissimilarity (DEPRECATED) — betapart_to_bioregion","text":"","code":"betapart_to_bioregion(betapart_result)"},{"path":"https://bioRgeo.github.io/bioregion/reference/betapart_to_bioregion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert betapart dissimilarity to bioregion dissimilarity (DEPRECATED) — betapart_to_bioregion","text":"betapart_result object produced betapart package (e.g., using beta.pair function).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/betapart_to_bioregion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert betapart dissimilarity to bioregion dissimilarity (DEPRECATED) — betapart_to_bioregion","text":"dissimilarity object class bioregion.pairwise, compatible bioregion package.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/betapart_to_bioregion.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert betapart dissimilarity to bioregion dissimilarity (DEPRECATED) — betapart_to_bioregion","text":"Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/betapart_to_bioregion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert betapart dissimilarity to bioregion dissimilarity (DEPRECATED) — betapart_to_bioregion","text":"","code":"comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  if (FALSE) { # \\dontrun{ beta_div <- betapart::beta.pair.abund(comat) betapart_to_bioregion(beta_div) } # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/bind_pairwise.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine and enrich bioregion (dis)similarity object(s) — bind_pairwise","title":"Combine and enrich bioregion (dis)similarity object(s) — bind_pairwise","text":"Combine two bioregion.pairwise objects /compute new pairwise metrics based columns object(s).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bind_pairwise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine and enrich bioregion (dis)similarity object(s) — bind_pairwise","text":"","code":"bind_pairwise(primary_metrics, secondary_metrics, new_metrics = NULL)"},{"path":"https://bioRgeo.github.io/bioregion/reference/bind_pairwise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine and enrich bioregion (dis)similarity object(s) — bind_pairwise","text":"primary_metrics bioregion.pairwise object. main set pairwise metrics used base combination. secondary_metrics second bioregion.pairwise object combined primary_metrics. must sites identifiers pairwise structure. Can set NULL new_metrics specified. new_metrics character vector single character string specifying custom formula(s) based column names primary_metrics secondary_metrics (see Details).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bind_pairwise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine and enrich bioregion (dis)similarity object(s) — bind_pairwise","text":"new bioregion.pairwise object containing combined /enriched data. includes original metrics inputs, well newly computed metrics.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bind_pairwise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Combine and enrich bioregion (dis)similarity object(s) — bind_pairwise","text":"primary_metrics secondary_metrics provided pairwise structure identical function combine two objects. new_metrics provided, formula evaluated based column names primary_metrics (secondary_metrics provided).","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/bind_pairwise.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Combine and enrich bioregion (dis)similarity object(s) — bind_pairwise","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bind_pairwise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine and enrich bioregion (dis)similarity object(s) — bind_pairwise","text":"","code":"comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"s\", 1:5) colnames(comat) <- paste0(\"sp\", 1:10)  sim <- bind_pairwise(primary_metrics = similarity(comat,                                                                 metric = \"abc\"),                                   secondary_metrics = similarity(comat,                                                                   metric = \"Simpson\"),                                   new_metrics = \"1 - (b + c) / (a + b + c)\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_colors.html","id":null,"dir":"Reference","previous_headings":"","what":"Add color palettes to bioregion cluster objects — bioregion_colors","title":"Add color palettes to bioregion cluster objects — bioregion_colors","text":"function assigns colors clusters bioregion.clusters object using color palettes rcartocolor package. handles large numbers clusters assigning vivid colors important clusters (based size), grey shades less important clusters, optionally black insignificant clusters.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_colors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add color palettes to bioregion cluster objects — bioregion_colors","text":"","code":"bioregion_colors(   clusters,   palette = \"Vivid\",   cluster_ordering = \"n_sites\",   cutoff_insignificant = NULL )"},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_colors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add color palettes to bioregion cluster objects — bioregion_colors","text":"clusters object class bioregion.clusters, typically output clustering functions netclu_infomap(), hclu_hierarclust(), nhclu_pam(). palette character string indicating color palette rcartocolor use. Default \"Vivid\". qualitative palettes include \"Bold\", \"Prism\", \"Safe\", \"Antique\", \"Pastel\". cluster_ordering character string indicating criterion ranking clusters determine color assignment priority. Options : \"n_sites\" (default): Rank number sites cluster \"n_species\": Rank number species (bipartite networks ) \"n_both\": Rank combined sites + species (bipartite networks ) Larger clusters (chosen criterion) receive vivid colors first. cutoff_insignificant numeric value NULL (default). specified, clusters values threshold (based cluster_ordering criterion) considered insignificant colored black, reducing visual clutter maps. NULL, clusters receive distinct colors.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_colors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add color palettes to bioregion cluster objects — bioregion_colors","text":"modified bioregion.clusters object two additional elements: colors: list element corresponds partition (bioregionalization). list element data.frame two columns: cluster (character): Cluster identifier partition color (character): Hex color code (e.g., \"#FF5733\") clusters_colors: data.frame structure clusters element, cluster IDs replaced corresponding hex color codes direct use plotting functions.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_colors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add color palettes to bioregion cluster objects — bioregion_colors","text":"function uses two-step algorithm assign colors: Step 1: Identify insignificant clusters (cutoff_insignificant specified) Insignificant clusters marginal size compared others. subjective threshold set user. clusters assigned color black (#000000) minimize visual impact. Clusters values threshold assigned black (#000000). Step 2: Assign colors significant clusters Remaining clusters ranked cluster_ordering criterion: Top clusters (12): Receive distinct colors chosen palette. limit 12 human eye struggles distinguish colors. Remaining clusters (beyond top 12): Receive shades grey light (#CCCCCC) dark (#404040), maintaining visual distinction less prominence. Multiple partitions: cluster object contains multiple partitions (e.g., hierarchical clustering different k values), colors assigned independently partition. partition gets color scale optimized number clusters partition.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_colors.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Add color palettes to bioregion cluster objects — bioregion_colors","text":"colored cluster object can directly used map_bioregions(), automatically detect apply color scheme present.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_colors.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add color palettes to bioregion cluster objects — bioregion_colors","text":"Color palettes rcartocolor package: Nowosad J (2018). \"CARTOColors: color palettes inspired CARTO.\" https://github.com/Nowosad/rcartocolor","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_colors.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add color palettes to bioregion cluster objects — bioregion_colors","text":"Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_colors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add color palettes to bioregion cluster objects — bioregion_colors","text":"","code":"data(fishmat) data(fishsf)  # Basic example with few clusters sim <- similarity(fishmat, metric = \"Simpson\") clust <- netclu_greedy(sim) clust_colored <- bioregion_colors(clust) print(clust_colored) #> Clustering results for algorithm : netclu_greedy  #>  - Number of sites:  338  #> Clustering results: #>  - Number of partitions:  1  #>  - Number of clusters:  4  #>  - Color palette assigned: #>    *  K_4 : 4 vivid colors   if (FALSE) { # \\dontrun{ # Map with automatic colors map_bioregions(clust_colored, fishsf)  # Example with many clusters and cutoff dissim <- similarity_to_dissimilarity(sim) clust <- hclu_hierarclust(dissim,                           optimal_tree_method = \"best\",                           n_clust = 15) clust_colored2 <- bioregion_colors(clust,                                     cluster_ordering = \"n_sites\",                                    cutoff_insignificant = 1) map_bioregions(clust_colored2, fishsf)  # Example with different palette clust_colored3 <- bioregion_colors(clust, palette = \"Bold\") map_bioregions(clust_colored3, fishsf)   # Example with bipartite network clust_bip <- netclu_greedy(fishdf, bipartite = TRUE) clust_bip_colored <- bioregion_colors(clust_bip,                                        cluster_ordering = \"n_both\") map_bioregions(clust_bip_colored, fishsf)                                        } # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate contribution metrics for bioregions — bioregion_metrics","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"function calculates number sites per bioregion, well number species sites , number endemic species, proportion endemism.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"","code":"bioregion_metrics(bioregionalization, comat, map = NULL, col_bioregion = NULL)"},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"bioregionalization bioregion.clusters object. comat co-occurrence matrix sites rows species columns. map spatial sf data.frame sites bioregions. output function map_bioregions. NULL default. col_bioregion integer specifying column position bioregion.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"data.frame 5 columns, 6 spatial coherence computed.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"Endemic species species found sites belonging one bioregion.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") clust <- netclu_louvain(net)  bioregion_metrics(bioregionalization = clust,                    comat = comat)  #>   Bioregion Site_number Species_number Endemics Percentage_Endemic #> 1         1           5             10       10                100"},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate metrics for one or several bioregionalizations — bioregionalization_metrics","title":"Calculate metrics for one or several bioregionalizations — bioregionalization_metrics","text":"function calculates metrics one several bioregionalizations, typically based outputs netclu_, hclu_, nhclu_ functions. metrics may require users provide either similarity dissimilarity matrix, initial species-site table.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate metrics for one or several bioregionalizations — bioregionalization_metrics","text":"","code":"bioregionalization_metrics(   bioregionalization,   dissimilarity = NULL,   dissimilarity_index = NULL,   net = NULL,   site_col = 1,   species_col = 2,   eval_metric = \"all\" )"},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate metrics for one or several bioregionalizations — bioregionalization_metrics","text":"bioregionalization bioregion.clusters object. dissimilarity dist object bioregion.pairwise object (output similarity_to_dissimilarity()). Required eval_metric includes \"pc_distance\" tree bioregion.hierar.tree object. dissimilarity_index character string indicating dissimilarity (beta-diversity) index use dissimilarity data.frame multiple dissimilarity indices. net site-species network (.e., bipartite network). provided data.frame eval_metric includes \"avg_endemism\" \"tot_endemism\". site_col name index column representing site nodes (.e., primary nodes). provided eval_metric includes \"avg_endemism\" \"tot_endemism\". species_col name index column representing species nodes (.e., feature nodes). provided eval_metric includes \"avg_endemism\" \"tot_endemism\". eval_metric character vector single character string indicating metric(s) calculated assess effect different numbers clusters. Available options \"pc_distance\", \"anosim\", \"avg_endemism\", \"tot_endemism\". \"\" specified, metrics calculated.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate metrics for one or several bioregionalizations — bioregionalization_metrics","text":"list class bioregion.bioregionalization.metrics two three elements: args: Input arguments. evaluation_df: data.frame containing eval_metric values explored numbers clusters. endemism_results: endemism calculations requested, list endemism results bioregionalization.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate metrics for one or several bioregionalizations — bioregionalization_metrics","text":"Evaluation metrics: pc_distance: metric, used Holt et al. (2013), ratio -cluster sum dissimilarities (beta-diversity) total sum dissimilarities full dissimilarity matrix. calculated two steps: Compute total sum dissimilarities summing elements dissimilarity matrix. Compute -cluster sum dissimilarities setting within-cluster dissimilarities zero summing matrix. pc_distance ratio obtained dividing -cluster sum dissimilarities total sum dissimilarities. anosim: metric statistic used Analysis Similarities, described Castro-Insua et al. (2018). compares -cluster within-cluster dissimilarities. statistic computed : R = (r_B - r_W) / (N (N-1) / 4), r_B r_W average ranks -cluster within-cluster dissimilarities, respectively, N total number sites. Note: function estimate significance; significance testing, use vegan::anosim(). avg_endemism: metric average percentage endemism clusters, recommended Kreft & Jetz (2010). calculated : End_mean = sum_i (E_i / S_i) / K, E_i number endemic species cluster , S_i number species cluster , K total number clusters. tot_endemism: metric total endemism across clusters, recommended Kreft & Jetz (2010). calculated : End_tot = E / C, E total number endemic species (.e., species found one cluster) C number non-endemic species.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate metrics for one or several bioregionalizations — bioregionalization_metrics","text":"Castro-Insua , Gómez-Rodríguez C & Baselga (2018) Dissimilarity measures affected richness differences yield biased delimitations biogeographic realms. Nature Communications 9, 9-11. Holt BG, Lessard J, Borregaard MK, Fritz SA, Araújo MB, Dimitrov D, Fabre P, Graham CH, Graves GR, Jønsson Ka, Nogués-Bravo D, Wang Z, Whittaker RJ, Fjeldså J & Rahbek C (2013) update Wallace's zoogeographic regions world. Science 339, 74-78. Kreft H & Jetz W (2010) framework delineating biogeographical regions based species distributions. Journal Biogeography 37, 2029-2053.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate metrics for one or several bioregionalizations — bioregionalization_metrics","text":"Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate metrics for one or several bioregionalizations — bioregionalization_metrics","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  comnet <- mat_to_net(comat)  dissim <- dissimilarity(comat, metric = \"all\")  # User-defined number of clusters tree1 <- hclu_hierarclust(dissim,                            n_clust = 10:15,                            index = \"Simpson\") #> Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. #> Error in if (nrow(dist_matrix) > 2) {    subclusters <- stable_binary_split(dist_matrix, method = method,         n_runs = n_runs, binsplit = \"tree\")} else {    subclusters <- list(attr(dist_matrix, \"Labels\")[1], attr(dist_matrix,         \"Labels\")[2])}: argument is of length zero tree1 #> Error: object 'tree1' not found  a <- bioregionalization_metrics(tree1,                                  dissimilarity = dissim,                                  net = comnet,                                 site_col = \"Node1\",                                  species_col = \"Node2\",                                 eval_metric = c(\"tot_endemism\",                                                  \"avg_endemism\",                                                 \"pc_distance\",                                                  \"anosim\")) #> Error: object 'tree1' not found a #> Error: object 'a' not found"},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"function computes pairwise comparisons several bioregionalizations, usually outputs netclu_, hclu_, nhclu_ functions. also provides confusion matrix pairwise comparisons, enabling user compute additional comparison metrics.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"","code":"compare_bioregionalizations(   bioregionalizations,   indices = c(\"rand\", \"jaccard\"),   cor_frequency = FALSE,   store_pairwise_membership = TRUE,   store_confusion_matrix = TRUE,   verbose = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"bioregionalizations data.frame object row corresponds site, column bioregionalization. indices NULL character. Indices compute pairwise comparison bioregionalizations. Currently available metrics \"rand\" \"jaccard\". cor_frequency boolean. TRUE, computes correlation bioregionalization total frequency co-membership items across bioregionalizations. useful identifying bioregionalization(s) () representative computed bioregionalizations. store_pairwise_membership boolean. TRUE, stores pairwise membership items output object. store_confusion_matrix boolean. TRUE, stores confusion matrices pairwise bioregionalization comparisons output object. verbose boolean indicating whether display progress messages. Set FALSE suppress messages.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"list containing 4 7 elements: args: list user-provided arguments. inputs: list containing information input bioregionalizations, number items clustered. pairwise_membership (optional): store_pairwise_membership = TRUE, boolean matrix TRUE indicates two items cluster, FALSE indicates . freq_item_pw_membership: numeric vector containing number times item pair clustered together, corresponding sum rows pairwise_membership. bioregionalization_freq_cor (optional): cor_frequency = TRUE, numeric vector correlations individual bioregionalizations total frequency pairwise membership. confusion_matrix (optional): store_confusion_matrix = TRUE, list confusion matrices pair bioregionalizations. bioregionalization_comparison: data.frame containing comparison results, first column indicates bioregionalizations compared, remaining columns contain requested indices.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"function operates two main steps: Within bioregionalization, function compares pairs items documents whether clustered together (TRUE) separately (FALSE). example, site 1 site 2 clustered cluster bioregionalization 1, pairwise membership site1_site2 TRUE. output stored pairwise_membership slot store_pairwise_membership = TRUE. Across bioregionalizations, function compares pairwise memberships determine similarity. pair bioregionalizations, computes confusion matrix following elements: : Number item pairs grouped bioregionalizations. b: Number item pairs grouped first second bioregionalization. c: Number item pairs grouped second first bioregionalization. d: Number item pairs grouped either bioregionalization. confusion matrix stored confusion_matrix store_confusion_matrix = TRUE. Based confusion matrices, various indices can computed measure agreement among bioregionalizations. currently implemented indices : Rand index: (+ d) / (+ b + c + d) Measures agreement considering grouped ungrouped item pairs. Jaccard index: / (+ b + c) Measures agreement based grouped item pairs. indices complementary: Jaccard index evaluates clustering similarity, Rand index considers clustering separation. example, two bioregionalizations never group pairs, Jaccard index 0, Rand index may > 0 due ungrouped pairs. Users can compute additional indices manually using list confusion matrices. identify bioregionalization representative others, function can compute correlation pairwise membership bioregionalization total frequency pairwise membership across bioregionalizations. enabled setting cor_frequency = TRUE.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"","code":"# We here compare three different bioregionalizations comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"Simpson\") bioregion1 <- nhclu_kmeans(dissim, n_clust = 3, index = \"Simpson\")  net <- similarity(comat, metric = \"Simpson\") bioregion2 <- netclu_greedy(net) bioregion3 <- netclu_walktrap(net)  # Make one single data.frame with the bioregionalizations to compare compare_df <- merge(bioregion1$clusters, bioregion2$clusters, by = \"ID\") compare_df <- merge(compare_df, bioregion3$clusters, by = \"ID\") colnames(compare_df) <- c(\"Site\", \"Hclu\", \"Greedy\", \"Walktrap\") rownames(compare_df) <- compare_df$Site compare_df <- compare_df[, c(\"Hclu\", \"Greedy\", \"Walktrap\")]  # Running the function compare_bioregionalizations(compare_df) #> 2026-01-23 10:07:15.736844 - Computing pairwise membership comparisons for each bioregionalization... #> 2026-01-23 10:07:15.738863 - Comparing memberships among bioregionalizations... #> 2026-01-23 10:07:15.739563 - Computing Rand index... #> 2026-01-23 10:07:15.739955 - Computing Jaccard index... #> $args #> $args$indices #> [1] \"rand\"    \"jaccard\" #>  #> $args$cor_frequency #> [1] FALSE #>  #> $args$store_pairwise_membership #> [1] TRUE #>  #> $args$store_confusion_matrix #> [1] TRUE #>  #>  #> $inputs #>               number_items number_bioregionalizations  #>                         20                          3  #>  #> $pairwise_membership #>        Hclu Greedy Walktrap #> 1_2   FALSE   TRUE     TRUE #> 1_3   FALSE   TRUE     TRUE #> 1_4   FALSE   TRUE     TRUE #> 1_5    TRUE   TRUE     TRUE #> 1_6   FALSE   TRUE     TRUE #> 1_7   FALSE   TRUE     TRUE #> 1_8   FALSE   TRUE     TRUE #> 1_9    TRUE   TRUE     TRUE #> 1_10  FALSE   TRUE     TRUE #> 1_11   TRUE   TRUE     TRUE #> 1_12  FALSE   TRUE     TRUE #> 1_13  FALSE   TRUE     TRUE #> 1_14   TRUE   TRUE     TRUE #> 1_15   TRUE   TRUE     TRUE #> 1_16  FALSE   TRUE     TRUE #> 1_17   TRUE   TRUE     TRUE #> 1_18  FALSE   TRUE     TRUE #> 1_19  FALSE  FALSE     TRUE #> 1_20  FALSE   TRUE     TRUE #> 2_3   FALSE   TRUE     TRUE #> 2_4    TRUE   TRUE     TRUE #> 2_5   FALSE   TRUE     TRUE #> 2_6    TRUE   TRUE     TRUE #> 2_7    TRUE   TRUE     TRUE #> 2_8    TRUE   TRUE     TRUE #> 2_9   FALSE   TRUE     TRUE #> 2_10  FALSE   TRUE     TRUE #> 2_11  FALSE   TRUE     TRUE #> 2_12   TRUE   TRUE     TRUE #> 2_13  FALSE   TRUE     TRUE #> 2_14  FALSE   TRUE     TRUE #> 2_15  FALSE   TRUE     TRUE #> 2_16  FALSE   TRUE     TRUE #> 2_17  FALSE   TRUE     TRUE #> 2_18  FALSE   TRUE     TRUE #> 2_19   TRUE  FALSE     TRUE #> 2_20  FALSE   TRUE     TRUE #> 3_4   FALSE   TRUE     TRUE #> 3_5   FALSE   TRUE     TRUE #> 3_6   FALSE   TRUE     TRUE #> 3_7   FALSE   TRUE     TRUE #> 3_8   FALSE   TRUE     TRUE #> 3_9   FALSE   TRUE     TRUE #> 3_10   TRUE   TRUE     TRUE #> 3_11  FALSE   TRUE     TRUE #> 3_12  FALSE   TRUE     TRUE #> 3_13   TRUE   TRUE     TRUE #> 3_14  FALSE   TRUE     TRUE #> 3_15  FALSE   TRUE     TRUE #> 3_16   TRUE   TRUE     TRUE #> 3_17  FALSE   TRUE     TRUE #> 3_18   TRUE   TRUE     TRUE #> 3_19  FALSE  FALSE     TRUE #> 3_20   TRUE   TRUE     TRUE #> 4_5   FALSE   TRUE     TRUE #> 4_6    TRUE   TRUE     TRUE #> 4_7    TRUE   TRUE     TRUE #> 4_8    TRUE   TRUE     TRUE #> 4_9   FALSE   TRUE     TRUE #> 4_10  FALSE   TRUE     TRUE #> 4_11  FALSE   TRUE     TRUE #> 4_12   TRUE   TRUE     TRUE #> 4_13  FALSE   TRUE     TRUE #> 4_14  FALSE   TRUE     TRUE #> 4_15  FALSE   TRUE     TRUE #> 4_16  FALSE   TRUE     TRUE #> 4_17  FALSE   TRUE     TRUE #> 4_18  FALSE   TRUE     TRUE #> 4_19   TRUE  FALSE     TRUE #> 4_20  FALSE   TRUE     TRUE #> 5_6   FALSE   TRUE     TRUE #> 5_7   FALSE   TRUE     TRUE #> 5_8   FALSE   TRUE     TRUE #> 5_9    TRUE   TRUE     TRUE #> 5_10  FALSE   TRUE     TRUE #> 5_11   TRUE   TRUE     TRUE #> 5_12  FALSE   TRUE     TRUE #> 5_13  FALSE   TRUE     TRUE #> 5_14   TRUE   TRUE     TRUE #> 5_15   TRUE   TRUE     TRUE #> 5_16  FALSE   TRUE     TRUE #> 5_17   TRUE   TRUE     TRUE #> 5_18  FALSE   TRUE     TRUE #> 5_19  FALSE  FALSE     TRUE #> 5_20  FALSE   TRUE     TRUE #> 6_7    TRUE   TRUE     TRUE #> 6_8    TRUE   TRUE     TRUE #> 6_9   FALSE   TRUE     TRUE #> 6_10  FALSE   TRUE     TRUE #> 6_11  FALSE   TRUE     TRUE #> 6_12   TRUE   TRUE     TRUE #> 6_13  FALSE   TRUE     TRUE #> 6_14  FALSE   TRUE     TRUE #> 6_15  FALSE   TRUE     TRUE #> 6_16  FALSE   TRUE     TRUE #> 6_17  FALSE   TRUE     TRUE #> 6_18  FALSE   TRUE     TRUE #> 6_19   TRUE  FALSE     TRUE #> 6_20  FALSE   TRUE     TRUE #> 7_8    TRUE   TRUE     TRUE #> 7_9   FALSE   TRUE     TRUE #> 7_10  FALSE   TRUE     TRUE #> 7_11  FALSE   TRUE     TRUE #> 7_12   TRUE   TRUE     TRUE #> 7_13  FALSE   TRUE     TRUE #> 7_14  FALSE   TRUE     TRUE #> 7_15  FALSE   TRUE     TRUE #> 7_16  FALSE   TRUE     TRUE #> 7_17  FALSE   TRUE     TRUE #> 7_18  FALSE   TRUE     TRUE #> 7_19   TRUE  FALSE     TRUE #> 7_20  FALSE   TRUE     TRUE #> 8_9   FALSE   TRUE     TRUE #> 8_10  FALSE   TRUE     TRUE #> 8_11  FALSE   TRUE     TRUE #> 8_12   TRUE   TRUE     TRUE #> 8_13  FALSE   TRUE     TRUE #> 8_14  FALSE   TRUE     TRUE #> 8_15  FALSE   TRUE     TRUE #> 8_16  FALSE   TRUE     TRUE #> 8_17  FALSE   TRUE     TRUE #> 8_18  FALSE   TRUE     TRUE #> 8_19   TRUE  FALSE     TRUE #> 8_20  FALSE   TRUE     TRUE #> 9_10  FALSE   TRUE     TRUE #> 9_11   TRUE   TRUE     TRUE #> 9_12  FALSE   TRUE     TRUE #> 9_13  FALSE   TRUE     TRUE #> 9_14   TRUE   TRUE     TRUE #> 9_15   TRUE   TRUE     TRUE #> 9_16  FALSE   TRUE     TRUE #> 9_17   TRUE   TRUE     TRUE #> 9_18  FALSE   TRUE     TRUE #> 9_19  FALSE  FALSE     TRUE #> 9_20  FALSE   TRUE     TRUE #> 10_11 FALSE   TRUE     TRUE #> 10_12 FALSE   TRUE     TRUE #> 10_13  TRUE   TRUE     TRUE #> 10_14 FALSE   TRUE     TRUE #> 10_15 FALSE   TRUE     TRUE #> 10_16  TRUE   TRUE     TRUE #> 10_17 FALSE   TRUE     TRUE #> 10_18  TRUE   TRUE     TRUE #> 10_19 FALSE  FALSE     TRUE #> 10_20  TRUE   TRUE     TRUE #> 11_12 FALSE   TRUE     TRUE #> 11_13 FALSE   TRUE     TRUE #> 11_14  TRUE   TRUE     TRUE #> 11_15  TRUE   TRUE     TRUE #> 11_16 FALSE   TRUE     TRUE #> 11_17  TRUE   TRUE     TRUE #> 11_18 FALSE   TRUE     TRUE #> 11_19 FALSE  FALSE     TRUE #> 11_20 FALSE   TRUE     TRUE #> 12_13 FALSE   TRUE     TRUE #> 12_14 FALSE   TRUE     TRUE #> 12_15 FALSE   TRUE     TRUE #> 12_16 FALSE   TRUE     TRUE #> 12_17 FALSE   TRUE     TRUE #> 12_18 FALSE   TRUE     TRUE #> 12_19  TRUE  FALSE     TRUE #> 12_20 FALSE   TRUE     TRUE #> 13_14 FALSE   TRUE     TRUE #> 13_15 FALSE   TRUE     TRUE #> 13_16  TRUE   TRUE     TRUE #> 13_17 FALSE   TRUE     TRUE #> 13_18  TRUE   TRUE     TRUE #> 13_19 FALSE  FALSE     TRUE #> 13_20  TRUE   TRUE     TRUE #> 14_15  TRUE   TRUE     TRUE #> 14_16 FALSE   TRUE     TRUE #> 14_17  TRUE   TRUE     TRUE #> 14_18 FALSE   TRUE     TRUE #> 14_19 FALSE  FALSE     TRUE #> 14_20 FALSE   TRUE     TRUE #> 15_16 FALSE   TRUE     TRUE #> 15_17  TRUE   TRUE     TRUE #> 15_18 FALSE   TRUE     TRUE #> 15_19 FALSE  FALSE     TRUE #> 15_20 FALSE   TRUE     TRUE #> 16_17 FALSE   TRUE     TRUE #> 16_18  TRUE   TRUE     TRUE #> 16_19 FALSE  FALSE     TRUE #> 16_20  TRUE   TRUE     TRUE #> 17_18 FALSE   TRUE     TRUE #> 17_19 FALSE  FALSE     TRUE #> 17_20 FALSE   TRUE     TRUE #> 18_19 FALSE  FALSE     TRUE #> 18_20  TRUE   TRUE     TRUE #> 19_20 FALSE  FALSE     TRUE #>  #> $freq_item_pw_membership #>   1_2   1_3   1_4   1_5   1_6   1_7   1_8   1_9  1_10  1_11  1_12  1_13  1_14  #>     2     2     2     3     2     2     2     3     2     3     2     2     3  #>  1_15  1_16  1_17  1_18  1_19  1_20   2_3   2_4   2_5   2_6   2_7   2_8   2_9  #>     3     2     3     2     1     2     2     3     2     3     3     3     2  #>  2_10  2_11  2_12  2_13  2_14  2_15  2_16  2_17  2_18  2_19  2_20   3_4   3_5  #>     2     2     3     2     2     2     2     2     2     2     2     2     2  #>   3_6   3_7   3_8   3_9  3_10  3_11  3_12  3_13  3_14  3_15  3_16  3_17  3_18  #>     2     2     2     2     3     2     2     3     2     2     3     2     3  #>  3_19  3_20   4_5   4_6   4_7   4_8   4_9  4_10  4_11  4_12  4_13  4_14  4_15  #>     1     3     2     3     3     3     2     2     2     3     2     2     2  #>  4_16  4_17  4_18  4_19  4_20   5_6   5_7   5_8   5_9  5_10  5_11  5_12  5_13  #>     2     2     2     2     2     2     2     2     3     2     3     2     2  #>  5_14  5_15  5_16  5_17  5_18  5_19  5_20   6_7   6_8   6_9  6_10  6_11  6_12  #>     3     3     2     3     2     1     2     3     3     2     2     2     3  #>  6_13  6_14  6_15  6_16  6_17  6_18  6_19  6_20   7_8   7_9  7_10  7_11  7_12  #>     2     2     2     2     2     2     2     2     3     2     2     2     3  #>  7_13  7_14  7_15  7_16  7_17  7_18  7_19  7_20   8_9  8_10  8_11  8_12  8_13  #>     2     2     2     2     2     2     2     2     2     2     2     3     2  #>  8_14  8_15  8_16  8_17  8_18  8_19  8_20  9_10  9_11  9_12  9_13  9_14  9_15  #>     2     2     2     2     2     2     2     2     3     2     2     3     3  #>  9_16  9_17  9_18  9_19  9_20 10_11 10_12 10_13 10_14 10_15 10_16 10_17 10_18  #>     2     3     2     1     2     2     2     3     2     2     3     2     3  #> 10_19 10_20 11_12 11_13 11_14 11_15 11_16 11_17 11_18 11_19 11_20 12_13 12_14  #>     1     3     2     2     3     3     2     3     2     1     2     2     2  #> 12_15 12_16 12_17 12_18 12_19 12_20 13_14 13_15 13_16 13_17 13_18 13_19 13_20  #>     2     2     2     2     2     2     2     2     3     2     3     1     3  #> 14_15 14_16 14_17 14_18 14_19 14_20 15_16 15_17 15_18 15_19 15_20 16_17 16_18  #>     3     2     3     2     1     2     2     3     2     1     2     2     3  #> 16_19 16_20 17_18 17_19 17_20 18_19 18_20 19_20  #>     1     3     2     1     2     1     3     1  #>  #> $confusion_matrix #> $confusion_matrix$`Hclu%Greedy` #>   a   b   c   d  #>  51   6 120  13  #>  #> $confusion_matrix$`Hclu%Walktrap` #>   a   b   c   d  #>  57   0 133   0  #>  #> $confusion_matrix$`Greedy%Walktrap` #>   a   b   c   d  #> 171   0  19   0  #>  #>  #> $bioregionalization_comparison #>   bioregionalization_comparison      rand   jaccard #> 1                   Hclu%Greedy 0.3368421 0.2881356 #> 2                 Hclu%Walktrap 0.3000000 0.3000000 #> 3               Greedy%Walktrap 0.9000000 0.9000000 #>  #> attr(,\"class\") #> [1] \"bioregion.bioregionalization.comparison\" #> [2] \"list\"                                     # Find out which bioregionalizations are most representative compare_bioregionalizations(compare_df,                             cor_frequency = TRUE) #> 2026-01-23 10:07:15.743436 - Computing pairwise membership comparisons for each bioregionalization... #> 2026-01-23 10:07:15.744974 - Comparing memberships among bioregionalizations... #> 2026-01-23 10:07:15.745617 - Computing Rand index... #> 2026-01-23 10:07:15.745958 - Computing Jaccard index... #> 2026-01-23 10:07:15.746303 - Computing the correlation between each bioregionalization and the vector of frequency of pairwise membership... #> $args #> $args$indices #> [1] \"rand\"    \"jaccard\" #>  #> $args$cor_frequency #> [1] TRUE #>  #> $args$store_pairwise_membership #> [1] TRUE #>  #> $args$store_confusion_matrix #> [1] TRUE #>  #>  #> $inputs #>               number_items number_bioregionalizations  #>                         20                          3  #>  #> $pairwise_membership #>        Hclu Greedy Walktrap #> 1_2   FALSE   TRUE     TRUE #> 1_3   FALSE   TRUE     TRUE #> 1_4   FALSE   TRUE     TRUE #> 1_5    TRUE   TRUE     TRUE #> 1_6   FALSE   TRUE     TRUE #> 1_7   FALSE   TRUE     TRUE #> 1_8   FALSE   TRUE     TRUE #> 1_9    TRUE   TRUE     TRUE #> 1_10  FALSE   TRUE     TRUE #> 1_11   TRUE   TRUE     TRUE #> 1_12  FALSE   TRUE     TRUE #> 1_13  FALSE   TRUE     TRUE #> 1_14   TRUE   TRUE     TRUE #> 1_15   TRUE   TRUE     TRUE #> 1_16  FALSE   TRUE     TRUE #> 1_17   TRUE   TRUE     TRUE #> 1_18  FALSE   TRUE     TRUE #> 1_19  FALSE  FALSE     TRUE #> 1_20  FALSE   TRUE     TRUE #> 2_3   FALSE   TRUE     TRUE #> 2_4    TRUE   TRUE     TRUE #> 2_5   FALSE   TRUE     TRUE #> 2_6    TRUE   TRUE     TRUE #> 2_7    TRUE   TRUE     TRUE #> 2_8    TRUE   TRUE     TRUE #> 2_9   FALSE   TRUE     TRUE #> 2_10  FALSE   TRUE     TRUE #> 2_11  FALSE   TRUE     TRUE #> 2_12   TRUE   TRUE     TRUE #> 2_13  FALSE   TRUE     TRUE #> 2_14  FALSE   TRUE     TRUE #> 2_15  FALSE   TRUE     TRUE #> 2_16  FALSE   TRUE     TRUE #> 2_17  FALSE   TRUE     TRUE #> 2_18  FALSE   TRUE     TRUE #> 2_19   TRUE  FALSE     TRUE #> 2_20  FALSE   TRUE     TRUE #> 3_4   FALSE   TRUE     TRUE #> 3_5   FALSE   TRUE     TRUE #> 3_6   FALSE   TRUE     TRUE #> 3_7   FALSE   TRUE     TRUE #> 3_8   FALSE   TRUE     TRUE #> 3_9   FALSE   TRUE     TRUE #> 3_10   TRUE   TRUE     TRUE #> 3_11  FALSE   TRUE     TRUE #> 3_12  FALSE   TRUE     TRUE #> 3_13   TRUE   TRUE     TRUE #> 3_14  FALSE   TRUE     TRUE #> 3_15  FALSE   TRUE     TRUE #> 3_16   TRUE   TRUE     TRUE #> 3_17  FALSE   TRUE     TRUE #> 3_18   TRUE   TRUE     TRUE #> 3_19  FALSE  FALSE     TRUE #> 3_20   TRUE   TRUE     TRUE #> 4_5   FALSE   TRUE     TRUE #> 4_6    TRUE   TRUE     TRUE #> 4_7    TRUE   TRUE     TRUE #> 4_8    TRUE   TRUE     TRUE #> 4_9   FALSE   TRUE     TRUE #> 4_10  FALSE   TRUE     TRUE #> 4_11  FALSE   TRUE     TRUE #> 4_12   TRUE   TRUE     TRUE #> 4_13  FALSE   TRUE     TRUE #> 4_14  FALSE   TRUE     TRUE #> 4_15  FALSE   TRUE     TRUE #> 4_16  FALSE   TRUE     TRUE #> 4_17  FALSE   TRUE     TRUE #> 4_18  FALSE   TRUE     TRUE #> 4_19   TRUE  FALSE     TRUE #> 4_20  FALSE   TRUE     TRUE #> 5_6   FALSE   TRUE     TRUE #> 5_7   FALSE   TRUE     TRUE #> 5_8   FALSE   TRUE     TRUE #> 5_9    TRUE   TRUE     TRUE #> 5_10  FALSE   TRUE     TRUE #> 5_11   TRUE   TRUE     TRUE #> 5_12  FALSE   TRUE     TRUE #> 5_13  FALSE   TRUE     TRUE #> 5_14   TRUE   TRUE     TRUE #> 5_15   TRUE   TRUE     TRUE #> 5_16  FALSE   TRUE     TRUE #> 5_17   TRUE   TRUE     TRUE #> 5_18  FALSE   TRUE     TRUE #> 5_19  FALSE  FALSE     TRUE #> 5_20  FALSE   TRUE     TRUE #> 6_7    TRUE   TRUE     TRUE #> 6_8    TRUE   TRUE     TRUE #> 6_9   FALSE   TRUE     TRUE #> 6_10  FALSE   TRUE     TRUE #> 6_11  FALSE   TRUE     TRUE #> 6_12   TRUE   TRUE     TRUE #> 6_13  FALSE   TRUE     TRUE #> 6_14  FALSE   TRUE     TRUE #> 6_15  FALSE   TRUE     TRUE #> 6_16  FALSE   TRUE     TRUE #> 6_17  FALSE   TRUE     TRUE #> 6_18  FALSE   TRUE     TRUE #> 6_19   TRUE  FALSE     TRUE #> 6_20  FALSE   TRUE     TRUE #> 7_8    TRUE   TRUE     TRUE #> 7_9   FALSE   TRUE     TRUE #> 7_10  FALSE   TRUE     TRUE #> 7_11  FALSE   TRUE     TRUE #> 7_12   TRUE   TRUE     TRUE #> 7_13  FALSE   TRUE     TRUE #> 7_14  FALSE   TRUE     TRUE #> 7_15  FALSE   TRUE     TRUE #> 7_16  FALSE   TRUE     TRUE #> 7_17  FALSE   TRUE     TRUE #> 7_18  FALSE   TRUE     TRUE #> 7_19   TRUE  FALSE     TRUE #> 7_20  FALSE   TRUE     TRUE #> 8_9   FALSE   TRUE     TRUE #> 8_10  FALSE   TRUE     TRUE #> 8_11  FALSE   TRUE     TRUE #> 8_12   TRUE   TRUE     TRUE #> 8_13  FALSE   TRUE     TRUE #> 8_14  FALSE   TRUE     TRUE #> 8_15  FALSE   TRUE     TRUE #> 8_16  FALSE   TRUE     TRUE #> 8_17  FALSE   TRUE     TRUE #> 8_18  FALSE   TRUE     TRUE #> 8_19   TRUE  FALSE     TRUE #> 8_20  FALSE   TRUE     TRUE #> 9_10  FALSE   TRUE     TRUE #> 9_11   TRUE   TRUE     TRUE #> 9_12  FALSE   TRUE     TRUE #> 9_13  FALSE   TRUE     TRUE #> 9_14   TRUE   TRUE     TRUE #> 9_15   TRUE   TRUE     TRUE #> 9_16  FALSE   TRUE     TRUE #> 9_17   TRUE   TRUE     TRUE #> 9_18  FALSE   TRUE     TRUE #> 9_19  FALSE  FALSE     TRUE #> 9_20  FALSE   TRUE     TRUE #> 10_11 FALSE   TRUE     TRUE #> 10_12 FALSE   TRUE     TRUE #> 10_13  TRUE   TRUE     TRUE #> 10_14 FALSE   TRUE     TRUE #> 10_15 FALSE   TRUE     TRUE #> 10_16  TRUE   TRUE     TRUE #> 10_17 FALSE   TRUE     TRUE #> 10_18  TRUE   TRUE     TRUE #> 10_19 FALSE  FALSE     TRUE #> 10_20  TRUE   TRUE     TRUE #> 11_12 FALSE   TRUE     TRUE #> 11_13 FALSE   TRUE     TRUE #> 11_14  TRUE   TRUE     TRUE #> 11_15  TRUE   TRUE     TRUE #> 11_16 FALSE   TRUE     TRUE #> 11_17  TRUE   TRUE     TRUE #> 11_18 FALSE   TRUE     TRUE #> 11_19 FALSE  FALSE     TRUE #> 11_20 FALSE   TRUE     TRUE #> 12_13 FALSE   TRUE     TRUE #> 12_14 FALSE   TRUE     TRUE #> 12_15 FALSE   TRUE     TRUE #> 12_16 FALSE   TRUE     TRUE #> 12_17 FALSE   TRUE     TRUE #> 12_18 FALSE   TRUE     TRUE #> 12_19  TRUE  FALSE     TRUE #> 12_20 FALSE   TRUE     TRUE #> 13_14 FALSE   TRUE     TRUE #> 13_15 FALSE   TRUE     TRUE #> 13_16  TRUE   TRUE     TRUE #> 13_17 FALSE   TRUE     TRUE #> 13_18  TRUE   TRUE     TRUE #> 13_19 FALSE  FALSE     TRUE #> 13_20  TRUE   TRUE     TRUE #> 14_15  TRUE   TRUE     TRUE #> 14_16 FALSE   TRUE     TRUE #> 14_17  TRUE   TRUE     TRUE #> 14_18 FALSE   TRUE     TRUE #> 14_19 FALSE  FALSE     TRUE #> 14_20 FALSE   TRUE     TRUE #> 15_16 FALSE   TRUE     TRUE #> 15_17  TRUE   TRUE     TRUE #> 15_18 FALSE   TRUE     TRUE #> 15_19 FALSE  FALSE     TRUE #> 15_20 FALSE   TRUE     TRUE #> 16_17 FALSE   TRUE     TRUE #> 16_18  TRUE   TRUE     TRUE #> 16_19 FALSE  FALSE     TRUE #> 16_20  TRUE   TRUE     TRUE #> 17_18 FALSE   TRUE     TRUE #> 17_19 FALSE  FALSE     TRUE #> 17_20 FALSE   TRUE     TRUE #> 18_19 FALSE  FALSE     TRUE #> 18_20  TRUE   TRUE     TRUE #> 19_20 FALSE  FALSE     TRUE #>  #> $freq_item_pw_membership #>   1_2   1_3   1_4   1_5   1_6   1_7   1_8   1_9  1_10  1_11  1_12  1_13  1_14  #>     2     2     2     3     2     2     2     3     2     3     2     2     3  #>  1_15  1_16  1_17  1_18  1_19  1_20   2_3   2_4   2_5   2_6   2_7   2_8   2_9  #>     3     2     3     2     1     2     2     3     2     3     3     3     2  #>  2_10  2_11  2_12  2_13  2_14  2_15  2_16  2_17  2_18  2_19  2_20   3_4   3_5  #>     2     2     3     2     2     2     2     2     2     2     2     2     2  #>   3_6   3_7   3_8   3_9  3_10  3_11  3_12  3_13  3_14  3_15  3_16  3_17  3_18  #>     2     2     2     2     3     2     2     3     2     2     3     2     3  #>  3_19  3_20   4_5   4_6   4_7   4_8   4_9  4_10  4_11  4_12  4_13  4_14  4_15  #>     1     3     2     3     3     3     2     2     2     3     2     2     2  #>  4_16  4_17  4_18  4_19  4_20   5_6   5_7   5_8   5_9  5_10  5_11  5_12  5_13  #>     2     2     2     2     2     2     2     2     3     2     3     2     2  #>  5_14  5_15  5_16  5_17  5_18  5_19  5_20   6_7   6_8   6_9  6_10  6_11  6_12  #>     3     3     2     3     2     1     2     3     3     2     2     2     3  #>  6_13  6_14  6_15  6_16  6_17  6_18  6_19  6_20   7_8   7_9  7_10  7_11  7_12  #>     2     2     2     2     2     2     2     2     3     2     2     2     3  #>  7_13  7_14  7_15  7_16  7_17  7_18  7_19  7_20   8_9  8_10  8_11  8_12  8_13  #>     2     2     2     2     2     2     2     2     2     2     2     3     2  #>  8_14  8_15  8_16  8_17  8_18  8_19  8_20  9_10  9_11  9_12  9_13  9_14  9_15  #>     2     2     2     2     2     2     2     2     3     2     2     3     3  #>  9_16  9_17  9_18  9_19  9_20 10_11 10_12 10_13 10_14 10_15 10_16 10_17 10_18  #>     2     3     2     1     2     2     2     3     2     2     3     2     3  #> 10_19 10_20 11_12 11_13 11_14 11_15 11_16 11_17 11_18 11_19 11_20 12_13 12_14  #>     1     3     2     2     3     3     2     3     2     1     2     2     2  #> 12_15 12_16 12_17 12_18 12_19 12_20 13_14 13_15 13_16 13_17 13_18 13_19 13_20  #>     2     2     2     2     2     2     2     2     3     2     3     1     3  #> 14_15 14_16 14_17 14_18 14_19 14_20 15_16 15_17 15_18 15_19 15_20 16_17 16_18  #>     3     2     3     2     1     2     2     3     2     1     2     2     3  #> 16_19 16_20 17_18 17_19 17_20 18_19 18_20 19_20  #>     1     3     2     1     2     1     3     1  #>  #> $bioregionalization_freq_cor #>      Hclu    Greedy  Walktrap  #> 0.8347745 0.5409681 0.0000000  #>  #> $confusion_matrix #> $confusion_matrix$`Hclu%Greedy` #>   a   b   c   d  #>  51   6 120  13  #>  #> $confusion_matrix$`Hclu%Walktrap` #>   a   b   c   d  #>  57   0 133   0  #>  #> $confusion_matrix$`Greedy%Walktrap` #>   a   b   c   d  #> 171   0  19   0  #>  #>  #> $bioregionalization_comparison #>   bioregionalization_comparison      rand   jaccard #> 1                   Hclu%Greedy 0.3368421 0.2881356 #> 2                 Hclu%Walktrap 0.3000000 0.3000000 #> 3               Greedy%Walktrap 0.9000000 0.9000000 #>  #> attr(,\"class\") #> [1] \"bioregion.bioregionalization.comparison\" #> [2] \"list\""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut a hierarchical tree — cut_tree","title":"Cut a hierarchical tree — cut_tree","text":"function designed work hierarchical tree cut user-selected heights. works outputs either hclu_hierarclust hclust objects. function allows cutting tree based chosen number(s) clusters specified height(s). Additionally, includes procedure automatically determine cutting height requested number(s) clusters.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut a hierarchical tree — cut_tree","text":"","code":"cut_tree(   tree,   n_clust = NULL,   cut_height = NULL,   find_h = TRUE,   h_max = 1,   h_min = 0,   dynamic_tree_cut = FALSE,   dynamic_method = \"tree\",   dynamic_minClusterSize = 5,   dissimilarity = NULL,   show_hierarchy = FALSE,   verbose = TRUE,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut a hierarchical tree — cut_tree","text":"tree bioregion.hierar.tree hclust object. n_clust integer vector single integer indicating number clusters obtained hierarchical tree, output bioregionalization_metrics(). used concurrently cut_height. cut_height numeric vector specifying height(s) tree cut. used concurrently n_clust optim_method. find_h boolean indicating whether cutting height determined requested n_clust. h_max numeric value indicating maximum possible tree height determining cutting height find_h = TRUE. h_min numeric value specifying minimum possible height tree determining cutting height find_h = TRUE. dynamic_tree_cut boolean indicating whether dynamic tree cut method used. TRUE, n_clust cut_height ignored. dynamic_method character string specifying method used dynamically cutting tree: either \"tree\" (clusters searched within tree) \"hybrid\" (clusters searched tree dissimilarity matrix). dynamic_minClusterSize integer indicating minimum cluster size dynamic tree cut method (see dynamicTreeCut::cutreeDynamic()). dissimilarity Relevant dynamic_method = \"hybrid\". Provide dissimilarity data.frame used build tree. show_hierarchy boolean specifying hierarchy clusters identifiable outputs (FALSE default). verbose boolean indicating whether display progress messages. Set FALSE suppress messages. ... Additional arguments passed dynamicTreeCut::cutreeDynamic() customize dynamic tree cut method.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut a hierarchical tree — cut_tree","text":"tree output hclu_hierarclust(), object returned updated content (.e., args clusters). tree hclust object, data.frame containing clusters returned.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cut a hierarchical tree — cut_tree","text":"function supports two main methods cutting tree. First, tree can cut uniform height (specified cut_height determined automatically requested n_clust). Second, dynamic tree cut method (Langfelder et al., 2008) can applied, adapts shape branches tree, cutting varying heights based cluster positions. dynamic tree cut method two variants: tree-based variant (dynamic_method = \"tree\") uses top-approach, relying solely tree order clustered objects. hybrid variant (dynamic_method = \"hybrid\") employs bottom-approach, leveraging tree dissimilarity matrix identify clusters based dissimilarity among sites. approach useful detecting outliers within clusters.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Cut a hierarchical tree — cut_tree","text":"find_h argument ignored dynamic_tree_cut = TRUE, cutting heights determined case.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cut a hierarchical tree — cut_tree","text":"Langfelder P, Zhang B & Horvath S (2008) Defining clusters hierarchical cluster tree: Dynamic Tree Cut package R. BIOINFORMATICS 24, 719-720.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cut a hierarchical tree — cut_tree","text":"Pierre Denelle (pierre.denelle@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut a hierarchical tree — cut_tree","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\", 1:20) colnames(comat) <- paste0(\"Species\", 1:25)  simil <- similarity(comat, metric = \"all\") dissimilarity <- similarity_to_dissimilarity(simil)  # User-defined number of clusters tree1 <- hclu_hierarclust(dissimilarity,                           n_clust = 5) #> Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. #> Error in if (nrow(dist_matrix) > 2) {    subclusters <- stable_binary_split(dist_matrix, method = method,         n_runs = n_runs, binsplit = \"tree\")} else {    subclusters <- list(attr(dist_matrix, \"Labels\")[1], attr(dist_matrix,         \"Labels\")[2])}: argument is of length zero tree2 <- cut_tree(tree1, cut_height = .05) #> Error: object 'tree1' not found tree3 <- cut_tree(tree1, n_clust = c(3, 5, 10)) #> Error: object 'tree1' not found tree4 <- cut_tree(tree1, cut_height = c(.05, .1, .15, .2, .25)) #> Error: object 'tree1' not found tree5 <- cut_tree(tree1, n_clust = c(3, 5, 10), find_h = FALSE) #> Error: object 'tree1' not found  hclust_tree <- tree2$algorithm$final.tree #> Error: object 'tree2' not found clusters_2 <- cut_tree(hclust_tree, n_clust = 10) #> Error: object 'hclust_tree' not found  cluster_dynamic <- cut_tree(tree1, dynamic_tree_cut = TRUE,                             dissimilarity = dissimilarity) #> Error: object 'tree1' not found"},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"function generates data.frame row provides one several dissimilarity metrics pairs sites, based co-occurrence matrix sites rows species columns.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"","code":"dissimilarity(comat, metric = \"Simpson\", formula = NULL, method = \"prodmat\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"comat co-occurrence matrix sites rows species columns. metric character vector single character string specifying metrics compute (see Details). Available options \"abc\", \"ABC\", \"Jaccard\", \"Jaccardturn\", \"Sorensen\", \"Simpson\", \"Bray\", \"Brayturn\", \"Euclidean\". \"\" specified, metrics calculated. Can set NULL formula used. formula character vector single character string specifying custom formula(s) based , b, c, , B, C quantities (see Details). default NULL. method character string specifying method compute abc (see Details). default \"prodmat\", efficient memory-intensive. Alternatively, \"loops\" less memory-intensive slower.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"data.frame additional class bioregion.pairwise, containing one several dissimilarity metrics pairs sites. first two columns represent pairs sites. one column per similarity metric provided metric formula, except abc ABC metrics, stored three separate columns (one letter).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"number species shared pair sites, b species present first site  c species present second site. Jaccard = (b + c) / (+ b + c) Jaccardturn = 2min(b, c) / (+ 2min(b, c)) (Baselga, 2012) Sorensen = (b + c) / (2a + b + c) Simpson = min(b, c) / (+ min(b, c)) abundances data available, Bray-Curtis turnover component can also computed following equation: Bray = (B + C) / (2A + B + C) Brayturn = min(B, C)/(+ min(B, C)) (Baselga, 2013) sum lesser values common species shared pair sites. B C total number specimens counted sites minus . formula can used compute customized metrics terms , b, c, , B, C. example formula = c(\"pmin(b,c) / (+ pmin(b,c))\", \"(B + C) / (2*+ B + C)\") compute Simpson Bray-Curtis dissimilarity metrics, respectively. Note pmin used Simpson formula , b, c, , B C numeric vectors. Euclidean computes Euclidean distance pair sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"Baselga, . (2012) Relationship Species Replacement, Dissimilarity Derived Nestedness, Nestedness. Global Ecology Biogeography, 21(12), 1223–1232. Baselga, . (2013) Separating two components abundance-based dissimilarity: balanced changes abundance vs. abundance gradients. Methods Ecology Evolution, 4(6), 552–557.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"","code":"comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"s\", 1:5) colnames(comat) <- paste0(\"sp\", 1:10)  dissim <- dissimilarity(comat, metric = c(\"abc\", \"ABC\", \"Simpson\", \"Brayturn\"))  dissim <- dissimilarity(comat, metric = \"all\", formula = \"1 - (b + c) / (a + b + c)\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"function converts data.frame dissimilarity metrics (beta diversity) sites similarity metrics.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"","code":"dissimilarity_to_similarity(dissimilarity, include_formula = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(). include_formula boolean indicating whether metrics based custom formula(s) also converted (see Details). default TRUE.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"data.frame additional class bioregion.pairwise, providing similarity metrics pair sites based dissimilarity object.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"behavior function changes depending column names. Columns Site1 Site2 copied identically. columns called , b, c, , B, C also copied identically. columns based formula (argument formula dissimilarity()) original list dissimilarity metrics (argument metrics dissimilarity()) argument include_formula set FALSE, also copied identically. Otherwise going converted like columns (default behavior). column called Euclidean, similarity calculated based following formula: Euclidean similarity = 1 / (1 - Euclidean distance) Otherwise, columns transformed dissimilarity following formula: similarity = 1 - dissimilarity","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"","code":"comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"s\", 1:5) colnames(comat) <- paste0(\"sp\", 1:10)  dissimil <- dissimilarity(comat, metric = \"all\") dissimil #> Data.frame of dissimilarity between sites #>  - Total number of sites:  5  #>  - Total number of species:  10  #>  - Number of rows:  10  #>  - Number of dissimilarity metrics:  7  #>  #>  #>    Site1 Site2   Jaccard Jaccardturn  Sorensen   Simpson      Bray  Brayturn #> 2     s1    s2 0.2000000   0.0000000 0.1111111 0.0000000 0.5068871 0.1516588 #> 3     s1    s3 0.2000000   0.0000000 0.1111111 0.0000000 0.8447894 0.8341232 #> 4     s1    s4 0.2000000   0.0000000 0.1111111 0.0000000 0.6442396 0.5426540 #> 5     s1    s5 0.3000000   0.0000000 0.1764706 0.0000000 0.8426362 0.7227488 #> 8     s2    s3 0.4000000   0.4000000 0.2500000 0.2500000 0.9099338 0.8583333 #> 9     s2    s4 0.2222222   0.2222222 0.1250000 0.1250000 0.5735381 0.4555053 #> 10    s2    s5 0.3333333   0.2500000 0.2000000 0.1428571 0.7011933 0.6961165 #> 14    s3    s4 0.2222222   0.2222222 0.1250000 0.1250000 0.8285214 0.7958333 #> 15    s3    s5 0.3333333   0.2500000 0.2000000 0.1428571 0.4446602 0.1062500 #> 20    s4    s5 0.5000000   0.4444444 0.3333333 0.2857143 0.7546296 0.6802413 #>    Euclidean a b c   A   B   C #> 2   333.8053 8 2 0 358  64 672 #> 3   399.5973 8 2 0  70 352 410 #> 4   310.5978 8 2 0 193 229 470 #> 5   609.6925 7 3 0 117 305 948 #> 8   611.8660 6 2 2  68 962 412 #> 9   485.2061 7 1 1 361 669 302 #> 10  657.9126 6 2 1 313 717 752 #> 14  456.2510 7 1 1  98 382 565 #> 15  395.4605 6 2 1 429  51 636 #> 20  590.0085 5 3 2 212 451 853  similarity <- dissimilarity_to_similarity(dissimil) similarity #> Data.frame of similarity between sites #>  - Total number of sites:  5  #>  - Total number of species:  10  #>  - Number of rows:  10  #>  - Number of similarity metrics:  7  #>  #>  #>    Site1 Site2   Jaccard Jaccardturn  Sorensen   Simpson       Bray  Brayturn #> 2     s1    s2 0.8000000   1.0000000 0.8888889 1.0000000 0.49311295 0.8483412 #> 3     s1    s3 0.8000000   1.0000000 0.8888889 1.0000000 0.15521064 0.1658768 #> 4     s1    s4 0.8000000   1.0000000 0.8888889 1.0000000 0.35576037 0.4573460 #> 5     s1    s5 0.7000000   1.0000000 0.8235294 1.0000000 0.15736382 0.2772512 #> 8     s2    s3 0.6000000   0.6000000 0.7500000 0.7500000 0.09006623 0.1416667 #> 9     s2    s4 0.7777778   0.7777778 0.8750000 0.8750000 0.42646190 0.5444947 #> 10    s2    s5 0.6666667   0.7500000 0.8000000 0.8571429 0.29880668 0.3038835 #> 14    s3    s4 0.7777778   0.7777778 0.8750000 0.8750000 0.17147857 0.2041667 #> 15    s3    s5 0.6666667   0.7500000 0.8000000 0.8571429 0.55533981 0.8937500 #> 20    s4    s5 0.5000000   0.5555556 0.6666667 0.7142857 0.24537037 0.3197587 #>      Euclidean a b c   A   B   C #> 2  0.002986810 8 2 0 358  64 672 #> 3  0.002496272 8 2 0  70 352 410 #> 4  0.003209265 8 2 0 193 229 470 #> 5  0.001637485 7 3 0 117 305 948 #> 8  0.001631678 6 2 2  68 962 412 #> 9  0.002056741 7 1 1 361 669 302 #> 10 0.001517652 6 2 1 313 717 752 #> 14 0.002186983 7 1 1  98 382 565 #> 15 0.002522319 6 2 1 429  51 636 #> 20 0.001692023 5 3 2 212 451 853"},{"path":"https://bioRgeo.github.io/bioregion/reference/exportGDF.html","id":null,"dir":"Reference","previous_headings":"","what":"Export a network to GDF format for Gephi visualization — exportGDF","title":"Export a network to GDF format for Gephi visualization — exportGDF","text":"function exports network (unipartite bipartite) data.frame GDF (Graph Data Format) file format, can directly imported Gephi visualization software. function handles edge data, node attributes, color specifications.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/exportGDF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Export a network to GDF format for Gephi visualization — exportGDF","text":"","code":"exportGDF(   df,   col1 = \"Node1\",   col2 = \"Node2\",   weight = NULL,   bioregions = NULL,   bioregionalization = NULL,   color_column = NULL,   file = \"output.gdf\" )"},{"path":"https://bioRgeo.github.io/bioregion/reference/exportGDF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Export a network to GDF format for Gephi visualization — exportGDF","text":"df two- three-column data.frame row represents edge (interaction) two nodes. first two columns contain node identifiers, optional third column can contain edge weights. col1 character string specifying name first column df containing node identifiers. Defaults \"Node1\". col2 character string specifying name second column df containing node identifiers. Defaults \"Node2\". weight character string specifying name column df containing edge weights. NULL (default), edges unweighted. bioregions optional bioregion.clusters object (typically clustering functions like netclu_greedy()) data.frame containing bioregionalization results. bioregion.clusters object colors (bioregion_colors()) provided, colors bioregion assignments automatically extracted used visualization. Alternatively, data.frame bioregionalization data can provided, row represents node one column containing node identifiers match df. bioregionalization character string positive integer two different uses depending type bioregions: bioregions bioregion.clusters object multiple partitions: specifies partition use. Can either character string partition name (e.g., \"K_3\", \"K_5\") positive integer indicating partition index (e.g., 1 first partition, 2 second). NULL (default), first partition used. bioregions data.frame: specifies name column containing node identifiers match df. Must character string. Defaults first column name specified. color_column character string specifying name column bioregions containing color information hexadecimal format (e.g., \"#FF5733\"). specified, colors converted RGB format Gephi. NULL (default), colors automatically extracted bioregions bioregion.clusters object colors. bioregions plain data.frame, parameter must specified include colors. file character string specifying output file path. Defaults \"output.gdf\".","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/exportGDF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Export a network to GDF format for Gephi visualization — exportGDF","text":"function writes GDF file specified path returns nothing (NULL invisibly). file can directly opened Gephi network visualization analysis.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/exportGDF.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Export a network to GDF format for Gephi visualization — exportGDF","text":"GDF format simple text-based format used Gephi define graph structure. function creates GDF file two main sections: nodedef: Defines nodes attributes (name, label, additional bioregionalization information bioregions) edgedef: Defines edges nodes, optionally weights color_column specified, hexadecimal color codes automatically converted RGB format (e.g., \"#FF5733\" becomes \"255,87,51\") required Gephi's color specification. Attributes automatically typed VARCHAR (text), DOUBLE (numeric), color (color attributes). Important note zero-weight edges: Gephi handle edges weight = 0 properly. weight column specified edges weight = 0 detected, automatically removed exported network, warning issued.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/exportGDF.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Export a network to GDF format for Gephi visualization — exportGDF","text":"Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/exportGDF.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Export a network to GDF format for Gephi visualization — exportGDF","text":"","code":"# Create a simple network net <- data.frame(   Node1 = c(\"A\", \"A\", \"B\", \"C\"),   Node2 = c(\"B\", \"C\", \"C\", \"D\"),   Weight = c(1.5, 2.0, 1.0, 3.5) )  # Export network with weights if (FALSE) { # \\dontrun{ exportGDF(net, weight = \"Weight\", file = \"my_network.gdf\") } # }  # Create bioregionalization data with colors (as data.frame) bioregion_data <- data.frame(   node_id = c(\"A\", \"B\", \"C\", \"D\"),   cluster = c(\"1\", \"2\", \"3\", \"4\"),   node_color = c(\"#FF5733\", \"#33FF57\", \"#3357FF\", \"#FF33F5\") )  # Export network with bioregionalization and colors if (FALSE) { # \\dontrun{ exportGDF(net,            weight = \"Weight\",           bioregions = bioregion_data,           bioregionalization = \"node_id\",           color_column = \"node_color\",           file = \"my_network_with_bioregions.gdf\") } # }  # Using bioregion.clusters object with colors (recommended) if (FALSE) { # \\dontrun{ data(fishmat) net <- similarity(fishmat, metric = \"Simpson\") clust <- netclu_greedy(net) clust_colored <- bioregion_colors(clust)  # Convert to network format net_df <- mat_to_net(fishmat, weight = TRUE)  # Export with automatic colors from clustering - very simple! exportGDF(net_df,            weight = \"weight\",           bioregions = clust_colored,           file = \"my_network_colored.gdf\")  # With multiple partitions, specify which one to use dissim <- similarity_to_dissimilarity(similarity(fishmat, metric = \"Simpson\")) clust_hier <- hclu_hierarclust(dissim, n_clust = c(3, 5, 8)) clust_hier_colored <- bioregion_colors(clust_hier)  # Using partition name exportGDF(net_df,           weight = \"weight\",           bioregions = clust_hier_colored,           bioregionalization = \"K_5\",           file = \"my_network_K5.gdf\")  # Or using partition index (2 = second partition) exportGDF(net_df,           weight = \"weight\",           bioregions = clust_hier_colored,           bioregionalization = 2,           file = \"my_network_partition2.gdf\") } # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Search for an optimal number of clusters in a list of bioregionalizations — find_optimal_n","title":"Search for an optimal number of clusters in a list of bioregionalizations — find_optimal_n","text":"function aims optimize one several criteria set ordered bioregionalizations. typically used find one optimal cluster counts hierarchical trees cut ranges bioregionalizations k-means PAM. Users exercise caution cases (e.g., unordered bioregionalizations unrelated bioregionalizations).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Search for an optimal number of clusters in a list of bioregionalizations — find_optimal_n","text":"","code":"find_optimal_n(   bioregionalizations,   metrics_to_use = \"all\",   criterion = \"elbow\",   step_quantile = 0.99,   step_levels = NULL,   step_round_above = TRUE,   metric_cutoffs = c(0.5, 0.75, 0.9, 0.95, 0.99, 0.999),   n_breakpoints = 1,   plot = TRUE,   verbose = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Search for an optimal number of clusters in a list of bioregionalizations — find_optimal_n","text":"bioregionalizations bioregion.bioregionalization.metrics object (output bioregionalization_metrics()) data.frame first two columns named K (bioregionalization name) n_clusters (number clusters), followed columns numeric evaluation metrics. metrics_to_use character vector single string specifying metrics bioregionalizations calculating optimal clusters. Defaults \"\" (uses metrics). criterion character string specifying criterion identify optimal clusters. Options include \"elbow\", \"increasing_step\", \"decreasing_step\", \"cutoff\", \"breakpoints\", \"min\", \"max\". Defaults \"elbow\". See Details. step_quantile \"increasing_step\" \"decreasing_step\", specifies quantile differences consecutive bioregionalizations cutoff identify significant steps eval_metric. step_levels \"increasing_step\" \"decreasing_step\", specifies number largest steps retain cutoffs. step_round_above boolean indicating whether optimal clusters (TRUE) (FALSE) identified steps. Defaults TRUE. metric_cutoffs criterion = \"cutoff\", specifies cutoffs eval_metric extract cluster counts. n_breakpoints Specifies number breakpoints find curve. Defaults 1. plot boolean indicating plot first eval_metric identified optimal clusters drawn. verbose boolean indicating whether display progress messages. Set FALSE suppress messages.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Search for an optimal number of clusters in a list of bioregionalizations — find_optimal_n","text":"list class bioregion.optimal.n elements: args: Input arguments. evaluation_df: input evaluation data.frame, appended boolean columns optimal cluster counts. optimal_nb_clusters: list optimal cluster counts metric \"metrics_to_use\", based chosen criterion. plot: plot (requested).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Search for an optimal number of clusters in a list of bioregionalizations — find_optimal_n","text":"function explores evaluation metric ~ cluster relationships, applying criteria find optimal cluster counts. Note criteria: Several criteria can return multiple optimal cluster counts, emphasizing hierarchical nested bioregionalizations. approach aligns modern recommendations biological datasets, seen Ficetola et al. (2017)'s reanalysis Holt et al. (2013). Criteria optimal clusters: elbow: Identifies \"elbow\" point evaluation metric curve, incremental improvements diminish. Based method find maximum distance straight line linking curve endpoints. increasing_step decreasing_step: Highlights significant increases decreases metrics analyzing pairwise differences bioregionalizations. Users specify step_quantile step_levels. cutoffs: Derives clusters specified metric cutoffs, e.g., Holt et al. (2013). Adjust cutoffs based spatial scale. breakpoints: Uses segmented regression find breakpoints. Requires specifying n_breakpoints. min & max: Selects clusters minimum maximum metric values.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Search for an optimal number of clusters in a list of bioregionalizations — find_optimal_n","text":"Please note finding optimal number clusters procedure normally requires decisions users, can hardly fully automatized. Users strongly advised read references indicated look guidance choose optimal number(s) clusters. Consider \"optimal\" numbers clusters returned function first approximation best numbers bioregionalization.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Search for an optimal number of clusters in a list of bioregionalizations — find_optimal_n","text":"Holt BG, Lessard J, Borregaard MK, Fritz SA, Araújo MB, Dimitrov D, Fabre P, Graham CH, Graves GR, Jønsson Ka, Nogués-Bravo D, Wang Z, Whittaker RJ, Fjeldså J & Rahbek C (2013) update Wallace's zoogeographic regions world. Science 339, 74-78. Ficetola GF, Mazel F & Thuiller W (2017) Global determinants zoogeographical boundaries. Nature Ecology & Evolution 1, 0089.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Search for an optimal number of clusters in a list of bioregionalizations — find_optimal_n","text":"Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Search for an optimal number of clusters in a list of bioregionalizations — find_optimal_n","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"all\")  # User-defined number of clusters tree <- hclu_hierarclust(dissim,                           optimal_tree_method = \"best\",                           n_clust = 5:10) #> Randomizing the dissimilarity matrix with 100 trials #>  -- range of cophenetic correlation coefficients among trials: 0.787 - 0.7896 #>  #> Final tree has a 0.7896 cophenetic correlation coefficient with the initial dissimilarity matrix #> Determining the cut height to reach 5 groups... #> --> 0.25 #> Determining the cut height to reach 6 groups... #> --> 0.234375 #> Determining the cut height to reach 7 groups... #> --> 0.2265625 #> Determining the cut height to reach 8 groups... #> --> 0.21875 #> Determining the cut height to reach 9 groups... #> --> 0.203125 #> Determining the cut height to reach 10 groups... #> --> 0.1875 tree #> Clustering results for algorithm : hclu_hierarclust  #> \t(hierarchical clustering based on a dissimilarity matrix) #>  - Number of sites:  20  #>  - Name of dissimilarity metric:  Jaccard  #>  - Tree construction method:  average  #>  - Randomization of the dissimilarity matrix:  yes, number of trials 100  #>  - Method to compute the final tree:  Tree with the best cophenetic correlation coefficient  #>  - Cophenetic correlation coefficient:  0.79  #>  - Number of clusters requested by the user:  5  #> Clustering results: #>  - Number of partitions:  6  #>  - Partitions are hierarchical #>  - Number of clusters:  5 6 7 8 9 10  #>  - Height of cut of the hierarchical tree: 0.25 0.234 0.227 0.219 0.203 0.188   a <- bioregionalization_metrics(tree,                                 dissimilarity = dissim,                                 species_col = \"Node2\",                                 site_col = \"Node1\",                                 eval_metric = \"anosim\") #> Computing similarity-based metrics... #>   - anosim OK                                     find_optimal_n(a, criterion = 'increasing_step', plot = FALSE) #> Number of bioregionalizations: 6 #> ...Caveat: be cautious with the interpretation of metric analyses with such a low number of bioregionalizations #> Searching for potential optimal number(s) of clusters based on the increasing_step method #>  - Step method #> Search for an optimal number of clusters: #>  - 6  partition(s) evaluated #>  - Range of clusters explored: from  5  to  10  #>  - Evaluated metric(s):  anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  increasing_step  #>    (step quantile chosen:  0.99  (i.e., only the top 1 %  increase  in evaluation metrics  are used as break points for the number of clusters) #>  - Optimal partition(s) of clusters for each metric: #> anosim - 9"},{"path":"https://bioRgeo.github.io/bioregion/reference/fishdf.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of fish in Europe (data.frame) — fishdf","title":"Spatial distribution of fish in Europe (data.frame) — fishdf","text":"dataset containing abundance 195 species 338 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishdf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of fish in Europe (data.frame) — fishdf","text":"","code":"fishdf"},{"path":"https://bioRgeo.github.io/bioregion/reference/fishdf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of fish in Europe (data.frame) — fishdf","text":"data.frame 2,703 rows 3 columns: Site Unique site identifier (corresponding field ID fishsf) Species Unique species identifier Abundance Species abundance","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of fish in Europe (co-occurrence matrix) — fishmat","title":"Spatial distribution of fish in Europe (co-occurrence matrix) — fishmat","text":"dataset containing abundance 195 species 338 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of fish in Europe (co-occurrence matrix) — fishmat","text":"","code":"fishmat"},{"path":"https://bioRgeo.github.io/bioregion/reference/fishmat.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of fish in Europe (co-occurrence matrix) — fishmat","text":"co-occurrence matrix sites rows species columns. element matrix represents abundance species site.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishsf.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of fish in Europe — fishsf","title":"Spatial distribution of fish in Europe — fishsf","text":"dataset containing geometry 338 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishsf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of fish in Europe — fishsf","text":"","code":"fishsf"},{"path":"https://bioRgeo.github.io/bioregion/reference/fishsf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of fish in Europe — fishsf","text":"ID Unique site identifier geometry Geometry site","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":null,"dir":"Reference","previous_headings":"","what":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"function computes divisive hierarchical clustering dissimilarity (beta-diversity) data.frame, calculates cophenetic correlation coefficient, can generate clusters tree requested user. function implements randomization dissimilarity matrix generate tree, selection method based optimal cophenetic correlation coefficient. Typically, dissimilarity data.frame bioregion.pairwise object obtained running similarity similarity followed similarity_to_dissimilarity.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"","code":"hclu_diana(   dissimilarity,   index = names(dissimilarity)[3],   n_clust = NULL,   cut_height = NULL,   find_h = TRUE,   h_max = 1,   h_min = 0,   verbose = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), remaining column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. n_clust integer vector single integer indicating number clusters obtained hierarchical tree, output bioregionalization_metrics. used concurrently cut_height. cut_height numeric vector indicating height(s) tree cut. used concurrently n_clust. find_h boolean indicating whether cutting height determined requested n_clust. h_max numeric value indicating maximum possible tree height chosen index. h_min numeric value indicating minimum possible height tree chosen index. verbose boolean indicating whether display progress messages. Set FALSE suppress messages.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"list class bioregion.clusters five slots: name: character string containing name algorithm. args: list input arguments provided user. inputs: list describing characteristics clustering process. algorithm: list containing objects associated clustering procedure, original cluster objects. clusters: data.frame containing clustering results.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"function based diana. Chapter 6 Kaufman & Rousseeuw (1990) fully details functioning diana algorithm. find optimal number clusters, see bioregionalization_metrics()","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"Kaufman L & Rousseeuw PJ (2009) Finding groups data: introduction cluster analysis. & Sons. JW (ed.), Finding groups data: introduction cluster analysis.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"all\")  data(\"fishmat\") fishdissim <- dissimilarity(fishmat) fish_diana <- hclu_diana(fishdissim, index = \"Simpson\") #> Output tree has a 0.51 cophenetic correlation coefficient with the initial dissimilarity matrix"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":null,"dir":"Reference","previous_headings":"","what":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"function generates hierarchical tree dissimilarity (beta-diversity) data.frame, calculates cophenetic correlation coefficient, optionally retrieves clusters tree upon user request. function includes randomization process dissimilarity matrix generate tree, two methods available constructing final tree. Typically, dissimilarity data.frame bioregion.pairwise object obtained running similarity, running similarity followed similarity_to_dissimilarity.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"","code":"hclu_hierarclust(   dissimilarity,   index = names(dissimilarity)[3],   method = \"average\",   randomize = TRUE,   n_runs = 100,   keep_trials = \"no\",   optimal_tree_method = \"iterative_consensus_tree\",   n_clust = NULL,   cut_height = NULL,   find_h = TRUE,   h_max = 1,   h_min = 0,   consensus_p = 0.5,   show_hierarchy = FALSE,   verbose = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. method name hierarchical classification method, hclust. one \"ward.D\", \"ward.D2\", \"single\", \"complete\", \"average\" (= UPGMA), \"mcquitty\" (= WPGMA), \"median\" (= WPGMC), \"centroid\" (= UPGMC). randomize boolean indicating whether dissimilarity matrix randomized account order sites dissimilarity matrix. n_runs number trials randomizing dissimilarity matrix. keep_trials character string indicating whether random trial results (including randomized matrix, associated tree metrics tree) stored output object. Possible values \"\" (default), \"\" \"metrics\". Note parameter automatically set \"\" optimal_tree_method = \"iterative_consensus_tree\". optimal_tree_method character string indicating final tree obtained trials. Possible values \"iterative_consensus_tree\" (default), \"best\" \"consensus\". recommend \"iterative_consensus_tree\". See Details. n_clust integer vector single integer indicating number clusters obtained hierarchical tree, output bioregionalization_metrics. parameter used simultaneously cut_height. cut_height numeric vector indicating height(s) tree cut. parameter used simultaneously n_clust. find_h boolean indicating whether height cut found requested n_clust. h_max numeric value indicating maximum possible tree height chosen index. h_min numeric value indicating minimum possible height tree chosen index. consensus_p numeric value (applicable optimal_tree_method = \"consensus\") indicating threshold proportion trees must support region/cluster included final consensus tree. show_hierarchy boolean specifying hierarchy clusters identifiable outputs (FALSE default). argument used tree cut (.e., n_clust cut_height provided). verbose boolean indicating whether display progress messages. Set FALSE suppress messages.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"list class bioregion.clusters five slots: name: character string containing name algorithm. args: list input arguments provided user. inputs: list describing characteristics clustering process. algorithm: list containing objects associated clustering procedure, original cluster objects. clusters: data.frame containing clustering results. algorithm slot, users can find following elements: trials: list containing randomization trials. trial includes dissimilarity matrix randomized site order, associated tree, cophenetic correlation coefficient tree. final.tree: hclust object representing final hierarchical tree used. final.tree.coph.cor: cophenetic correlation coefficient initial dissimilarity matrix final.tree.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"function based hclust. default method hierarchical tree average, .e. UPGMA recommended best method generate tree beta diversity dissimilarity (Kreft & Jetz, 2010). Clusters can obtained two methods: Specifying desired number clusters n_clust Specifying one several heights cut cut_height find optimal number clusters, see bioregionalization_metrics() important pay attention fact order rows input distance matrix influences tree topology explained Dapporto (2013). address , function generates multiple trees randomizing distance matrix. Two methods available obtain final tree: optimal_tree_method = \"iterative_consensus_tree\": Iterative Hierarchical Consensus Tree (IHCT) method reconstructs consensus tree iteratively splitting dataset two subclusters based pairwise dissimilarity sites across n_runs trees based n_runs randomizations distance matrix. iteration, identifies majority membership sites two stable groups across trees, calculates height based selected linkage method (method), enforces monotonic constraints node heights produce coherent tree structure. approach provides robust, hierarchical representation site relationships, balancing cluster stability hierarchical constraints. optimal_tree_method = \"best\": method selects one tree among highest cophenetic correlation coefficient, representing best fit hierarchical structure original distance matrix. optimal_tree_method = \"consensus\": method constructs consensus tree using phylogenetic methods function consensus. using option, must set consensus_p parameter, indicates proportion trees must contain region/cluster included final consensus tree. Consensus trees lack inherent height represent majority structure rather actual hierarchical clustering. assign heights, use non-negative least squares method (nnls.tree) based initial distance matrix, ensuring consensus tree preserves approximate distances among clusters. recommend using \"iterative_consensus_tree\" branches tree always reflect majority decision among many randomized versions distance matrix. method inspired Dapporto et al. (2015), also used majority decision among many randomized versions distance matrix, expands reconstruct entire topology tree iteratively. recommend using basic consensus method many contexts provides inconsistent results, meaningless tree topology low cophenetic correlation coefficient. fast exploration tree, recommend using best method select tree highest cophenetic correlation coefficient among randomized versions distance matrix.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"Kreft H & Jetz W (2010) framework delineating biogeographical regions based species distributions. Journal Biogeography 37, 2029-2053. Dapporto L, Ramazzotti M, Fattorini S, Talavera G, Vila R & Dennis, RLH (2013) Recluster: unbiased clustering procedure beta-diversity turnover. Ecography 36, 1070–1075. Dapporto L, Ciolli G, Dennis RLH, Fox R & Shreeve TG (2015) new procedure extrapolating turnover regionalization mid-small spatial scales, tested British butterflies. Methods Ecology Evolution 6 , 1287–1297.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"Simpson\")  # User-defined number of clusters tree1 <- hclu_hierarclust(dissim,                            n_clust = 5) #> Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. #> Error in if (nrow(dist_matrix) > 2) {    subclusters <- stable_binary_split(dist_matrix, method = method,         n_runs = n_runs, binsplit = \"tree\")} else {    subclusters <- list(attr(dist_matrix, \"Labels\")[1], attr(dist_matrix,         \"Labels\")[2])}: argument is of length zero tree1 #> Error: object 'tree1' not found plot(tree1) #> Error: object 'tree1' not found str(tree1) #> Error: object 'tree1' not found tree1$clusters #> Error: object 'tree1' not found  # User-defined height cut # Only one height tree2 <- hclu_hierarclust(dissim,                            cut_height = .05) #> Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. #> Error in if (nrow(dist_matrix) > 2) {    subclusters <- stable_binary_split(dist_matrix, method = method,         n_runs = n_runs, binsplit = \"tree\")} else {    subclusters <- list(attr(dist_matrix, \"Labels\")[1], attr(dist_matrix,         \"Labels\")[2])}: argument is of length zero tree2 #> Error: object 'tree2' not found tree2$clusters #> Error: object 'tree2' not found  # Multiple heights tree3 <- hclu_hierarclust(dissim,                            cut_height = c(.05, .15, .25)) #> Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. #> Error in if (nrow(dist_matrix) > 2) {    subclusters <- stable_binary_split(dist_matrix, method = method,         n_runs = n_runs, binsplit = \"tree\")} else {    subclusters <- list(attr(dist_matrix, \"Labels\")[1], attr(dist_matrix,         \"Labels\")[2])}: argument is of length zero  tree3$clusters # Mind the order of height cuts: from deep to shallow cuts #> Error: object 'tree3' not found # Info on each partition can be found in table cluster_info tree3$cluster_info #> Error: object 'tree3' not found plot(tree3) #> Error: object 'tree3' not found"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":null,"dir":"Reference","previous_headings":"","what":"OPTICS hierarchical clustering algorithm — hclu_optics","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"function performs semi-hierarchical clustering based dissimilarity using OPTICS algorithm (Ordering Points Identify Clustering Structure).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"","code":"hclu_optics(   dissimilarity,   index = names(dissimilarity)[3],   minPts = NULL,   eps = NULL,   xi = 0.05,   minimum = FALSE,   show_hierarchy = FALSE,   algorithm_in_output = TRUE,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. minPts numeric value specifying minPts argument dbscan. minPts minimum number points required form dense region. default, set natural logarithm number sites dissimilarity. eps numeric value specifying eps argument optics. defines upper limit size epsilon neighborhood. Limiting neighborhood size improves performance little impact ordering long set low. specified (default behavior), largest minPts-distance dataset used, gives result infinity. xi numeric value specifying steepness threshold identify clusters hierarchically using Xi method (see optics). minimum boolean specifying whether hierarchy pruned output retain clusters \"minimal\" level, .e., leaf / non-overlapping clusters. TRUE, argument show_hierarchy set FALSE. show_hierarchy boolean specifying whether hierarchy clusters included output. default, hierarchy visible clusters obtained OPTICS; can visualized plotting OPTICS object. show_hierarchy = TRUE, output cluster data.frame contain additional columns showing hierarchy clusters. algorithm_in_output boolean indicating whether original output dbscan returned output (TRUE default, see Value). ... Additional arguments passed optics() (see optics).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"list class bioregion.clusters five slots: name: character string containing name algorithm. args: list input arguments provided user. inputs: list describing characteristics clustering process. algorithm: list containing objects associated clustering procedure, original cluster objects. clusters: data.frame containing clustering results. algorithm slot, algorithm_in_output = TRUE, users can find output optics.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"OPTICS (Ordering points identify clustering structure) semi-hierarchical clustering algorithm orders points dataset points closest become neighbors, calculates reachability distance point. , clusters can extracted hierarchical manner reachability distance, identifying clusters depending changes relative cluster density. reachability plot explored understand clusters hierarchical nature, running plot output function algorithm_in_output = TRUE: plot(object$algorithm). recommend reading (Hahsler et al., 2019) grasp algorithm, works, clusters mean. extract clusters, use extractXi function based steepness reachability plot (see optics)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"Hahsler M, Piekenbrock M & Doran D (2019) Dbscan: Fast density-based clustering R. Journal Statistical Software 91, 1–30.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"","code":"dissim <- dissimilarity(fishmat, metric = \"all\")    clust1 <- hclu_optics(dissim, index = \"Simpson\") clust1 #> Clustering results for algorithm : hclu_optics  #>  - Number of sites:  338  #> Clustering results: #>  - Number of partitions:  1  #>  - Number of clusters:  4   # Visualize the optics plot (the hierarchy of clusters is illustrated at the # bottom) plot(clust1$algorithm)   # Extract the hierarchy of clusters clust1 <- hclu_optics(dissim, index = \"Simpson\", show_hierarchy = TRUE) clust1 #> Clustering results for algorithm : hclu_optics  #>  - Number of sites:  338  #> Clustering results: #>  - Number of partitions:  2  #>  - Partitions are hierarchical #>  - Number of clusters:  2 4"},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":null,"dir":"Reference","previous_headings":"","what":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"function downloads unzips 'bin' folder required run certain functions bioregion package. also verifies files necessary permissions executed programs. Finally, tests whether binary files running correctly.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"","code":"install_binaries(   binpath = \"tempdir\",   download_only = FALSE,   infomap_version = c(\"2.1.0\", \"2.6.0\", \"2.7.1\", \"2.8.0\"),   verbose = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"binpath character string specifying path folder host bin folder containing binary files (see Details). download_only logical value indicating whether function download bin.zip file perform entire process (see Details). infomap_version character vector single character string specifying Infomap version(s) install. verbose boolean indicating whether display progress messages. Set FALSE suppress messages.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"return value.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"default, binary files installed R's temporary directory (binpath = \"tempdir\"). case, bin folder automatically removed end R session. Alternatively, binary files can installed bioregion package folder (binpath = \"pkgfolder\"). custom folder path can also specified. case, case, download_only can set TRUE, must ensure files required permissions executed programs. cases, PLEASE MAKE SURE update binpath check_install parameters accordingly netclu_infomap, netclu_louvain, netclu_oslom.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"Currently, Infomap versions 2.1.0, 2.6.0, 2.7.1, 2.8.0 available.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a map of bioregions — map_bioregions","title":"Create a map of bioregions — map_bioregions","text":"plot function can used visualize bioregions based bioregion.clusters object combined geometry (sf objects).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a map of bioregions — map_bioregions","text":"","code":"map_bioregions(   clusters,   geometry,   bioregionalization = NULL,   write_clusters = FALSE,   plot = TRUE,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a map of bioregions — map_bioregions","text":"clusters object class bioregion.clusters data.frame. data.frame used, first column represent sites' ID, subsequent column(s) represent clusters. geometry spatial object can handled sf package. first attribute correspond sites' ID (see Details). bioregionalization integer, character, NULL specifying bioregionalization(s) plot. NULL (default), bioregionalizations plotted. integer vector integers, bioregionalization(s) selected column number(s) clusters data.frame (starting 1 ID column). character vector characters, bioregionalization(s) selected name(s) matching column names clusters. write_clusters boolean indicating clusters added geometry. plot boolean indicating plot drawn. ... arguments passed sf::plot().","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a map of bioregions — map_bioregions","text":"One several maps bioregions plot = TRUE geometry additional clusters' attributes write_clusters = TRUE.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a map of bioregions — map_bioregions","text":"clusters geometry site IDs correspond. type (.e., character clusters bioregion.clusters object) sites clusters included sites geometry. Bipartite networks: clusters object bipartite network (containing sites species), site nodes mapped. function automatically filters site nodes using node_type attribute. Colors: clusters object contains colors (added via bioregion_colors()), colors automatically used plotting. Otherwise, default sf color scheme applied.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a map of bioregions — map_bioregions","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a map of bioregions — map_bioregions","text":"","code":"data(fishmat) data(fishdf) # (data.frame version of fishmat) data(fishsf)  net <- similarity(fishmat, metric = \"Simpson\") clu <- netclu_greedy(net) map <- map_bioregions(clu, fishsf, write_clusters = TRUE, plot = FALSE)  # With colors clu_colored <- bioregion_colors(clu) map_bioregions(clu_colored, fishsf, plot = TRUE)   # With bipartite network (sites and species) clu_bip <- netclu_greedy(fishdf, bipartite = TRUE) clu_bip_colored <- bioregion_colors(clu_bip) map_bioregions(clu_bip_colored, fishsf, plot = TRUE)   # With multiple bioregionalizations, plot only specific ones dissim <- dissimilarity(fishmat, metric = \"Simpson\") clu_multi <- hclu_hierarclust(dissim,                               optimal_tree_method = \"best\",                               n_clust = c(2, 4, 10)) #> Randomizing the dissimilarity matrix with 100 trials #>  -- range of cophenetic correlation coefficients among trials: 0.8263 - 0.8586 #>  #> Final tree has a 0.8586 cophenetic correlation coefficient with the initial dissimilarity matrix #> Determining the cut height to reach 2 groups... #> --> 0.9921875 #> Determining the cut height to reach 4 groups... #> --> 0.96875 #> Determining the cut height to reach 10 groups... #> --> 0.765625 map_bioregions(clu_multi, fishsf, bioregionalization = c(1, 3),  plot = TRUE)  # By index  map_bioregions(clu_multi, fishsf, bioregionalization = c(\"K_2\", \"K_4\"),  plot = TRUE)  # By name"},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a data.frame from a contingency table — mat_to_net","title":"Create a data.frame from a contingency table — mat_to_net","text":"function generates two- three-column data.frame, row represents interaction two nodes (e.g., site species) optional third column indicates weight interaction (weight = TRUE). input contingency table, rows representing one set entities (e.g., site) columns representing another set (e.g., species).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a data.frame from a contingency table — mat_to_net","text":"","code":"mat_to_net(   mat,   weight = FALSE,   remove_zeroes = TRUE,   include_diag = TRUE,   include_lower = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a data.frame from a contingency table — mat_to_net","text":"mat contingency table (.e., matrix). weight logical value indicating whether values matrix interpreted interaction weights. remove_zeroes logical value determining whether interactions weight equal 0 excluded output. include_diag logical value indicating whether diagonal (self-interactions) included output. applies square matrices. include_lower logical value indicating whether lower triangular part matrix included output. applies square matrices.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a data.frame from a contingency table — mat_to_net","text":"data.frame row represents interaction two nodes. weight = TRUE, data.frame includes third column representing weight interaction.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a data.frame from a contingency table — mat_to_net","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a data.frame from a contingency table — mat_to_net","text":"","code":"mat <- matrix(sample(1000, 50), 5, 10) rownames(mat) <- paste0(\"Site\", 1:5) colnames(mat) <- paste0(\"Species\", 1:10)  net <- mat_to_net(mat, weight = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a contingency table from a data.frame — net_to_mat","title":"Create a contingency table from a data.frame — net_to_mat","text":"function generates contingency table two- three-column data.frame, row represents interaction two nodes (e.g., site species) optional third column indicates weight interaction (weight = TRUE).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a contingency table from a data.frame — net_to_mat","text":"","code":"net_to_mat(   net,   weight = FALSE,   squared = FALSE,   symmetrical = FALSE,   missing_value = 0 )"},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a contingency table from a data.frame — net_to_mat","text":"net two- three-column data.frame row represents interaction two nodes (e.g., site species), optional third column indicating weight interaction. weight logical value indicating whether weight column considered. squared logical value indicating whether output matrix square (.e., containing nodes rows columns). symmetrical logical value indicating whether resulting matrix symmetrical. applies squared = TRUE. Note different weights associated opposite pairs already present net preserved. missing_value value assign pairs nodes present net. Defaults 0.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a contingency table from a data.frame — net_to_mat","text":"matrix first nodes (first column net) rows second nodes (second column net) columns. squared = TRUE, rows columns number elements, corresponding unique union objects first second columns net. squared = TRUE symmetrical = TRUE, matrix forced symmetrical based upper triangular part matrix.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a contingency table from a data.frame — net_to_mat","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a contingency table from a data.frame — net_to_mat","text":"","code":"net <- data.frame(   Site = c(rep(\"A\", 2), rep(\"B\", 3), rep(\"C\", 2)),   Species = c(\"a\", \"b\", \"a\", \"c\", \"d\", \"b\", \"d\"),   Weight = c(10, 100, 1, 20, 50, 10, 20) )  mat <- net_to_mat(net, weight = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":null,"dir":"Reference","previous_headings":"","what":"Community structure detection in weighted bipartite networks via modularity optimization — netclu_beckett","title":"Community structure detection in weighted bipartite networks via modularity optimization — netclu_beckett","text":"function takes bipartite weighted graph computes modules applying Newman’s modularity measure bipartite weighted version.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Community structure detection in weighted bipartite networks via modularity optimization — netclu_beckett","text":"","code":"netclu_beckett(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   seed = NULL,   forceLPA = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Community structure detection in weighted bipartite networks via modularity optimization — netclu_beckett","text":"net data.frame representing bipartite network first two columns representing undirected links pairs nodes, next column(s) representing weights links. weight boolean indicating whether weights considered two columns (see Note). cut_weight minimal weight value. weight TRUE, links weights strictly lower value considered (0 default). index name number column use weight. default, third column name net used. seed seed random number generator (NULL random default). forceLPA boolean indicating whether even faster pure LPA-algorithm Beckett used. DIRT-LPA (default) less likely get trapped local minimum slightly slower. Defaults FALSE. site_col name number column site nodes (.e., primary nodes). species_col name number column species nodes (.e., feature nodes). return_node_type character indicating types nodes (\"site\", \"species\", \"\") returned output (\"\" default). algorithm_in_output boolean indicating whether original output computeModules returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Community structure detection in weighted bipartite networks via modularity optimization — netclu_beckett","text":"list class bioregion.clusters five slots: name: character containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm_in_output = TRUE, users can find output computeModules algorithm slot.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Community structure detection in weighted bipartite networks via modularity optimization — netclu_beckett","text":"function based modularity optimization algorithm provided Stephen Beckett (Beckett, 2016) implemented bipartite package (computeModules).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Community structure detection in weighted bipartite networks via modularity optimization — netclu_beckett","text":"Beckett's algorithm designed handle weighted bipartite networks. weight = FALSE, weight 1 assigned pair nodes. Ensure site_col species_col arguments correctly identify respective columns site nodes (primary nodes) species nodes (feature nodes). type nodes returned output can selected using return_node_type argument: \"\" include node types, \"site\" return site nodes, \"species\" return species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Community structure detection in weighted bipartite networks via modularity optimization — netclu_beckett","text":"Beckett SJ (2016) Improved community detection weighted bipartite networks. Royal Society Open Science 3, 140536.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Community structure detection in weighted bipartite networks via modularity optimization — netclu_beckett","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Community structure detection in weighted bipartite networks via modularity optimization — netclu_beckett","text":"","code":"net <- data.frame(   Site = c(rep(\"A\", 2), rep(\"B\", 3), rep(\"C\", 2)),   Species = c(\"a\", \"b\", \"a\", \"c\", \"d\", \"b\", \"d\"),   Weight = c(10, 100, 1, 20, 50, 10, 20))  com <- netclu_beckett(net)"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":null,"dir":"Reference","previous_headings":"","what":"Community structure detection via greedy optimization of modularity — netclu_greedy","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"function finds communities (un)weighted undirected network via greedy optimization modularity.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"","code":"netclu_greedy(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (0 default). index name number column use weight. default, third column name net used. bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (site, species ) returned output (return_node_type = \"\" default). algorithm_in_output boolean indicating original output cluster_fast_greedy returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"list class bioregion.clusters five slots: name: character containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find output cluster_fast_greedy.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"function based fast greedy modularity optimization algorithm (Clauset et al., 2004) implemented igraph package (cluster_fast_greedy).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal keep types nodes, sites preserve sites nodes species preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"Clauset , Newman MEJ & Moore C (2004) Finding community structure large networks. Phys. Rev. E 70, 066111.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_greedy(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_greedy(net_bip, bipartite = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":null,"dir":"Reference","previous_headings":"","what":"Infomap community finding — netclu_infomap","title":"Infomap community finding — netclu_infomap","text":"function finds communities (un)weighted (un)directed network based Infomap algorithm (https://github.com/mapequation/infomap).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Infomap community finding — netclu_infomap","text":"","code":"netclu_infomap(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   seed = NULL,   nbmod = 0,   markovtime = 1,   numtrials = 1,   twolevel = FALSE,   show_hierarchy = FALSE,   directed = FALSE,   bipartite_version = FALSE,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   version = \"2.8.0\",   binpath = \"tempdir\",   check_install = TRUE,   path_temp = \"infomap_temp\",   delete_temp = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Infomap community finding — netclu_infomap","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (0 default). index name number column use weight. default, third column name net used. seed seed random number generator (NULL random default). nbmod Penalize solutions differ number (0 default preferred number modules). markovtime Scales link flow change cost moving modules, higher values result fewer modules (1 default). numtrials number trials picking best solution. twolevel boolean indicating algorithm optimize two-level partition network (FALSE default multi-level). show_hierarchy boolean specifying hierarchy community identifiable outputs (FALSE default). directed boolean indicating network directed (column 1 column 2). bipartite_version boolean indicating bipartite version Infomap used (see Note). bipartite boolean indicating network bipartite (see Note). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"site\", \"species\", \"\") returned output (\"\" default). version character indicating Infomap version use. binpath character indicating path bin folder (see install_binaries Details). check_install boolean indicating function check Infomap properly installed (see install_binaries Details). path_temp character indicating path temporary folder (see Details). delete_temp boolean indicating temporary folder removed (see Details).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Infomap community finding — netclu_infomap","text":"list class bioregion.clusters five slots: name: character containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects. clusters: data.frame containing clustering results. algorithm slot, users can find following elements: cmd: command line used run Infomap. version: Infomap version. web: Infomap's GitHub repository.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Infomap community finding — netclu_infomap","text":"Infomap network clustering algorithm based Map equation proposed Rosvall & Bergstrom (2008) finds communities (un)weighted (un)directed networks. function based C++ version Infomap (https://github.com/mapequation/infomap/releases). function needs binary files run. can installed install_binaries. changed default path bin folder running install_binaries PLEASE MAKE SURE set binpath accordingly. use install_binaries change permissions test binary files PLEASE MAKE SURE set check_install accordingly. C++ version Infomap generates temporary folders /files stored path_temp folder (\"infomap_temp\" unique timestamp located bin folder binpath default). temporary folder removed default (delete_temp = TRUE). Several versions Infomap available package. See install_binaries details.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Infomap community finding — netclu_infomap","text":"Infomap designed deal bipartite networks. use functionality, set bipartite_version argument TRUE order approximate two-step random walker (see https://www.mapequation.org/infomap/ information). Note bipartite network can also considered unipartite network (bipartite = TRUE). cases, forget indicate first two columns dedicated site nodes (.e., primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"site\" preserve site nodes, \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Infomap community finding — netclu_infomap","text":"Rosvall M & Bergstrom CT (2008) Maps random walks complex networks reveal community structure. Proceedings National Academy Sciences 105, 1118-1123.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Infomap community finding — netclu_infomap","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Infomap community finding — netclu_infomap","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_infomap(net) #> Infomap 2.8.0 is not installed... Please have a look at https//bioRgeo.github.io/bioregion/articles/a1_install_binary_files.html for more details. #> It should be located in /tmp/RtmpLARmQ8/bin/INFOMAP/2.8.0/"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":null,"dir":"Reference","previous_headings":"","what":"Finding communities based on propagating labels — netclu_labelprop","title":"Finding communities based on propagating labels — netclu_labelprop","text":"function finds communities (un)weighted undirected network based propagating labels.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finding communities based on propagating labels — netclu_labelprop","text":"","code":"netclu_labelprop(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   seed = NULL,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finding communities based on propagating labels — netclu_labelprop","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (0 default). index name number column use weight. default, third column name net used. seed seed random number generator (NULL random default). bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"site\", \"species\", \"\") returned output (\"\" default). algorithm_in_output boolean indicating original output cluster_label_prop returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finding communities based on propagating labels — netclu_labelprop","text":"list class bioregion.clusters five slots: name: character containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm slot, algorithm_in_output = TRUE, users can find \"communities\" object, output cluster_label_prop.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finding communities based on propagating labels — netclu_labelprop","text":"function based propagating labels (Raghavan et al., 2007) implemented igraph package (cluster_label_prop).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Finding communities based on propagating labels — netclu_labelprop","text":"Although algorithm primarily designed deal bipartite networks, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e., primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"site\" preserve site nodes, \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Finding communities based on propagating labels — netclu_labelprop","text":"Raghavan UN, Albert R & Kumara S (2007) Near linear time algorithm detect community structures large-scale networks. Physical Review E 76, 036106.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finding communities based on propagating labels — netclu_labelprop","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finding communities based on propagating labels — netclu_labelprop","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_labelprop(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_labelprop(net_bip, bipartite = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":null,"dir":"Reference","previous_headings":"","what":"Finding communities based on the leading eigenvector of the community matrix — netclu_leadingeigen","title":"Finding communities based on the leading eigenvector of the community matrix — netclu_leadingeigen","text":"function finds communities (un)weighted undirected network based leading eigenvector community matrix.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finding communities based on the leading eigenvector of the community matrix — netclu_leadingeigen","text":"","code":"netclu_leadingeigen(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finding communities based on the leading eigenvector of the community matrix — netclu_leadingeigen","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (0 default). index name number column use weight. default, third column name net used. bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e., primary nodes). species_col name number column species nodes (.e., feature nodes). return_node_type character indicating types nodes (\"site\", \"species\", \"\") returned output (\"\" default). algorithm_in_output boolean indicating original output cluster_leading_eigen returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finding communities based on the leading eigenvector of the community matrix — netclu_leadingeigen","text":"list class bioregion.clusters five slots: name: character containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm slot, algorithm_in_output = TRUE, users can find output cluster_leading_eigen.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finding communities based on the leading eigenvector of the community matrix — netclu_leadingeigen","text":"function based leading eigenvector community matrix (Newman, 2006) implemented igraph package (cluster_leading_eigen).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Finding communities based on the leading eigenvector of the community matrix — netclu_leadingeigen","text":"Although algorithm primarily designed deal bipartite networks, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e., primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"site\" preserve site nodes, \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Finding communities based on the leading eigenvector of the community matrix — netclu_leadingeigen","text":"Newman MEJ (2006) Finding community structure networks using eigenvectors matrices. Physical Review E 74, 036104.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finding communities based on the leading eigenvector of the community matrix — netclu_leadingeigen","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finding communities based on the leading eigenvector of the community matrix — netclu_leadingeigen","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_leadingeigen(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_leadingeigen(net_bip, bipartite = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":null,"dir":"Reference","previous_headings":"","what":"Finding communities using the Leiden algorithm — netclu_leiden","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"function finds communities (un)weighted undirected network based Leiden algorithm Traag, van Eck & Waltman.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"","code":"netclu_leiden(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   seed = NULL,   objective_function = \"CPM\",   resolution_parameter = 1,   beta = 0.01,   n_iterations = 2,   vertex_weights = NULL,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (0 default). index name number column use weight. default, third column name net used. seed random number generator seed (NULL random default). objective_function string indicating objective function use, either Constant Potts Model (\"CPM\") \"modularity\" (\"CPM\" default). resolution_parameter resolution parameter use. Higher resolutions lead smaller communities, lower resolutions lead larger communities. beta parameter affecting randomness Leiden algorithm. affects refinement step algorithm. n_iterations number iterations Leiden algorithm. iteration may improve partition. vertex_weights vertex weights used Leiden algorithm. provided, automatically determined based objective_function. Please see details function understand interpret vertex weights. bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e., primary nodes). species_col name number column species nodes (.e., feature nodes). return_node_type character indicating types nodes (\"site\", \"species\", \"\") returned output (\"\" default). algorithm_in_output boolean indicating original output cluster_leiden returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"list class bioregion.clusters five slots: name: character containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm slot, algorithm_in_output = TRUE, users can find output cluster_leiden.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"function based Leiden algorithm (Traag et al., 2019) implemented igraph package (cluster_leiden).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"Although algorithm primarily designed deal bipartite networks, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e., primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"site\" preserve site nodes, \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"Traag VA, Waltman L & Van Eck NJ (2019) Louvain Leiden: guaranteeing well-connected communities. Scientific reports 9, 5233.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_leiden(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_leiden(net_bip, bipartite = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":null,"dir":"Reference","previous_headings":"","what":"Louvain community finding — netclu_louvain","title":"Louvain community finding — netclu_louvain","text":"function finds communities (un)weighted undirected network based Louvain algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Louvain community finding — netclu_louvain","text":"","code":"netclu_louvain(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   lang = \"igraph\",   resolution = 1,   seed = NULL,   q = 0,   c = 0.5,   k = 1,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   binpath = \"tempdir\",   check_install = TRUE,   path_temp = \"louvain_temp\",   delete_temp = TRUE,   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Louvain community finding — netclu_louvain","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (0 default). index name number column use weight. default, third column name net used. lang string indicating version Louvain used (\"igraph\" \"cpp\", see Details). resolution resolution parameter adjust modularity (1 chosen default, see Details). seed random number generator seed (lang = \"igraph\", NULL random default). q quality function used compute partition graph (modularity chosen default, see Details). c parameter Owsinski-Zadrozny quality function (0 1, 0.5 chosen default). k kappa_min value Shi-Malik quality function (must > 0, 1 chosen default). bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e., primary nodes). species_col name number column species nodes (.e., feature nodes). return_node_type character indicating types nodes (\"site\", \"species\", \"\") returned output (\"\" default). binpath character indicating path bin folder (see install_binaries Details). check_install boolean indicating function check Louvain properly installed (see install_binaries Details). path_temp character indicating path temporary folder (see Details). delete_temp boolean indicating temporary folder removed (see Details). algorithm_in_output boolean indicating original output cluster_louvain returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Louvain community finding — netclu_louvain","text":"list class bioregion.clusters five slots: name: character containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm slot, algorithm_in_output = TRUE, users can find output cluster_louvain lang = \"igraph\" following element lang = \"cpp\": cmd: command line used run Louvain. version: Louvain version. web: Louvain's website.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Louvain community finding — netclu_louvain","text":"Louvain network community detection algorithm proposed (Blondel et al., 2008). function offers two implementations Louvain algorithm (controlled lang parameter): igraph implementation (cluster_louvain) C++ implementation (https://sourceforge.net/projects/louvain/, version 0.3). igraph implementation allows adjustment resolution parameter modularity function (resolution argument) used internally algorithm. Lower values typically yield fewer, larger clusters. original definition modularity recovered resolution parameter set 1 (default). C++ implementation provides several quality functions: q = 0 classical Newman-Girvan criterion (Modularity), q = 1 Zahn-Condorcet criterion, q = 2 Owsinski-Zadrozny criterion (parameterized c), q = 3 Goldberg Density criterion, q = 4 -weighted Condorcet criterion, q = 5 Deviation Indetermination criterion, q = 6 Deviation Uniformity criterion, q = 7 Profile Difference criterion, q = 8 Shi-Malik criterion (parameterized k), q = 9 Balanced Modularity criterion. C++ version based version 0.3 (https://sourceforge.net/projects/louvain/). Binary files required run , can installed install_binaries. changed default path bin folder running install_binaries, PLEASE MAKE SURE set binpath accordingly. use install_binaries change permissions test binary files, PLEASE MAKE SURE set check_install accordingly. C++ version generates temporary folders /files path_temp folder (\"louvain_temp\" unique timestamp located bin folder binpath default). temporary folder removed default (delete_temp = TRUE).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Louvain community finding — netclu_louvain","text":"Although algorithm primarily designed deal bipartite networks, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e., primary nodes) species nodes (.e., feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"site\" preserve site nodes, \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Louvain community finding — netclu_louvain","text":"Blondel VD, Guillaume JL, Lambiotte R & Mech ELJS (2008) Fast unfolding communities large networks. J. Stat. Mech. 10, P10008.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Louvain community finding — netclu_louvain","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Louvain community finding — netclu_louvain","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_louvain(net, lang = \"igraph\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":null,"dir":"Reference","previous_headings":"","what":"OSLOM community finding — netclu_oslom","title":"OSLOM community finding — netclu_oslom","text":"function finds communities (un)weighted (un)directed network based OSLOM algorithm (http://oslom.org/, version 2.4).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OSLOM community finding — netclu_oslom","text":"","code":"netclu_oslom(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   seed = NULL,   reassign = \"no\",   r = 10,   hr = 50,   t = 0.1,   cp = 0.5,   directed = FALSE,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   binpath = \"tempdir\",   check_install = TRUE,   path_temp = \"oslom_temp\",   delete_temp = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OSLOM community finding — netclu_oslom","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (0 default). index Name number column use weight. default, third column name net used. seed random number generator (NULL random default). reassign character indicating nodes belonging several community reassigned method used (see Note). r number runs first hierarchical level (10 default). hr number runs higher hierarchical level (50 default, 0 interested hierarchies). t p-value, default value 0.10. Increase value want modules. cp Kind resolution parameter used decide taking modules union (default value 0.5; bigger value leads bigger clusters). directed boolean indicating network directed (column 1 column 2). bipartite boolean indicating network bipartite (see Details). site_col Name number column site nodes (.e. primary nodes). species_col Name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (site, species, ) returned output (return_node_type = \"\" default). binpath character indicating path bin folder (see install_binaries Details). check_install boolean indicating function check OSLOM properly installed (see install_binaries Details). path_temp character indicating path temporary folder (see Details). delete_temp boolean indicating temporary folder removed (see Details).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"OSLOM community finding — netclu_oslom","text":"list class bioregion.clusters five slots: name: character containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm slot, users can find following elements: cmd: command line used run OSLOM. version: OSLOM version. web: OSLOM's web site.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"OSLOM community finding — netclu_oslom","text":"OSLOM network community detection algorithm proposed Lancichinetti et al. (2011) finds statistically significant (overlapping) communities (un)weighted (un)directed networks. function based 2.4 C++ version OSLOM (http://www.oslom.org/software.htm). function needs files run. can installed install_binaries. changed default path bin folder running install_binaries, PLEASE MAKE SURE set binpath accordingly. use install_binaries change permissions test binary files, PLEASE MAKE SURE set check_install accordingly. C++ version OSLOM generates temporary folders /files stored path_temp folder (folder \"oslom_temp\" unique timestamp located bin folder binpath default). temporary folder removed default (delete_temp = TRUE).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"OSLOM community finding — netclu_oslom","text":"Although algorithm primarily designed deal bipartite networks, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal keep types nodes, sites preserve sites nodes, species preserve species nodes. Since OSLOM potentially returns overlapping communities, propose two methods reassign 'overlapping' nodes: randomly (reassign = \"random\") based closest candidate community (reassign = \"simil\") (weighted networks, case closest candidate community determined average similarity). default, reassign = \"\" information provided. number partitions depend number overlapping modules (three). suffix _semel, _bis, _ter added column names. first partition (_semel) assigns module node. value NA second (_bis) third (_ter) columns indicates overlapping module found node (.e. non-overlapping nodes).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"OSLOM community finding — netclu_oslom","text":"Lancichinetti , Radicchi F, Ramasco JJ & Fortunato S (2011) Finding statistically significant communities networks. PLOS ONE 6, e18961.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"OSLOM community finding — netclu_oslom","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OSLOM community finding — netclu_oslom","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_oslom(net) #> OSLOM is not installed... Please have a look at https://bioRgeo.github.io/bioregion/articles/a1_install_binary_files.html for more details. #> It should be located in /tmp/RtmpLARmQ8/bin/OSLOM/"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Community structure detection via short random walks — netclu_walktrap","title":"Community structure detection via short random walks — netclu_walktrap","text":"function finds communities (un)weighted undirected network via short random walks.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Community structure detection via short random walks — netclu_walktrap","text":"","code":"netclu_walktrap(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   steps = 4,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Community structure detection via short random walks — netclu_walktrap","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (0 default). index Name number column use weight. default, third column name net used. steps length random walks perform. bipartite boolean indicating network bipartite (see Details). site_col Name number column site nodes (.e. primary nodes). species_col Name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (site, species, ) returned output (return_node_type = \"\" default). algorithm_in_output boolean indicating original output cluster_walktrap returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Community structure detection via short random walks — netclu_walktrap","text":"list class bioregion.clusters five slots: name: character containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm slot, algorithm_in_output = TRUE, users can find output cluster_walktrap.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Community structure detection via short random walks — netclu_walktrap","text":"function based random walks (Pons & Latapy, 2005) implemented igraph package (cluster_walktrap).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Community structure detection via short random walks — netclu_walktrap","text":"Although algorithm primarily designed deal bipartite networks, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal keep types nodes, sites preserve site nodes, species preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Community structure detection via short random walks — netclu_walktrap","text":"Pons P & Latapy M (2005) Computing Communities Large Networks Using Random Walks. Yolum , Güngör T, Gürgen F, Özturan C (eds.), Computer Information Sciences - ISCIS 2005, Lecture Notes Computer Science, 284-293.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Community structure detection via short random walks — netclu_walktrap","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Community structure detection via short random walks — netclu_walktrap","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_walktrap(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_walktrap(net_bip, bipartite = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"function performs non-hierarchical clustering using Affinity Propagation algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"","code":"nhclu_affprop(   similarity,   index = names(similarity)[3],   seed = NULL,   p = NA,   q = NA,   maxits = 1000,   convits = 100,   lam = 0.9,   details = FALSE,   nonoise = FALSE,   K = NULL,   prc = NULL,   bimaxit = NULL,   exact = NULL,   algorithm_in_output = TRUE,   verbose = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"similarity output object similarity() dissimilarity_to_similarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain similarity indices. index name number similarity column use. default, third column name similarity used. seed seed random number generator used nonoise = FALSE. p Input preference, can vector specifying individual preferences data point. scalar, value used data points. NA, exemplar preferences initialized based distribution non-Inf values similarity matrix, controlled q. q p = NA, exemplar preferences initialized according distribution non-Inf values similarity matrix. default, median used. value 0 1 specifies sample quantile, q = 0.5 results median. maxits maximum number iterations execute. convits algorithm terminates exemplars change convits iterations. lam damping factor, value range [0.5, 1). Higher values correspond heavier damping, may help prevent oscillations. details TRUE, detailed information algorithm's progress stored output object. nonoise TRUE, disables addition small amount noise similarity object, prevents degenerate cases. K desired number clusters. NULL, function apclusterK called. prc parameter needed K NULL. algorithm stops number clusters deviates less prc percent desired value K. Set 0 enforce exactly K clusters. bimaxit parameter needed K NULL. Specifies maximum number bisection steps perform. warning issued number clusters remains outside desired range. exact flag indicating whether compute initial preference range exactly. algorithm_in_output boolean indicating whether include original output apcluster result. Defaults TRUE. verbose boolean indicating whether display progress messages. Set FALSE suppress messages.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"list class bioregion.clusters five slots: name: character string containing name algorithm. args: list input arguments provided user. inputs: list describing characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm_in_output = TRUE, algorithm slot includes output apcluster.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"function based apcluster package (apcluster).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"Frey B & Dueck D (2007) Clustering Passing Messages Data Points. Science 315, 972-976.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"","code":"comat_1 <- matrix(sample(0:1000, size = 10*12, replace = TRUE, prob = 1/1:1001), 10, 12) rownames(comat_1) <- paste0(\"Site\", 1:10) colnames(comat_1) <- paste0(\"Species\", 1:12) comat_1 <- cbind(comat_1,                  matrix(0, 10, 8,                         dimnames = list(paste0(\"Site\", 1:10),                                         paste0(\"Species\", 13:20))))                                          comat_2 <- matrix(sample(0:1000,                           size = 10*12,                           replace = TRUE,                           prob = 1/1:1001),                    10, 12) rownames(comat_2) <- paste0(\"Site\", 11:20) colnames(comat_2) <- paste0(\"Species\", 9:20) comat_2 <- cbind(matrix(0, 10, 8,                          dimnames = list(paste0(\"Site\", 11:20),                                         paste0(\"Species\", 1:8))),                  comat_2)                   comat <- rbind(comat_1, comat_2)  dissim <- dissimilarity(comat, metric = \"Simpson\") sim <- dissimilarity_to_similarity(dissim)  clust1 <- nhclu_affprop(sim)  clust2 <- nhclu_affprop(sim, q = 1)  # Fixed number of clusters  clust3 <- nhclu_affprop(sim, K = 2, prc = 10, bimaxit = 20, exact = FALSE) #> Trying p = 0.9930872  #>    Number of clusters: 6  #> Trying p = 0.9308716  #>    Number of clusters: 6  #> Trying p = 0.3087157  #>    Number of clusters: 1  #> Trying p = 0.6543579 (bisection step no. 1 ) #>    Number of clusters: 1  #> Trying p = 0.8271789 (bisection step no. 2 ) #>    Number of clusters: 3  #> Trying p = 0.7407684 (bisection step no. 3 ) #>    Number of clusters: 1  #> Trying p = 0.7839737 (bisection step no. 4 ) #>    Number of clusters: 1  #> Trying p = 0.8055763 (bisection step no. 5 ) #>    Number of clusters: 3  #> Trying p = 0.794775 (bisection step no. 6 ) #>    Number of clusters: 2  #>  #> Number of clusters: 2 for p = 0.794775"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-hierarchical clustering: CLARA — nhclu_clara","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"function performs non-hierarchical clustering based dissimilarity using partitioning around medoids, implemented via Clustering Large Applications (CLARA) algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"","code":"nhclu_clara(   dissimilarity,   index = names(dissimilarity)[3],   seed = NULL,   n_clust = c(1, 2, 3),   maxiter = 0,   initializer = \"LAB\",   fasttol = 1,   numsamples = 5,   sampling = 0.25,   independent = FALSE,   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. seed value random number generator (set NULL random initialization default). n_clust integer vector single integer specifying desired number(s) clusters. maxiter integer defining maximum number iterations. initializer character string, either \"BUILD\" (used classic PAM algorithm) \"LAB\" (Linear Approximate BUILD). fasttol positive numeric value defining tolerance fast swapping behavior. Defaults 1. numsamples positive integer specifying number samples draw. sampling positive numeric value defining sampling rate. independent boolean indicating whether previous medoids excluded next sample. Defaults FALSE. algorithm_in_output boolean indicating whether original output fastclara included output. Defaults TRUE (see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"list class bioregion.clusters five components: name: character string containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm_in_output = TRUE, algorithm slot includes output fastclara.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"Based fastkmedoids package (fastclara).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"Schubert E & Rousseeuw PJ (2019) Faster k-Medoids Clustering: Improving PAM, CLARA, CLARANS Algorithms. Similarity Search Applications 11807, 171-187.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"all\")  #clust <- nhclu_clara(dissim, index = \"Simpson\", n_clust = 5)"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-hierarchical clustering: CLARANS — nhclu_clarans","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"function performs non-hierarchical clustering based dissimilarity using partitioning around medoids, implemented via Clustering Large Applications based RANdomized Search (CLARANS) algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"","code":"nhclu_clarans(   dissimilarity,   index = names(dissimilarity)[3],   seed = NULL,   n_clust = c(1, 2, 3),   numlocal = 2,   maxneighbor = 0.025,   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. seed value random number generator (NULL random initialization default). n_clust integer vector single integer specifying desired number(s) clusters. numlocal integer defining number local searches perform. maxneighbor positive numeric value defining maximum number neighbors consider local search. algorithm_in_output boolean indicating whether original output fastclarans included output. Defaults TRUE (see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"list class bioregion.clusters five components: name: character string containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm_in_output = TRUE, algorithm slot includes output fastclarans.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"Based fastkmedoids package (fastclarans).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"Schubert E & Rousseeuw PJ (2019) Faster k-Medoids Clustering: Improving PAM, CLARA, CLARANS Algorithms. Similarity Search Applications 11807, 171-187.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"all\")  #clust <- nhclu_clarans(dissim, index = \"Simpson\", n_clust = 5)"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"function performs non-hierarchical clustering based dissimilarity using Density-Based Spatial Clustering Applications Noise (DBSCAN) algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"","code":"nhclu_dbscan(   dissimilarity,   index = names(dissimilarity)[3],   minPts = NULL,   eps = NULL,   plot = TRUE,   algorithm_in_output = TRUE,   verbose = TRUE,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. minPts numeric vector single numeric value specifying minPts argument dbscan::dbscan(). minPts minimum number points form dense region. default, set natural logarithm number sites dissimilarity. See Details guidance choosing parameter. eps numeric vector single numeric value specifying eps argument dbscan::dbscan(). eps specifies similar points considered part cluster. See Details guidance choosing parameter. plot boolean indicating whether k-nearest neighbor distance plot displayed. algorithm_in_output boolean indicating whether original output dbscan::dbscan included output. Defaults TRUE (see Value). verbose boolean indicating whether display progress messages. Set FALSE suppress messages. ... Additional arguments passed dbscan() (see dbscan::dbscan).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"list class bioregion.clusters five components: name: character string containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm_in_output = TRUE, algorithm slot includes output dbscan::dbscan.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"DBSCAN (Density-Based Spatial Clustering Applications Noise) algorithm clusters points based density neighbors around data point. requires two main arguments: minPts, minimum number points identify core, eps, radius used find neighbors. Choosing minPts: determines many points necessary form cluster. example, minimum number sites expected bioregion? Choose value sufficiently large dataset expectations. Choosing eps: determines similar sites form cluster. eps small, points considered distinct marked noise. eps large, clusters may merge. value eps depends minPts. recommended choose eps identifying knee k-nearest neighbor distance plot. default, function attempts find knee curve automatically, result uncertain. Users inspect graph modify eps accordingly. explore eps values, run function initially without defining eps, review recommendations, adjust needed based clustering results.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"Hahsler M, Piekenbrock M & Doran D (2019) Dbscan: Fast density-based clustering R. Journal Statistical Software, 91(1), 1–30.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"all\")  clust1 <- nhclu_dbscan(dissim, index = \"Simpson\") #> Trying to find a knee in the curve to search for an optimal eps value... #>        NOTE: this automatic identification of the knee may not work properly #>        if the curve has knees and elbows. Please adjust eps manually by #>        inspecting the curve, identifying a knee as follows: #>  #>                            / #>                  curve    / #>               ___________/  <- knee #>   elbow ->   / #>             / #>            /  clust2 <- nhclu_dbscan(dissim, index = \"Simpson\", eps = 0.2)  clust3 <- nhclu_dbscan(dissim, index = \"Simpson\", minPts = c(5, 10, 15, 20),      eps = c(.1, .15, .2, .25, .3))"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-hierarchical clustering: K-means analysis — nhclu_kmeans","title":"Non-hierarchical clustering: K-means analysis — nhclu_kmeans","text":"function performs non-hierarchical clustering based dissimilarity using k-means analysis.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-hierarchical clustering: K-means analysis — nhclu_kmeans","text":"","code":"nhclu_kmeans(   dissimilarity,   index = names(dissimilarity)[3],   seed = NULL,   n_clust = c(1, 2, 3),   iter_max = 10,   nstart = 10,   algorithm = \"Hartigan-Wong\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-hierarchical clustering: K-means analysis — nhclu_kmeans","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. seed value random number generator (NULL random default). n_clust integer vector single integer value specifying requested number(s) clusters. iter_max integer specifying maximum number iterations k-means method (see kmeans). nstart integer specifying many random sets n_clust selected starting points k-means analysis (see kmeans). algorithm character specifying algorithm use k-means (see kmeans). Available options Hartigan-Wong, Lloyd, Forgy, MacQueen. algorithm_in_output boolean indicating whether original output kmeans included output. Defaults TRUE (see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-hierarchical clustering: K-means analysis — nhclu_kmeans","text":"list class bioregion.clusters five components: name: character string containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm_in_output = TRUE, algorithm slot includes output kmeans.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-hierarchical clustering: K-means analysis — nhclu_kmeans","text":"method partitions data k groups sum squares Euclidean distances points assigned cluster centers minimized. K-means applied directly dissimilarity beta-diversity metrics distances Euclidean. Therefore, first requires transforming dissimilarity matrix using Principal Coordinate Analysis (PCoA) pcoa, applying k-means coordinates points PCoA. additional transformation alters initial dissimilarity matrix, partitioning around medoids method (nhclu_pam) preferred.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non-hierarchical clustering: K-means analysis — nhclu_kmeans","text":"Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-hierarchical clustering: K-means analysis — nhclu_kmeans","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  comnet <- mat_to_net(comat)  dissim <- dissimilarity(comat, metric = \"all\")  clust <- nhclu_kmeans(dissim, n_clust = 2:10, index = \"Simpson\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-hierarchical clustering: Partitioning Around Medoids — nhclu_pam","title":"Non-hierarchical clustering: Partitioning Around Medoids — nhclu_pam","text":"function performs non-hierarchical clustering based dissimilarity using partitioning around medoids (PAM).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-hierarchical clustering: Partitioning Around Medoids — nhclu_pam","text":"","code":"nhclu_pam(   dissimilarity,   index = names(dissimilarity)[3],   seed = NULL,   n_clust = c(1, 2, 3),   variant = \"faster\",   nstart = 1,   cluster_only = FALSE,   algorithm_in_output = TRUE,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-hierarchical clustering: Partitioning Around Medoids — nhclu_pam","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. seed value random number generator (NULL random default). n_clust integer vector single integer value specifying requested number(s) clusters. variant character string specifying PAM variant use. Defaults faster. Available options original, o_1, o_2, f_3, f_4, f_5, faster. See pam details. nstart integer specifying number random starts PAM algorithm. Defaults 1 (faster variant). cluster_only boolean specifying whether clustering results returned pam function. Setting TRUE makes function efficient. algorithm_in_output boolean indicating whether original output pam included result. Defaults TRUE (see Value). ... Additional arguments pass pam() (see pam).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-hierarchical clustering: Partitioning Around Medoids — nhclu_pam","text":"list class bioregion.clusters five components: name: character string containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm_in_output = TRUE, algorithm slot includes output pam.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-hierarchical clustering: Partitioning Around Medoids — nhclu_pam","text":"method partitions data chosen number clusters based input dissimilarity matrix. robust k-means minimizes sum dissimilarities cluster centers (medoids) points assigned cluster. contrast, k-means minimizes sum squared Euclidean distances, makes unsuitable dissimilarity matrices based Euclidean distances.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Non-hierarchical clustering: Partitioning Around Medoids — nhclu_pam","text":"Kaufman L & Rousseeuw PJ (2009) Finding groups data: introduction cluster analysis. & Sons. JW (ed.), Finding groups data: introduction cluster analysis.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non-hierarchical clustering: Partitioning Around Medoids — nhclu_pam","text":"Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-hierarchical clustering: Partitioning Around Medoids — nhclu_pam","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  comnet <- mat_to_net(comat) dissim <- dissimilarity(comat, metric = \"all\")  clust <- nhclu_pam(dissim, n_clust = 2:15, index = \"Simpson\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute similarity metrics between sites based on species composition — similarity","title":"Compute similarity metrics between sites based on species composition — similarity","text":"function generates data.frame row provides one several similarity metrics pairs sites, based co-occurrence matrix sites rows species columns.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute similarity metrics between sites based on species composition — similarity","text":"","code":"similarity(comat, metric = \"Simpson\", formula = NULL, method = \"prodmat\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute similarity metrics between sites based on species composition — similarity","text":"comat co-occurrence matrix sites rows species columns. metric character vector single character string specifying metrics compute (see Details). Available options \"abc\", \"ABC\", \"Jaccard\", \"Jaccardturn\", \"Sorensen\", \"Simpson\", \"Bray\", \"Brayturn\", \"Euclidean\". \"\" specified, metrics calculated. Can set NULL formula used. formula character vector single character string specifying custom formula(s) based , b, c, , B, C quantities (see Details). default NULL. method character string specifying method compute abc (see Details). default \"prodmat\", efficient memory-intensive. Alternatively, \"loops\" less memory-intensive slower.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute similarity metrics between sites based on species composition — similarity","text":"data.frame additional class bioregion.pairwise, containing one several similarity metrics pairs sites. first two columns represent pairs sites. one column per similarity metric provided metric formula, except abc ABC metrics, stored three separate columns (one letter).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute similarity metrics between sites based on species composition — similarity","text":"number species shared pair sites, b species present first site c species present second site. Jaccard = 1 - (b + c) / (+ b + c) Jaccardturn = 1 - 2min(b, c) / (+ 2min(b, c)) (Baselga, 2012) Sorensen = 1 - (b + c) / (2a + b + c) Simpson = 1 - min(b, c) / (+ min(b, c)) abundances data available, Bray-Curtis turnover component can also computed following equation: Bray = 1 - (B + C) / (2A + B + C) Brayturn = 1 - min(B, C) / (+ min(B, C)) (Baselga, 2013) sum lesser values common species shared pair sites. B C total number specimens counted sites minus . formula can used compute customized metrics terms , b, c, , B, C. example formula = c(\"1 - pmin(b,c) / (+ pmin(b,c))\", \"1 - (B + C) / (2*+ B + C)\") compute Simpson Bray-Curtis similarity metrics, respectively. Note pmin used Simpson formula , b, c, , B C numeric vectors. Euclidean computes Euclidean similarity pair sites following equation: Euclidean = 1 / (1 + d_ij) d_ij Euclidean distance site site j terms species composition.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute similarity metrics between sites based on species composition — similarity","text":"Baselga (2012) Relationship Species Replacement, Dissimilarity Derived Nestedness, Nestedness. Global Ecology Biogeography 21, 1223–1232. Baselga (2013) Separating two components abundance-based dissimilarity: balanced changes abundance vs. abundance gradients. Methods Ecology Evolution 4, 552–557.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute similarity metrics between sites based on species composition — similarity","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute similarity metrics between sites based on species composition — similarity","text":"","code":"comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"s\", 1:5) colnames(comat) <- paste0(\"sp\", 1:10)  sim <- similarity(comat, metric = c(\"abc\", \"ABC\", \"Simpson\", \"Brayturn\"))  sim <- similarity(comat, metric = \"all\", formula = \"1 - (b + c) / (a + b + c)\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"function converts data.frame similarity metrics sites dissimilarity metrics (beta diversity).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"","code":"similarity_to_dissimilarity(similarity, include_formula = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"similarity output object similarity() dissimilarity_to_similarity(). include_formula boolean indicating whether metrics based custom formula(s) also converted (see Details). default TRUE.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"data.frame additional class bioregion.pairwise, providing dissimilarity metric(s) pair sites based similarity object.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"behavior function changes depending column names. Columns Site1 Site2 copied identically. columns called , b, c, , B, C also copied identically. columns based formula (argument formula similarity()) original list similarity metrics (argument metrics similarity()) argument include_formula set FALSE, also copied identically. Otherwise going converted like columns (default behavior). column called Euclidean, distance calculated based following formula: Euclidean distance = (1 - Euclidean similarity) / Euclidean similarity Otherwise, columns transformed dissimilarity following formula: dissimilarity = 1 - similarity","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"","code":"comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"s\", 1:5) colnames(comat) <- paste0(\"sp\", 1:10)  simil <- similarity(comat, metric = \"all\") simil #> Data.frame of similarity between sites #>  - Total number of sites:  5  #>  - Total number of species:  10  #>  - Number of rows:  10  #>  - Number of similarity metrics:  7  #>  #>  #>    Site1 Site2   Jaccard Jaccardturn  Sorensen Simpson       Bray  Brayturn #> 2     s1    s2 0.7777778   0.7777778 0.8750000   0.875 0.28300259 0.5754386 #> 3     s1    s3 0.7000000   0.7777778 0.8235294   0.875 0.26832845 0.6421053 #> 4     s1    s4 0.7777778   0.7777778 0.8750000   0.875 0.26045884 0.6771930 #> 5     s1    s5 0.8000000   1.0000000 0.8888889   1.000 0.09679666 0.4877193 #> 8     s2    s3 0.7000000   0.7777778 0.8235294   0.875 0.32360471 0.3615561 #> 9     s2    s4 0.7777778   0.7777778 0.8750000   0.875 0.43650410 0.5171625 #> 10    s2    s5 0.8000000   1.0000000 0.8888889   1.000 0.22016758 0.4359268 #> 14    s3    s4 0.7000000   0.7777778 0.8235294   0.875 0.26274165 0.2771084 #> 15    s3    s5 0.9000000   1.0000000 0.9473684   1.000 0.07801418 0.1325301 #> 20    s4    s5 0.8000000   1.0000000 0.8888889   1.000 0.09302326 0.1470343 #>       Euclidean a b c   A    B    C #> 2  0.0023121341 7 1 1 164  121  710 #> 3  0.0017037657 7 1 2 183  102  896 #> 4  0.0013878424 7 1 1 193   92 1004 #> 5  0.0008442520 8 0 2 139  146 2448 #> 8  0.0014929371 7 1 2 316  558  763 #> 9  0.0015926682 7 1 1 452  422  745 #> 10 0.0008229557 8 0 2 381  493 2206 #> 14 0.0011348981 7 2 1 299  780  898 #> 15 0.0007504370 9 0 1 143  936 2444 #> 20 0.0006782972 8 0 2 176 1021 2411  dissimilarity <- similarity_to_dissimilarity(simil) dissimilarity #> Data.frame of dissimilarity between sites #>  - Total number of sites:  5  #>  - Total number of species:  10  #>  - Number of rows:  10  #>  - Number of dissimilarity metrics:  7  #>  #>  #>    Site1 Site2   Jaccard Jaccardturn   Sorensen Simpson      Bray  Brayturn #> 2     s1    s2 0.2222222   0.2222222 0.12500000   0.125 0.7169974 0.4245614 #> 3     s1    s3 0.3000000   0.2222222 0.17647059   0.125 0.7316716 0.3578947 #> 4     s1    s4 0.2222222   0.2222222 0.12500000   0.125 0.7395412 0.3228070 #> 5     s1    s5 0.2000000   0.0000000 0.11111111   0.000 0.9032033 0.5122807 #> 8     s2    s3 0.3000000   0.2222222 0.17647059   0.125 0.6763953 0.6384439 #> 9     s2    s4 0.2222222   0.2222222 0.12500000   0.125 0.5634959 0.4828375 #> 10    s2    s5 0.2000000   0.0000000 0.11111111   0.000 0.7798324 0.5640732 #> 14    s3    s4 0.3000000   0.2222222 0.17647059   0.125 0.7372583 0.7228916 #> 15    s3    s5 0.1000000   0.0000000 0.05263158   0.000 0.9219858 0.8674699 #> 20    s4    s5 0.2000000   0.0000000 0.11111111   0.000 0.9069767 0.8529657 #>    Euclidean a b c   A    B    C #> 2   431.5009 7 1 1 164  121  710 #> 3   585.9351 7 1 2 183  102  896 #> 4   719.5429 7 1 1 193   92 1004 #> 5  1183.4805 8 0 2 139  146 2448 #> 8   668.8206 7 1 2 316  558  763 #> 9   626.8772 7 1 1 452  422  745 #> 10 1214.1322 8 0 2 381  493 2206 #> 14  880.1364 7 2 1 299  780  898 #> 15 1331.5570 9 0 1 143  936 2444 #> 20 1473.2800 8 0 2 176 1021 2411"},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate metrics for sites and species relative to bioregions and chorotypes — site_species_metrics","title":"Calculate metrics for sites and species relative to bioregions and chorotypes — site_species_metrics","text":"function computes metrics quantify species sites relate clusters (bioregions chorotypes). Depending type clustering, metrics can measure species distributed across bioregions (site clusters), sites relate chorotypes (species clusters), .","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate metrics for sites and species relative to bioregions and chorotypes — site_species_metrics","text":"","code":"site_species_metrics(   bioregionalization,   bioregion_metrics = c(\"Specificity\", \"NSpecificity\", \"Fidelity\", \"IndVal\", \"NIndVal\",     \"Rho\"),   bioregionalization_metrics = \"P\",   data_type = \"auto\",   cluster_on = \"site\",   comat,   similarity = NULL,   include_cluster = FALSE,   index = names(similarity)[3],   verbose = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate metrics for sites and species relative to bioregions and chorotypes — site_species_metrics","text":"bioregionalization bioregion.clusters object. bioregion_metrics character vector single character string specifying metrics compute cluster. Available metrics depend type clustering (see arg cluster_on): sites clustered bioregions (default case): species-level metrics include \"Specificity\", \"NSpecificity\", \"Fidelity\", \"IndVal\", \"NIndVal\", \"Rho\", \"CoreTerms\". Site-level metrics include \"Richness\", \"Rich_Endemics\", \"Prop_Endemics\", \"MeanSim\", \"SdSim\". species clustered chorotypes (e.g., bipartite network clustering): site-level metrics include \"Specificity\", \"NSpecificity\", \"Fidelity\", \"IndVal\", \"NIndVal\", \"Rho\", \"CoreTerms\". Use \"\" compute available metrics. See Details metric descriptions. bioregionalization_metrics character vector single character string specifying summary metrics computed across clusters. metrics assess entity (species site) distributed across entire bioregionalization, rather relative individual cluster: \"P\": Participation coefficient measuring evenly species site distributed across clusters (0 = restricted one cluster, 1 = evenly spread). \"Silhouette\": well site fits assigned bioregion compared nearest alternative bioregion (requires similarity data). Use \"\" compute available metrics. data_type character string specifying whether metrics computed based presence/absence (\"occurrence\") abundance values (\"abundance\"). affects Specificity, Fidelity, IndVal, Rho CoreTerms calculated: \"auto\" (default): Automatically detected input data (bioregionalization /comat). \"occurrence\": Metrics based presence/absence . \"abundance\": Metrics weighted abundance values. \"\": Compute versions metrics. cluster_on character string specifying clustered bioregionalization, determines types metrics can computed: \"site\" (default): Sites clustered bioregions. Metrics describe species distributed across bioregions. \"species\": Species clustered chorotypes. Metrics describe site relates chorotypes. available species assigned clusters (e.g., bipartite network clustering). \"\": Compute metrics perspectives. available sites species cluster assignments. comat site-species matrix sites rows species columns. Values can occurrence (1/0) abundance. Required metrics. similarity site--site similarity object similarity() dissimilarity_to_similarity(). Required similarity-based metrics (\"MeanSim\", \"SdSim\", \"Silhouette\"). include_cluster boolean indicating whether add Assigned column output, marking TRUE rows site belongs bioregion evaluated. Useful quickly identifying site's bioregion. Default FALSE. index name number column use similarity. default, third column name similarity used. verbose boolean indicating whether display progress messages. Set FALSE suppress messages.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate metrics for sites and species relative to bioregions and chorotypes — site_species_metrics","text":"list containing one data.frame elements, depending selected metrics clustering type: sites clustered (cluster_on = \"site\"): species_bioregions: Metrics species x bioregion combination (e.g., Specificity, IndVal). One row per species x bioregion pair. species_bioregionalization: Summary metrics species across bioregions (e.g., Participation coefficient). One row per species. site_bioregions: Metrics site x bioregion combination (e.g., MeanSim, Richness). One row per site x bioregion pair. site_bioregionalization: Summary metrics site (e.g., Silhouette). One row per site. species clustered (cluster_on = \"species\"): site_chorotypes: Metrics site x chorotype combination (e.g., Specificity, IndVal). One row per site x chorotype pair. site_chorological: Summary metrics site across chorotypes (e.g., Participation coefficient). One row per site. Note bioregionalization contains multiple partitions (.e., dim(bioregionalization$clusters) > 2), nested list returned, one sublist per partition.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate metrics for sites and species relative to bioregions and chorotypes — site_species_metrics","text":"function computes metrics characterize relationship species, sites, clusters. available metrics depend whether clustered sites (bioregions) species (chorotypes).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"-understanding-the-two-perspectives-","dir":"Reference","previous_headings":"","what":"— 1. Understanding the two perspectives —","title":"Calculate metrics for sites and species relative to bioregions and chorotypes — site_species_metrics","text":"Bioregions clusters sites similar species composition. Chorotypes clusters species similar distributions. general, package designed cluster sites bioregions. However, possible group species clusters. call species clusters 'chorotypes', following conceptual definitions biogeographical literature, avoid confusion calculation metrics. cases, bipartite network clustering, species sites receive clusters. maintain name distinction calculation metrics - remember case BIOREGION IDs = CHOROTYPE IDs. cluster_on argument determines perspective use.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"-metrics-when-sites-are-clustered-cluster-on-site-or-cluster-on-both-","dir":"Reference","previous_headings":"","what":"— 2. Metrics when sites are clustered (cluster_on = \"site\" or cluster_on = \"both\") —","title":"Calculate metrics for sites and species relative to bioregions and chorotypes — site_species_metrics","text":"Species-per-bioregion metrics quantify species distributed across bioregions. metrics derived three core terms (see online vignette visual diagram): n_sb: Number sites bioregion b species s present n_s: Total number sites species s present. n_b: Total number sites bioregion b. Abundance version core terms can also calculated data_type = \"abundance\" (data_type = \"auto\" bioregionalization based abundance): w_sb: Sum abundances species s sites bioregion b. w_s: Total abundance species s. w_b: Total abundance species present sites bioregion b. species-per-bioregion metrics (click metric names access formulas): Specificity: Fraction species' occurrences found given bioregion (De Cáceres & Legendre 2009). value 1 means species occurs bioregion. NSpecificity: Normalized specificity accounts differences bioregion size (De Cáceres & Legendre 2009). Fidelity: Fraction sites bioregion species occurs (De Cáceres & Legendre 2009). value 1 means species present sites bioregion. IndVal: Indicator Value = Specificity × Fidelity (De Cáceres & Legendre 2009). High values identify species restricted frequent within bioregion. NIndVal: Normalized IndVal accounting bioregion size (De Cáceres & Legendre 2009). Rho: Standardized contribution index comparing observed vs. expected co-occurrence random association (Lenormand 2019). CoreTerms: Raw counts (n, n_b, n_s, n_sb) custom calculations. metrics can found output slot species_bioregions. Site-per-bioregion metrics characterize sites relative bioregions: Richness: Number species site. Rich_Endemics: Number species site endemic one bioregion. Prop_Endemics: Proportion endemic species site. MeanSim: Mean similarity site sites bioregion. SdSim: Standard deviation similarity values. metrics can found output slot site_bioregions. Summary metrics across whole bioregionalization: metrics summarize entity (species site) distributed across clusters, rather relation individual cluster. Species-level summary metric: P (Participation): Evenness species distribution across bioregions (Denelle et al. 2020). Found output slot species_bioregionalization. Site-level summary metric: Silhouette: well site fits assigned bioregion vs. nearest alternative (Rousseeuw 1987). Found output slot site_bioregionalization.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"-metrics-when-species-are-clustered-cluster-on-species-or-cluster-on-both-","dir":"Reference","previous_headings":"","what":"— 3. Metrics when species are clustered (cluster_on = \"species\" or cluster_on = \"both\") —","title":"Calculate metrics for sites and species relative to bioregions and chorotypes — site_species_metrics","text":"Site-per-chorotype metrics quantify site relates species clusters (chorotypes). metrics (Specificity, Fidelity, IndVal, etc.) can computed, interpretation inverted. metrics based following core terms: n_gc: Number species belonging chorotype c present site g. n_g: Total number species present site g. n_c: Total number species belonging chorotype c. Abundance version core terms can also calculated data_type = \"abundance\" (data_type = \"auto\" bioregionalization based abundance). interpretation changes, example: Specificity: Fraction site's species belonging chorotype. Fidelity: Fraction chorotype's species present site. IndVal: Indicator value site-chorotype associations. P: Evenness sites across chorotypes","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate metrics for sites and species relative to bioregions and chorotypes — site_species_metrics","text":"data_type = \"auto\", choice occurrence- abundance- based metrics determined automatically input data, message explain choice made. Strict matching entity IDs (site species IDs) bioregionalization comat / similarity required.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate metrics for sites and species relative to bioregions and chorotypes — site_species_metrics","text":"De Cáceres M & Legendre P (2009) Associations species groups sites: indices statistical inference. Ecology 90, 3566–3574. Denelle P, Violle C & Munoz F (2020) Generalist plants competitive functionally similar specialist plants: insights network analyses. Journal Biogeography 47, 1922–-1933. Lenormand M, Papuga G, Argagnon O, Soubeyrand M, Alleaume S & Luque S (2019) Biogeographical network analysis plant species distribution Mediterranean region. Ecology Evolution 9, 237–250. Rousseeuw PJ (1987) Silhouettes: graphical aid interpretation validation cluster analysis. Journal Computational Applied Mathematics 20, 53–65.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate metrics for sites and species relative to bioregions and chorotypes — site_species_metrics","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate metrics for sites and species relative to bioregions and chorotypes — site_species_metrics","text":"","code":"data(fishmat)  fishsim <- similarity(fishmat, metric = \"Jaccard\")  bioregionalization <- hclu_hierarclust(similarity_to_dissimilarity(fishsim),                                        index = \"Jaccard\",                                        method = \"average\",                                        randomize = TRUE,                                        optimal_tree_method = \"best\",                                        n_clust = c(1,2,3),                                        verbose = FALSE)                                       ind <- site_species_metrics(bioregionalization = bioregionalization,                              bioregion_metrics = \"all\",                              bioregionalization_metrics = \"all\",                              data_type = \"auto\",                              cluster_on = \"site\",                              comat = fishmat,                              similarity = fishsim,                              include_cluster = TRUE,                              index = 3,                              verbose = TRUE) #> The bioregionalization is based on occurence data and comat is based on occurence data so occurrence-based metrics will be computed."},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"function extracts subset nodes based type (\"site\" \"species\") bioregion.clusters object, contains types nodes (sites species).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"","code":"site_species_subset(clusters, node_type = \"site\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"clusters object class bioregion.clusters. node_type character string indicating type nodes extract. Possible values \"site\" \"species\". default \"site\".","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"object class bioregion.clusters containing specified node type (sites species).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"bioregion.clusters objects may contain types nodes (sites species). information available $inputs$node_type slot. function allows extract specific type node (either sites species) bioregion.clusters object includes .","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"","code":"net <- data.frame(   Site = c(rep(\"A\", 2), rep(\"B\", 3), rep(\"C\", 2)),   Species = c(\"a\", \"b\", \"a\", \"c\", \"d\", \"b\", \"d\"),   Weight = c(10, 100, 1, 20, 50, 10, 20) )  clusters <- netclu_louvain(net, lang = \"igraph\", bipartite = TRUE)  clusters_sites <- site_species_subset(clusters, node_type = \"site\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/vegedf.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","title":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","text":"dataset containing abundance 3,697 species 715 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegedf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","text":"","code":"vegedf"},{"path":"https://bioRgeo.github.io/bioregion/reference/vegedf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","text":"data.frame 460,878 rows 3 columns: Site Unique site identifier (corresponding field ID vegesp) Species Unique species identifier Abundance Species abundance","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegedf.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","text":"doi:10.1002/ece3.4718","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegemat.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","title":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","text":"dataset containing abundance 3,697 species 715 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegemat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","text":"","code":"vegemat"},{"path":"https://bioRgeo.github.io/bioregion/reference/vegemat.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","text":"co-occurrence matrix sites rows species columns. element matrix represents abundance species site.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegemat.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","text":"doi:10.1002/ece3.4718","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegesf.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","title":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","text":"dataset containing geometry 715 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegesf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","text":"","code":"vegesf"},{"path":"https://bioRgeo.github.io/bioregion/reference/vegesf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","text":"ID Unique site identifier geometry Geometry site","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegesf.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","text":"doi:10.1002/ece3.4718","code":""},{"path":"https://bioRgeo.github.io/bioregion/news/index.html","id":"bioregion-1309000","dir":"Changelog","previous_headings":"","what":"bioregion 1.3.0.9000","title":"bioregion 1.3.0.9000","text":"list changes made development/GitHub version package bioregion 1.3.0 (CRAN release 2026-01-23) next CRAN release.","code":""},{"path":"https://bioRgeo.github.io/bioregion/news/index.html","id":"bioregion-130","dir":"Changelog","previous_headings":"","what":"bioregion 1.3.0","title":"bioregion 1.3.0","text":"list changes made bioregion 1.2.0 (CRAN release 2025-01-31) bioregion 1.3.0 (CRAN release 2026-01-23). Function changes Added inputs$data_type field clustering outputs explicitly track whether original co-occurrence data occurrence-based abundance-based. field automatically determined based algorithm type similarity/dissimilarity metric used. Added inputs$node_type field clustering outputs explicitly indicate whether clustering includes sites sites species. changes include hidden node_type attributes. site_species_metrics() thoroughly reformatted now provides: species-per-bioregions metrics, species--bioregionalization metrics, site-per-chorotypes metrics, site--chorological classification metrics, site-per-bioregions metrics, site--bioregionalization metrics, rigorously defined corresponding vignette. site_species_subset() simplified taking advantage inputs$node_type. Renamed class bioregion.pairwise.metric bioregion.pairwise. Added verbose argument talkative functions allowing users control display progress messages. New features Added export function exportGDF() documentation tests. Added bioregion_colors() provide consistent bioregion color palettes use across multiple visualizations (maps, networks, graphs, etc.). Updated map_bioregions() handle bioregion colors. Added generic function summary() clearer display results. Added bind_pairwise() combine pairwise (dis)similarity objects. Added as_bioregion_pairwise() replace improve upon betapart_to_bioregion(), now deprecated. Added comparison R packages computing dissimilarity metrics tutorial 3 (Pairwise similarity/dissimilarity metrics). Bug fixes Fixed tibble input problem net_to_mat() (issue #11). Fixed problem inputs$pairwise_metric numeric index clustering outputs. Modified keep_trials argument hclu_hierarclust() fixed potential issue randomized matrix storage.","code":""},{"path":"https://bioRgeo.github.io/bioregion/news/index.html","id":"bioregion-120","dir":"Changelog","previous_headings":"","what":"bioregion 1.2.0","title":"bioregion 1.2.0","text":"list changes made bioregion 1.1.1 (CRAN release 2024-04-19) bioregion 1.2.0 (CRAN release 2025-01-31). Added affinity propagation algorithm (nhclu_affprop()). Added new method hclu_hierarclust() construct consensus tree called Iterative Hierarchical Consensus Tree (IHCT). resolves issues related order sites distance matrix builds consensus hierarchical tree meaningful topology. Made many changes functions related hclu_hierarclust() due major update. Updated generic functions provide plot print methods hclu_diana(). Added site_species_metrics() package workflow. Added bioregion_metrics() package workflow. Renamed subset_node() site_species_subset(). Added indices Cz site_species_metrics(). Updated install_binaries(): Archive bin.zip now stored GitHub backed NextCloud. Added Infomap version 2.8.0. Added argument download_only execute download step.   Added check_install argument netclu_infomap(), netclu_louvain(), netclu_oslom(). Added betapart_to_bioregion() package. Added compare_bioregionalizations() package. Added bioregionalization_metrics() package. Updated documentation, vignettes, tests. Modified way seeds generated nhclu_clara() nhclu_clarans().","code":""},{"path":"https://bioRgeo.github.io/bioregion/news/index.html","id":"bioregion-111","dir":"Changelog","previous_headings":"","what":"bioregion 1.1.1","title":"bioregion 1.1.1","text":"list changes made bioregion 1.1.0 (CRAN release 2024-03-19) bioregion 1.1.1 (CRAN release 2024-04-19). Added hierarchy support Louvain (C++). Added seed argument stochastic algorithms (except Louvain C++). Added cut_weight argument netclu_* functions. Changed value sites without clusters 0 NA. Updated automated tests (code coverage > 60%). Standardized controls, inputs, outputs. Fixed bug find_optimal_n() cases partition metrics vary.","code":""},{"path":"https://bioRgeo.github.io/bioregion/news/index.html","id":"bioregion-110","dir":"Changelog","previous_headings":"","what":"bioregion 1.1.0","title":"bioregion 1.1.0","text":"list changes made bioregion 1.0.0 (CRAN release 2023-04-15) bioregion 1.1.0 (CRAN release 2024-03-19). Added resolution parameter igraph Louvain implementation. Added options mat_to_net() exclude diagonal lower triangular matrices using include_diag include_lower. Added function extract subset nodes (sites species) bioregion.clusters objects containing types. Added generic function maintain attributes bioregion.pairwise objects track number sites species. Added new functions: nhclu_clara() nhclu_clarans(). Edited vignettes document new functions. Modified controls bioregion.pairwise objects. Added include_formula argument similarity_dissimilarity_conversion() () select formula metrics. Allowed negative values similarity() Euclidean metric.","code":""},{"path":"https://bioRgeo.github.io/bioregion/news/index.html","id":"bioregion-100","dir":"Changelog","previous_headings":"","what":"bioregion 1.0.0","title":"bioregion 1.0.0","text":"First release CRAN","code":""}]
