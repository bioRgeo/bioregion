[{"path":"https://bioRgeo.github.io/bioregion/TODO.html","id":null,"dir":"","previous_headings":"","what":"bioregion","title":"bioregion","text":"list","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/TODO.html","id":"id_11-améliorations-générales","dir":"","previous_headings":"1. Package V1","what":"1.1 Améliorations générales","title":"bioregion","text":"Points à vérifier -> stop( , call. = FALSE) ->  pour le code dans les docs et ... dans les vignettes -> mettre un point “.” à la fin des phrases dans la documentation (?) -> dir.exists() ou file.exists() (win et lin) -> identifier package folder (lipPaths()) -> controls length (>1) glossaire ? Bien vérifier les packages importés (il y en aura à supprimer…)","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/TODO.html","id":"optics","dir":"","previous_headings":"1. Package V1 > 1.2 Amélirations spécifiques dans des fonctions","what":"optics","title":"bioregion","text":"permettre de lancer plusieurs optics avec différentes valeurs de paramètres ?","code":""},{"path":"https://bioRgeo.github.io/bioregion/TODO.html","id":"clustering_hierarchical","dir":"","previous_headings":"1. Package V1 > 1.2 Amélirations spécifiques dans des fonctions","what":"clustering_hierarchical","title":"bioregion","text":"Ajouter l’algorithme diana ?","code":""},{"path":"https://bioRgeo.github.io/bioregion/TODO.html","id":"partition_metrics","dir":"","previous_headings":"1. Package V1 > 1.2 Amélirations spécifiques dans des fonctions","what":"partition_metrics","title":"bioregion","text":"décider si MARS utile ou pas. Switcher vers segmented? Voir si rounding nécessaire avec la nouvelle version de elbow Implémenter la parallélisation de la recherche de clusters Ajouter d’autres métriques, basées par exemple sur l’abondance","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/TODO.html","id":"id_14-fonctions-génériques","dir":"","previous_headings":"1. Package V1","what":"1.4 Fonctions génériques","title":"bioregion","text":"Envisager une fonction générique plot qui s’adapte au type de cluster pour la classe bioregion.clusters","code":""},{"path":[]},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a1_install_binary_files.html","id":"run-install_binaries","dir":"Articles","previous_headings":"","what":"Run install_binaries()","title":"1. Installation of the binary files","text":"function install_binaries run prior using netclu_infomap, Cpp version netclu_louvain netclu_oslom follows. function two parameters. binpath indicating path folder host ‘bin’ folder containing binary files. default, binary files installed R’s temporary directory (binpath = \"tempdir\"). case ‘bin’ folder automatically removed end R session. Alternatively, binary files can installed bioregion’s package folder (binpath = \"pkgfolder\"). folder can chosen use different folder please sure update binpath argument netclu_infomap, netclu_louvain netclu_oslom accordingly. second parameter infomap_version indicating Infomap version(s) install. Infomap version 2.1.0 2.6.0 available now. installation binary files divided six steps:","code":"install_binaries(binpath = \"tempdir\" , infomap_version = c(\"2.1.0\", \"2.6.0\"))"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a1_install_binary_files.html","id":"known-issues","dir":"Articles","previous_headings":"","what":"Known issues","title":"1. Installation of the binary files","text":"OpenMP versions Infomap require libomp-dev Ubuntu (sudo apt-get install libomp-dev) libomp macOS (install Homebrew run brew install libomp).","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a2_matrix_and_network_formats.html","id":"load-data","dir":"Articles","previous_headings":"","what":"Load data","title":"2. Matrix and network formats","text":"bioregion’s package contains example dataset spatial distribution Mediterranean vegetation. dataset analyzed article contains abundance 3,697 species 715 sites. dataset composed three files, vegedf data.frame 460,878 rows 3 columns (Site, Species Abundance), vegemat co-occurrence matrix containing information gathered matrix 715 rows 3,697 columns, vegesf spatial object containing geometry 715 sites.","code":"data(vegedf) head(vegedf) ##   Site Species Abundance ## 1   35   10017         1 ## 2   35   10024        18 ## 3   35   10034         1 ## 4   35   10035         1 ## 5   35   10056         2 ## 6   35   10080         3 dim(vegedf) ## [1] 460878      3 sum(!duplicated(vegedf[,1])) ## [1] 715 sum(!duplicated(vegedf[,2])) ## [1] 3697 data(vegemat) vegemat[1:10,1:10] ##     Species ## Site 10001 10002 10003 10004 10005 10006 10007 10008 10009 10010 ##   35     0     0     0     0     0     0     0     0     0     0 ##   36     2     0     0     0     0     0     1    12     0     0 ##   37     0     0     0     0     0     0     0     0     0     0 ##   38     0     0     0     0     0     0     0     0     0     0 ##   39     5     0     0     0     0     0     0     2     0     0 ##   84     0     0     0     0     0     0     0     0     0     0 ##   85     3     0     0     0     0     0     1     7     0     0 ##   86     0     0     0     2     0     0     2    22     0     0 ##   87    16     0     0     0     0     0     2    54     0     0 ##   88   228     0     0     0     0     0     0     5     0     0 dim(vegemat) ## [1]  715 3697"},{"path":"https://bioRgeo.github.io/bioregion/articles/a2_matrix_and_network_formats.html","id":"from-matrix-to-network","dir":"Articles","previous_headings":"","what":"From matrix to network","title":"2. Matrix and network formats","text":"function mat_to_net transforms co-occurrence matrix vegemat network represented data.frame (vegedf case). weight = TRUE third column added values contained matrix. line network format, two first columns named Node1 Node2 default. remove_zeroes = TRUE pairs nodes weight equal 0 removed output.","code":"net <- mat_to_net(vegemat, weight = TRUE, remove_zeroes = FALSE) head(net) ##   Node1 Node2 Weight ## 1    35 10001      0 ## 2    35 10002      0 ## 3    35 10003      0 ## 4    35 10004      0 ## 5    35 10005      0 ## 6    35 10006      0 dim(net) ## [1] 2643355       3 net <- mat_to_net(vegemat, weight = TRUE, remove_zeroes = TRUE) head(net) ##    Node1 Node2 Weight ## 17    35 10017      1 ## 24    35 10024     18 ## 34    35 10034      1 ## 35    35 10035      1 ## 56    35 10056      2 ## 80    35 10080      3 dim(net) ## [1] 460878      3"},{"path":"https://bioRgeo.github.io/bioregion/articles/a2_matrix_and_network_formats.html","id":"from-network-to-matrix","dir":"Articles","previous_headings":"","what":"From network to matrix","title":"2. Matrix and network formats","text":"function net_to_mat opposite. transforms network represented two- three-columns data.frame (vegedf) co-occurrence matrix (vegemat case). squared = TRUE squared matrix generated, rownames colnames correspond concatenation without duplicates two first columns data.frame. argument missing_value defines value assign pairs nodes present input network. default value 0 numeric value can used. Finally, squared = TRUE possible get symmetrical matrix output (symmetrical = TRUE). case resulting squared matrix symmetrical, except symmetrical pairs nodes already present input network (35 <-> 36) example .","code":"mat <- net_to_mat(vegedf, weight = TRUE, squared = FALSE, symmetrical = FALSE, missing_value = 0) mat[1:5,1:5] ##    10017 10024 10034 10035 10056 ## 35     1    18     1     1     2 ## 36   252    57    72    19    75 ## 37    66     1    13    23    43 ## 38    17     1     5    89    27 ## 39    17    17    34     3     8 dim(mat) ## [1]  715 3697 mat <- net_to_mat(vegedf, weight = TRUE, squared = TRUE, symmetrical = FALSE, missing_value = 0) mat[1:5,1:5] ##    35 36 37 38 39 ## 35  0  0  0  0  0 ## 36  0  0  0  0  0 ## 37  0  0  0  0  0 ## 38  0  0  0  0  0 ## 39  0  0  0  0  0 dim(mat) ## [1] 4412 4412 temp <- data.frame(Site=c(\"35\",\"36\",\"36\",\"38\",\"39\"), Species=c(\"36\",\"35\",\"37\",\"37\",\"39\"), Abundance=c(1,2,3,4,0)) net <- rbind(temp,vegedf) mat <- net_to_mat(net, weight = TRUE, squared = TRUE, symmetrical = FALSE, missing_value = -1) mat[1:5,1:5] ##    35 36 38 39 37 ## 35 -1  1 -1 -1 -1 ## 36  2 -1 -1 -1  3 ## 38 -1 -1 -1 -1  4 ## 39 -1 -1 -1  0 -1 ## 37 -1 -1 -1 -1 -1 mat <- net_to_mat(net, weight = TRUE, squared = TRUE, symmetrical = TRUE, missing_value = 0) mat[1:5,1:5] ##    35 36 38 39 37 ## 35  0  1  0  0  0 ## 36  2  0  0  0  3 ## 38  0  0  0  0  4 ## 39  0  0  0  0  0 ## 37  0  3  4  0  0"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"compute-dissimilarity-indices-from-input-data","dir":"Articles","previous_headings":"","what":"1. Compute dissimilarity indices from input data","title":"4.1 Hierarchical clustering","text":"initiate hierarchical clustering procedure, need provide pairwise distances sites. pairwise distances sites can obtained running dissimilarity() species-site matrix, presence-absence abundance matrix. example , use vegetation dataset package compute distance metrics. going compute \\(\\beta_{sim}\\) diversity metric, presence-absence dissimilarity index. formula follows: \\(\\beta_{sim} = min(b, c) / (+min(b, c))\\) number species shared sites; b number species occurring first site; c number species occurring second site. typically choose metric bioregionalisation, turnover component Sorensen index (Baselga, 2012) (nutshell, tells us sites different distinct species), less dependence species richness Jaccard turnover (Leprieur & Oikonomou, 2014). Alternatively, given abundance data , also use Bray-Curtis turnover index (Baselga, 2013). choice distance metric important outcome clustering procedure, recommend choose carefully depending research question. default, Simpson index computed, options available metric argument dissimilarity(). Furthermore, users can also write formula compute index wish argument formula, see ?dissimilarity(). now ready start hierarchical clustering procedure object dissim just created. Alternatively, can also use types objects hclu_hierarclust(), distance matrix object (class dist) data.frame crafting (make sure read required format carefully ?hclu_hierarclust).","code":"library(bioregion)  # Work with the vegetation dataset we include in the package data(vegemat)  # This is an abundance matrix where sites are in rows and species in columns vegemat[1:10, 1:10] ##     Species ## Site 10001 10002 10003 10004 10005 10006 10007 10008 10009 10010 ##   35     0     0     0     0     0     0     0     0     0     0 ##   36     2     0     0     0     0     0     1    12     0     0 ##   37     0     0     0     0     0     0     0     0     0     0 ##   38     0     0     0     0     0     0     0     0     0     0 ##   39     5     0     0     0     0     0     0     2     0     0 ##   84     0     0     0     0     0     0     0     0     0     0 ##   85     3     0     0     0     0     0     1     7     0     0 ##   86     0     0     0     2     0     0     2    22     0     0 ##   87    16     0     0     0     0     0     2    54     0     0 ##   88   228     0     0     0     0     0     0     5     0     0 dissim <- dissimilarity(vegemat)  head(dissim) ## Data.frame of dissimilarity between sites ##  - Total number of sites:  7  ##  - Number of rows:  6  ##  - Number of dissimilarity metrics:  1  ##  ##  ##   Site1 Site2    Simpson ## 2    35    36 0.02325581 ## 3    35    37 0.03100775 ## 4    35    38 0.05426357 ## 5    35    39 0.05426357 ## 6    35    84 0.72093023 ## 7    35    85 0.08527132"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"basic-usage","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters","what":"2.1 Basic usage","title":"4.1 Hierarchical clustering","text":"basic usage function follows: functions gives us information proceeds. Notably, talks randomization dissimilarity matrix - important feature hierarchical clustering heavily influenced order sites distance matrix. Therefore, default, function performs randomization order sites distance matrix 30 trials (information randomization section). also tells us among trials selected tree highest cophenetic correlation coefficient, value 0.7. can see type name object console see information: last line tells us clustering procedure incomplete: tree built, cut yet - hence clusters yet object. cut tree, can use function cut_tree(): , asked 4 clusters, algorithm automatically finds height 4 clusters found (h = 0.532). type name object console, gives us results clustering: 1 partition: partition clustering result. cut tree , 1 partition moment 4 clusters: number clusters partition. asked 4, obtained 4, good. Sometimes, however, get number clusters asked - case outcome indicated. **heigh cut 0.532: height cut can obtain 4 clusters tree. can make quick plot partitioned tree  Now, hierarchical tree, cutting (= 1 partition) oversimplifies result tree. cut multiple times? example, make deep, intermediate, shallow cuts tree, likewise Ficetola et al. (2017), allow us see broad- fine-scale relationships among sites tree. can specify, e.g. 4, 10 20 clusters: However, may useful choose heights cut, rather number clusters. , example, cut tree heights 0.4 (shallow cut), 0.5 (intermediate cut) 0.6 (deep cut):  plot easy read large number sites. can rather extract information directly object: result, can read deep cut partition (h = 0.6) clusters, intermediate cut partition (h = 0.5) 7 clusters shallow cut partition (h = 0.4) 18 clusters. next section see default settings chose , see find optimal numbers clusters.","code":"tree1 <- hclu_hierarclust(dissim) ## Randomizing the dissimilarity matrix with 30 trials ##  -- range of cophenetic correlation coefficients among ##                      trials: 0.68 - 0.7 ## Optimal tree has a 0.7 cophenetic correlation coefficient with the initial dissimilarity ##       matrix tree1 ## Clustering results for algorithm : hierarchical_clustering  ##  (hierarchical clustering based on a dissimilarity matrix) ##  - Number of sites:  715  ##  - Name of dissimilarity metric:  Simpson  ##  - Tree construction method:  average  ##  - Randomization of the dissimilarity matrix:  yes, number of trials 30  ##  - Cophenetic correlation coefficient:  0.703  ## Clustering procedure incomplete - no clusters yet # Ask for 4 clusters tree1 <- cut_tree(tree1,                   n_clust = 4) ## Determining the cut height to reach 4 groups... ## Registered S3 method overwritten by 'dendextend': ##   method     from  ##   rev.hclust vegan ## --> 0.5322265625 tree1 ## Clustering results for algorithm : hierarchical_clustering  ##  (hierarchical clustering based on a dissimilarity matrix) ##  - Number of sites:  715  ##  - Name of dissimilarity metric:  Simpson  ##  - Tree construction method:  average  ##  - Randomization of the dissimilarity matrix:  yes, number of trials 30  ##  - Cophenetic correlation coefficient:  0.703  ##  - Number of clusters requested by the user:  4  ## Clustering results: ##  - Number of partitions:  1  ##  - Number of clusters:  4  ##  - Height of cut of the hierarchical tree: 0.532 # We reduced the size of text labels with cex = .2, because there are too many sites plot(tree1, cex = .2) # Ask for 4, 10 and 20 clusters tree1 <- cut_tree(tree1,                   n_clust = c(4, 10, 20)) ## Determining the cut height to reach 4 groups... ## --> 0.5322265625 ## Determining the cut height to reach 10 groups... ## --> 0.462890625 ## Determining the cut height to reach 20 groups... ## --> 0.38671875 plot(tree1, cex = .2) tree1 <- cut_tree(tree1,                   cut_height = c(.4, .5, .6))  plot(tree1, cex = .2) tree1 ## Clustering results for algorithm : hierarchical_clustering  ##  (hierarchical clustering based on a dissimilarity matrix) ##  - Number of sites:  715  ##  - Name of dissimilarity metric:  Simpson  ##  - Tree construction method:  average  ##  - Randomization of the dissimilarity matrix:  yes, number of trials 30  ##  - Cophenetic correlation coefficient:  0.703  ##  - Heights of cut requested by the user:  0.4 0.5 0.6  ## Clustering results: ##  - Number of partitions:  3  ##  - Number of clusters:  2 7 18  ##  - Height of cut of the hierarchical tree: 0.6 0.5 0.4"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"exploring-the-outputs","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters","what":"2.2 Exploring the outputs","title":"4.1 Hierarchical clustering","text":"explore object, can use str() see object structure: show different slots object, can access . example, want access clusters slot, type tree1$clusters. name: name method using args: arguments selected tree inputs: mostly internal use package, provides info nature input data methods algorithm: slot contains detailed information hierarchical clustering. example, can access raw tree , hclust format. access , can type tree1$algorithm$final.tree clusters: data.frame containing partitions. first column sites, columns partitions. cluster_info: small data.frame help link requests clusters data.frame. content varies depending choices; example, case, looks like : shows name partition (corresponding column names tree1$clusters), number clusters partition, cut height initially requested.","code":"str(tree1) ## List of 6 ##  $ name        : chr \"hierarchical_clustering\" ##  $ args        :List of 11 ##   ..$ index              : chr \"Simpson\" ##   ..$ method             : chr \"average\" ##   ..$ randomize          : logi TRUE ##   ..$ n_runs             : num 30 ##   ..$ optimal_tree_method: chr \"best\" ##   ..$ n_clust            : NULL ##   ..$ cut_height         : num [1:3] 0.4 0.5 0.6 ##   ..$ find_h             : logi TRUE ##   ..$ h_max              : num 1 ##   ..$ h_min              : num 0 ##   ..$ dynamic_tree_cut   : logi FALSE ##  $ inputs      :List of 5 ##   ..$ bipartite      : logi FALSE ##   ..$ weight         : logi TRUE ##   ..$ pairwise_metric: logi TRUE ##   ..$ dissimilarity  : logi TRUE ##   ..$ nb_sites       : int 715 ##  $ algorithm   :List of 5 ##   ..$ trials             : chr \"Trials not stored in output\" ##   ..$ final.tree         :List of 7 ##   .. ..- attr(*, \"class\")= chr \"hclust\" ##   ..$ final.tree.coph.cor: num 0.703 ##   ..$ output_n_clust     : Named int [1:3] 2 7 18 ##   .. ..- attr(*, \"names\")= chr [1:3] \"h_0.6\" \"h_0.5\" \"h_0.4\" ##   ..$ output_cut_height  : num [1:3] 0.6 0.5 0.4 ##  $ clusters    :'data.frame':    715 obs. of  4 variables: ##   ..$ ID  : chr [1:715] \"1426\" \"988\" \"807\" \"565\" ... ##   ..$ K_2 : chr [1:715] \"1\" \"2\" \"2\" \"2\" ... ##   ..$ K_7 : chr [1:715] \"1\" \"2\" \"3\" \"2\" ... ##   ..$ K_18: chr [1:715] \"1\" \"2\" \"3\" \"2\" ... ##  $ cluster_info:'data.frame':    3 obs. of  3 variables: ##   ..$ partition_name      : chr [1:3] \"K_2\" \"K_7\" \"K_18\" ##   ..$ n_clust             : int [1:3] 2 7 18 ##   ..$ requested_cut_height: num [1:3] 0.6 0.5 0.4 ##  - attr(*, \"class\")= chr [1:2] \"bioregion.clusters\" \"list\" tree1$cluster_info ##       partition_name n_clust requested_cut_height ## h_0.6            K_2       2                  0.6 ## h_0.5            K_7       7                  0.5 ## h_0.4           K_18      18                  0.4"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"randomization","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters > 2.3 Explanation of the default settings and how to change them","what":"2.3.1 Randomization of the distance matrix","title":"4.1 Hierarchical clustering","text":"order sites distance matrix influences outcome hierarchical tree. Let’s see example:  tree looks like matrix randomized. Now let’s randomize regenerate tree:  See tree looks different? problematic means outcome heavily influenced order sites distance matrix. address issue, randomize distance matrix multiple times (30, default, can probably increase number 100 ) generate associated trees. individual tree, function calculates cophenetic correlation coefficient, correlation initial distance \\(\\beta_{sim}\\) among sites cophenetic distance, distance sites connected tree. tells us representative tree initial distance matrix. next question individual trees? default, package select tree best represents distance matrix; .e., one highest cophenetic correlation coefficient (argument optimal_tree_method = \"best\") Let’s see example higher number runs (n_runs = 100). can also ask function keep individual trees exploration (keep_trials = TRUE). Another approach build consensus tree individual trees, use tree, done example package recluster, yet available bioregion.","code":"# Compute the tree without randomizing the distance matrix tree2 <- hclu_hierarclust(dissim,                           randomize = FALSE) ## Output tree has a 0.7 cophenetic correlation coefficient with the initial ##                    dissimilarity matrix plot(tree2, cex = .1) # This line randomizes the order of rows in the distance matrix dissim_random <- dissim[sample(1:nrow(dissim)), ]  # Recompute the tree tree3 <- hclu_hierarclust(dissim_random,                           randomize = FALSE) ## Output tree has a 0.7 cophenetic correlation coefficient with the initial ##                    dissimilarity matrix plot(tree3, cex = .1) tree1 <- hclu_hierarclust(dissim_random,                           randomize = TRUE,                           n_runs = 100,                           keep_trials = TRUE) ## Randomizing the dissimilarity matrix with 100 trials ##  -- range of cophenetic correlation coefficients among ##                      trials: 0.65 - 0.71 ## Optimal tree has a 0.71 cophenetic correlation coefficient with the initial dissimilarity ##       matrix"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"tree-construction-algorithm","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters > 2.3 Explanation of the default settings and how to change them","what":"2.3.2 Tree construction algorithm","title":"4.1 Hierarchical clustering","text":"default, function uses UPGMA method (Unweighted Pair Group Method Arithmetic Mean) recommended bioregionalisation better performance approaches (Kreft & Jetz, 2010). can change method changing argument method; methods implemented stats::hclust() available.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"cutting-the-tree","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters > 2.3 Explanation of the default settings and how to change them","what":"2.3.3 Cutting the tree","title":"4.1 Hierarchical clustering","text":"three ways cutting tree: Specify expected number clusters: can request specific number clusters (n_clust = 5 example). can also request multiple partitions, number clusters (n_clust = c(5, 10, 15)) example. Note: specify number clusters, function search associated height cut automatically; can disable parameter find_h = FALSE. search h value h_max (default 1) h_min (default 0). arguments can adjusted working indices whose values range 0 1. Specify height cut: can request height want cut tree (e.g., cut_height = 0.5). can also request multiple partitions, cut height (cut_height = c(0.4, 0.5, 0.6)) example. Use dynamic tree cut method: Rather cutting entire tree , alternative approach consists cutting individual branches different heights. method can requested using dynamic_tree_cut = TRUE, based dynamicTreeCut R package.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"optimaln","dir":"Articles","previous_headings":"","what":"3. How to find an optimal number of clusters?","title":"4.1 Hierarchical clustering","text":"Step 1. Build tree hclu_hierarclust() Step 2. Explore range partitions, minimum (e.g., starting 2 clusters) maximum (e.g. \\(n-1\\) clusters \\(n\\) number sites). Step 3. Calculate one several metrics partition, used basis evaluation plots. Step 4. Search one several optimal number(s) clusters using evaluation plots. Different criteria can applied identify optimal number(s) clusters. Step 5. Export optimal partitions cluster object.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"a-practical-example","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters?","what":"3.1 A practical example","title":"4.1 Hierarchical clustering","text":"example compute evaluation metric used Holt et al. (2013), compares total dissimilarity distance matrix (sum distances) inter-cluster dissimilarity (sum distances clusters). choose optimal number clusters elbow evaluation plot.   allergic lines code, also simply recut tree identified optimal number cut-offs cut_tree().","code":"data(vegemat)  # Calculate dissimilarities dissim <- dissimilarity(vegemat)  # Step 1 & 2. Compute the tree and cut it into many different partitions tree4 <- hclu_hierarclust(dissim,                           n_clust = 2:100) ## Randomizing the dissimilarity matrix with 30 trials ##  -- range of cophenetic correlation coefficients among ##                      trials: 0.68 - 0.71 ## Optimal tree has a 0.71 cophenetic correlation coefficient with the initial dissimilarity ##       matrix # Step 3. Calculate the same evaluation metric as Holt et al. 2013 eval_tree4 <- partition_metrics(tree4,                                  dissimilarity = dissim, # Provide distances to compute the metrics                                 eval_metric = \"pc_distance\") ## Computing similarity-based metrics... ##   - pc_distance OK # Step 4. Find the optimal number of clusters opti_n_tree4 <- find_optimal_n(eval_tree4) ## [1] \"pc_distance\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the elbow method ##    * elbow found at: ## pc_distance 18 ## Plotting results... opti_n_tree4 ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  elbow  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 18 # Step 5. Extract the optimal number of clusters # We get the name of the correct partition in the next line K_name <- opti_n_tree4$evaluation_df$K[opti_n_tree4$evaluation_df$optimal_n_pc_distance] # Look at the site-cluster table head(tree4$clusters[, c(\"ID\", K_name)]) ##        ID K_18 ## 505   505    1 ## 1428 1428    2 ## 1182 1182    3 ## 330   330    4 ## 1333 1333    5 ## 537   537    4 # Make a map of the clusters data(vegesf) library(sf) ## Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE map_clusters(tree4$clusters[, c(\"ID\", K_name)],              vegesf)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"evaluation-metrics","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters?","what":"3.2 Evaluation metrics","title":"4.1 Hierarchical clustering","text":"Currently, four evaluation metrics available package: pc_distance: \\(\\sum{-cluster\\beta_{sim }} / \\sum{\\beta_{sim}}\\) metric metric computed Holt et al. (2013). anosim: statistic used Analysis Similarities, suggested Castro-Insua et al. (2018). compares -cluster dissimilarities within-cluster dissimilarities. based based difference mean ranks groups within groups following formula: \\(R=(r_B-r_W)/(N(N-1)/4)\\) \\(r_B\\) \\(r_W\\) average ranks within clusters respectively, \\(N\\) total number sites. avg_endemism: average percentage endemism clusters (Kreft & Jetz, 2010). calculated follows: \\(End_{mean} = \\frac{\\sum_{=1}^K E_i / S_i}{K}\\) \\(E_i\\) number endemic species cluster \\(\\), \\(S_i\\) number species cluster \\(\\), \\(K\\) maximum number clusters. tot_endemism: total endemism across clusters (Kreft & Jetz, 2010). calculated follows: \\(End_{tot} = E / C\\) \\(E\\) total number endemic species (.e., species occurring one cluster) \\(C\\) number non- endemic species. Important note able calculate pc_distance anosim, need provide dissimilarity object argument dissimilarity. addition, able calculate avg_endemism tot_endemism, need provide species-site network argument net. Let’s see practice. Depending size dataset, computing endemism-based metrics can take .","code":"# Calculate pc_distance and anosim partition_metrics(tree4,                    dissimilarity = dissim,                    eval_metric = c(\"pc_distance\", \"anosim\")) ## Computing similarity-based metrics... ##   - pc_distance OK ##   - anosim OK ## Partition metrics: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Requested metric(s):  pc_distance anosim  ##  - Metric summary: ##      pc_distance    anosim ## Min    0.5085031 0.7062941 ## Mean   0.8954095 0.8051543 ## Max    0.9830195 0.8722432 ##  ## Access the data.frame of metrics with your_object$evaluation_df # Calculate avg_endemism and tot_endemism # I have an abundance matrix, I need to convert it into network format first: vegenet <- mat_to_net(vegemat)  partition_metrics(tree4,                    net = vegenet,                    eval_metric = c(\"avg_endemism\", \"tot_endemism\")) ## Computing composition-based metrics... ##   - avg_endemism OK ##   - tot_endemism OK ## Partition metrics: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Requested metric(s):  avg_endemism tot_endemism  ##  - Metric summary: ##      avg_endemism tot_endemism ## Min   0.001106092   0.04598323 ## Mean  0.008628013   0.08150753 ## Max   0.185061583   0.31890722 ##  ## Access the data.frame of metrics with your_object$evaluation_df ## Details of endemism % for each partition are available in  ##         your_object$endemism_results"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"criteria-to-choose-an-optimal-number-of-clusters","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters?","what":"3.2 Criteria to choose an optimal number of clusters","title":"4.1 Hierarchical clustering","text":"Choosing optimal number clusters long-standing issue literature absolute objective answer question. plethora methods proposed years, best approach tackle issue probably compare results multiple approaches make informed decision. bioregion package, implemented several methods suitable bioregionalisation analyses specifically. example, standard criterion used identify optimal number clusters elbow method, default criterion find_optimal_n(). However, recommend moving beyond paradigm single optimal number clusters, likely oversimplification hierarchy tree. recommend considering multiple cuts tree, provide several methods : identifying large steps curve using multiple cutoffs. Additionally, implement approaches using maximum minimum value metrics, , experimentally, using MARS model (multiple adaptive regression splines) identify cutoff points curve. head different methods, compute evaluation metrics store eval_tree4:","code":"vegenet <- mat_to_net(vegemat) eval_tree4 <- partition_metrics(tree4,                                  dissimilarity = dissim,                                  net = vegenet,                                  eval_metric = c(\"pc_distance\", \"anosim\",                                                 \"avg_endemism\", \"tot_endemism\")) ## Computing similarity-based metrics... ##   - pc_distance OK ##   - anosim OK ## Computing composition-based metrics... ##   - avg_endemism OK ##   - tot_endemism OK"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"elbow-method","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.1 Elbow method","title":"4.1 Hierarchical clustering","text":"elbow method consists find ‘elbow’ form metric-cluster relationship. method typically work metrics L-shaped form (typically, pc_distance endemism metrics), metrics (e.g. form anosim necessarily follow L-shape). rationale behind elbow method find cut-metric values stop increase significantly, adding new clusters provide much significant improvement metric. elbow method default method find_optimal_n(). parameters adjust . curve elbow-shaped, may give spurious results.   example , optimal number clusters varies depending metric, minimum 10 maximum 33. final choice depends preferences respect metrics, objectives clustering. Alternatively, two cut-offs used, deep cut-based endemism metrics e.g. value 10, shallow cutoff based pc_distance, 18.","code":"find_optimal_n(eval_tree4) ## [1] \"pc_distance\"  \"anosim\"       \"avg_endemism\" \"tot_endemism\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the elbow method ##    * elbow found at: ## pc_distance 18 ## anosim 33 ## avg_endemism 10 ## tot_endemism 12 ## Warning in find_optimal_n(eval_tree4): The elbow method is likely not suitable ## for the ANOSIM metric. You should rather look for leaps in the curve (see ## criterion = 'increasing_step' or decreasing_step) ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  pc_distance anosim avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  elbow  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 18 ## anosim - 33 ## avg_endemism - 10 ## tot_endemism - 12 ## [1] \"pc_distance\"  \"anosim\"       \"avg_endemism\" \"tot_endemism\""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"step-method","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.2 Step method","title":"4.1 Hierarchical clustering","text":"step method consists identifying largest “steps” metrics, .e., largest increases decreases value metric. , function compute consecutive differences metrics partitions. keep largest positive differences (increasing_step) negative differences (decreasing_step). increasing_step increasing metrics (pc_distance) decreasing_step decreasing metrics (avg_endemism tot_endemism). anosim values can either increase decrease depending dataset, explore ways. default, function select top 1% steps:   However, can adjust two different ways. First, choose number steps select, e.g. select largest 3 steps, use step_levels = 3:  Second, can set quantile steps select, e.g. select 5% largest steps set quantile 0.90 (step_quantile = 0.95):  Finally, one question may arise cluster number select large step happens. example, largest step occurs partitions 4 5 clusters, keep partition 4 clusters, partition 5 clusters? default, function keep partition \\(N + 1\\) (5 clusters example ). can change setting step_round_above = FALSE:","code":"find_optimal_n(eval_tree4,                metrics_to_use = c(\"anosim\", \"pc_distance\"),                criterion = \"increasing_step\") ## [1] \"anosim\"      \"pc_distance\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the increasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  anosim pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  increasing_step  ##    (step quantile chosen:  0.99  (i.e., only the top 1 %  increase  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## anosim - 18 ## pc_distance - 10 find_optimal_n(eval_tree4,                metrics_to_use = c(\"avg_endemism\", \"tot_endemism\"),                criterion = \"decreasing_step\") ## [1] \"avg_endemism\" \"tot_endemism\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the decreasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  decreasing_step  ##    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## avg_endemism - 3 ## tot_endemism - 5 find_optimal_n(eval_tree4,                metrics_to_use = c(\"anosim\", \"pc_distance\"),                criterion = \"increasing_step\",                step_levels = 3) ## [1] \"anosim\"      \"pc_distance\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the increasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  anosim pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  increasing_step  ##    (step quantile chosen:  0.99  (i.e., only the top 1 %  increase  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## anosim - 5 18 33 ## pc_distance - 5 10 18 find_optimal_n(eval_tree4,                metrics_to_use = c(\"anosim\", \"pc_distance\"),                criterion = \"increasing_step\",                step_quantile = 0.95) ## [1] \"anosim\"      \"pc_distance\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the increasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  anosim pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  increasing_step  ##    (step quantile chosen:  0.95  (i.e., only the top 5 %  increase  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## anosim - 5 10 18 33 100 ## pc_distance - 4 5 10 18 72 find_optimal_n(eval_tree4,                metrics_to_use = c(\"avg_endemism\", \"tot_endemism\"),                criterion = \"decreasing_step\",                step_round_above = FALSE) ## [1] \"avg_endemism\" \"tot_endemism\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the decreasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  decreasing_step  ##    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## avg_endemism - 2 ## tot_endemism - 4"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"cutting-at-different-cut-off-values","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.3 Cutting at different cut-off values","title":"4.1 Hierarchical clustering","text":"idea method select specific metric values number clusters used. example, study, Holt et al. (2013) used different cutoffs pc_distance find global biogeographical regions: 0.90, 0.95, 0.99, 0.999. higher value, -diversity explained also clusters . Therefore, choice trade-total -diversity explained number clusters. Eventually, choice values depends different factors: geographical scale study. Global scale study can use large cutoffs like Holt et al. (2013) end reasonable amount clusters, whereas regional local-scale studies less endemism taxa shared among clusters, values high, cutoffs explored, 0.5 0.75. characteristics study increase decrease degree endemism among clusters: dispersal capacities taxonomic group, connectivity/barriers study area, etc. Use lower cutoffs large number widespread species, use higher cutoffs high degrees endemism. use abundance phylogenetic data compute -diversity metrics may give better distinction clusters, turn allow use higher cutoffs. case, regional scale study vegetation, can example use three cutoffs: 0.6 (deep cutoff), 0.8 (intermediate cutoff) 0.9 (shallow cutoff).","code":"find_optimal_n(eval_tree4,                metrics_to_use = \"pc_distance\",                criterion = \"cutoff\",                metric_cutoffs = c(.6, .8, .9)) ## [1] \"pc_distance\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the cutoff method ##  - Cutoff method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  cutoff  ##    --> cutoff(s) chosen:  0.6 0.8 0.9  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 5 18 33"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"cutting-at-the-maximum-or-minimum-metric-value","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.4 Cutting at the maximum or minimum metric value","title":"4.1 Hierarchical clustering","text":"criterion find maximum (criterion = \"max\") minimum (criterion = \"min\") value metric list partitions select associated partition. criterion can interesting case anosim, probably much less useful metrics implemented package.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"finding-break-points-with-a-mars-model-experimental","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.5 Finding break points with a MARS model (experimental)","title":"4.1 Hierarchical clustering","text":"exploratory method may give adequate results. criterion consists applying MARS model formula evaluation metric ~ number clusters. main issue model may require larger number points find appropriate number clusters. example , make 100 cuts tree enough values.  can see anosim, break point meaningful, whereas metrics, mars break points seem lag behind actual break points.","code":"tree5 <- cut_tree(tree4,                   cut_height = seq(0, 0.67, # We cut the tree 1000 times from 0 to 0.67                                     length = 100)) # (0.67 is the maximum height of my tree here)  eval_tree5 <- partition_metrics(tree5,                                  dissimilarity = dissim,                                  net = vegenet,                                  eval_metric = c(\"pc_distance\", \"anosim\",                                                 \"avg_endemism\", \"tot_endemism\")) ## Computing similarity-based metrics... ##   - pc_distance OK ##   - anosim OK ## Computing composition-based metrics... ##   - avg_endemism OK ##   - tot_endemism OK find_optimal_n(eval_tree5,                criterion = \"mars\") ## [1] \"pc_distance\"  \"anosim\"       \"avg_endemism\" \"tot_endemism\" ## Number of partitions: 100 ## Searching for potential optimal number(s) of clusters based on the mars method ## Plotting results... ##    (the red line is the prediction from MARS models) ## Search for an optimal number of clusters: ##  - 100  partition(s) evaluated ##  - Range of clusters explored: from  2  to  701  ##  - Evaluated metric(s):  pc_distance anosim avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  mars  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 119 232 ## anosim - 119 ## avg_endemism - 119 ## tot_endemism - 119"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"optics-as-a-semi-hierarchical-clustering-approach","dir":"Articles","previous_headings":"","what":"4. OPTICS as a semi-hierarchical clustering approach","title":"4.1 Hierarchical clustering","text":"OPTICS (Ordering Points Identify Clustering Structure) semi- hierarchical clustering approach orders points datasets points closest become neighbours, calculates ‘reachability’ distance point extract clusters reachability distance hierarchical manner. However, hierarchical nature clusters directly provided algorithm tree-like output. Hence, users explore ‘reachability plot’ understand hierarchical nature OPTICS clusters, read associated publication grasp method (Hahsler et al., 2019). run optics algorithm, use hclu_optics() function:","code":"data(vegemat)  # Calculate dissimilarities dissim <- dissimilarity(vegemat)  clust1 <- hclu_optics(dissim)  clust1 ## Clustering results for algorithm : optics  ##  - Number of sites:  715  ## Clustering results: ##  - Number of partitions:  1  ##  - Number of clusters:  9"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"dissimilarity-indices","dir":"Articles","previous_headings":"","what":"1. Dissimilarity indices","title":"4.2 Non-hierarchical clustering","text":"Pairwise distances sites can obtained running dissimilarity() site-species matrix. example , use fish dataset package compute distance metrics. going compute \\(\\beta_{sim}\\) diversity metric, presence-absence dissimilarity index. formula follows:\\(\\beta_{sim} = min(b, c) / (+min(b, c))\\) number species shared sites; b number species occurring first site; c number species occurring second site. typically choose metric bioregionalisation, turnover component Sorensen index (Baselga, 2012) (nutshell, tells us sites different distinct species), less dependence species richness Jaccard turnover (Leprieur & Oikonomou, 2014).  choice distance metric important outcome clustering procedure, recommend choose carefully depending research question. default, Simpson index computed, options available metric argument dissimilarity(). Furthermore, users can also write formula compute index wish argument formula, see ?dissimilarity(). now ready start non-hierarchical clustering procedure object dissim just created. Alternatively, can also use types objects distance matrix object (class dist) data.frame crafting (make sure read required format carefully explained help function).","code":"library(\"bioregion\") data(\"fishmat\")  # It is a presence/absence matrix with sites in rows and species in columns fishmat[1:3, 1:3] ##          Abramis brama Alburnus alburnus Barbatula barbatula ## Aa                   1                 1                   1 ## Abula                0                 0                   0 ## Acheloos             0                 0                   0 dissim <- dissimilarity(fishmat, metric = \"Simpson\")  dissim[1:3, ] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  4  ##  - Number of rows:  3  ##  - Number of dissimilarity metrics:  1  ##  ##  ##   Site1    Site2   Simpson ## 2    Aa    Abula 0.3333333 ## 3    Aa Acheloos 1.0000000 ## 4    Aa    Adige 0.7692308"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"centroid-based-clustering","dir":"Articles","previous_headings":"","what":"2. Centroid-based clustering","title":"4.2 Non-hierarchical clustering","text":"core idea algorithms place points cluster central-point closest. central-point can either centroid cluster, .e. mean x y coordinates points belonging cluster, medoid. medoid centrally located data point cluster, words least dissimilar point points cluster. objective minimize sum squared distances points assigned centroids/medoids.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"kmeans","dir":"Articles","previous_headings":"2. Centroid-based clustering","what":"2.1. Kmeans","title":"4.2 Non-hierarchical clustering","text":"K-means clustering perhaps famous method non-hierarchical clustering. uses centroids clusters. algorithm usually follows iterative framework : initialization step creates k centroids random placements. every point, Euclidean distance centroids calculated. point assigned nearest centroid. points assigned centroid form cluster. clusters formed, new centroids cluster calculated taking mean x y coordinates points belonging cluster. re-assignment step calculates new centroids based membership cluster. Steps 2 3 repeated solution converges, .e. centroid positions longer change. Finding optimal solution K-means computationally intensive implementation rely efficient heuristic algorithms quickly converge local optimum. Side-note k-means algorithm can become ‘stuck’ local optima. Repeating clustering algorithm adding noise data can help evaluate robustness solution. function compute K-means clustering bioregion nhclu_kmeans(). illustrate functions works example applied dissimilarity matrix calculated . chose 3 clusters. steps come arguments can tweaked. Specifically, iter_max determines maximum number iterations allowed (.e. many times steps described run) nstart specifies many random sets n_clust selected starting points.  Several heuristic algorithms can also used along K-means method can parameterized using algorithm argument. default, algorithm Hartigan-Wong (Hartigan & Wong (1979)) used. Let’s start setting iter_max nstart 1. asking one iteration , function displays message saying algorithm converge. therefore need increase value iter_max. Like functions bioregion package, class object specific package (bioregion.clusters) contains several parts. clusters assigned site accessible $clusters part output: , see 145 sites assigned cluster 1, 96 cluster 2 97 cluster 3. assignment can change depending two main arguments functions, iter_max nstart. shown , distribution sites among three clusters appears quite homogeneous three examples discrepancies emerge. Overall, increasing iter_max nstart increases chances convergence algorithm also increases computation time.","code":"ex_kmeans <- nhclu_kmeans(dissim, index = \"Simpson\", n_clust = 3, iter_max = 1,                           nstart = 1, algorithm = \"Hartigan-Wong\") ex_kmeans <- nhclu_kmeans(dissim, index = \"Simpson\", n_clust = 3, iter_max = 3,                           nstart = 1, algorithm = \"Hartigan-Wong\") ex_kmeans$clusters[1:3, ] ##                ID K_3 ## Aa             Aa   1 ## Abula       Abula   3 ## Acheloos Acheloos   2 table(ex_kmeans$clusters$K_3) ##  ##   1   2   3  ## 145  96  97 ex_kmeans2 <- nhclu_kmeans(dissim, index = \"Simpson\", n_clust = 3,                            iter_max = 100, nstart = 1,                            algorithm = \"Hartigan-Wong\")  ex_kmeans3 <- nhclu_kmeans(dissim, index = \"Simpson\", n_clust = 3,                            iter_max = 3, nstart = 100,                            algorithm = \"Hartigan-Wong\") table(ex_kmeans$clusters$K_3, ex_kmeans2$clusters$K_3) ##     ##       1   2   3 ##   1  14 131   0 ##   2   0   0  96 ##   3  97   0   0 table(ex_kmeans$clusters$K_3, ex_kmeans3$clusters$K_3) ##     ##       1   2   3 ##   1 131  14   0 ##   2   0   0  96 ##   3   0  97   0"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"section22","dir":"Articles","previous_headings":"2. Centroid-based clustering","what":"2.2. K-medoids","title":"4.2 Non-hierarchical clustering","text":"Instead using mean cluster, medoid can also used partition data points. comparison centroid used K-means, medoid less sensitive outliers data. partitions can also use types distances rely Euclidean distance . Several heuristics exist solve K-medoids problem, famous ones Partition Around Medoids (PAM), extensions CLARA CLARANS.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"partitioning-around-medoids-pam","dir":"Articles","previous_headings":"2. Centroid-based clustering > 2.2. K-medoids","what":"2.2.1. Partitioning Around Medoids (PAM)","title":"4.2 Non-hierarchical clustering","text":"PAM fast heuristic find solution k-medoids problem. k clusters, decomposes following steps:  1. Randomly pick k points initial medoids Assign point nearest medoid x Calculate objective function (sum dissimilarities points nearest medoids) Randomly select point y Swap x y swap reduces objective function Repeat 3-6 change nhclu_pam() function, several arguments tweak. number clusters n_clust defined well number starting positions medoids nstart. Several variants PAM algorithm available can changed argument variant (see cluster::pam() details). 2 clusters, see 172 sites assigned cluster 1 166 cluster 2.","code":"ex_pam <- nhclu_pam(dissim, index = \"Simpson\", n_clust = 2:25, nstart = 1,                     variant = \"faster\", cluster_only = FALSE) table(ex_pam$clusters$K_2) ##  ##   1   2  ## 172 166"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"density-based-clustering","dir":"Articles","previous_headings":"","what":"3. Density-based clustering","title":"4.2 Non-hierarchical clustering","text":"Density-based clustering another type non-hierarchical clustering. connects areas high density clusters. allows arbitrary-shaped distributions long dense areas can connected. algorithms can however difficulty data varying densities high dimensions.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"dbscan","dir":"Articles","previous_headings":"3. Density-based clustering","what":"3.1. DBSCAN","title":"4.2 Non-hierarchical clustering","text":"Density-based Spatial Clustering Applications Noise (DBSCAN) (Hahsler et al. (2019)) famous density-based clustering approach.  operates locating points dataset surrounded significant number points. points regarded part dense zone, algorithm next attempt extend region encompass cluster’s points. DBSCAN uses two following parameters: Epsilon (eps): maximum distance two points considered neighboring points (belonging cluster). Minimum Points (minPts): minimum number neighboring points given point needs considered core data point. includes point . example, minimum number points set 4, given point needs 3 neighboring data points considered core data point. minimum number points meet epsilon distance requirement considered cluster. set two parameters, algorithm works like : Decide value eps minPts. point: Calculate distance points. distance less equal eps mark point neighbor x. point gets neighboring count greater equal minPts, mark core point visited. core point, already assigned cluster create new cluster. Recursively find neighboring points assign cluster core point. Continue steps unvisited points covered. algorithm can called function nhclu_dbscan(). user define two arguments presented , minPts eps, function provide knee curve helping search optimal eps value.  , see can set eps 1. set parameters, get one cluster. decrease eps value increase minPts, can get clusters.","code":"ex_dbscan <- nhclu_dbscan(dissim, index = \"Simpson\", minPts = NULL, eps = NULL,                           plot = TRUE) ## Trying to find a knee in the curve to search for an optimal eps value... ##        NOTE: this automatic identification of the knee may not work properly ##        if the curve has knees and elbows. Please adjust eps manually by ##        inspecting the curve, identifying a knee as follows: ##  ##                            / ##                  curve    / ##               ___________/  <- knee ##   elbow ->   / ##             / ##            / ex_dbscan2 <- nhclu_dbscan(dissim, index = \"Simpson\", minPts = NULL, eps = 1,                            plot = FALSE) table(ex_dbscan2$clusters$K_1) ##  ##   1  ## 338 ex_dbscan3 <- nhclu_dbscan(dissim, index = \"Simpson\", minPts = 4, eps = 0.5,                            plot = FALSE)  table(ex_dbscan3$clusters$K_2) ##  ##   0   1  ##   4 334"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"section4","dir":"Articles","previous_headings":"","what":"4. Optimal number of clusters","title":"4.2 Non-hierarchical clustering","text":"Previous methods help determining optimal number bioregions structuring site-species matrix. purpose, can combine functions partition_metrics() find_optimal(). partition_metrics() calcultes several metrics based previous clustering attempts. *Note two metrics tot_endemism avg_endemism, also need provide site-species matrix. partition_metrics() function calculated partitioning metrics, can call find_optimal() get optimal number clusters.  Based metric selected, optimal number clusters can vary.","code":"partition_metrics(ex_pam, dissimilarity = dissim,                   eval_metric = \"pc_distance\") ## Partition metrics: ##  - 24  partition(s) evaluated ##  - Range of clusters explored: from  2  to  25  ##  - Requested metric(s):  pc_distance  ##  - Metric summary: ##      pc_distance ## Min    0.5172332 ## Mean   0.7901065 ## Max    0.8970663 ##  ## Access the data.frame of metrics with your_object$evaluation_df a <- partition_metrics(ex_pam, dissimilarity = dissim, net = fishdf,                        species_col = \"Species\", site_col = \"Site\",                        eval_metric = c(\"tot_endemism\", \"avg_endemism\",                                        \"pc_distance\", \"anosim\")) find_optimal_n(a) ## [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\" ## Number of partitions: 24 ## Searching for potential optimal number(s) of clusters based on the elbow method ##    * elbow found at: ## tot_endemism 4 ## avg_endemism 4 ## pc_distance 7 ## anosim 3 ## Plotting results... ## Search for an optimal number of clusters: ##  - 24  partition(s) evaluated ##  - Range of clusters explored: from  2  to  25  ##  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  elbow  ##  - Optimal partition(s) of clusters for each metric: ## tot_endemism - 4 ## avg_endemism - 4 ## pc_distance - 7 ## anosim - 3"},{"path":[]},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"input-data","dir":"Articles","previous_headings":"Introduction","what":"Input data","title":"4.3 Network clustering","text":"network algorithms work network format, .e. data.frame 3 columns: sites, species abundance given species given site. type object can obtained site x species matrix use mat_to_net(). vignette, directly load network format distribution fish European basins.","code":"library(\"bioregion\") data(\"fishdf\")"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"main-arguments","dir":"Articles","previous_headings":"Introduction","what":"Main arguments","title":"4.3 Network clustering","text":"algorithms presented specific parameters can tweaked arguments common functions. Among common arguments following: * weight boolean indicating weights considered * index name number column use weight. default, third column name network data.frame used * site_col name number column site nodes (.e. primary nodes). * species_col = name number column species nodes (.e. feature nodes) * return_node_type character indicating types nodes (“sites”, “species” “”) returned output (keep_nodes_type=“” default). * algorithm_in_output boolean indicating original output communities returned output (see Value). three algorithms relying executable binary files, following arguments needed: * delete_temp boolean indicating temporary folder removed * path_temp character indicating path temporary folder * binpath character indicating path bin folder","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"binary-files","dir":"Articles","previous_headings":"","what":"Binary files","title":"4.3 Network clustering","text":"","code":"install_binaries(binpath = \"tempdir\", infomap_version = c(\"2.1.0\", \"2.6.0\"))"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"infomap","dir":"Articles","previous_headings":"Binary files","what":"Infomap","title":"4.3 Network clustering","text":"Rosvall & Bergstrom (2008) nbmod penalize solutions differ number (0 default preferred number modules). markovtime scales link flow change cost moving modules, higher values results fewer modules (default 1). seed random number generator (0 random default) numtrials number trials picking best solution. twolevel boolean indicating algorithm optimize two-level partition network (default multi-level). show_hierarchy boolean specifying hierarchy community identifiable outputs (FALSE default).","code":"set.seed(1) ex_infomap <- netclu_infomap(fishdf,                              weight = TRUE,                              index = names(fishdf)[3],                              nbmod = 0,                              markovtime = 1,                              seed = 0,                              numtrials = 1,                              twolevel = FALSE,                              show_hierarchy = FALSE,                              directed = FALSE,                              bipartite_version = FALSE,                              bipartite = FALSE,                              site_col = 1,                              species_col = 2,                              return_node_type = \"both\",                              version = \"2.6.0\",                              binpath = \"tempdir\",                              path_temp = \"infomap_temp\",                              delete_temp = TRUE)  table(ex_infomap$clusters$K_10) ##  ##   1  10   2   3   4   5   6   7   8   9  ## 274  12   7  62  47  30  26  22  26  27"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"oslom","dir":"Articles","previous_headings":"Binary files","what":"OSLOM","title":"4.3 Network clustering","text":"OSLOM stands Order Statistics Local Optimization Method. Lancichinetti et al. (2011) reassign string indicating nodes belonging several community reassign method used (see Note). * r number runs first hierarchical level (10 default). * hr number runs higher hierarchical level (50 default, 0 interested hierarchies). * seed random number generator (0 random default). * t p−value, default value 0.10, increase value get modules. * cp kind resolution parameter used decide taking modules union (default value 0.5, bigger value leads bigger clusters).","code":"set.seed(1) ex_oslom <- netclu_oslom(fishdf,                          weight = TRUE,                          index = names(fishdf)[3],                          reassign = \"no\",                          r = 10,                          hr = 50,                          seed = 0,                          t = 0.1,                          cp = 0.5,                          directed = FALSE,                          bipartite = FALSE,                          site_col = 1,                          species_col = 2,                          return_node_type = \"both\",                          binpath = \"tempdir\",                          path_temp = \"oslom_temp\",                          delete_temp = TRUE))  table(ex_oslom$clusters$K_4_semel)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"louvain","dir":"Articles","previous_headings":"Binary files","what":"Louvain","title":"4.3 Network clustering","text":"Blondel et al. (2008) q quality function used compute partition graph (modularity chosen default, see Details). c parameter Owsinski-Zadrozny quality function (0 1, 0.5 chosen default) k kappa_min value Shi-Malik quality function (must > 0, 1 chosen default)","code":"set.seed(1) ex_louvain <- netclu_louvain(fishdf,                              weight = TRUE,                              index = names(fishdf)[3],                              lang = \"Cpp\",                              q = 0,                              c = 0.5,                              k = 1,                              bipartite = FALSE,                              site_col = 1,                              species_col = 2,                              return_node_type = \"both\",                              binpath = \"tempdir\",                              path_temp = \"louvain_temp\",                              delete_temp = TRUE,                              algorithm_in_output = TRUE) table(ex_louvain$clusters$K_23) ## < table of extent 0 >"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"fastgreedy","dir":"Articles","previous_headings":"Functions from the igraph package","what":"Fastgreedy","title":"4.3 Network clustering","text":"Clauset et al. (2004)","code":"set.seed(1) ex_greedy <- netclu_greedy(fishdf,                            weight = TRUE,                            index = names(fishdf)[3],                            bipartite = FALSE,                            site_col = 1,                            species_col = 2,                            return_node_type = \"both\",                            algorithm_in_output = TRUE) table(ex_greedy$clusters$K_5) ##  ##   1   2   3   4   5  ## 138  61 144 132  58"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"label-propagation","dir":"Articles","previous_headings":"Functions from the igraph package","what":"Label propagation","title":"4.3 Network clustering","text":"Raghavan et al. (2007)","code":"set.seed(1) ex_labelprop <- netclu_labelprop(fishdf,                                  weight = TRUE,                                  index = names(fishdf)[3],                                  bipartite = FALSE,                                  site_col = 1,                                  species_col = 2,                                  return_node_type = \"both\",                                  algorithm_in_output = TRUE) table(ex_labelprop$clusters$K_11) ##  ##   1  10  11   2   3   4   5   6   7   8   9  ## 369   3  10  26  47  29   4  17  18   6   4"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"leiden-algorithm","dir":"Articles","previous_headings":"Functions from the igraph package","what":"Leiden algorithm","title":"4.3 Network clustering","text":"Traag et al. (2019)","code":"set.seed(1) ex_leiden <- netclu_leiden(fishdf,                            weight = TRUE,                            index = names(fishdf)[3],                            objective_function = c(\"CPM\", \"modularity\"),                            resolution_parameter = 1,                            beta = 0.01,                            initial_membership = NULL,                            n_iterations = 2,                            vertex_weights = NULL,                            bipartite = TRUE,                            site_col = 1,                            species_col = 2,                            return_node_type = \"both\",                            algorithm_in_output = TRUE) length(unique(ex_leiden$clusters$K_505)) ## [1] 0"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"leading-eigenvector","dir":"Articles","previous_headings":"Functions from the igraph package","what":"Leading eigenvector","title":"4.3 Network clustering","text":"Newman (2006)","code":"set.seed(1) ex_leadingeigen <- netclu_leadingeigen(fishdf,                                        weight = TRUE,                                        index = names(fishdf)[3],                                        bipartite = FALSE,                                        site_col = 1,                                        species_col = 2,                                        return_node_type = \"both\",                                        algorithm_in_output = TRUE) table(ex_leadingeigen$clusters$K_17) ## < table of extent 0 >"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"walktrap","dir":"Articles","previous_headings":"Functions from the igraph package","what":"Walktrap","title":"4.3 Network clustering","text":"Pons & Latapy (2005)","code":"set.seed(1) ex_walktrap <- netclu_walktrap(fishdf,                                weight = TRUE,                                index = names(fishdf)[3],                                steps = 4,                                bipartite = FALSE,                                site_col = 1,                                species_col = 2,                                return_node_type = \"both\",                                algorithm_in_output = TRUE) table(ex_walktrap$clusters$K_14) ##  ##   1  10  11  12  13  14   2   3   4   5   6   7   8   9  ##  11  47  10   2   6  17  84   5  37  16   5 270   4  19"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"beckett","dir":"Articles","previous_headings":"Function from the bipartite package","what":"Beckett","title":"4.3 Network clustering","text":"Update QuanBiMo algorithm developed Dormann & Strauss (2014). Beckett (2016)","code":"set.seed(1) ex_beckett <- netclu_beckett(fishdf,                              weight = TRUE,                              index = names(fishdf)[3],                              site_col = 1,                              species_col = 2,                              return_node_type = \"both\",                              forceLPA = TRUE,                              algorithm_in_output = TRUE) ex_beckett$clusters$K_23 ##   [1] \"4\"  \"1\"  \"2\"  \"3\"  \"4\"  \"4\"  \"3\"  \"3\"  \"16\" \"13\" \"1\"  \"1\"  \"8\"  \"1\"  \"16\" ##  [16] \"5\"  \"4\"  \"3\"  \"4\"  \"8\"  \"4\"  \"1\"  \"4\"  \"4\"  \"5\"  \"4\"  \"4\"  \"1\"  \"13\" \"1\"  ##  [31] \"4\"  \"3\"  \"1\"  \"3\"  \"4\"  \"4\"  \"4\"  \"4\"  \"3\"  \"3\"  \"4\"  \"3\"  \"1\"  \"5\"  \"3\"  ##  [46] \"3\"  \"6\"  \"4\"  \"3\"  \"4\"  \"1\"  \"4\"  \"1\"  \"4\"  \"4\"  \"4\"  \"7\"  \"8\"  \"4\"  \"9\"  ##  [61] \"4\"  \"4\"  \"4\"  \"4\"  \"10\" \"10\" \"1\"  \"4\"  \"5\"  \"1\"  \"5\"  \"4\"  \"8\"  \"8\"  \"4\"  ##  [76] \"1\"  \"3\"  \"1\"  \"16\" \"13\" \"12\" \"1\"  \"22\" \"4\"  \"3\"  \"1\"  \"3\"  \"1\"  \"13\" \"4\"  ##  [91] \"4\"  \"8\"  \"4\"  \"8\"  \"15\" \"15\" \"15\" \"15\" \"4\"  \"1\"  \"8\"  \"4\"  \"1\"  \"8\"  \"4\"  ## [106] \"8\"  \"4\"  \"1\"  \"1\"  \"4\"  \"1\"  \"15\" \"1\"  \"1\"  \"5\"  \"1\"  \"16\" \"8\"  \"1\"  \"1\"  ## [121] \"1\"  \"13\" \"1\"  \"8\"  \"1\"  \"8\"  \"17\" \"18\" \"1\"  \"1\"  \"1\"  \"8\"  \"1\"  \"19\" \"1\"  ## [136] \"1\"  \"8\"  \"4\"  \"4\"  \"4\"  \"4\"  \"5\"  \"4\"  \"1\"  \"1\"  \"1\"  \"4\"  \"4\"  \"5\"  \"5\"  ## [151] \"3\"  \"8\"  \"1\"  \"11\" \"1\"  \"4\"  \"1\"  \"1\"  \"1\"  \"1\"  \"13\" \"16\" \"4\"  \"1\"  \"1\"  ## [166] \"1\"  \"1\"  \"1\"  \"1\"  \"3\"  \"8\"  \"5\"  \"5\"  \"20\" \"5\"  \"4\"  \"3\"  \"1\"  \"4\"  \"1\"  ## [181] \"4\"  \"1\"  \"6\"  \"1\"  \"13\" \"3\"  \"8\"  \"8\"  \"4\"  \"3\"  \"1\"  \"8\"  \"1\"  \"4\"  \"8\"  ## [196] \"1\"  \"3\"  \"4\"  \"1\"  \"4\"  \"8\"  \"4\"  \"1\"  \"1\"  \"4\"  \"1\"  \"16\" \"1\"  \"4\"  \"8\"  ## [211] \"1\"  \"3\"  \"15\" \"1\"  \"1\"  \"16\" \"13\" \"1\"  \"3\"  \"1\"  \"1\"  \"1\"  \"3\"  \"1\"  \"21\" ## [226] \"1\"  \"4\"  \"1\"  \"1\"  \"1\"  \"1\"  \"1\"  \"4\"  \"1\"  \"1\"  \"1\"  \"8\"  \"4\"  \"4\"  \"4\"  ## [241] \"1\"  \"22\" \"1\"  \"1\"  \"1\"  \"4\"  \"1\"  \"5\"  \"1\"  \"4\"  \"1\"  \"1\"  \"1\"  \"8\"  \"15\" ## [256] \"4\"  \"1\"  \"4\"  \"4\"  \"1\"  \"4\"  \"4\"  \"4\"  \"8\"  \"3\"  \"4\"  \"8\"  \"3\"  \"4\"  \"1\"  ## [271] \"1\"  \"13\" \"1\"  \"4\"  \"22\" \"1\"  \"1\"  \"3\"  \"3\"  \"5\"  \"5\"  \"4\"  \"4\"  \"1\"  \"4\"  ## [286] \"4\"  \"4\"  \"4\"  \"3\"  \"11\" \"4\"  \"3\"  \"4\"  \"1\"  \"1\"  \"1\"  \"1\"  \"8\"  \"4\"  \"4\"  ## [301] \"4\"  \"4\"  \"3\"  \"1\"  \"5\"  \"1\"  \"1\"  \"4\"  \"5\"  \"8\"  \"1\"  \"1\"  \"1\"  \"1\"  \"1\"  ## [316] \"5\"  \"1\"  \"4\"  \"1\"  \"1\"  \"14\" \"10\" \"8\"  \"4\"  \"1\"  \"4\"  \"4\"  \"4\"  \"4\"  \"3\"  ## [331] \"1\"  \"1\"  \"5\"  \"4\"  \"8\"  \"8\"  \"4\"  \"23\" \"4\"  \"4\"  \"4\"  \"8\"  \"8\"  \"1\"  \"4\"  ## [346] \"4\"  \"4\"  \"13\" \"1\"  \"4\"  \"4\"  \"1\"  \"16\" \"16\" \"2\"  \"16\" \"2\"  \"2\"  \"2\"  \"16\" ## [361] \"2\"  \"16\" \"3\"  \"4\"  \"3\"  \"3\"  \"3\"  \"3\"  \"3\"  \"3\"  \"3\"  \"3\"  \"4\"  \"5\"  \"4\"  ## [376] \"4\"  \"3\"  \"3\"  \"12\" \"16\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" ## [391] \"13\" \"13\" \"13\" \"8\"  \"8\"  \"16\" \"16\" \"5\"  \"20\" \"15\" \"5\"  \"5\"  \"4\"  \"3\"  \"3\"  ## [406] \"8\"  \"15\" \"5\"  \"5\"  \"5\"  \"5\"  \"5\"  \"5\"  \"13\" \"8\"  \"13\" \"9\"  \"3\"  \"3\"  \"3\"  ## [421] \"5\"  \"6\"  \"19\" \"6\"  \"6\"  \"7\"  \"7\"  \"7\"  \"7\"  \"7\"  \"8\"  \"7\"  \"7\"  \"7\"  \"7\"  ## [436] \"21\" \"21\" \"7\"  \"21\" \"7\"  \"7\"  \"7\"  \"7\"  \"7\"  \"7\"  \"8\"  \"10\" \"8\"  \"10\" \"9\"  ## [451] \"9\"  \"9\"  \"9\"  \"10\" \"9\"  \"9\"  \"8\"  \"10\" \"22\" \"9\"  \"9\"  \"9\"  \"10\" \"9\"  \"8\"  ## [466] \"10\" \"9\"  \"9\"  \"4\"  \"10\" \"10\" \"8\"  \"10\" \"10\" \"15\" \"5\"  \"5\"  \"11\" \"11\" \"15\" ## [481] \"13\" \"13\" \"22\" \"22\" \"13\" \"22\" \"12\" \"12\" \"22\" \"13\" \"13\" \"15\" \"15\" \"14\" \"15\" ## [496] \"15\" \"15\" \"15\" \"15\" \"5\"  \"16\" \"17\" \"18\" \"18\" \"18\" \"18\" \"23\" \"19\" \"19\" \"13\" ## [511] \"20\" \"13\" \"22\" \"13\" \"13\" \"13\" \"3\"  \"21\" \"21\" \"21\" \"21\" \"21\" \"21\" \"4\"  \"22\" ## [526] \"22\" \"5\"  \"22\" \"22\" \"22\" \"5\"  \"10\" \"23\""},{"path":[]},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_4_microbenchmark.html","id":"vegemat","dir":"Articles","previous_headings":"1. Datasets","what":"1.1. Vegemat","title":"4.4 Microbenchmark","text":"first dataset comes available bioregion analyzed article. contains abundance 3,697 plant species distributed 715 sites French Mediterranean area. dataset use two following files: vegedf data.frame 460,878 rows 3 columns (Site, Species Abundance) vegemat co-occurrence matrix containing information gathered matrix 715 rows 3,697 columns.","code":"data(vegedf) data(vegemat)  vegemat_dissim <- dissimilarity(vegemat,  metric = c(\"abc\", \"Simpson\")) vegemat_df <- mat_to_net(vegemat, weight = TRUE, remove_zeroes = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_4_microbenchmark.html","id":"european-fish","dir":"Articles","previous_headings":"1. Datasets","what":"1.2. European fish","title":"4.4 Microbenchmark","text":"second dataset also comes available bioregion contains distribution 195 freshwater fish distributed basins Europe.","code":"data(\"fishmat\") fishdissim <- dissimilarity(fishmat, metric = \"all\") data(\"fishdf\")"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_4_microbenchmark.html","id":"aravo","dir":"Articles","previous_headings":"1. Datasets","what":"1.3. Aravo","title":"4.4 Microbenchmark","text":"third dataset, called aravo, retrieved package ade4. contains distribution 82 alpine plants 75 sites distributed French Alps.","code":"data(\"aravo\") aravo <- as.matrix(aravo$spe) dim(aravo) ## [1] 75 82 ara_dissim <- dissimilarity(aravo, metric = \"all\")  ara_df <- mat_to_net(aravo, weight = TRUE, remove_zeroes = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_4_microbenchmark.html","id":"microbenchmark","dir":"Articles","previous_headings":"","what":"2. Microbenchmark","title":"4.4 Microbenchmark","text":"assessing time needed clustering algorithm three datasets loaded . Plotting results.   OSLOM Beckett slow, ran far Vegetation data.","code":"install_binaries()  mbm <- suppressMessages(   microbenchmark(     # aravo     ara_nhclu_dbscan = nhclu_dbscan(dissimilarity = ara_dissim,                                     index = \"Simpson\", plot = FALSE),     ara_nhclu_kmeans = nhclu_kmeans(ara_dissim, n_clust = 2:10,                                     index = \"Simpson\"),     ara_nhclu_pam = nhclu_pam(ara_dissim, n_clust = 2:10, index = \"Simpson\"),     ara_hclu_hierarclust = hclu_hierarclust(dissimilarity = ara_dissim,                                             n_clust = 5),     ara_hclu_optics = hclu_optics(ara_dissim, index = \"Simpson\"),     ara_netclu_beckett = netclu_beckett(ara_df),     ara_netclu_greedy = netclu_greedy(ara_df),     ara_netclu_labelprop = netclu_labelprop(ara_df),     ara_netclu_leadingeigen = netclu_leadingeigen(ara_df),     ara_netclu_oslom = netclu_oslom(ara_df),     ara_netclu_walktrap = netclu_walktrap(ara_df),     ara_netclu_infomap = netclu_infomap(ara_df),     ara_netclu_louvain = netclu_louvain(ara_df),          # fish vertebrates     fish_nhclu_dbscan = nhclu_dbscan(dissimilarity = fishdissim,                                      index = \"Simpson\", plot = FALSE),     fish_nhclu_kmeans = nhclu_kmeans(fishdissim, n_clust = 2:10,                                      index = \"Simpson\"),     fish_nhclu_pam = nhclu_pam(fishdissim, n_clust = 2:10, index = \"Simpson\"),     fish_hclu_hierarclust = hclu_hierarclust(dissimilarity = fishdissim,                                              n_clust = 5),     fish_hclu_optics = hclu_optics(fishdissim, index = \"Simpson\"),     fish_netclu_beckett = netclu_beckett(fishdf),     fish_netclu_greedy = netclu_greedy(fishdf),     fish_netclu_labelprop = netclu_labelprop(fishdf),     fish_netclu_leadingeigen = netclu_leadingeigen(fishdf),     fish_netclu_oslom = netclu_oslom(fishdf),     fish_netclu_walktrap = netclu_walktrap(fishdf),     fish_netclu_infomap = netclu_infomap(fishdf),     fish_netclu_louvain = netclu_louvain(fishdf),          # vegetation     veg_nhclu_dbscan = nhclu_dbscan(dissimilarity = vegemat_dissim,                                     index = \"Simpson\", plot = FALSE),     veg_nhclu_kmeans = nhclu_kmeans(vegemat_dissim, n_clust = 2:10,                                     index = \"Simpson\"),     veg_nhclu_pam = nhclu_pam(vegemat_dissim, n_clust = 2:10,                               index = \"Simpson\"),     veg_hclu_hierarclust = hclu_hierarclust(dissimilarity = vegemat_dissim,                                             n_clust = 5),     veg_hclu_optics = hclu_optics(vegemat_dissim, index = \"Simpson\"),     # veg_netclu_beckett = netclu_beckett(vegemat_df),     veg_netclu_greedy = netclu_greedy(vegemat_df),     veg_netclu_labelprop = netclu_labelprop(vegemat_df),     veg_netclu_leadingeigen = netclu_leadingeigen(vegemat_df),     # veg_netclu_oslom = netclu_oslom(vegemat_df),     veg_netclu_walktrap = netclu_walktrap(vegemat_df),     veg_netclu_infomap = netclu_infomap(vegemat_df),     veg_netclu_louvain = netclu_louvain(vegemat_df),          times = 2))  mbm_plot <- data.frame(mbm) mbm_plot$expr <- as.character(mbm_plot$expr) mbm_plot$dataset <- ifelse(   grepl(\"ara_\", mbm_plot$expr),   paste0(\"Aravo (\", nrow(aravo) * ncol(aravo), \" cells)\"),   ifelse(grepl(\"fish\", mbm_plot$expr),          paste0(\"Fish (\", nrow(fishmat) * ncol(fishmat), \" cells)\"),          paste0(\"Vegetation (\", nrow(vegemat) * ncol(vegemat), \" cells)\")))  mbm_plot$algorithm <- gsub( \".*_\", \"\", mbm_plot$expr)  # Time in minutes mbm_plot$time_min <- mbm_plot$time / 60e9 # Time in seconds mbm_plot$time_sec <- mbm_plot$time / 1e9 ggplot(mbm_plot[which(mbm_plot$dataset == \"Aravo (6150 cells)\"), ],        aes(reorder(algorithm, time_sec), time_sec)) +   geom_boxplot(aes(color = reorder(algorithm, time_sec),                    fill = reorder(algorithm, time_sec)), show.legend = FALSE) +   scale_color_viridis_d(\"Algorithm\") +   scale_fill_viridis_d(\"Algorithm\") +   labs(title = \"Aravo (6,510 cells)\", x = \"\", y = \"Time (seconds)\") +   theme_classic() +   theme(panel.border = element_rect(fill = NA),         axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) ggplot(mbm_plot[which(mbm_plot$dataset == \"Fish (65910 cells)\"), ],        aes(reorder(algorithm, time_sec), time_sec)) +   geom_boxplot(aes(color = reorder(algorithm, time_sec),                    fill = reorder(algorithm, time_sec)), show.legend = FALSE) +   scale_color_viridis_d(\"Algorithm\") +   scale_fill_viridis_d(\"Algorithm\") +   labs(title = \"European fish (65,910 cells)\",        x = \"\", y = \"Time (seconds)\") +   theme_classic() +   theme(panel.border = element_rect(fill = NA),         axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) ggplot(mbm_plot[which(mbm_plot$dataset == \"Vegetation (2643355 cells)\"), ],        aes(reorder(algorithm, time_min), time_min)) +   geom_boxplot(aes(color = reorder(algorithm, time_min),                    fill = reorder(algorithm, time_min)), show.legend = FALSE) +   scale_color_viridis_d(\"Algorithm\") +   scale_fill_viridis_d(\"Algorithm\") +   labs(title = \"Vegetation (2,643,355 cells)\", x = \"\", y = \"Time (minutes)\") +   theme_classic() +   theme(panel.border = element_rect(fill = NA),         axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_visualization.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"5. Visualization","text":"vignette, rely dataset describing distribution fresh water fish Europe. first load matrix format dataset, computes dissimilarity matrix also load data.frame format data. Since aim plotting result, also need object fishsf linking site dataset geometry. also import world coastlines, available rnaturalearth R package.","code":"data(\"fishmat\") fishdissim <- dissimilarity(fishmat, metric = \"all\") data(\"fishdf\") data(\"fishsf\") world <- rnaturalearth::ne_coastline(returnclass = \"sf\")"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_visualization.html","id":"plots","dir":"Articles","previous_headings":"","what":"Plots","title":"5. Visualization","text":"section, show three ways plot results.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_visualization.html","id":"map_clusters","dir":"Articles","previous_headings":"Plots","what":"map_clusters()","title":"5. Visualization","text":"first possibility use function map_clusters() package. function can directly provide plot site colored according cluster belong .  Let’s take example K-means clustering, number clusters set 5. map_clusters() function can now simply takes object fish_nhclu_kmeans, bioregion.clusters class, spatial distribution sites, stored fishsf.","code":"fish_nhclu_kmeans <- nhclu_kmeans(fishdissim, n_clust = 5, index = \"Simpson\") map_clusters(fish_nhclu_kmeans, geometry = fishsf, plot = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_visualization.html","id":"custom-plot","dir":"Articles","previous_headings":"Plots","what":"Custom plot","title":"5. Visualization","text":"want customize plot simply rely default option, map_clusters() gives possibility extract site well geometry cluster number. purpose, can set arguments like chunk :","code":"custom <- map_clusters(fish_nhclu_kmeans, geometry = fishsf,                        write_clusters = TRUE, plot = FALSE) custom ## Simple feature collection with 338 features and 2 fields (with 70 geometries empty) ## Geometry type: GEOMETRY ## Dimension:     XY ## Bounding box:  xmin: -9.299647 ymin: 36.46054 xmax: 37.75 ymax: 69.67881 ## Geodetic CRS:  +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## First 10 features: ##            ID K_5                       geometry ## 500        Aa   3 POLYGON ((2.09202 50.98091,... ## 2766    Abula   1       GEOMETRYCOLLECTION EMPTY ## 501  Acheloos   5 MULTIPOLYGON (((21.22557 38... ## 2277    Adige   5 POLYGON ((12.12917 47.07917... ## 504     Adour   3 POLYGON ((-0.06622891 44.10... ## 505      Agly   3 POLYGON ((2.761574 42.92824... ## 506      Agri   2 POLYGON ((16.52326 40.32881... ## 510   Albegna   5 POLYGON ((11.54804 42.5839,... ## 2278   Alfios   5 POLYGON ((21.29943 37.68212... ## 512  Aliakmon   3 POLYGON ((21.28508 40.75452... # Crop world coastlines to the extent of the sf object of interest europe <- sf::st_crop(world, sf::st_bbox(custom))  # Plot ggplot(custom) +   geom_sf(aes(fill = K_5), show.legend = FALSE) +   geom_sf(data = europe) +   scale_fill_viridis_d() +   labs(title = \"Kmeans with 5 clusters\") +   theme_void()"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_visualization.html","id":"plot-with-facets","dir":"Articles","previous_headings":"Plots","what":"Plot with facets","title":"5. Visualization","text":"Finally, can interested plotting several bioregionalizations . purpose, can build single data.frame gathering bioregions obtained distinct algorithms take advantage facets implemented ggplot2. first compute bioregionalization dataset using algorithms. can now make single data.frame extra-column indicating algorithm used. now convert data.frame long-format data.frame. now add back geometry extra column make object spatial. Now long-format spatial data.frame, can take advantage facets implemented ggplot2.","code":"fish_nhclu_pam <- nhclu_pam(fishdissim, n_clust = 5, index = \"Simpson\") fish_hclu_hierarclust <- hclu_hierarclust(dissimilarity = fishdissim,                                           n_clust = 5) fish_netclu_greedy <- netclu_greedy(fishdf) fish_kmeans <- fish_nhclu_kmeans$clusters colnames(fish_kmeans)<- c(\"ID\", \"NHCLU_KMEANS\") fish_pam <- fish_nhclu_pam$clusters colnames(fish_pam)<- c(\"ID\", \"NHCLU_PAM\") fish_hieraclust <- fish_hclu_hierarclust$clusters colnames(fish_hieraclust)<- c(\"ID\", \"HCLU_HIERARCLUST\") fish_greedy <- fish_netclu_greedy$clusters colnames(fish_greedy)<- c(\"ID\", \"NET_GREEDY\")  all_clusters <- dplyr::left_join(fish_kmeans, fish_pam, by = \"ID\") all_clusters <- dplyr::left_join(all_clusters, fish_hieraclust, by = \"ID\") all_clusters <- dplyr::left_join(all_clusters, fish_greedy, by = \"ID\") all_long <- tidyr::pivot_longer(data = all_clusters,                                 cols = dplyr::contains(\"_\"),                                 names_to = \"Algorithm\",                                 values_to = \"Clusters\") all_long <- as.data.frame(all_long) all_long_sf <- dplyr::left_join(all_long,                                 custom[, c(\"ID\", \"geometry\")],                                 by = \"ID\") all_long_sf <- sf::st_as_sf(all_long_sf) ggplot(all_long_sf) +   geom_sf(aes(color = Clusters, fill = Clusters)) +   geom_sf(data = europe, fill = \"gray80\") +   scale_color_viridis_d() +   scale_fill_viridis_d() +   theme_void() +   facet_wrap(~ Algorithm)"},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"brief-introduction","dir":"Articles","previous_headings":"","what":"0. Brief introduction","title":"Tutorial for bioregion","text":"tutorial aims describing different features R package bioregion. main purpose bioregion‘s package propose transparent methodological framework compare bioregionalization methods. typical flow chart bioregions’ identification based site-species bipartite network co-occurrence matrix bioregion (Figure 1). workflow can divided four main steps: Preprocess data (matrix network formats) Compute similarity/dissimilarity metrics sites based species composition Run different algorithms identify different set bioregions Evaluate visualize results","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"install-binary-files","dir":"Articles","previous_headings":"","what":"1. Install binary files","title":"Tutorial for bioregion","text":"functions least part (listed ) require binary files run. netclu_infomap netclu_louvain (Cpp version) netclu_oslom Please check tutorial page get instructions regarding installation binary files.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"matrix-or-network-formats","dir":"Articles","previous_headings":"","what":"2. Matrix or Network formats","title":"Tutorial for bioregion","text":"bioregion’s package takes input site-species information stored bipartite network co-occurrence matrix. Relying function mat_to_net net_to_mat , handles matrix network formats throughout workflow. Please look tutorial page better understand two functions work.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"pairwise-similaritydissimilarity-metrics","dir":"Articles","previous_headings":"","what":"3. Pairwise similarity/dissimilarity metrics","title":"Tutorial for bioregion","text":"functions similarity dissimilarity compute respectively pairwise similarity dissimilarity metrics based (site-species) co-occurrence matrix. resulting data.frame stored bioregion.pairwise.metric object containing requested metrics pair sites. functions dissimilarity_to_similarity similarity_to_dissimilarity can used transform similarity object dissimilarity object vice versa. Please look tutorial page better understand functions work.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"clustering-algorithms","dir":"Articles","previous_headings":"","what":"4. Clustering algorithms","title":"Tutorial for bioregion","text":"bioregion.clusters class bioregion.clusters","code":""},{"path":[]},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"network-clustering","dir":"Articles","previous_headings":"4. Clustering algorithms","what":"4.3 Network clustering","title":"Tutorial for bioregion","text":"bioregion’s package contains 8 network clustering functions: netclu_infomap netclu_oslom netclu_louvain netclu_greedy netclu_labelprop netclu_leadingeigen netclu_walktrap netclu_beckett Please check tutorial page get information regarding network clustering functions.","code":""},{"path":[]},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Maxime Lenormand. Author, maintainer. Boris Leroy. Author. Pierre Denelle. Author.","code":""},{"path":"https://bioRgeo.github.io/bioregion/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lenormand M, Leroy B, Denelle P (2023). bioregion: Bioregionalisation Methods R. https://github.com/bioRgeo/bioregion, https://bioRgeo.github.io/bioregion/.","code":"@Manual{,   title = {bioregion: Bioregionalisation Methods in R},   author = {Maxime Lenormand and Boris Leroy and Pierre Denelle},   year = {2023},   note = {https://github.com/bioRgeo/bioregion, https://bioRgeo.github.io/bioregion/}, }"},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"bioregion-","dir":"","previous_headings":"","what":"Bioregionalisation Methods in R","title":"Bioregionalisation Methods in R","text":"R package gathers comprehensive set algorithms perform bioregionalization analyses.  different algorithms come network literature can (non)-hierarchical.","code":""},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"arrow_double_down-installation","dir":"","previous_headings":"","what":"⏬ Installation","title":"Bioregionalisation Methods in R","text":"package CRAN yet still active development. can install development version GitHub repository following command:","code":"# install.packages(\"devtools\") devtools::install_github(\"bioRgeo/bioregion\")"},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"scroll-vignettes","dir":"","previous_headings":"","what":"📜 Vignettes","title":"Bioregionalisation Methods in R","text":"wrote several vignettes help using bioregion R package. Vignettes available following ones: 1. Installation executable binary files 2. Matrix network formats 3. Pairwise similarity/dissimilarity metrics 4.1 Hierarchical clustering 4.2 Non-hierarchical clustering 4.3 Network clustering 4.4 Microbenchmark 5. Visualization Alternatively, prefer view vignettes R, can install package build_vignettes = TRUE. aware vignettes can slow generate.","code":"remotes::install_github(\"bioRgeo/bioregion\",                         dependencies = TRUE, upgrade = \"ask\",                          build_vignettes = TRUE)  vignette(\"bioregion\")"},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"desktop_computer-functions","dir":"","previous_headings":"","what":"🖥️ Functions","title":"Bioregionalisation Methods in R","text":"overview functions data given .","code":""},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"bug-find-a-bug","dir":"","previous_headings":"","what":"🐛 Find a bug?","title":"Bioregionalisation Methods in R","text":"Thank finding . Head GitHub Issues tab let us know . Alternatively, can also send us e-mail. try get soon can!","code":""},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"references-and-dependencies","dir":"","previous_headings":"","what":"References and dependencies","title":"Bioregionalisation Methods in R","text":"bioregion depends ape, bipartite, cluster, data.table, dbscan, dendextend, dynamicTreeCut, earth, fastcluster, ggplot2, grDevices, igraph, mathjaxr, Matrix, Rcpp, Rdpack, rlang, rmarkdown, sf, stats, tidyr utils.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut a hierarchical tree — cut_tree","title":"Cut a hierarchical tree — cut_tree","text":"functions designed work hierarchical tree cut user-selected heights. works either outputs hclu_hierarclust hclust objects. cuts tree chosen number(s) clusters selected height(s). also includes procedure automatically return height cut chosen number(s) clusters.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut a hierarchical tree — cut_tree","text":"","code":"cut_tree(   tree,   n_clust = NULL,   cut_height = NULL,   find_h = TRUE,   h_max = 1,   h_min = 0,   dynamic_tree_cut = FALSE,   dynamic_method = \"tree\",   dynamic_minClusterSize = 5,   dissimilarity = NULL,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut a hierarchical tree — cut_tree","text":"tree bioregion.hierar.tree hclust object n_clust integer vector integers indicating number clusters obtained hierarchical tree, output partition_metrics(). used time cut_height cut_height numeric vector indicating height(s) tree cut. used time n_clust optim_method find_h boolean indicating height cut found requested n_clust h_max numeric indicating maximum possible tree height finding height cut find_h = TRUE h_min numeric indicating minimum possible height tree finding height cut find_h = TRUE dynamic_tree_cut boolean indicating dynamic tree cut method used, case n_clust & cut_height ignored dynamic_method character vector indicating method used dynamically cut tree: either \"tree\" (clusters searched tree) \"hybrid\" (clusters searched tree dissimilarity matrix) dynamic_minClusterSize integer indicating minimum cluster size use dynamic tree cut method (see dynamicTreeCut::cutreeDynamic()) dissimilarity useful dynamic_method = \"hybrid\". Provide dissimilarity data.frame used build tree ... arguments passed dynamicTreeCut::cutreeDynamic() customize dynamic tree cut method.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut a hierarchical tree — cut_tree","text":"tree output hclu_hierarclust(), object returned content updated (.e., args clusters). tree hclust object, data.frame containing clusters returned.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cut a hierarchical tree — cut_tree","text":"function can cut tree two main methods. First, can cut entire tree height (either specified cut_height automatically defined chosen n_clust). Second, can use dynamic tree cut method (Langfelder et al. 2008) , case clusters detected adaptive method based shape branches tree (thus cuts happen multiple heights depending cluster positions tree). dynamic tree cut method two variants. tree-based variant (dynamic_method = \"tree\") top-approach relies tree follows order clustered objects hybrid variant (dynamic_method = \"hybrid\") bottom-approach relies tree dissimilarity matrix build clusters basis dissimilarity information among sites. method useful detect outlying members cluster.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Cut a hierarchical tree — cut_tree","text":"argument find_h ignored dynamic_tree_cut = TRUE, heights cut estimated case.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cut a hierarchical tree — cut_tree","text":"Langfelder P, Zhang B, Horvath S (2008). “Defining clusters hierarchical cluster tree: Dynamic Tree Cut package R.” BIOINFORMATICS, 24(5), 719--720.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cut a hierarchical tree — cut_tree","text":"Pierre Denelle (pierre.denelle@gmail.com), Maxime Lenormand (maxime.lenormand@inrae.fr) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut a hierarchical tree — cut_tree","text":"","code":"# \\donttest{ comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\", 1:20) colnames(comat) <- paste0(\"Species\", 1:25)  simil <- similarity(comat, metric = \"all\") dissimilarity <- similarity_to_dissimilarity(simil)  # User-defined number of clusters tree1 <- hclu_hierarclust(dissimilarity, n_clust = 5) #> Randomizing the dissimilarity matrix with 30 trials #>  -- range of cophenetic correlation coefficients among #>                      trials: 0.85 - 0.86 #> Optimal tree has a 0.86 cophenetic correlation coefficient with the initial dissimilarity #>       matrix #> Determining the cut height to reach 5 groups... #> Registered S3 method overwritten by 'dendextend': #>   method     from  #>   rev.hclust vegan #> --> 0.234375 tree2 <- cut_tree(tree1, cut_height = .05) tree3 <- cut_tree(tree1, n_clust = c(3, 5, 10)) #> Determining the cut height to reach 3 groups... #> --> 0.3125 #> Determining the cut height to reach 5 groups... #> --> 0.234375 #> Determining the cut height to reach 10 groups... #> --> 0.1875 tree4 <- cut_tree(tree1, cut_height = c(.05, .1, .15, .2, .25)) tree5 <- cut_tree(tree1, n_clust = c(3, 5, 10), find_h = FALSE)  hclust_tree <- tree2$algorithm$final.tree clusters_2 <- cut_tree(hclust_tree, n_clust = 10) #> Determining the cut height to reach 10 groups... #> --> 0.1875  cluster_dynamic <- cut_tree(tree1, dynamic_tree_cut = TRUE,                             dissimilarity = dissimilarity) #> Some sites were not assigned to any cluster. They will have a NA #>               in the cluster data.frame. # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute dissimilarity metrics (beta-diversity) between sites based on\nspecies composition — dissimilarity","title":"Compute dissimilarity metrics (beta-diversity) between sites based on\nspecies composition — dissimilarity","text":"function creates data.frame row provides one several dissimilarity metric(s) pair sites co-occurrence matrix sites rows species columns.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute dissimilarity metrics (beta-diversity) between sites based on\nspecies composition — dissimilarity","text":"","code":"dissimilarity(comat, metric = \"Simpson\", formula = NULL, method = \"prodmat\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute dissimilarity metrics (beta-diversity) between sites based on\nspecies composition — dissimilarity","text":"comat co-occurrence matrix sites rows species columns. metric vector string(s) indicating metrics chose (see Details). Available options abc, ABC, Jaccard, Jaccardturn, Sorensen, Simpson,  Bray, Brayturn Euclidean. \"\" specified, metrics calculated. Can set NULL formula used. formula vector string(s) formula based , b, c, , B, C quantities (see Details). formula set NULL default. method string indicating method used compute abc (see Details). method = \"prodmat\" default efficient can greedy memory method=\"loops\" less efficient less greedy memory.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute dissimilarity metrics (beta-diversity) between sites based on\nspecies composition — dissimilarity","text":"data.frame additional class bioregion.pairwise.metric, providing one several dissimilarity metric(s) pair sites. two first columns represent pair sites. One column per dissimilarity metric provided metric formula except metric abc ABC stored three columns (one letter).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute dissimilarity metrics (beta-diversity) between sites based on\nspecies composition — dissimilarity","text":"number species shared pair sites, b species present first site  c species present second site. \\(Jaccard = (b + c) / (+ b + c)\\) \\(Jaccardturn = 2min(b, c) / (+ 2min(b, c))\\)(Baselga 2012) \\(Sorensen = (b + c) / (2a + b + c)\\) \\(Simpson = min(b, c) / (+ min(b, c))\\) abundances data available, Bray-Curtis turnover component can also computed following equation: \\(Bray = (B + C) / (2A + B + C)\\) \\(Brayturn = min(B, C)/(+ min(B, C))\\) (Baselga 2013) sum lesser values common species shared pair sites. B C total number specimens counted sites minus . formula can used compute customized metrics terms , b, c, , B, C. example formula = c(\"(b + c) / (+ b + c)\", \"(B + C) / (2*+ B + C)\") compute Jaccard Bray-Curtis dissimilarity metrics, respectively. Euclidean computes Euclidean distance pair sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute dissimilarity metrics (beta-diversity) between sites based on\nspecies composition — dissimilarity","text":"Baselga (2012). “Relationship Species Replacement, Dissimilarity Derived Nestedness, Nestedness.” Global Ecology Biogeography, 21(12), 1223--1232. Baselga (2013). “Separating two components abundance-based dissimilarity: balanced changes abundance vs. abundance gradients.” Methods Ecology Evolution, 4(6), 552--557.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute dissimilarity metrics (beta-diversity) between sites based on\nspecies composition — dissimilarity","text":"Pierre Denelle (pierre.denelle@gmail.com), Maxime Lenormand (maxime.lenormand@inrae.fr) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute dissimilarity metrics (beta-diversity) between sites based on\nspecies composition — dissimilarity","text":"","code":"# \\donttest{ comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  dissim <- dissimilarity(comat, metric = c(\"abc\", \"ABC\", \"Simpson\", \"Brayturn\"))  simil <- dissimilarity(comat, metric = \"all\", formula = \"1 - (b + c) / (a + b + c)\") # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert dissimilarity indices to similarity indices — dissimilarity_to_similarity","title":"Convert dissimilarity indices to similarity indices — dissimilarity_to_similarity","text":"function converts data.frame dissimilarity indices (beta diversity) sites similarity indices.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert dissimilarity indices to similarity indices — dissimilarity_to_similarity","text":"","code":"dissimilarity_to_similarity(dissimilaritydata)"},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert dissimilarity indices to similarity indices — dissimilarity_to_similarity","text":"dissimilaritydata output object similarity_to_dissimilarity() data.frame first columns called \"Site1\" \"Site2\", columns similarity metrics.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert dissimilarity indices to similarity indices — dissimilarity_to_similarity","text":"data.frame additional class bioregion.pairwise.metric, providing one several dissimilarity metric(s) pair sites. two first columns represent pair sites, column represent dissimilarity metrics. Columns names \"\", \"b\", \"c\", \"\", \"B\" \"C\"  altered.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert dissimilarity indices to similarity indices — dissimilarity_to_similarity","text":"behaviour function changes depending column names. Columns \"Site1\" \"Site2\" copied identically. columns called \"\", \"b\", \"c\", \"\", \"B\", \"C\", also copied identically. column called \"Euclidean\", similarity calculated based following formula: \\(Euclidean similarity = (1 - Euclidean distance) / Euclidean distance\\) Otherwise, columns transformed similarity following formula: \\(similarity = 1 - dissimilarity\\)","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert dissimilarity indices to similarity indices — dissimilarity_to_similarity","text":"Boris Leroy (leroy.boris@gmail.com), Maxime Lenormand (maxime.lenormand@inrae.fr) Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert dissimilarity indices to similarity indices — dissimilarity_to_similarity","text":"","code":"# \\donttest{ comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  simil <- similarity(comat, metric = \"all\") simil #> Data.frame of similarity between sites #>  - Total number of sites:  5  #>  - Number of rows:  10  #>  - Number of similarity metrics:  7  #>  #>  #>    Site1 Site2 Jaccard Jaccardturn  Sorensen   Simpson       Bray  Brayturn #> 2  Site1 Site2     0.9        1.00 0.9473684 1.0000000 0.35018051 0.6092965 #> 3  Site1 Site3     0.8        0.80 0.8888889 0.8888889 0.10000000 0.1469849 #> 4  Site1 Site4     0.9        1.00 0.9473684 1.0000000 0.06445837 0.1121495 #> 5  Site1 Site5     0.6        0.75 0.7500000 0.8571429 0.26452064 0.2985782 #> 8  Site2 Site3     0.9        1.00 0.9473684 1.0000000 0.14667425 0.1670984 #> 9  Site2 Site4     1.0        1.00 1.0000000 1.0000000 0.20740741 0.7414330 #> 10 Site2 Site5     0.7        1.00 0.8235294 1.0000000 0.40122746 0.8262243 #> 14 Site3 Site4     0.9        1.00 0.9473684 1.0000000 0.11903485 0.3457944 #> 15 Site3 Site5     0.6        0.75 0.7500000 0.8571429 0.15066605 0.2590837 #> 20 Site4 Site5     0.7        1.00 0.8235294 1.0000000 0.50524109 0.7507788 #>       Euclidean  a b c   A    B    C #> 2  0.0013972445  9 0 1 485  311 1489 #> 3  0.0010353772  8 1 1 117  679 1427 #> 4  0.0018802318  9 0 1  36  760  285 #> 5  0.0019558855  6 3 1 189  607  444 #> 8  0.0008395322  9 1 0 258 1716 1286 #> 9  0.0011393014 10 0 0 238 1736   83 #> 10 0.0013419708  7 3 0 523 1451  110 #> 14 0.0011686012  9 0 1 111 1433  210 #> 15 0.0011275055  6 3 1 164 1380  469 #> 20 0.0046274878  7 3 0 241   80  392  dissimilarity <- similarity_to_dissimilarity(simil) dissimilarity #> Data.frame of dissimilarity between sites #>  - Total number of sites:  5  #>  - Number of rows:  10  #>  - Number of dissimilarity metrics:  7  #>  #>  #>    Site1 Site2 Jaccard Jaccardturn   Sorensen   Simpson      Bray  Brayturn #> 2  Site1 Site2     0.1        0.00 0.05263158 0.0000000 0.6498195 0.3907035 #> 3  Site1 Site3     0.2        0.20 0.11111111 0.1111111 0.9000000 0.8530151 #> 4  Site1 Site4     0.1        0.00 0.05263158 0.0000000 0.9355416 0.8878505 #> 5  Site1 Site5     0.4        0.25 0.25000000 0.1428571 0.7354794 0.7014218 #> 8  Site2 Site3     0.1        0.00 0.05263158 0.0000000 0.8533258 0.8329016 #> 9  Site2 Site4     0.0        0.00 0.00000000 0.0000000 0.7925926 0.2585670 #> 10 Site2 Site5     0.3        0.00 0.17647059 0.0000000 0.5987725 0.1737757 #> 14 Site3 Site4     0.1        0.00 0.05263158 0.0000000 0.8809651 0.6542056 #> 15 Site3 Site5     0.4        0.25 0.25000000 0.1428571 0.8493339 0.7409163 #> 20 Site4 Site5     0.3        0.00 0.17647059 0.0000000 0.4947589 0.2492212 #>    Euclidean  a b c   A    B    C #> 2   714.6943  9 0 1 485  311 1489 #> 3   964.8316  8 1 1 117  679 1427 #> 4   530.8493  9 0 1  36  760  285 #> 5   510.2774  6 3 1 189  607  444 #> 8  1190.1395  9 1 0 258 1716 1286 #> 9   876.7309 10 0 0 238 1736   83 #> 10  744.1727  7 3 0 523 1451  110 #> 14  854.7239  9 0 1 111 1433  210 #> 15  885.9137  6 3 1 164 1380  469 #> 20  215.1000  7 3 0 241   80  392  simil <- dissimilarity_to_similarity(dissimilarity) simil #> Data.frame of dissimilarity between sites #>  - Total number of sites:  5  #>  - Number of rows:  10  #>  - Number of dissimilarity metrics:  7  #>  #>  #>    Site1 Site2 Jaccard Jaccardturn  Sorensen   Simpson       Bray  Brayturn #> 2  Site1 Site2     0.9        1.00 0.9473684 1.0000000 0.35018051 0.6092965 #> 3  Site1 Site3     0.8        0.80 0.8888889 0.8888889 0.10000000 0.1469849 #> 4  Site1 Site4     0.9        1.00 0.9473684 1.0000000 0.06445837 0.1121495 #> 5  Site1 Site5     0.6        0.75 0.7500000 0.8571429 0.26452064 0.2985782 #> 8  Site2 Site3     0.9        1.00 0.9473684 1.0000000 0.14667425 0.1670984 #> 9  Site2 Site4     1.0        1.00 1.0000000 1.0000000 0.20740741 0.7414330 #> 10 Site2 Site5     0.7        1.00 0.8235294 1.0000000 0.40122746 0.8262243 #> 14 Site3 Site4     0.9        1.00 0.9473684 1.0000000 0.11903485 0.3457944 #> 15 Site3 Site5     0.6        0.75 0.7500000 0.8571429 0.15066605 0.2590837 #> 20 Site4 Site5     0.7        1.00 0.8235294 1.0000000 0.50524109 0.7507788 #>       Euclidean  a b c   A    B    C #> 2  0.0013972445  9 0 1 485  311 1489 #> 3  0.0010353772  8 1 1 117  679 1427 #> 4  0.0018802318  9 0 1  36  760  285 #> 5  0.0019558855  6 3 1 189  607  444 #> 8  0.0008395322  9 1 0 258 1716 1286 #> 9  0.0011393014 10 0 0 238 1736   83 #> 10 0.0013419708  7 3 0 523 1451  110 #> 14 0.0011686012  9 0 1 111 1433  210 #> 15 0.0011275055  6 3 1 164 1380  469 #> 20 0.0046274878  7 3 0 241   80  392 # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"function aims optimizing one several criteria set ordered partitions. usually applied find one (several) optimal number(s) clusters , example, hierarchical tree cut, range partitions obtained k-means PAM. Users advised careful applied cases (e.g., partitions ordered increasing decreasing sequence, partitions related ).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"","code":"find_optimal_n(   partitions,   metrics_to_use = \"all\",   criterion = \"elbow\",   step_quantile = 0.99,   step_levels = NULL,   step_round_above = TRUE,   metric_cutoffs = c(0.5, 0.75, 0.9, 0.95, 0.99, 0.999),   mars_breakpoints = \"all\",   plot = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"partitions bioregion.partition.metrics object (output partition_metrics() data.frame first two columns named \"K\" (partition name) \"n_clusters\" (number clusters) following columns containing evaluation metrics (numeric values) metrics_to_use character string vector character strings indicating upon metric(s) partitions optimal number clusters calculated. Defaults \"\" means metrics available partitions used criterion character string indicating criterion used identify optimal number(s) clusters. Available methods currently include \"elbow\", \"increasing_step\", \"decreasing_step\", \"cutoff\", \"mars\", \"min\" \"max\". Default \"elbow\". See details. step_quantile \"increasing_step\" \"decreasing_step\", specify quantile differences two consecutive k used cutoff identify important steps eval_metric step_levels \"increasing_step\" \"decreasing_step\", specify number largest steps keep cutoffs. step_round_above boolean indicating optimal number clusters picked identified steps. Indeed, step correspond sudden increase decrease partition X & partition X+1: optimal partition X+1 (step_round_above = TRUE) X (step_round_above = FALSE? Defaults TRUE metric_cutoffs criterion = \"cutoff\", specify cutoffs eval_metric number clusters extracted mars_breakpoints \"\", \"increasing\" \"decreasing\". criterion = \"mars\", specify want extract break points identified mars model (\"\"), breakpoints corresponding increases (increasing\") decreases \"decreasing\". Defaults \"\" plot boolean indicating plot first eval_metric drawn identified optimal numbers cutoffs","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"list class bioregion.optimal.n three elements: args: input arguments evaluation_df: input evaluation data.frame appended boolean columns identifying optimal numbers clusters optimal_nb_clusters: list containing optimal number(s) cluster(s) metric specified \"metrics_to_use\", based chosen criterion plot: requested, plot stored slot","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"function explores relationship evaluation metric ~ number clusters, criterion applied search optimal number clusters. Please read note section following criteria. Foreword: implemented set criteria commonly found literature recommended bioregionalisation literature. Nevertheless, also advocate move beyond \"Search one optimal number clusters\" paradigm, consider investigating \"multiple optimal numbers clusters\". Indeed, using one optimal number clusters may simplify natural complexity biological datasets, , example, ignore often hierarchical / nested nature bioregionalisations. Using multiple partitions likely avoids oversimplification bias may convey information. See, example, reanalysis Holt et al. (2013) (Ficetola et al. 2017) , used deep, intermediate shallow cuts. Following rationale, several criteria implemented can/return multiple \"optimal\" numbers clusters, depending user choices. Criteria find optimal number(s) clusters elbow: method consists finding one elbow evaluation metric curve, commonly done clustering analyses. idea approximate number clusters evaluation metric longer increments.based fast method finding maximum distance curve straight line linking minimum maximum number points. code use based code written Esben Eickhardt available https://stackoverflow.com/questions/2018178/finding--best-trade--point---curve/42810075#42810075. code modified work increasing decreasing evaluation metrics. increasing_step decreasing_step: method consists identifying clusters important changes, steps, evaluation metric. objective can either look largest increases (increasing_step) largest decreases decreasing_step. Steps calculated based pairwise differences partitions. Therefore, relative distribution differences evaluation metric tested partitions. Specify step_quantile quantile cutoff steps selected important (default, 0.99, .e. largest 1\\ selected).Alternatively, can also choose specify number top steps keep, e.g. keep largest three steps, specify step_level = 3. Basically method emphasize important changes evaluation metric first approximation important cuts can chosen.**Please note choose increasing_step decreasing_step depending nature evaluation metrics. example, metrics monotonously decreasing (e.g., endemism metrics \"avg_endemism\" & \"tot_endemism\") number clusters n_clusters, choose decreasing_step. contrary, metrics monotonously increasing number clusters (e.g., \"pc_distance\"), choose increasing_step. ** cutoffs: method consists specifying cutoff value(s) evaluation metric number(s) clusters derived. method used (Holt et al. 2013) . Note, however, cut-offs suggested Holt et al. (0.9, 0.95, 0.99, 0.999) may relevant large spatial scales, lower cut-offs considered finer spatial scales. mars: method consists fitting mars model evaluation curve, using identify cutoffs increase evaluation metric. words, method find cutoffs two following conditions: (1) evaluation metric increasing cutoff (2) increase increase slower cutoff. method uses earth::earth(). method probably applied low number partitions (e.g. <= 20) min & max: Picks optimal partition(s) respectively minimum maximum value evaluation metric.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"Please note finding optimal number clusters procedure normally requires decisions users, can hardly fully automatized. Users strongly advised read references indicated look guidance choose optimal number(s) clusters. Consider \"optimal\" numbers clusters returned function first approximation best numbers bioregionalisation.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"Castro-Insua , Gómez-Rodríguez C, Baselga (2018). “Dissimilarity measures affected richness differences yield biased delimitations biogeographic realms.” Nature Communications, 9(1), 9--11. Ficetola GF, Mazel F, Thuiller W (2017). “Global determinants zoogeographical boundaries.” Nature Ecology & Evolution, 1, 0089. Holt BG, Lessard J, Borregaard MK, Fritz SA, Araújo MB, Dimitrov D, Fabre P, Graham CH, Graves GR, Jønsson Ka, Nogués-Bravo D, Wang Z, Whittaker RJ, Fjeldså J, Rahbek C (2013). “update Wallace's zoogeographic regions world.” Science, 339(6115), 74--78. Kreft H, Jetz W (2010). “framework delineating biogeographical regions based species distributions.” Journal Biogeography, 37, 2029--2053. Langfelder P, Zhang B, Horvath S (2008). “Defining clusters hierarchical cluster tree: Dynamic Tree Cut package R.” BIOINFORMATICS, 24(5), 719--720.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"Boris Leroy (leroy.boris@gmail.com), Maxime Lenormand (maxime.lenormand@inrae.fr) Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"","code":"# \\donttest{ dissim <- dissimilarity(fishmat, metric = \"all\")  # User-defined number of clusters tree1 <- hclu_hierarclust(dissim,                           n_clust = 2:50,                           index = \"Simpson\") #> Randomizing the dissimilarity matrix with 30 trials #>  -- range of cophenetic correlation coefficients among #>                      trials: 0.79 - 0.83 #> Optimal tree has a 0.83 cophenetic correlation coefficient with the initial dissimilarity #>       matrix tree1 #> Clustering results for algorithm : hierarchical_clustering  #> \t(hierarchical clustering based on a dissimilarity matrix) #>  - Number of sites:  338  #>  - Name of dissimilarity metric:  Simpson  #>  - Tree construction method:  average  #>  - Randomization of the dissimilarity matrix:  yes, number of trials 30  #>  - Cophenetic correlation coefficient:  0.829  #>  - Number of clusters requested by the user:  2 3 4 5 6 7 8 9 10 11 ... (with 39 more values)  #> Clustering results: #>  - Number of partitions:  49  #>  - Number of clusters:  2 3 4 5 6 7 8 9 10 11 ... (with 39 more values)  #>  - Height of cut of the hierarchical tree: 0.992 0.99 0.969 0.938 0.93 0.906 0.875 0.781 0.75 0.688 ... (with 39 more values)   a <- partition_metrics(tree1,                    dissimilarity = dissim,                    net = fishdf,                    species_col = \"Species\",                    site_col = \"Site\",                    eval_metric = c(\"tot_endemism\",                                    \"avg_endemism\",                                    \"pc_distance\",                                    \"anosim\")) #> Computing similarity-based metrics... #>   - pc_distance OK #>   - anosim OK #> Computing composition-based metrics... #>   - avg_endemism OK #>   - tot_endemism OK                                     find_optimal_n(a) #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 49 #> Searching for potential optimal number(s) of clusters based on the elbow method #>    * elbow found at: #> tot_endemism 26 #> avg_endemism 12 #> pc_distance 13 #> anosim 6 #> Warning: The elbow method is likely not suitable for the ANOSIM metric. You should rather look for leaps in the curve (see criterion = 'increasing_step' or decreasing_step) #> Plotting results...  #> Search for an optimal number of clusters: #>  - 49  partition(s) evaluated #>  - Range of clusters explored: from  2  to  50  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  elbow  #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism - 26 #> avg_endemism - 12 #> pc_distance - 13 #> anosim - 6 find_optimal_n(a, criterion = \"increasing_step\") #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 49 #> Searching for potential optimal number(s) of clusters based on the increasing_step method #>  - Step method #> Warning: Criterion 'increasing_step' cannot work properly with metric 'tot_endemism', because this metric is usually monotonously decreasing. Consider using criterion = 'decreasing_step' instead. #> Plotting results...  #> Search for an optimal number of clusters: #>  - 49  partition(s) evaluated #>  - Range of clusters explored: from  2  to  50  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  increasing_step  #>    (step quantile chosen:  0.99  (i.e., only the top 1 %  increase  in evaluation metrics  are used as break points for the number of clusters) #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism -  #> avg_endemism - 6 #> pc_distance - 6 #> anosim - 6 find_optimal_n(a, criterion = \"decreasing_step\") #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 49 #> Searching for potential optimal number(s) of clusters based on the decreasing_step method #>  - Step method #> Warning: Criterion 'decreasing_step' cannot work properly with metrics 'pc_distance' or 'avg_endemism', because these metrics are usually monotonously decreasing. Consider using criterion = 'increasing_step' instead. #> Plotting results...  #> Search for an optimal number of clusters: #>  - 49  partition(s) evaluated #>  - Range of clusters explored: from  2  to  50  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  decreasing_step  #>    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism - 5 #> avg_endemism - 4 #> pc_distance - 32 #> anosim - 26 find_optimal_n(a, criterion = \"decreasing_step\",                step_levels = 3)  #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 49 #> Searching for potential optimal number(s) of clusters based on the decreasing_step method #>  - Step method #> Warning: Criterion 'decreasing_step' cannot work properly with metrics 'pc_distance' or 'avg_endemism', because these metrics are usually monotonously decreasing. Consider using criterion = 'increasing_step' instead. #> Plotting results...  #> Search for an optimal number of clusters: #>  - 49  partition(s) evaluated #>  - Range of clusters explored: from  2  to  50  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  decreasing_step  #>    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism - 5 13 26 #> avg_endemism - 4 5 9 #> pc_distance - 32 38 41 #> anosim - 24 26 49 find_optimal_n(a, criterion = \"decreasing_step\",                step_quantile = .9)  #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 49 #> Searching for potential optimal number(s) of clusters based on the decreasing_step method #>  - Step method #> Warning: Criterion 'decreasing_step' cannot work properly with metrics 'pc_distance' or 'avg_endemism', because these metrics are usually monotonously decreasing. Consider using criterion = 'increasing_step' instead. #> Plotting results...  #> Search for an optimal number of clusters: #>  - 49  partition(s) evaluated #>  - Range of clusters explored: from  2  to  50  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  decreasing_step  #>    (step quantile chosen:  0.9  (i.e., only the top 10 %  decrease  in evaluation metrics  are used as break points for the number of clusters) #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism - 5 6 13 16 26 #> avg_endemism - 4 5 8 9 11 #> pc_distance - 32 38 41 43 48 #> anosim - 20 21 24 26 49 find_optimal_n(a, criterion = \"decreasing_step\",                step_levels = 3)  #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 49 #> Searching for potential optimal number(s) of clusters based on the decreasing_step method #>  - Step method #> Warning: Criterion 'decreasing_step' cannot work properly with metrics 'pc_distance' or 'avg_endemism', because these metrics are usually monotonously decreasing. Consider using criterion = 'increasing_step' instead. #> Plotting results...  #> Search for an optimal number of clusters: #>  - 49  partition(s) evaluated #>  - Range of clusters explored: from  2  to  50  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  decreasing_step  #>    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism - 5 13 26 #> avg_endemism - 4 5 9 #> pc_distance - 32 38 41 #> anosim - 24 26 49 find_optimal_n(a, criterion = \"decreasing_step\",                step_levels = 3)                  #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 49 #> Searching for potential optimal number(s) of clusters based on the decreasing_step method #>  - Step method #> Warning: Criterion 'decreasing_step' cannot work properly with metrics 'pc_distance' or 'avg_endemism', because these metrics are usually monotonously decreasing. Consider using criterion = 'increasing_step' instead. #> Plotting results...  #> Search for an optimal number of clusters: #>  - 49  partition(s) evaluated #>  - Range of clusters explored: from  2  to  50  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  decreasing_step  #>    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism - 5 13 26 #> avg_endemism - 4 5 9 #> pc_distance - 32 38 41 #> anosim - 24 26 49 b <- find_optimal_n(a, criterion = \"mars\")              #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 49 #> Searching for potential optimal number(s) of clusters based on the mars method #> Plotting results... #>    (the red line is the prediction from MARS models)  # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/fishdf.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of fish in Europe (data.frame) — fishdf","title":"Spatial distribution of fish in Europe (data.frame) — fishdf","text":"dataset containing abundance 195 species 338 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishdf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of fish in Europe (data.frame) — fishdf","text":"","code":"fishdf"},{"path":"https://bioRgeo.github.io/bioregion/reference/fishdf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of fish in Europe (data.frame) — fishdf","text":"data.frame 2,703 rows 3 columns: Site Unique site identifier (corresponding field ID fishsf). Species Unique species identifier. Abundance Species abundance","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of fish in Europe (co-occurrence matrix) — fishmat","title":"Spatial distribution of fish in Europe (co-occurrence matrix) — fishmat","text":"dataset containing abundance 195 species 338 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of fish in Europe (co-occurrence matrix) — fishmat","text":"","code":"fishmat"},{"path":"https://bioRgeo.github.io/bioregion/reference/fishmat.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of fish in Europe (co-occurrence matrix) — fishmat","text":"co-occurrence matrix sites rows species columns. element matrix represents abundance species site.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishsf.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of fish in Europe — fishsf","title":"Spatial distribution of fish in Europe — fishsf","text":"dataset containing geometry 338 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishsf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of fish in Europe — fishsf","text":"","code":"fishsf"},{"path":"https://bioRgeo.github.io/bioregion/reference/fishsf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of fish in Europe — fishsf","text":"ID Unique site identifier. geometry Geometry site.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":null,"dir":"Reference","previous_headings":"","what":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"function generates hierarchical tree dissimilarity (beta-diversity) data.frame, calculates cophenetic correlation coefficient, can get clusters tree requested user. function implements randomization dissimilarity matrix generate tree, selection method based optimal cophenetic correlation coefficient. Typically, dissimilarity data.frame bioregion.pairwise.metric object obtained running similarity similarity similarity_to_dissimilarity.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"","code":"hclu_hierarclust(   dissimilarity,   index = names(dissimilarity)[3],   method = \"average\",   randomize = TRUE,   n_runs = 30,   keep_trials = FALSE,   optimal_tree_method = \"best\",   n_clust = NULL,   cut_height = NULL,   find_h = TRUE,   h_max = 1,   h_min = 0 )"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), next column(s) dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. method name hierarchical classification method, fastcluster::hclust(). one \"ward.D\", \"ward.D2\", \"single\", \"complete\", \"average\" (= UPGMA), \"mcquitty\" (= WPGMA), \"median\" (= WPGMC) \"centroid\" (= UPGMC). randomize boolean indicating dissimilarity matrix randomized, account order sites dissimilarity matrix. n_runs number trials randomize dissimilarity matrix. keep_trials boolean indicating random trial results. stored output object (set FALSE save space dissimilarity object large). optimal_tree_method character vector indicating final tree obtained trials. option currently \"best\", means tree best cophenetic correlation coefficient chosen. n_clust integer vector integers indicating number clusters obtained hierarchical tree, output partition_metrics. used time cut_height. cut_height numeric vector indicating height(s) tree cut. used time n_clust. find_h boolean indicating height cut found requested n_clust. h_max numeric indicating maximum possible tree height chosen index. h_min numeric indicating minimum possible height tree chosen index.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics input dataset algorithm: list objects associated clustering procedure, original cluster objects clusters: data.frame containing clustering results algorithm slot, users can find following elements: trials: list containing randomization trials. trial contains dissimilarity matrix, site order randomized, associated tree cophenetic correlation coefficient (Spearman) tree final.tree: hclust object containing final hierarchical tree used final.tree.coph.cor: cophenetic correlation coefficient initial dissimilarity matrix final.tree","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"default method hierarchical tree \"average\", .e. UPGMA recommended best method generate tree beta diversity dissimilarity (Kreft Jetz 2010) Clusters can obtained two methods: Specifying desired number clusters n_clust Specifying one several heights cut cut_height find optimal number clusters, see partition_metrics()","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"Kreft H, Jetz W (2010). “framework delineating biogeographical regions based species distributions.” Journal Biogeography, 37, 2029--2053.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"Boris Leroy (leroy.boris@gmail.com), Pierre Denelle (pierre.denelle@gmail.com) Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"","code":"# \\donttest{ comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"all\")  # User-defined number of clusters tree1 <- hclu_hierarclust(dissim, n_clust = 5) #> Randomizing the dissimilarity matrix with 30 trials #>  -- range of cophenetic correlation coefficients among #>                      trials: 0.77 - 0.77 #> Optimal tree has a 0.77 cophenetic correlation coefficient with the initial dissimilarity #>       matrix #> Determining the cut height to reach 5 groups... #> --> 0.296875 tree1 #> Clustering results for algorithm : hierarchical_clustering  #> \t(hierarchical clustering based on a dissimilarity matrix) #>  - Number of sites:  20  #>  - Name of dissimilarity metric:  Jaccard  #>  - Tree construction method:  average  #>  - Randomization of the dissimilarity matrix:  yes, number of trials 30  #>  - Cophenetic correlation coefficient:  0.773  #>  - Number of clusters requested by the user:  5  #> Clustering results: #>  - Number of partitions:  1  #>  - Number of clusters:  5  #>  - Height of cut of the hierarchical tree: 0.297  plot(tree1)  str(tree1) #> List of 6 #>  $ name        : chr \"hierarchical_clustering\" #>  $ args        :List of 11 #>   ..$ index              : chr \"Jaccard\" #>   ..$ method             : chr \"average\" #>   ..$ randomize          : logi TRUE #>   ..$ n_runs             : num 30 #>   ..$ optimal_tree_method: chr \"best\" #>   ..$ n_clust            : num 5 #>   ..$ cut_height         : NULL #>   ..$ find_h             : logi TRUE #>   ..$ h_max              : num 1 #>   ..$ h_min              : num 0 #>   ..$ dynamic_tree_cut   : logi FALSE #>  $ inputs      :List of 5 #>   ..$ bipartite      : logi FALSE #>   ..$ weight         : logi TRUE #>   ..$ pairwise_metric: logi TRUE #>   ..$ dissimilarity  : logi TRUE #>   ..$ nb_sites       : int 20 #>  $ algorithm   :List of 5 #>   ..$ trials             : chr \"Trials not stored in output\" #>   ..$ final.tree         :List of 7 #>   .. ..- attr(*, \"class\")= chr \"hclust\" #>   ..$ final.tree.coph.cor: num 0.773 #>   ..$ output_n_clust     : int 5 #>   ..$ output_cut_height  : Named num 0.297 #>   .. ..- attr(*, \"names\")= chr \"k_5\" #>  $ clusters    :'data.frame':\t20 obs. of  2 variables: #>   ..$ ID : chr [1:20] \"Site1\" \"Site20\" \"Site5\" \"Site3\" ... #>   ..$ K_5: chr [1:20] \"1\" \"2\" \"2\" \"1\" ... #>  $ cluster_info:'data.frame':\t1 obs. of  4 variables: #>   ..$ partition_name   : chr \"K_5\" #>   ..$ n_clust          : int 5 #>   ..$ requested_n_clust: num 5 #>   ..$ output_cut_height: num 0.297 #>  - attr(*, \"class\")= chr [1:2] \"bioregion.clusters\" \"list\" tree1$clusters #>            ID K_5 #> Site1   Site1   1 #> Site20 Site20   2 #> Site5   Site5   2 #> Site3   Site3   1 #> Site12 Site12   2 #> Site8   Site8   2 #> Site6   Site6   2 #> Site19 Site19   2 #> Site9   Site9   2 #> Site7   Site7   2 #> Site4   Site4   2 #> Site16 Site16   3 #> Site2   Site2   2 #> Site17 Site17   2 #> Site13 Site13   2 #> Site18 Site18   2 #> Site10 Site10   4 #> Site11 Site11   5 #> Site15 Site15   5 #> Site14 Site14   2  # User-defined height cut # Only one height tree2 <- hclu_hierarclust(dissim, cut_height = .05) #> Randomizing the dissimilarity matrix with 30 trials #>  -- range of cophenetic correlation coefficients among #>                      trials: 0.77 - 0.77 #> Optimal tree has a 0.77 cophenetic correlation coefficient with the initial dissimilarity #>       matrix tree2 #> Clustering results for algorithm : hierarchical_clustering  #> \t(hierarchical clustering based on a dissimilarity matrix) #>  - Number of sites:  20  #>  - Name of dissimilarity metric:  Jaccard  #>  - Tree construction method:  average  #>  - Randomization of the dissimilarity matrix:  yes, number of trials 30  #>  - Cophenetic correlation coefficient:  0.773  #>  - Heights of cut requested by the user:  0.05  #> Clustering results: #>  - Number of partitions:  1  #>  - Number of clusters:  19  #>  - Height of cut of the hierarchical tree: 0.05  tree2$clusters #>        ID K_19 #> 1   Site9    1 #> 2  Site10    2 #> 3  Site15    3 #> 4  Site19    4 #> 5   Site4    5 #> 6  Site11    6 #> 7  Site20    7 #> 8  Site18    8 #> 9   Site3    9 #> 10 Site17   10 #> 11  Site6   11 #> 12  Site1   12 #> 13  Site8   13 #> 14 Site14   14 #> 15  Site2   15 #> 16 Site13   16 #> 17 Site16   17 #> 18  Site7   18 #> 19 Site12   19 #> 20  Site5   13  # Multiple heights tree3 <- hclu_hierarclust(dissim, cut_height = c(.05, .15, .25)) #> Randomizing the dissimilarity matrix with 30 trials #>  -- range of cophenetic correlation coefficients among #>                      trials: 0.77 - 0.77 #> Optimal tree has a 0.77 cophenetic correlation coefficient with the initial dissimilarity #>       matrix  tree3$clusters # Mind the order of height cuts: from deep to shallow cuts #>            ID K_8 K_14 K_19 #> Site10 Site10   1    1    1 #> Site19 Site19   2    2    2 #> Site12 Site12   2    3    3 #> Site18 Site18   2    4    4 #> Site14 Site14   2    2    5 #> Site17 Site17   2    2    6 #> Site16 Site16   3    5    7 #> Site2   Site2   4    6    8 #> Site15 Site15   5    7    9 #> Site6   Site6   2    8   10 #> Site11 Site11   5    9   11 #> Site5   Site5   2    2   12 #> Site9   Site9   2    8   13 #> Site8   Site8   2    2   12 #> Site1   Site1   6   10   14 #> Site20 Site20   2    2   15 #> Site4   Site4   2   11   16 #> Site7   Site7   4   12   17 #> Site3   Site3   7   13   18 #> Site13 Site13   8   14   19 # Info on each partition can be found in table cluster_info tree3$cluster_info #>        partition_name n_clust requested_cut_height #> h_0.25            K_8       8                 0.25 #> h_0.15           K_14      14                 0.15 #> h_0.05           K_19      19                 0.05 plot(tree3)   # Recut the tree afterwards tree3.1 <- cut_tree(tree3, n = 5) #> Determining the cut height to reach 5 groups... #> --> 0.296875  tree4 <- hclu_hierarclust(dissim, n_clust = 1:19) #> Randomizing the dissimilarity matrix with 30 trials #>  -- range of cophenetic correlation coefficients among #>                      trials: 0.77 - 0.77 #> Optimal tree has a 0.77 cophenetic correlation coefficient with the initial dissimilarity #>       matrix # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":null,"dir":"Reference","previous_headings":"","what":"OPTICS hierarchical clustering algorithm — hclu_optics","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"function performs semi-hierarchical clustering basis dissimilarity OPTICS algorithm (Ordering Points Identify Clustering Structure)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"","code":"hclu_optics(   dissimilarity,   index = names(dissimilarity)[3],   minPts = NULL,   eps = NULL,   xi = 0.05,   minimum = FALSE,   show_hierarchy = FALSE,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), next column(s) dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. minPts numeric value specifying minPts argument dbscan::dbscan()). minPts minimum number points form dense region. default, set natural logarithm number sites dissimilarity. eps numeric value specifying eps argument dbscan::optics()). upper limit size epsilon neighborhood. Limiting neighborhood size improves performance little impact ordering long set low. specified (default behavior), largest minPts-distance data set used gives result infinity. xi numeric value specifying steepness threshold identify clusters hierarchically using Xi method (see dbscan::optics()) minimum boolean specifying hierarchy pruned output keep clusters \"minimal\" level, .e. leaf / non-overlapping clusters. TRUE, argument show_hierarchy FALSE show_hierarchy boolean specifying hierarchy clusters included output. default, hierarchy visible clusters obtained OPTICS - can visualized visualising plot OPTICS object. show_hierarchy = TRUE, output cluster data.frame contain additional columns showing hierarchy clusters. ... can add arguments passed optics() (see dbscan::optics())","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics input dataset algorithm: list objects associated clustering procedure, original cluster objects clusters: data.frame containing clustering results","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"optics (Ordering points identify clustering structure) semi-hierarchical clustering algorithm orders points dataset points closest become neighbors, calculates reachability distance point. , clusters can extracted hierarchical manner reachability distance, identifying clusters depending changes relative cluster density. reachability plot explored understand clusters hierarchical nature, running plot output function: plot(object$algorithm$optics). recommend reading (Hahsler et al. 2019)  grasp algorithm, works, clusters mean. extract clusters, use dbscan::extractXi() function based steepness reachability plot (see dbscan::optics())","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"Hahsler M, Piekenbrock M, Doran D (2019). “Dbscan: Fast density-based clustering R.” Journal Statistical Software, 91(1). ISSN 15487660.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"Boris Leroy (leroy.boris@gmail.com), Pierre Denelle (pierre.denelle@gmail.com) Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"","code":"# \\donttest{ dissim <- dissimilarity(fishmat, metric = \"all\")    clust1 <- hclu_optics(dissim, index = \"Simpson\") clust1 #> Clustering results for algorithm : optics  #>  - Number of sites:  338  #> Clustering results: #>  - Number of partitions:  1  #>  - Number of clusters:  4   # Visualize the optics plot (the hierarchy of clusters is illustrated at the # bottom) plot(clust1$algorithm$optics)   # Extract the hierarchy of clusters clust1 <- hclu_optics(dissim, index = \"Simpson\", show_hierarchy = TRUE) #> Error in vec_size(x): `x` must be a vector, not a <data.frame/xics> object. clust1 #> Clustering results for algorithm : optics  #>  - Number of sites:  338  #> Clustering results: #>  - Number of partitions:  1  #>  - Number of clusters:  4  # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":null,"dir":"Reference","previous_headings":"","what":"Download, unzip, check permission and test the bioregion's binary files — install_binaries","title":"Download, unzip, check permission and test the bioregion's binary files — install_binaries","text":"function downloads unzips 'bin' folder needed run functions bioregion. also checks files permissions executed programs. finally tests binary files running properly.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download, unzip, check permission and test the bioregion's binary files — install_binaries","text":"","code":"install_binaries(binpath = \"tempdir\", infomap_version = c(\"2.1.0\", \"2.6.0\"))"},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download, unzip, check permission and test the bioregion's binary files — install_binaries","text":"binpath character indicating path folder host 'bin' folder containing binary files (see Details). infomap_version character vector indicating Infomap version(s) install.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Download, unzip, check permission and test the bioregion's binary files — install_binaries","text":"default, binary files installed R's temporary directory (binpath = \"tempdir\"). case 'bin' folder automatically removed end R session. Alternatively, binary files can installed bioregion's package folder (binpath = \"pkgfolder\"). Finally, path folder choice can chosen. Please sure update binpath accordingly netclu_infomap, netclu_louvain netclu_oslom).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Download, unzip, check permission and test the bioregion's binary files — install_binaries","text":"Infomap version 2.1.0 2.6.0 available now.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Download, unzip, check permission and test the bioregion's binary files — install_binaries","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Boris Leroy (leroy.boris@gmail.com) Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_clusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a map of bioregions — map_clusters","title":"Create a map of bioregions — map_clusters","text":"plot function can used visualise bioregions based bioregion.clusters object combined geometry (sf objects).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_clusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a map of bioregions — map_clusters","text":"","code":"map_clusters(clusters, geometry, write_clusters = FALSE, plot = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/map_clusters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a map of bioregions — map_clusters","text":"clusters object class bioregion.clusters data.frame. data.frame used, first column represent sites' ID, next column(s) clusters. geometry spatial object can handled sf package. first attribute correspond sites' ID (see Details). write_clusters boolean indicating clusters added geometry. plot boolean indicating plot drawn.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_clusters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a map of bioregions — map_clusters","text":"One several maps bioregions plot = TRUE geometry additional clusters' attributes write_clusters = TRUE.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_clusters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a map of bioregions — map_clusters","text":"clusters geometry site IDs correspond. type (.e. character cluster bioregion.clusters object) site clusters included sites geometry.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_clusters.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a map of bioregions — map_clusters","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Boris Leroy (leroy.boris@gmail.com) Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_clusters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a map of bioregions — map_clusters","text":"","code":"# \\donttest{ data(fishmat) data(fishsp) #> Warning: data set ‘fishsp’ not found  net <- similarity(fishmat, metric = \"Simpson\") clu <- netclu_greedy(net) map <- map_clusters(clu, fishsf, write_clusters = TRUE, plot = FALSE) # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a data.frame from a contingency table — mat_to_net","title":"Create a data.frame from a contingency table — mat_to_net","text":"function creates two- three-columns data.frame row represents interaction two nodes (site species example) optional third column indicating weight interaction (weight = TRUE) contingency table (sites rows species columns example).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a data.frame from a contingency table — mat_to_net","text":"","code":"mat_to_net(mat, weight = FALSE, remove_zeroes = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a data.frame from a contingency table — mat_to_net","text":"mat contingency table (.e. matrix). weight boolean indicating value weights. remove_zeroes boolean determining whether interactions weight equal 0 removed output.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a data.frame from a contingency table — mat_to_net","text":"data.frame row represents interaction two nodes optional third column indicating weight interaction.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a data.frame from a contingency table — mat_to_net","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a data.frame from a contingency table — mat_to_net","text":"","code":"# \\donttest{ mat <- matrix(sample(1000, 50), 5, 10) rownames(mat) <- paste0(\"Site\", 1:5) colnames(mat) <- paste0(\"Species\", 1:10)  net <- mat_to_net(mat, weight = TRUE) # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a contingency table from a data.frame — net_to_mat","title":"Create a contingency table from a data.frame — net_to_mat","text":"function creates contingency table two- three-columns data.frame row represents interaction two nodes (site species example) optional third column indicating weight interaction (weight = TRUE).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a contingency table from a data.frame — net_to_mat","text":"","code":"net_to_mat(   net,   weight = FALSE,   squared = FALSE,   symmetrical = FALSE,   missing_value = 0 )"},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a contingency table from a data.frame — net_to_mat","text":"net two- three-columns data.frame row represents interaction two nodes (site species example) optional third column indicating weight interaction. weight boolean indicating weight considered squared boolean indicating output matrix squared (nodes rows columns). symmetrical boolean indicating resulting matrix symmetrical (squared = TRUE). Note different weights associated two opposite pairs already present net preserved. missing_value value assign pairs nodes present net (0 default).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a contingency table from a data.frame — net_to_mat","text":"matrix first nodes (first column net) rows second nodes (second column net) columns. Note squared = TRUE rows columns number elements corresponding concatenation unique objects net's first second columns. squared = TRUE matrix can forced symmetrical based upper triangular part matrix.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a contingency table from a data.frame — net_to_mat","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a contingency table from a data.frame — net_to_mat","text":"","code":"# \\donttest{ net <- data.frame(   Site = c(rep(\"A\", 2), rep(\"B\", 3), rep(\"C\", 2)),   Species = c(\"a\", \"b\", \"a\", \"c\", \"d\", \"b\", \"d\"),   Weight = c(10, 100, 1, 20, 50, 10, 20) )  mat <- net_to_mat(net, weight = TRUE) # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":null,"dir":"Reference","previous_headings":"","what":"Community structure detection in weighted bipartite network via modularity\noptimization — netclu_beckett","title":"Community structure detection in weighted bipartite network via modularity\noptimization — netclu_beckett","text":"function takes bipartite weighted graph computes modules applying Newman’s modularity measure bipartite weighted version .","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Community structure detection in weighted bipartite network via modularity\noptimization — netclu_beckett","text":"","code":"netclu_beckett(   net,   weight = TRUE,   index = names(net)[3],   site_col = 1,   species_col = 2,   return_node_type = \"both\",   forceLPA = FALSE,   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Community structure detection in weighted bipartite network via modularity\noptimization — netclu_beckett","text":"net data.frame representing bipartite network two first columns undirected links pair nodes next column(s) weight links. weight boolean indicating weights considered two columns (see Note). index name number column use weight. default, third column name net used. site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"sites\", \"species\" \"\") returned output (keep_nodes_type=\"\" default). forceLPA boolean indicating even faster pure LPA-algorithm Beckett used? DIRT-LPA, default, less likely get trapped local minimum, slightly slower. Defaults FALSE. algorithm_in_output boolean indicating original output computeModules returned output (see Value). Default TRUE.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Community structure detection in weighted bipartite network via modularity\noptimization — netclu_beckett","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics input dataset algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find object class \"moduleWeb\", output computeModules.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Community structure detection in weighted bipartite network via modularity\noptimization — netclu_beckett","text":"function based modularity optimization algorithm provided Stephen Beckett (Beckett 2016)  implemented bipartite package (computeModules).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Community structure detection in weighted bipartite network via modularity\noptimization — netclu_beckett","text":"Beckett designed deal weighted bipartite networks. Note weight = FALSE, weight 1 assigned pair nodes. forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes,\"sites\" preserve sites nodes \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Community structure detection in weighted bipartite network via modularity\noptimization — netclu_beckett","text":"Beckett SJ (2016). “Improved community detection weighted bipartite networks.” Royal Society Open Science, 3(1), 140536.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Community structure detection in weighted bipartite network via modularity\noptimization — netclu_beckett","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Community structure detection in weighted bipartite network via modularity\noptimization — netclu_beckett","text":"","code":"# \\donttest{ net <- data.frame(   Site = c(rep(\"A\", 2), rep(\"B\", 3), rep(\"C\", 2)),   Species = c(\"a\", \"b\", \"a\", \"c\", \"d\", \"b\", \"d\"),   Weight = c(10, 100, 1, 20, 50, 10, 20))  com <- netclu_beckett(net) # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":null,"dir":"Reference","previous_headings":"","what":"Community structure detection via greedy optimization of modularity — netclu_greedy","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"function finds communities (un)weighted undirected network via greedy optimization modularity.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"","code":"netclu_greedy(   net,   weight = TRUE,   index = names(net)[3],   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. index name number column use weight. default, third column name net used. bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"sites\", \"species\" \"\") returned output (keep_nodes_type=\"\" default). algorithm_in_output boolean indicating original output communities returned output (see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics input dataset algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find \"communities\" object, output cluster_fast_greedy.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"function based fast greedy modularity optimization algorithm (Clauset et al. 2004)  implemented igraph package (cluster_fast_greedy).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"sites\" preserve sites nodes \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"Clauset , Newman MEJ, Moore C (2004). “Finding community structure large networks.” Phys. Rev. E, 70, 066111.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"","code":"# \\donttest{ comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_greedy(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_greedy(net_bip, bipartite = TRUE) # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":null,"dir":"Reference","previous_headings":"","what":"Infomap community finding — netclu_infomap","title":"Infomap community finding — netclu_infomap","text":"function finds communities (un)weighted (un)directed network based Infomap algorithm (https://github.com/mapequation/infomap).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Infomap community finding — netclu_infomap","text":"","code":"netclu_infomap(   net,   weight = TRUE,   index = names(net)[3],   nbmod = 0,   markovtime = 1,   seed = 0,   numtrials = 1,   twolevel = FALSE,   show_hierarchy = FALSE,   directed = FALSE,   bipartite_version = FALSE,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   version = \"2.6.0\",   binpath = \"tempdir\",   path_temp = \"infomap_temp\",   delete_temp = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Infomap community finding — netclu_infomap","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. index name number column use weight. default, third column name net used. nbmod penalize solutions differ number (0 default preferred number modules). markovtime scales link flow change cost moving modules, higher values results fewer modules (default 1). seed random number generator (0 random default). numtrials number trials picking best solution. twolevel boolean indicating algorithm optimize two-level partition network (default multi-level). show_hierarchy boolean specifying hierarchy community identifiable outputs (FALSE default). directed boolean indicating network directed (column 1 column 2). bipartite_version boolean indicating bipartite version Infomap used (see Note). bipartite boolean indicating network bipartite (see Note). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"sites\", \"species\" \"\") returned output (keep_nodes_type=\"\" default). version character indicating Infomap version use. binpath character indicating path bin folder (see install_binaries Details). path_temp character indicating path temporary folder (see Details). delete_temp boolean indicating temporary folder removed (see Details).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Infomap community finding — netclu_infomap","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics input dataset algorithm: list objects associated clustering procedure, original cluster objects clusters: data.frame containing clustering results algorithm slot, users can find following elements: cmd: command line use run Infomap version: Infomap version web: Infomap's GitHub repository","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Infomap community finding — netclu_infomap","text":"Infomap network clustering algorithm based Map equation proposed (Rosvall Bergstrom 2008)  finds communities (un)weighted (un)directed networks. function based C++ version Infomap (https://github.com/mapequation/infomap/releases). function needs binary files run. can installed install_binaries. set path folder host bin folder running install_binaries please make sure set binpath accordingly. C++ version Infomap generates temporary folders /files stored path_temp folder (\"infomap_temp\" unique timestamp located bin folder binpath default). temporary folder removed default (delete_temp = TRUE). Several version Infomap available package. See install_binaries details.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Infomap community finding — netclu_infomap","text":"Infomap designed deal bipartite networks. use functionality set bipartite_version argument TRUE order approximate two-step random walker (see https://www.mapequation.org/infomap/ information). Note bipartite network can also considered unipartite network (bipartite = TRUE). cases forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"sites\" preserve sites nodes \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Infomap community finding — netclu_infomap","text":"Rosvall M, Bergstrom CT (2008). “Maps random walks complex networks reveal community structure.” Proceedings National Academy Sciences, 105(4), 1118--1123.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Infomap community finding — netclu_infomap","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Infomap community finding — netclu_infomap","text":"","code":"# \\donttest{ comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_infomap(net) #> Infomap 2.6.0 is not installed... Please have a look at #>     https//bioRgeo.github.io/bioregion/articles/a1_install_binary_files.html #>     for more details. #> It should be located in /tmp/RtmpH65oRk/bin/INFOMAP/2.6.0/ # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":null,"dir":"Reference","previous_headings":"","what":"Finding communities based on propagating labels — netclu_labelprop","title":"Finding communities based on propagating labels — netclu_labelprop","text":"function finds communities (un)weighted undirected network based propagating labels.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finding communities based on propagating labels — netclu_labelprop","text":"","code":"netclu_labelprop(   net,   weight = TRUE,   index = names(net)[3],   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finding communities based on propagating labels — netclu_labelprop","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. index name number column use weight. default, third column name net used. bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"sites\", \"species\" \"\") returned output (keep_nodes_type=\"\" default). algorithm_in_output boolean indicating original output communities returned output (see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finding communities based on propagating labels — netclu_labelprop","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics input dataset algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find \"communities\" object, output cluster_label_prop.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finding communities based on propagating labels — netclu_labelprop","text":"function based propagating labels (Raghavan et al. 2007)  implemented igraph package (cluster_label_prop).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Finding communities based on propagating labels — netclu_labelprop","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"sites\" preserve sites nodes \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Finding communities based on propagating labels — netclu_labelprop","text":"Raghavan UN, Albert R, Kumara S (2007). “Near linear time algorithm detect community structures large-scale networks.” Physical Review E, 76(3), 036106.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finding communities based on propagating labels — netclu_labelprop","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finding communities based on propagating labels — netclu_labelprop","text":"","code":"# \\donttest{ comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_labelprop(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_labelprop(net_bip, bipartite = TRUE) # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":null,"dir":"Reference","previous_headings":"","what":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"function finds communities (un)weighted undirected network based leading eigen vector community matrix.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"","code":"netclu_leadingeigen(   net,   weight = TRUE,   index = names(net)[3],   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. index name number column use weight. default, third column name net used. bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"sites\", \"species\" \"\") returned output (keep_nodes_type=\"\" default). algorithm_in_output boolean indicating original output communities returned output (see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics input dataset algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find \"communities\" object, output cluster_leading_eigen.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"function based leading eigenvector community matrix (Newman 2006)  implemented igraph package (cluster_leading_eigen).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"sites\" preserve sites nodes \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"Newman MEJ (2006). “Finding community structure networks using eigenvectors matrices.” Physical Review E, 74(3), 036104.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"","code":"# \\donttest{ comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_leadingeigen(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_leadingeigen(net_bip, bipartite = TRUE) # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":null,"dir":"Reference","previous_headings":"","what":"Finding communities using the Leiden algorithm — netclu_leiden","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"function finds communities (un)weighted undirected network based Leiden algorithm Traag, van Eck & Waltman.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"","code":"netclu_leiden(   net,   weight = TRUE,   index = names(net)[3],   objective_function = c(\"CPM\", \"modularity\"),   resolution_parameter = 1,   beta = 0.01,   initial_membership = NULL,   n_iterations = 2,   vertex_weights = NULL,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. index name number column use weight. default, third column name net used. objective_function Whether use Constant Potts Model (CPM) modularity. Must either \"CPM\" \"modularity\". resolution_parameter resolution parameter use. Higher resolutions lead smaller communities, lower resolutions lead fewer larger communities. beta Parameter affecting randomness Leiden algorithm. affects refinement step algorithm. initial_membership provided, Leiden algorithm try improve provided membership. argument provided, aglorithm simply starts singleton partition. n_iterations number iterations iterate Leiden algorithm. iteration may improve partition . vertex_weights vertex weights used Leiden algorithm. provided, automatically determined basis objective_function. Please see details function interpret vertex weights. bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"sites\", \"species\" \"\") returned output (keep_nodes_type=\"\" default). algorithm_in_output boolean indicating original output communities returned output (see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics input dataset algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find \"communities\" object, output cluster_leiden.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"function based Leiden algorithm (Traag et al. 2019)  implemented igraph package (cluster_leiden).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"sites\" preserve sites nodes \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"Traag VA, Waltman L, Van Eck NJ (2019). “Louvain Leiden: guaranteeing well-connected communities.” Scientific reports, 9(1), 5233. Publisher: Nature Publishing Group UK London.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"","code":"# \\donttest{ comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_leiden(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_leiden(net_bip, bipartite = TRUE) # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":null,"dir":"Reference","previous_headings":"","what":"Louvain community finding — netclu_louvain","title":"Louvain community finding — netclu_louvain","text":"function finds communities (un)weighted undirected network based Louvain algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Louvain community finding — netclu_louvain","text":"","code":"netclu_louvain(   net,   weight = TRUE,   index = names(net)[3],   lang = \"Cpp\",   q = 0,   c = 0.5,   k = 1,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   binpath = \"tempdir\",   path_temp = \"louvain_temp\",   delete_temp = TRUE,   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Louvain community finding — netclu_louvain","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. index name number column use weight. default, third column name net used. lang string indicating version Louvain used (igraph Cpp, see Details). q quality function used compute partition graph (modularity chosen default, see Details). c parameter Owsinski-Zadrozny quality function (0 1, 0.5 chosen default). k kappa_min value Shi-Malik quality function (must > 0, 1 chosen default). bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"sites\", \"species\" \"\") returned output (keep_nodes_type=\"\" default). binpath character indicating path bin folder (see install_binaries Details). path_temp character indicating path temporary folder (see Details). delete_temp boolean indicating temporary folder removed (see Details). algorithm_in_output boolean indicating original output communities returned output (see Value). Default TRUE.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Louvain community finding — netclu_louvain","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics input dataset algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find \"communities\" object, output cluster_louvain lang = \"igraph\" following element lang = \"Cpp\": cmd: command line use run Louvain version: Louvain version web: Louvain's website .","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Louvain community finding — netclu_louvain","text":"Louvain network community detection algorithm proposed (Blondel et al. 2008) . function proposed two implementations function (parameter lang): igraph implementation (cluster_louvain) C++ implementation (https://sourceforge.net/projects/louvain/, version 0.3). latest offers possibility choose among several quality functions, q = 0 classical Newman-Girvan criterion (also called \"Modularity\"), 1 Zahn-Condorcet criterion, 2 Owsinski-Zadrozny criterion (specify value parameter c argument), 3 Goldberg Density criterion, 4 -weighted Condorcet criterion,5 Deviation Indetermination criterion, 6 Deviation Uniformity criterion, 7 Profile Difference criterion, 8\tShi-Malik criterion (specify value kappa_min k argument) 9 Balanced Modularity criterion. C++ version Louvain based version 0.3 (https://sourceforge.net/projects/louvain/). function needs binary files run. can installed install_binaries. set path folder host bin folder running install_binaries please make sure set binpath accordingly. C++ version Louvain generates temporary folders /files stored path_temp folder (\"louvain_temp\" unique timestamp located bin folder binpath default). temporary folder removed default (delete_temp = TRUE).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Louvain community finding — netclu_louvain","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"sites\" preserve sites nodes \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Louvain community finding — netclu_louvain","text":"Blondel VD, Guillaume JL, Lambiotte R, Mech ELJS (2008). “Fast unfolding communities large networks.” J. Stat. Mech, P10008.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Louvain community finding — netclu_louvain","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Louvain community finding — netclu_louvain","text":"","code":"# \\donttest{ comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_louvain(net, lang = \"igraph\") # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":null,"dir":"Reference","previous_headings":"","what":"OSLOM community finding — netclu_oslom","title":"OSLOM community finding — netclu_oslom","text":"function finds communities (un)weighted (un)directed network based OSLOM algorithm (http://oslom.org/, version 2.4).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OSLOM community finding — netclu_oslom","text":"","code":"netclu_oslom(   net,   weight = TRUE,   index = names(net)[3],   reassign = \"no\",   r = 10,   hr = 50,   seed = 0,   t = 0.1,   cp = 0.5,   directed = FALSE,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   binpath = \"tempdir\",   path_temp = \"oslom_temp\",   delete_temp = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OSLOM community finding — netclu_oslom","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. index name number column use weight. default, third column name net used. reassign string indicating nodes belonging several community reassign method used (see Note). r number runs first hierarchical level (10 default). hr number runs higher hierarchical level (50 default, 0 interested hierarchies). seed random number generator (0 random default). t p-value, default value 0.10, increase value get modules. cp kind resolution parameter used decide taking modules union (default value 0.5, bigger value leads bigger clusters). directed boolean indicating network directed (column 1 column 2). bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"sites\", \"species\" \"\") returned output (keep_nodes_type=\"\" default). binpath character indicating path bin folder (see install_binaries Details). path_temp character indicating path temporary folder (see Details). delete_temp boolean indicating temporary folder removed (see Details).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"OSLOM community finding — netclu_oslom","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics input dataset algorithm: list objects associated clustering procedure, original cluster objects clusters: data.frame containing clustering results algorithm slot, users can find following elements: cmd: command line use run OSLOM version: OSLOM version web: OSLOM's web site","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"OSLOM community finding — netclu_oslom","text":"OSLOM network community detection algorithm proposed (Lancichinetti et al. 2011)  finds statistically significant (overlapping) communities (un)weighted (un)directed networks. function based 2.4 C++ version OSLOM (http://www.oslom.org/software.htm). function needs files run. can installed install_binaries. set path folder host bin folder running install_binaries please make sure set binpath accordingly. C++ version OSLOM generates temporary folders /files stored path_temp folder (folder \"oslom_temp\" unique timestamp located bin folder binpath default). temporary folder removed default (delete_temp = TRUE).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"OSLOM community finding — netclu_oslom","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e.feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"sites\" preserve sites nodes \"species\" preserve species nodes. Since OSLOM potentially returns overlapping communities propose two methods reassign 'overlapping' nodes randomly reassign = 'random' based closest candidate community reassign = 'simil' (weighted networks, case closest candidate community determined average similarity). default reassign = '' information provided. number partitions depend number overlapping modules (three). suffix '_semel', '_bis' '_ter' added column names. first partition ('_semel') assigns module node. value 0 second ('_bis') third ('_ter') columns indicates overlapping module found node (.e. non-overlapping nodes).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"OSLOM community finding — netclu_oslom","text":"Lancichinetti , Radicchi F, Ramasco JJ, Fortunato S (2011). “Finding statistically significant communities networks.” PloS one, 6(4).","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"OSLOM community finding — netclu_oslom","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OSLOM community finding — netclu_oslom","text":"","code":"if (FALSE) { comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_oslom(net) }"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Community structure detection via short random walks — netclu_walktrap","title":"Community structure detection via short random walks — netclu_walktrap","text":"function finds communities (un)weighted undirected network via short random walks.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Community structure detection via short random walks — netclu_walktrap","text":"","code":"netclu_walktrap(   net,   weight = TRUE,   index = names(net)[3],   steps = 4,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Community structure detection via short random walks — netclu_walktrap","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. index name number column use weight. default, third column name net used. steps length random walks perform. bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"sites\", \"species\" \"\") returned output (keep_nodes_type=\"\" default). algorithm_in_output boolean indicating original output communities returned output (see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Community structure detection via short random walks — netclu_walktrap","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics input dataset algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find \"communities\" object, output cluster_walktrap.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Community structure detection via short random walks — netclu_walktrap","text":"function based random walks (Pons Latapy 2005)  implemented igraph package (cluster_walktrap).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Community structure detection via short random walks — netclu_walktrap","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"sites\" preserve sites nodes \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Community structure detection via short random walks — netclu_walktrap","text":"Pons P, Latapy M (2005). “Computing Communities Large Networks Using Random Walks.” Yolum , Güngör T, Gürgen F, Özturan C (eds.), Computer Information Sciences - ISCIS 2005,  Lecture Notes Computer Science, 284--293.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Community structure detection via short random walks — netclu_walktrap","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Community structure detection via short random walks — netclu_walktrap","text":"","code":"# \\donttest{ comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_walktrap(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_walktrap(net_bip, bipartite = TRUE) # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":null,"dir":"Reference","previous_headings":"","what":"dbscan clustering — nhclu_dbscan","title":"dbscan clustering — nhclu_dbscan","text":"function performs non hierarchical clustering basis dissimilarity Density-based Spatial Clustering Applications Noise (DBSCAN)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dbscan clustering — nhclu_dbscan","text":"","code":"nhclu_dbscan(   dissimilarity,   index = names(dissimilarity)[3],   minPts = NULL,   eps = NULL,   plot = TRUE,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dbscan clustering — nhclu_dbscan","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), next column(s) dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. minPts numeric value vector numeric values specifying minPts argument dbscan::dbscan()). minPts minimum number points form dense region. default, set natural logarithm number sites dissimilarity. See details guidance choosing parameter. eps numeric value vector numeric values specifying eps argument dbscan::dbscan()). eps specifies similar points considered part cluster. See details guidance choosing parameter. plot boolean indicating  k-nearest neighbor distance plot plotted. ... can add arguments passed dbscan() (see dbscan::dbscan())","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dbscan clustering — nhclu_dbscan","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics input dataset algorithm: list objects associated clustering procedure, original cluster objects clusters: data.frame containing clustering results","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"dbscan clustering — nhclu_dbscan","text":"dbscan (Density-based spatial clustering applications noise) clustering algorithm clusters points basis density neighbours around data points. necessitates two main arguments, minPts, stands minimum number points identify core, eps, radius find neighbors. minPts eps defined user, straightforward. recommend reading help dbscan::dbscan()) learn set arguments, well paper (Hahsler et al. 2019) . Note clusters value 0 points deemed noise algorithm. default function select values minPts eps. However, values can inadequate users advised tune values running function multiple times. Choosing minPts: many points necessary make cluster? .e., minimum number sites expect bioregion? Set value sufficiently large dataset expectations. Choosing eps: similar sites cluster?  eps small, majority points considered distinct clustered (.e., considered noise)? value high, clusters merge together. value eps depends minPts argument, literature recommends choose eps identifying knee k-nearest neighbor distance plot. default function try automatically find knee curve, result uncertain, user inspect graph modify dbscan_eps accordingly.explore eps values, follow recommendation function launch first time without defining eps. , adjust depending clustering results.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"dbscan clustering — nhclu_dbscan","text":"Boris Leroy (leroy.boris@gmail.com), Pierre Denelle (pierre.denelle@gmail.com) Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dbscan clustering — nhclu_dbscan","text":"","code":"# \\donttest{ dissim <- dissimilarity(fishmat, metric = \"all\")  clust1 <- nhclu_dbscan(dissim, index = \"Simpson\") #> Trying to find a knee in the curve to search for an optimal eps value... #>        NOTE: this automatic identification of the knee may not work properly #>        if the curve has knees and elbows. Please adjust eps manually by #>        inspecting the curve, identifying a knee as follows: #>  #>                            / #>                  curve    / #>               ___________/  <- knee #>   elbow ->   / #>             / #>            /  clust2 <- nhclu_dbscan(dissim, index = \"Simpson\", eps = 0.2)  clust3 <- nhclu_dbscan(dissim, index = \"Simpson\", minPts = c(5, 10, 15, 20),      eps = c(.1, .15, .2, .25, .3))     # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":null,"dir":"Reference","previous_headings":"","what":"Non hierarchical clustering: k-means analysis — nhclu_kmeans","title":"Non hierarchical clustering: k-means analysis — nhclu_kmeans","text":"function performs non hierarchical clustering basis dissimilarity k-means analysis.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non hierarchical clustering: k-means analysis — nhclu_kmeans","text":"","code":"nhclu_kmeans(   dissimilarity,   index = names(dissimilarity)[3],   n_clust = NULL,   iter_max = 10,   nstart = 10,   algorithm = \"Hartigan-Wong\" )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non hierarchical clustering: k-means analysis — nhclu_kmeans","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), next column(s) dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. n_clust integer vector integers specifying requested number(s) clusters iter_max integer specifying maximum number iterations kmeans method (see stats::kmeans()) nstart integer specifying many random sets n_clust selected starting points kmeans analysis (see stats::kmeans()) algorithm character string specifying algorithm use kmean (see stats::kmeans()). Available options Hartigan-Wong, Lloyd, Forgy MacQueen.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non hierarchical clustering: k-means analysis — nhclu_kmeans","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics input dataset algorithm: list objects associated clustering procedure, original cluster objects clusters: data.frame containing clustering results","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non hierarchical clustering: k-means analysis — nhclu_kmeans","text":"method partitions data k groups sum squares euclidean distances points assigned cluster centers minimized. k-means applied directly dissimilarity/beta-diversity metrics, distances euclidean. Therefore, requires first transform dissimilarity matrix Principal Coordinate Analysis (using function ape::pcoa()), applying k-means coordinates points PCoA. makes additional transformation initial matrix dissimilarity, partitioning around medoids method preferred (nhclu_pam())","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non hierarchical clustering: k-means analysis — nhclu_kmeans","text":"Boris Leroy (leroy.boris@gmail.com), Pierre Denelle (pierre.denelle@gmail.com) Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non hierarchical clustering: k-means analysis — nhclu_kmeans","text":"","code":"# \\donttest{ dissim <- dissimilarity(fishmat, metric = \"all\")  clust1 <- nhclu_kmeans(dissim, n_clust = 2:10, index = \"Simpson\") clust2 <- nhclu_kmeans(dissim, n_clust = 2:25, index = \"Simpson\") partition_metrics(clust2, dissimilarity = dissim,                    eval_metric = \"pc_distance\") #> Computing similarity-based metrics... #>   - pc_distance OK #> Partition metrics: #>  - 24  partition(s) evaluated #>  - Range of clusters explored: from  2  to  25  #>  - Requested metric(s):  pc_distance  #>  - Metric summary: #>      pc_distance #> Min    0.6669141 #> Mean   0.9422323 #> Max    0.9898197 #>  #> Access the data.frame of metrics with your_object$evaluation_df  partition_metrics(clust2, net = fishdf, species_col = \"Species\",                    site_col = \"Site\", eval_metric = \"avg_endemism\") #> Computing composition-based metrics... #>   - avg_endemism OK #> Partition metrics: #>  - 24  partition(s) evaluated #>  - Range of clusters explored: from  2  to  25  #>  - Requested metric(s):  avg_endemism  #>  - Metric summary: #>      avg_endemism #> Min    0.08207398 #> Mean   0.16178385 #> Max    0.57629179 #>  #> Access the data.frame of metrics with your_object$evaluation_df #> Details of endemism % for each partition are available in  #>         your_object$endemism_results # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":null,"dir":"Reference","previous_headings":"","what":"Non hierarchical clustering: partitioning around medoids — nhclu_pam","title":"Non hierarchical clustering: partitioning around medoids — nhclu_pam","text":"function performs non hierarchical clustering basis dissimilarity partitioning around medoids.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non hierarchical clustering: partitioning around medoids — nhclu_pam","text":"","code":"nhclu_pam(   dissimilarity,   index = names(dissimilarity)[3],   n_clust = NULL,   nstart = if (variant == \"faster\") 1 else NA,   variant = \"faster\",   cluster_only = FALSE,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non hierarchical clustering: partitioning around medoids — nhclu_pam","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), next column(s) dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. n_clust integer vector integers specifying requested number(s) clusters. nstart integer specifying number random “starts” pam algorithm. default, 1 (\"faster\" variant). variant character string specifying variant pam use, default \"faster\". Available options original, o_1, o_2, f_3, f_4, f_5 fasterSee cluster::pam() details. cluster_only boolean specifying clustering returned cluster::pam() function (efficient). ... can add arguments passed pam() (see cluster::pam())","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non hierarchical clustering: partitioning around medoids — nhclu_pam","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics input dataset algorithm: list objects associated clustering procedure, original cluster objects clusters: data.frame containing clustering results","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non hierarchical clustering: partitioning around medoids — nhclu_pam","text":"method partitions data chosen number cluster basis input dissimilarity matrix. robust k-means minimizes sum dissimilarity cluster centres points assigned cluster - whereas k-means approach minimizes sum squared euclidean distances (thus k-means applied directly input dissimilarity matrix distances euclidean).","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non hierarchical clustering: partitioning around medoids — nhclu_pam","text":"Boris Leroy (leroy.boris@gmail.com), Pierre Denelle (pierre.denelle@gmail.com) Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non hierarchical clustering: partitioning around medoids — nhclu_pam","text":"","code":"# \\donttest{ dissim <- dissimilarity(fishmat, metric = \"all\")  clust1 <- nhclu_pam(dissim, n_clust = 2:10, index = \"Simpson\") clust2 <- nhclu_pam(dissim, n_clust = 2:25, index = \"Simpson\") partition_metrics(clust2, dissimilarity = dissim, eval_metric = \"pc_distance\") #> Computing similarity-based metrics... #>   - pc_distance OK #> Partition metrics: #>  - 24  partition(s) evaluated #>  - Range of clusters explored: from  2  to  25  #>  - Requested metric(s):  pc_distance  #>  - Metric summary: #>      pc_distance #> Min    0.5464742 #> Mean   0.7997407 #> Max    0.8996280 #>  #> Access the data.frame of metrics with your_object$evaluation_df partition_metrics(clust2, net = fishdf, species_col = \"Species\",                    site_col = \"Site\", eval_metric = \"avg_endemism\") #> Computing composition-based metrics... #>   - avg_endemism OK #> Partition metrics: #>  - 24  partition(s) evaluated #>  - Range of clusters explored: from  2  to  25  #>  - Requested metric(s):  avg_endemism  #>  - Metric summary: #>      avg_endemism #> Min     0.1482677 #> Mean    0.2771854 #> Max     0.5845317 #>  #> Access the data.frame of metrics with your_object$evaluation_df #> Details of endemism % for each partition are available in  #>         your_object$endemism_results # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/partition_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate metrics for one or several partitions — partition_metrics","title":"Calculate metrics for one or several partitions — partition_metrics","text":"function aims calculating metrics one several partitions, usually outputs netclu_, hclu_ nhclu_ functions. Metrics may require users provide either similarity dissimilarity matrix, provide initial species-site table.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/partition_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate metrics for one or several partitions — partition_metrics","text":"","code":"partition_metrics(   cluster_object,   dissimilarity = NULL,   dissimilarity_index = NULL,   net = NULL,   site_col = 1,   species_col = 2,   eval_metric = c(\"pc_distance\", \"anosim\", \"avg_endemism\", \"tot_endemism\") )"},{"path":"https://bioRgeo.github.io/bioregion/reference/partition_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate metrics for one or several partitions — partition_metrics","text":"cluster_object tree bioregion.clusters object dissimilarity dist object bioregion.pairwise.metric object (output similarity_to_dissimilarity()). Necessary eval_metric includes pc_distance tree bioregion.hierar.tree object dissimilarity_index character string indicating dissimilarity (beta-diversity) index used case dist data.frame multiple dissimilarity indices net species-site network (.e., bipartite network). provided eval_metric includes \"avg_endemism\" \"tot_endemism\" site_col name number column site nodes (.e. primary nodes). provided eval_metric includes \"avg_endemism\" \"tot_endemism\" species_col name number column species nodes (.e. feature nodes). provided eval_metric includes \"avg_endemism\" \"tot_endemism\" eval_metric character string vector character strings indicating metric(s) calculated investigate effect different number clusters. Available options: \"pc_distance\", \"anosim\", \"avg_endemism\" \"tot_endemism\"","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/partition_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate metrics for one or several partitions — partition_metrics","text":"list class bioregion.partition.metrics two three elements: args: input arguments evaluation_df: data.frame containing eval_metric explored numbers clusters endemism_results: endemism calculations requested, list endemism results partition","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/partition_metrics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate metrics for one or several partitions — partition_metrics","text":"Evaluation metrics: pc_distance: metric method used (Holt et al. 2013) . ratio -cluster sum dissimilarity (beta-diversity) versus total sum dissimilarity (beta-diversity) full dissimilarity matrix. words, calculated basis two elements. First, total sum dissimilarity calculated summing entire dissimilarity matrix (dist). Second, -cluster sum dissimilarity calculated follows: given number cluster, dissimilarity summed clusters, within clusters. efficiently, pairs sites within clusters dissimilarity set zero dissimilarity matrix, dissimilarity matrix summed. pc_distance ratio obtained dividing -cluster sum dissimilarity total sum dissimilarity. anosim: metric statistic used Analysis Similarities, suggested (Castro-Insua et al. 2018)  (see vegan::anosim()). compares -cluster dissimilarities within-cluster dissimilarities. based based difference mean ranks groups within groups following formula: \\(R = (r_B - r_W)/(N (N-1) / 4)\\), \\(r_B\\) \\(r_W\\) average ranks within clusters respectively, \\(N\\) total number sites. Note function estimate significance , computes statistic - significance testing see vegan::anosim(). avg_endemism: metric average percentage endemism clusters recommended (Kreft Jetz 2010) . Calculated follows: \\(End_{mean} = \\frac{\\sum_{=1}^K E_i / S_i}{K}\\) \\(E_i\\) number endemic species cluster , \\(S_i\\) number species cluster , K maximum number clusters. tot_endemism: metric total endemism across clusters, recommended (Kreft Jetz 2010) . Calculated follows: \\(End_{tot} = \\frac{E}{C}\\)\\(E\\) total number endemics (.e., species found one cluster) \\(C\\) number non-endemic species.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/partition_metrics.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate metrics for one or several partitions — partition_metrics","text":"Castro-Insua , Gómez-Rodríguez C, Baselga (2018). “Dissimilarity measures affected richness differences yield biased delimitations biogeographic realms.” Nature Communications, 9(1), 9--11. Ficetola GF, Mazel F, Thuiller W (2017). “Global determinants zoogeographical boundaries.” Nature Ecology & Evolution, 1, 0089. Holt BG, Lessard J, Borregaard MK, Fritz SA, Araújo MB, Dimitrov D, Fabre P, Graham CH, Graves GR, Jønsson Ka, Nogués-Bravo D, Wang Z, Whittaker RJ, Fjeldså J, Rahbek C (2013). “update Wallace's zoogeographic regions world.” Science, 339(6115), 74--78. Kreft H, Jetz W (2010). “framework delineating biogeographical regions based species distributions.” Journal Biogeography, 37, 2029--2053. Langfelder P, Zhang B, Horvath S (2008). “Defining clusters hierarchical cluster tree: Dynamic Tree Cut package R.” BIOINFORMATICS, 24(5), 719--720.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/partition_metrics.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate metrics for one or several partitions — partition_metrics","text":"Boris Leroy (leroy.boris@gmail.com), Maxime Lenormand (maxime.lenormand@inrae.fr) Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/partition_metrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate metrics for one or several partitions — partition_metrics","text":"","code":"# \\donttest{ dissim <- dissimilarity(fishmat, metric = \"all\")  # User-defined number of clusters tree1 <- hclu_hierarclust(dissim, n_clust = 2:20, index = \"Simpson\") #> Randomizing the dissimilarity matrix with 30 trials #>  -- range of cophenetic correlation coefficients among #>                      trials: 0.8 - 0.83 #> Optimal tree has a 0.83 cophenetic correlation coefficient with the initial dissimilarity #>       matrix tree1 #> Clustering results for algorithm : hierarchical_clustering  #> \t(hierarchical clustering based on a dissimilarity matrix) #>  - Number of sites:  338  #>  - Name of dissimilarity metric:  Simpson  #>  - Tree construction method:  average  #>  - Randomization of the dissimilarity matrix:  yes, number of trials 30  #>  - Cophenetic correlation coefficient:  0.828  #>  - Number of clusters requested by the user:  2 3 4 5 6 7 8 9 10 11 ... (with 9 more values)  #> Clustering results: #>  - Number of partitions:  19  #>  - Number of clusters:  2 3 4 5 6 7 8 9 10 11 ... (with 9 more values)  #>  - Height of cut of the hierarchical tree: 0.992 0.99 0.969 0.945 0.938 0.875 0.859 0.812 0.75 0.719 ... (with 9 more values)   a <- partition_metrics(tree1, dissimilarity = dissim, net = fishdf,                   site_col = \"Site\", species_col = \"Species\",                   eval_metric = c(\"tot_endemism\", \"avg_endemism\",                                   \"pc_distance\", \"anosim\")) #> Computing similarity-based metrics... #>   - pc_distance OK #>   - anosim OK #> Computing composition-based metrics... #>   - avg_endemism OK #>   - tot_endemism OK a #> Partition metrics: #>  - 19  partition(s) evaluated #>  - Range of clusters explored: from  2  to  20  #>  - Requested metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  - Metric summary: #>      tot_endemism avg_endemism pc_distance    anosim #> Min     0.5282051    0.2272652   0.1398730 0.6954843 #> Mean    0.6742240    0.3910500   0.5703020 0.8240596 #> Max     0.9435897    0.8188070   0.7755036 0.8611714 #>  #> Access the data.frame of metrics with your_object$evaluation_df #> Details of endemism % for each partition are available in  #>         your_object$endemism_results # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute similarity metrics between sites based on species composition — similarity","title":"Compute similarity metrics between sites based on species composition — similarity","text":"function creates data.frame row provides one several similarity metric(s) pair sites co-occurrence matrix sites rows species columns.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute similarity metrics between sites based on species composition — similarity","text":"","code":"similarity(comat, metric = \"Simpson\", formula = NULL, method = \"prodmat\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute similarity metrics between sites based on species composition — similarity","text":"comat co-occurrence matrix sites rows species columns. metric vector string(s) indicating similarity metric(s) chose (see Details). \"\" specified, metrics calculated. Can set NULL formula used. formula vector string(s) formula based , b, c, , B, C quantities (see Details). formula set NULL default. method string indicating method used compute abc (see Details). method = \"prodmat\" default efficient can greedy memory method=\"loops\" less efficient less greedy memory.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute similarity metrics between sites based on species composition — similarity","text":"data.frame additional class bioregion.pairwise.metric, providing one several similarity metric(s) pair sites. two first columns represent pair sites. One column per similarity metric provided metric formula except metric abc ABC stored three columns (one letter).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute similarity metrics between sites based on species composition — similarity","text":"number species shared pair sites, b species present first site c species present second site. \\(Jaccard = 1 - (b + c) / (+ b + c)\\) \\(Jaccardturn = 1 - 2min(b, c) / (+ 2min(b, c))\\) (Baselga 2012) \\(Sorensen = 1 - (b + c) / (2a + b + c)\\) \\(Simpson = 1 - min(b, c) / (+ min(b, c))\\) abundances data available, Bray-Curtis turnover component can also computed following equation: \\(Bray = 1 - (B + C) / (2A + B + C)\\) \\(Brayturn = 1 - min(B, C)/(+ min(B, C))\\) (Baselga 2013) sum lesser values common species shared pair sites. B C total number specimens counted sites minus . formula can used compute customized metrics terms , b, c, , B, C. example formula = c(\"1 - (b + c) / (+ b + c)\", \"1 - (B + C) / (2*+ B + C)\") compute Jaccard Bray-Curtis similarity metrics, respectively. Euclidean computes Euclidean similarity pair site following equation: \\(Euclidean = 1 / (1 + d_{ij})\\) \\(d_{ij}\\) Euclidean distance site site j terms species composition.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute similarity metrics between sites based on species composition — similarity","text":"Baselga (2012). “Relationship Species Replacement, Dissimilarity Derived Nestedness, Nestedness.” Global Ecology Biogeography, 21(12), 1223--1232. Baselga (2013). “Separating two components abundance-based dissimilarity: balanced changes abundance vs. abundance gradients.” Methods Ecology Evolution, 4(6), 552--557.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute similarity metrics between sites based on species composition — similarity","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute similarity metrics between sites based on species composition — similarity","text":"","code":"# \\donttest{ comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  simil <- similarity(comat, metric = c(\"abc\", \"ABC\", \"Simpson\", \"Brayturn\"))  simil <- similarity(comat, metric = \"all\", formula = \"1 - (b + c) / (a + b + c)\") # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert similarity indices to dissimilarity metrics — similarity_to_dissimilarity","title":"Convert similarity indices to dissimilarity metrics — similarity_to_dissimilarity","text":"function converts data.frame similarity metrics sites dissimilarity metrics (= beta diversity).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert similarity indices to dissimilarity metrics — similarity_to_dissimilarity","text":"","code":"similarity_to_dissimilarity(similarity)"},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert similarity indices to dissimilarity metrics — similarity_to_dissimilarity","text":"similarity output object similarity() data.frame first columns called \"Site1\" \"Site2\", columns similarity metrics.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert similarity indices to dissimilarity metrics — similarity_to_dissimilarity","text":"data.frame additional class bioregion.pairwise.metric, providing one several similarity metric(s) pair sites. two first columns represent pair sites, column represent similarity metrics. Columns names \"\", \"b\", \"c\", \"\", \"B\" \"C\"  altered.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert similarity indices to dissimilarity metrics — similarity_to_dissimilarity","text":"behavior function changes depending column names. Columns \"Site1\" \"Site2\" copied identically. columns called \"\", \"b\", \"c\", \"\", \"B\", \"C\", also copied identically. column called \"Euclidean\", distance calculated based following formula: \\(Euclidean distance = (1 - Euclidean similarity) / Euclidean similarity\\) Otherwise, columns transformed dissimilarity following formula: \\(dissimilarity = 1 - similarity\\)","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert similarity indices to dissimilarity metrics — similarity_to_dissimilarity","text":"Boris Leroy (leroy.boris@gmail.com), Maxime Lenormand (maxime.lenormand@inrae.fr) Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert similarity indices to dissimilarity metrics — similarity_to_dissimilarity","text":"","code":"# \\donttest{ comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  simil <- similarity(comat, metric = \"all\") simil #> Data.frame of similarity between sites #>  - Total number of sites:  5  #>  - Number of rows:  10  #>  - Number of similarity metrics:  7  #>  #>  #>    Site1 Site2   Jaccard Jaccardturn  Sorensen   Simpson       Bray   Brayturn #> 2  Site1 Site2 0.7000000   0.7777778 0.8235294 0.8750000 0.43721357 0.51904244 #> 3  Site1 Site3 0.7000000   0.7777778 0.8235294 0.8750000 0.19498607 0.80924855 #> 4  Site1 Site4 0.7000000   0.7777778 0.8235294 0.8750000 0.07150675 0.07759303 #> 5  Site1 Site5 0.8000000   0.8000000 0.8888889 0.8888889 0.08709677 0.13567839 #> 8  Site2 Site3 0.6000000   0.6000000 0.7500000 0.7500000 0.13186813 0.41618497 #> 9  Site2 Site4 0.7777778   0.7777778 0.8750000 0.8750000 0.28368794 0.36996736 #> 10 Site2 Site5 0.7000000   0.7777778 0.8235294 0.8750000 0.04485488 0.05695142 #> 14 Site3 Site4 0.6000000   0.6000000 0.7500000 0.7500000 0.09448819 0.45086705 #> 15 Site3 Site5 0.8888889   1.0000000 0.9411765 1.0000000 0.21818182 0.48554913 #> 20 Site4 Site5 0.7000000   0.7777778 0.8235294 0.8750000 0.06843373 0.11892797 #>       Euclidean a b c   A    B    C #> 2  0.0020743265 7 2 1 477  786  442 #> 3  0.0015379020 7 2 1 140 1123   33 #> 4  0.0008108403 7 2 1  98 1165 1380 #> 5  0.0011854783 8 1 1  81 1182  516 #> 8  0.0022275480 6 2 2  72  847  101 #> 9  0.0009369168 7 1 1 340  579 1138 #> 10 0.0014338840 7 1 2  34  885  563 #> 14 0.0010057835 6 2 2  78   95 1400 #> 15 0.0019570072 8 0 1  84   89  513 #> 20 0.0008948127 7 1 2  71 1407  526  dissimilarity <- similarity_to_dissimilarity(simil) dissimilarity #> Data.frame of dissimilarity between sites #>  - Total number of sites:  5  #>  - Number of rows:  10  #>  - Number of dissimilarity metrics:  7  #>  #>  #>    Site1 Site2   Jaccard Jaccardturn   Sorensen   Simpson      Bray  Brayturn #> 2  Site1 Site2 0.3000000   0.2222222 0.17647059 0.1250000 0.5627864 0.4809576 #> 3  Site1 Site3 0.3000000   0.2222222 0.17647059 0.1250000 0.8050139 0.1907514 #> 4  Site1 Site4 0.3000000   0.2222222 0.17647059 0.1250000 0.9284933 0.9224070 #> 5  Site1 Site5 0.2000000   0.2000000 0.11111111 0.1111111 0.9129032 0.8643216 #> 8  Site2 Site3 0.4000000   0.4000000 0.25000000 0.2500000 0.8681319 0.5838150 #> 9  Site2 Site4 0.2222222   0.2222222 0.12500000 0.1250000 0.7163121 0.6300326 #> 10 Site2 Site5 0.3000000   0.2222222 0.17647059 0.1250000 0.9551451 0.9430486 #> 14 Site3 Site4 0.4000000   0.4000000 0.25000000 0.2500000 0.9055118 0.5491329 #> 15 Site3 Site5 0.1111111   0.0000000 0.05882353 0.0000000 0.7818182 0.5144509 #> 20 Site4 Site5 0.3000000   0.2222222 0.17647059 0.1250000 0.9315663 0.8810720 #>    Euclidean a b c   A    B    C #> 2   481.0842 7 2 1 477  786  442 #> 3   649.2365 7 2 1 140 1123   33 #> 4  1232.2885 7 2 1  98 1165 1380 #> 5   842.5414 8 1 1  81 1182  516 #> 8   447.9241 6 2 2  72  847  101 #> 9  1066.3306 7 1 1 340  579 1138 #> 10  696.4065 7 1 2  34  885  563 #> 14  993.2497 6 2 2  78   95 1400 #> 15  509.9843 8 0 1  84   89  513 #> 20 1116.5523 7 1 2  71 1407  526 # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/vegedf.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","title":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","text":"dataset containing abundance 3,697 species 715 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegedf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","text":"","code":"vegedf"},{"path":"https://bioRgeo.github.io/bioregion/reference/vegedf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","text":"data.frame 460,878 rows 3 columns: Site Unique site identifier (corresponding field ID vegesp). Species Unique species identifier. Abundance Species abundance","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegedf.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","text":"https://onlinelibrary.wiley.com/doi/full/10.1002/ece3.4718","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegemat.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","title":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","text":"dataset containing abundance 3,697 species 715 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegemat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","text":"","code":"vegemat"},{"path":"https://bioRgeo.github.io/bioregion/reference/vegemat.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","text":"co-occurrence matrix sites rows species columns. element matrix represents abundance species site.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegemat.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","text":"https://onlinelibrary.wiley.com/doi/full/10.1002/ece3.4718","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegesf.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","title":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","text":"dataset containing geometry 715 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegesf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","text":"","code":"vegesf"},{"path":"https://bioRgeo.github.io/bioregion/reference/vegesf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","text":"ID Unique site identifier. geometry Geometry site.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegesf.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","text":"https://onlinelibrary.wiley.com/doi/full/10.1002/ece3.4718","code":""},{"path":"https://bioRgeo.github.io/bioregion/news/index.html","id":"bioregion-v010-release-date-20--","dir":"Changelog","previous_headings":"","what":"bioregion v0.1.0 (Release date: 20??-??-??)","title":"bioregion v0.1.0 (Release date: 20??-??-??)","text":"First release GitHub","code":""}]
