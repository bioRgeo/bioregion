[{"path":"https://bioRgeo.github.io/bioregion/TODO.html","id":"issues-in-french-some-of-them-may-have-already-been-fixed","dir":"","previous_headings":"","what":"Issues (in French, some of them may have already been fixed).","title":"NA","text":"nhbclu_clara et clarans - bien vérifier le problème de seed… site_species_metrics - Ajouter un test pour bipartite_link ? - Changer le nom bipartite_link (net dans bioregionalization_metrics) ? - Problèmes avec affinity, fidelity et indicator_value : - Plantage lorsqu’ils sont utilisés seuls (problème avec names(p_ij) non défini). - Seulement rho et cz spécifié dans la documentation. - Problème de contradiction entre la documentation et la fonction pour cluster_object (peut-utiliser un data.frame ou une liste de data.frame ?) ? bioregion_metrics - Problème de contradiction entre la documentation et la fonction pour cluster_object (peut-utiliser un data.frame ou une liste de data.frame ?) ? - bug comat_not_j <- comat[-(rownames(comat) %% sites_j), ] quand un seul site dans une bioregion j’ai l’impression #’ comat <- matrix(sample(1000, 50), 5, 10) #’ rownames(comat) <- paste0(“Site”, 1:5) #’ colnames(comat) <- paste0(“Species”, 1:10) #’ #’ net <- similarity(comat, metric = “Simpson”) #’ clust <- netclu_greedy(net) #’ #’ bioregion_metrics(bioregionalization = clust, #’ comat = comat) bioregionalizations_metrics - bioregion.partition.metrics ? utilise les termes cluster_object, clusters, partition, partitions, bioregionalizations de manière interchangeable. Faut-il harmoniser les noms ? - Ajouter data.frame et dist dans les entrées possibles. - Documentation étrange pour dissimilarity (tree ?) find_optimal_n - Changer le nom partitions ? - Le data.frame avec les colonnes K et n_clusters trop contraignant ? - Test valeurs NA (et d’autres tests) pour le data.frame ? - Problème avec les valeurs min et max (voir tests) ? compare_bioregionalizations - Ajouter un test pour vérifier les data.frame et adapter les contrôles pour les listes de data.frame ? - Ajouter une colonne ID pour chaque data.frame ? - Imaginer un méta-objet bioregion.clusters permettant de fusionner les sorties des algorithmes ?","code":""},{"path":"https://bioRgeo.github.io/bioregion/TODO.html","id":"new-functions","dir":"","previous_headings":"","what":"New functions","title":"NA","text":"Add fuzzy clustering methods from_abcABC (compute metrics abc /ABC). reassign_cluster (assign reassign cluster based partition (dis)similarity metric) + spatial coherence (reassignment sites) between_bioregions_metrics() => ‘beta-diversity’ bioregions, output: matrix/network, produces results like Lenormand et al. 2019 Function visualize network (maybe visNetwork()) between_bioregions_metrics()","code":""},{"path":"https://bioRgeo.github.io/bioregion/TODO.html","id":"new-features","dir":"","previous_headings":"","what":"New features","title":"NA","text":"Allow launch OPTICS vector parameter values (kmeans). Parallelize clu_ functions. https://stats.stackexchange.com/questions/260487/adjusted-rand-index-vs-adjusted-mutual-information Code IHCT Rcpp","code":""},{"path":"https://bioRgeo.github.io/bioregion/TODO.html","id":"miscellaneous","dir":"","previous_headings":"","what":"Miscellaneous","title":"NA","text":"data-raw ?","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a1_install_binary_files.html","id":"run-install_binaries","dir":"Articles","previous_headings":"","what":"1. Run install_binaries()","title":"1. Installation of the binary files","text":"function install_binaries run prior using netclu_infomap, Cpp version netclu_louvain netclu_oslom follows. function three parameters. binpath indicating path folder host bin folder containing binary files. default, binary files installed R’s temporary directory (binpath = \"tempdir\"). case bin folder automatically removed end R session. Alternatively, binary files can installed bioregion’s package folder (binpath = \"pkgfolder\"). folder can chosen case PLEASE MAKE SURE update binpath argument netclu_infomap, netclu_louvain netclu_oslom accordingly. Note case, case, download_only can set TRUE (first step executed), must ensure files necessary permissions executed programs otherwise. third parameter infomap_version indicating Infomap version(s) install. Infomap version 2.1.0, 2.6.0, 2.7.1 2.8.0 available now. installation binary files divided six steps: Download bin.zip Unzip bin.zip binpath Check permissions, try change automatically propose iterative process change manually Test Infomap running properly Test Louvain running properly Test OSLOM running properly function designed help change permissions third step. Subsequently, binary files Infomap, Louvain, OSLOM tested, file check.txt added folder bin/INFOMAP/X.X.X, bin/LOUVAIN bin/OSLOM inform package netclu_infomap, netclu_louvain netclu_oslom can used without issues. However, may happen (particularly macOS) function fails automatically manually assist changing permissions. case, set argument download_only TRUE download bin.zip folder myfolder choice (different tempdir pkgfolder) can manually change permissions . Note ; package able test binary files running netclu_infomap, netclu_louvain netclu_oslom (.e., check.txt added folders…). bypass automatic check using functions, use argument check_install = FALSE, without guarantee success.","code":"install_binaries(binpath = \"tempdir\" ,                  download_only =  FALSE,                  infomap_version = c(\"2.1.0\",                                       \"2.6.0\",                                      \"2.7.1\",                                      \"2.8.0\")) ## ## 1. Download bin.zip ## ## The folder has been successfully downloaded to /tmp/RtmpjTeghK. ## ## 2. Unzip folder ## ## The folder has been successfully unzipped in /tmp/RtmpjTeghK. ## ## 3. Check permissions ## ## Permission to execute /tmp/RtmpjTeghK/bin/INFOMAP/2.1.0/infomap_omp_lin as program: denied. ## Permission to execute /tmp/RtmpjTeghK/bin/INFOMAP/2.1.0/infomap_noomp_lin as program: denied. ## Permission to execute /tmp/RtmpjTeghK/bin/INFOMAP/2.6.0/infomap_omp_lin as program: denied. ## Permission to execute /tmp/RtmpjTeghK/bin/INFOMAP/2.6.0/infomap_noomp_lin as program: denied. ## Permission to execute /tmp/RtmpjTeghK/bin/INFOMAP/2.7.1/infomap_omp_lin as program: denied. ## Permission to execute /tmp/RtmpjTeghK/bin/INFOMAP/2.7.1/infomap_noomp_lin as program: denied. ## Permission to execute /tmp/RtmpjTeghK/bin/INFOMAP/2.8.0/infomap_omp_lin as program: denied. ## Permission to execute /tmp/RtmpjTeghK/bin/INFOMAP/2.8.0/infomap_noomp_lin as program: denied. ## Permission to execute /tmp/RtmpjTeghK/bin/LOUVAIN/convert_lin as program: denied. ## Permission to execute /tmp/RtmpjTeghK/bin/LOUVAIN/louvain_lin as program: denied. ## Permission to execute /tmp/RtmpjTeghK/bin/OSLOM/oslom_dir_lin as program: denied. ## Permission to execute /tmp/RtmpjTeghK/bin/OSLOM/oslom_undir_lin as program: denied. ## ## Try to change permissions automatically ## ## Automatic change of permission succeed, /tmp/RtmpjTeghK/bin/INFOMAP/2.1.0/infomap_omp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpjTeghK/bin/INFOMAP/2.1.0/infomap_noomp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpjTeghK/bin/INFOMAP/2.6.0/infomap_omp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpjTeghK/bin/INFOMAP/2.6.0/infomap_noomp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpjTeghK/bin/INFOMAP/2.7.1/infomap_omp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpjTeghK/bin/INFOMAP/2.7.1/infomap_noomp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpjTeghK/bin/INFOMAP/2.8.0/infomap_omp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpjTeghK/bin/INFOMAP/2.8.0/infomap_noomp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpjTeghK/bin/LOUVAIN/convert_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpjTeghK/bin/LOUVAIN/louvain_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpjTeghK/bin/OSLOM/oslom_dir_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpjTeghK/bin/OSLOM/oslom_undir_lin can now be executed as progam. ## ## 4. Test Infomap ## ## Congratulation, you successfully install the 2.1.0 OpenMP version of Infomap! ## Congratulation, you successfully install the 2.6.0 OpenMP version of Infomap! ## Congratulation, you successfully install the 2.7.1 OpenMP version of Infomap! ## Congratulation, you successfully install the 2.8.0 OpenMP version of Infomap! ## ## 5. Test Louvain ## ## Congratulation, you successfully install the version 0.3 of Louvain! ## ## 6. Test OSLOM ## ## Congratulation, you successfully install the version 2.5 of OSLOM! install_binaries(binpath = \"myfolder\" ,                  download_only =  TRUE,                  infomap_version = c(\"2.1.0\",                                       \"2.6.0\",                                      \"2.7.1\",                                      \"2.8.0\"))  comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_infomap(net,                       binpath = \"myfolder\",                       check_install = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a1_install_binary_files.html","id":"known-issues","dir":"Articles","previous_headings":"","what":"2. Known issues","title":"1. Installation of the binary files","text":"OpenMP versions Infomap require libomp-dev Ubuntu (sudo apt-get install libomp-dev) libomp macOS (install Homebrew run brew install libomp).","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a2_matrix_and_network_formats.html","id":"load-data","dir":"Articles","previous_headings":"","what":"1. Load data","title":"2. Matrix and network formats","text":"bioregion’s package contains example dataset spatial distribution Mediterranean vegetation. dataset analyzed article contains abundance 3,697 species 715 sites. dataset composed three files, vegedf data.frame 460,878 rows 3 columns (Site, Species Abundance), vegemat co-occurrence matrix containing information gathered matrix 715 rows 3,697 columns, vegesf spatial object containing geometry 715 sites.","code":"data(vegedf) head(vegedf) ##   Site Species Abundance ## 1   35   10017         1 ## 2   35   10024        18 ## 3   35   10034         1 ## 4   35   10035         1 ## 5   35   10056         2 ## 6   35   10080         3 dim(vegedf) ## [1] 460878      3 sum(!duplicated(vegedf[,1])) ## [1] 715 sum(!duplicated(vegedf[,2])) ## [1] 3697 data(vegemat) vegemat[1:10,1:10] ##     Species ## Site 10001 10002 10003 10004 10005 10006 10007 10008 10009 10010 ##   35     0     0     0     0     0     0     0     0     0     0 ##   36     2     0     0     0     0     0     1    12     0     0 ##   37     0     0     0     0     0     0     0     0     0     0 ##   38     0     0     0     0     0     0     0     0     0     0 ##   39     5     0     0     0     0     0     0     2     0     0 ##   84     0     0     0     0     0     0     0     0     0     0 ##   85     3     0     0     0     0     0     1     7     0     0 ##   86     0     0     0     2     0     0     2    22     0     0 ##   87    16     0     0     0     0     0     2    54     0     0 ##   88   228     0     0     0     0     0     0     5     0     0 dim(vegemat) ## [1]  715 3697"},{"path":"https://bioRgeo.github.io/bioregion/articles/a2_matrix_and_network_formats.html","id":"from-matrix-to-network","dir":"Articles","previous_headings":"","what":"2. From matrix to network","title":"2. Matrix and network formats","text":"function mat_to_net transforms co-occurrence matrix vegemat network represented data.frame (vegedf case). weight = TRUE third column added values contained matrix. line network format, two first columns named Node1 Node2 default. remove_zeroes = TRUE pairs nodes weight equal 0 removed output.","code":"net <- mat_to_net(vegemat, weight = TRUE, remove_zeroes = FALSE) head(net) ##   Node1 Node2 Weight ## 1    35 10001      0 ## 2    35 10002      0 ## 3    35 10003      0 ## 4    35 10004      0 ## 5    35 10005      0 ## 6    35 10006      0 dim(net) ## [1] 2643355       3 net <- mat_to_net(vegemat, weight = TRUE, remove_zeroes = TRUE) head(net) ##    Node1 Node2 Weight ## 17    35 10017      1 ## 24    35 10024     18 ## 34    35 10034      1 ## 35    35 10035      1 ## 56    35 10056      2 ## 80    35 10080      3 dim(net) ## [1] 460878      3"},{"path":"https://bioRgeo.github.io/bioregion/articles/a2_matrix_and_network_formats.html","id":"from-network-to-matrix","dir":"Articles","previous_headings":"","what":"3. From network to matrix","title":"2. Matrix and network formats","text":"function net_to_mat opposite. transforms network represented two- three-columns data.frame (vegedf) co-occurrence matrix (vegemat case). squared = TRUE squared matrix generated, rownames colnames correspond concatenation without duplicates two first columns data.frame. argument missing_value defines value assign pairs nodes present input network. default value 0 numeric value can used. Finally, squared = TRUE possible get symmetrical matrix output (symmetrical = TRUE). case resulting squared matrix symmetrical, except symmetrical pairs nodes already present input network (35 <-> 36) example .","code":"mat <- net_to_mat(vegedf, weight = TRUE, squared = FALSE, symmetrical = FALSE, missing_value = 0) mat[1:5,1:5] ##    10017 10024 10034 10035 10056 ## 35     1    18     1     1     2 ## 36   252    57    72    19    75 ## 37    66     1    13    23    43 ## 38    17     1     5    89    27 ## 39    17    17    34     3     8 dim(mat) ## [1]  715 3697 mat <- net_to_mat(vegedf, weight = TRUE, squared = TRUE, symmetrical = FALSE, missing_value = 0) mat[1:5,1:5] ##    35 36 37 38 39 ## 35  0  0  0  0  0 ## 36  0  0  0  0  0 ## 37  0  0  0  0  0 ## 38  0  0  0  0  0 ## 39  0  0  0  0  0 dim(mat) ## [1] 4412 4412 temp <- data.frame(Site=c(\"35\",\"36\",\"36\",\"38\",\"39\"), Species=c(\"36\",\"35\",\"37\",\"37\",\"39\"), Abundance=c(1,2,3,4,0)) net <- rbind(temp,vegedf) mat <- net_to_mat(net, weight = TRUE, squared = TRUE, symmetrical = FALSE, missing_value = -1) mat[1:5,1:5] ##    35 36 38 39 37 ## 35 -1  1 -1 -1 -1 ## 36  2 -1 -1 -1  3 ## 38 -1 -1 -1 -1  4 ## 39 -1 -1 -1  0 -1 ## 37 -1 -1 -1 -1 -1 mat <- net_to_mat(net, weight = TRUE, squared = TRUE, symmetrical = TRUE, missing_value = 0) mat[1:5,1:5] ##    35 36 38 39 37 ## 35  0  1  0  0  0 ## 36  2  0  0  0  3 ## 38  0  0  0  0  4 ## 39  0  0  0  0  0 ## 37  0  3  4  0  0"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"compute-pairwise-similarity-metrics","dir":"Articles","previous_headings":"","what":"1. Compute pairwise similarity metrics","title":"3. Pairwise similarity/dissimilarity metrics","text":"function similarity computes well-known customized pairwise similarity metrics based co-occurrence matrix, vegemat. example , Simpson similarity index computed pair sites. resulting data.frame stored bioregion.pairwise.metric object, contains Simpson similarity metric pair sites. function similarity can handle three types metrics: metrics based abc, metrics based ABC, one metric based Euclidean distance. first kind metrics Jaccard, turnover component Jaccard (Baselga, 2012), Simpson Sørensen based presence data \\(\\) number species shared pair sites, \\(b\\) species present first site \\(c\\) species present second site. \\[\\displaystyle Jaccard = 1 - \\frac{b + c}{+ b + c}\\] \\[\\displaystyle Jaccardturn = 1 - \\frac{2 \\cdot min(b, c)}{+ 2 \\cdot min(b, c)}\\] \\[\\displaystyle Sorensen = 1 - \\frac{b + c}{2 \\cdot + b + c}\\] \\[\\displaystyle Simpson = 1 - \\frac{min(b, c)}{+ min(b, c)}\\] Two methods can used compute abc based metrics. first method based matrix product (performed tcrossprod function R package Matrix). method fast greedy memory… second method based three loops function coded C++ largely inspired bcdist function R package ecodist (version 2.0.7). less efficient matrix product allows handle co-occurrence matrix large number sites /species. second kind metrics Bray-Curtis turnover component Bray-Curtis (Baselga, 2012) based abundance data \\(\\) sum lesser values common species shared pair sites. \\(B\\) \\(C\\) total number specimens counted sites minus \\(\\). three loops function available ABC based metrics. \\[\\displaystyle Bray = 1 - \\frac{B + C}{2 \\cdot + B + C}\\] \\[\\displaystyle Brayturn = 1 - \\frac{min(B, C)}{+ min(B, C)}\\] main advantage similarity function compute return several metrics, allow computation customized metric formula argument include possibility returning quantities \\(\\), \\(b\\) \\(c\\) /\\(\\), \\(B\\) \\(C\\). feature particularly interesting compute similarity metrics large co-occurrence matrix. also possible compute Euclidean similarity pair sites following equation: \\[\\displaystyle Euclidean = \\frac{1}{1 + d_{ij}}\\] \\(d_{ij}\\) Euclidean distance site \\(\\) site \\(j\\) terms species composition.","code":"sim <- similarity(vegemat,                    metric = \"Simpson\",                    formula = NULL,                    method = \"prodmat\") sim[1:10,] ## Data.frame of similarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  3697  ##  - Number of rows:  255255  ##  - Number of similarity metrics:  1  ##  ##  ##    Site1 Site2   Simpson ## 2     35    36 0.9767442 ## 3     35    37 0.9689922 ## 4     35    38 0.9457364 ## 5     35    39 0.9457364 ## 6     35    84 0.2790698 ## 7     35    85 0.9147287 ## 8     35    86 1.0000000 ## 9     35    87 0.9922481 ## 10    35    88 0.9844961 ## 11    35    89 0.6821705 sim <- similarity(vegemat,                    metric = c(\"abc\",\"ABC\",\"Simpson\",\"Bray\"),                    formula = c(\"1 - pmin(b,c) / (a + pmin(b,c))\", \"1 - (B + C) / (2*A + B + C)\")) sim[1:10,] ## Data.frame of similarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  3697  ##  - Number of rows:  255255  ##  - Number of similarity metrics:  4  ##  ##  ##    Site1 Site2   Simpson       Bray   a  b   c   A   B     C ## 2     35    36 0.9767442 0.01901485 126  3 741 420   3 43333 ## 3     35    37 0.9689922 0.03745203 125  4 534 366  57 18756 ## 4     35    38 0.9457364 0.04025289 122  7 440 347  76 16471 ## 5     35    39 0.9457364 0.09754761 122  7 501 356  67  6520 ## 6     35    84 0.2790698 0.18757921  36 93 177  74 349   292 ## 7     35    85 0.9147287 0.13256181 118 11 614 378  45  4902 ## 8     35    86 1.0000000 0.02663928 129  0 753 415   8 30319 ## 9     35    87 0.9922481 0.02332663 128  1 909 406  17 33981 ## 10    35    88 0.9844961 0.02198536 127  2 812 395  28 35115 ## 11    35    89 0.6821705 0.15954416  88 41 177 196 227  1838 ##    1 - pmin(b,c) / (a + pmin(b,c)) 1 - (B + C) / (2*A + B + C) ## 2                        0.9767442                  0.01901485 ## 3                        0.9689922                  0.03745203 ## 4                        0.9457364                  0.04025289 ## 5                        0.9457364                  0.09754761 ## 6                        0.2790698                  0.18757921 ## 7                        0.9147287                  0.13256181 ## 8                        1.0000000                  0.02663928 ## 9                        0.9922481                  0.02332663 ## 10                       0.9844961                  0.02198536 ## 11                       0.6821705                  0.15954416"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"compute-pairwise-dissimilarity-metrics","dir":"Articles","previous_headings":"","what":"2. Compute pairwise dissimilarity metrics","title":"3. Pairwise similarity/dissimilarity metrics","text":"dissimilarity function similar, sole exception computes dissimilarity version available metrics. corresponds 1 minus similarity metrics, except Euclidean dissimilarity, corresponds Euclidean distance (.e. \\(d_{ij}\\)).","code":"dissim <- dissimilarity(vegemat,                          metric = \"Sorensen\",                          formula = \"(b + c) / (2*a + b + c)\") dissim[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  3697  ##  - Number of rows:  255255  ##  - Number of dissimilarity metrics:  2  ##  ##  ##    Site1 Site2  Sorensen (b + c) / (2*a + b + c) ## 2     35    36 0.7469880               0.7469880 ## 3     35    37 0.6827411               0.6827411 ## 4     35    38 0.6468886               0.6468886 ## 5     35    39 0.6755319               0.6755319 ## 6     35    84 0.7894737               0.7894737 ## 7     35    85 0.7259001               0.7259001 ## 8     35    86 0.7448071               0.7448071 ## 9     35    87 0.7804460               0.7804460 ## 10    35    88 0.7621723               0.7621723 ## 11    35    89 0.5532995               0.5532995"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"from-similarity-to-dissimilarity-and-vice-versa","dir":"Articles","previous_headings":"","what":"3. From similarity to dissimilarity (and vice versa)","title":"3. Pairwise similarity/dissimilarity metrics","text":"functions similarity_to_dissimilarity dissimilarity_to_similarity can used switch easily switch similarity dissimilarity metrics.","code":"sim1 <- similarity(vegemat,                    metric = c(\"abc\",\"Sorensen\"),                    formula = \"1 - (b + c) / (2*a + b + c)\") sim1[1:10,] ## Data.frame of similarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  3697  ##  - Number of rows:  255255  ##  - Number of similarity metrics:  2  ##  ##  ##    Site1 Site2  Sorensen   a  b   c 1 - (b + c) / (2*a + b + c) ## 2     35    36 0.2530120 126  3 741                   0.2530120 ## 3     35    37 0.3172589 125  4 534                   0.3172589 ## 4     35    38 0.3531114 122  7 440                   0.3531114 ## 5     35    39 0.3244681 122  7 501                   0.3244681 ## 6     35    84 0.2105263  36 93 177                   0.2105263 ## 7     35    85 0.2740999 118 11 614                   0.2740999 ## 8     35    86 0.2551929 129  0 753                   0.2551929 ## 9     35    87 0.2195540 128  1 909                   0.2195540 ## 10    35    88 0.2378277 127  2 812                   0.2378277 ## 11    35    89 0.4467005  88 41 177                   0.4467005 dissim1 <- dissimilarity(vegemat,                           metric = c(\"abc\",\"Sorensen\"),                           formula = \"(b + c) / (2*a + b + c)\") dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  3697  ##  - Number of rows:  255255  ##  - Number of dissimilarity metrics:  2  ##  ##  ##    Site1 Site2  Sorensen   a  b   c (b + c) / (2*a + b + c) ## 2     35    36 0.7469880 126  3 741               0.7469880 ## 3     35    37 0.6827411 125  4 534               0.6827411 ## 4     35    38 0.6468886 122  7 440               0.6468886 ## 5     35    39 0.6755319 122  7 501               0.6755319 ## 6     35    84 0.7894737  36 93 177               0.7894737 ## 7     35    85 0.7259001 118 11 614               0.7259001 ## 8     35    86 0.7448071 129  0 753               0.7448071 ## 9     35    87 0.7804460 128  1 909               0.7804460 ## 10    35    88 0.7621723 127  2 812               0.7621723 ## 11    35    89 0.5532995  88 41 177               0.5532995 dissim2 <- similarity_to_dissimilarity(sim1) dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  3697  ##  - Number of rows:  255255  ##  - Number of dissimilarity metrics:  2  ##  ##  ##    Site1 Site2  Sorensen   a  b   c 1 - (b + c) / (2*a + b + c) ## 2     35    36 0.7469880 126  3 741                   0.7469880 ## 3     35    37 0.6827411 125  4 534                   0.6827411 ## 4     35    38 0.6468886 122  7 440                   0.6468886 ## 5     35    39 0.6755319 122  7 501                   0.6755319 ## 6     35    84 0.7894737  36 93 177                   0.7894737 ## 7     35    85 0.7259001 118 11 614                   0.7259001 ## 8     35    86 0.7448071 129  0 753                   0.7448071 ## 9     35    87 0.7804460 128  1 909                   0.7804460 ## 10    35    88 0.7621723 127  2 812                   0.7621723 ## 11    35    89 0.5532995  88 41 177                   0.5532995 sim2 <- dissimilarity_to_similarity(dissim1) sim2[1:10,] ## Data.frame of similarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  3697  ##  - Number of rows:  255255  ##  - Number of similarity metrics:  2  ##  ##  ##    Site1 Site2  Sorensen   a  b   c (b + c) / (2*a + b + c) ## 2     35    36 0.2530120 126  3 741               0.2530120 ## 3     35    37 0.3172589 125  4 534               0.3172589 ## 4     35    38 0.3531114 122  7 440               0.3531114 ## 5     35    39 0.3244681 122  7 501               0.3244681 ## 6     35    84 0.2105263  36 93 177               0.2105263 ## 7     35    85 0.2740999 118 11 614               0.2740999 ## 8     35    86 0.2551929 129  0 753               0.2551929 ## 9     35    87 0.2195540 128  1 909               0.2195540 ## 10    35    88 0.2378277 127  2 812               0.2378277 ## 11    35    89 0.4467005  88 41 177               0.4467005"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"comparison-with-other-r-packages","dir":"Articles","previous_headings":"","what":"4. Comparison with other R packages","title":"3. Pairwise similarity/dissimilarity metrics","text":"bioregion R package allows computation similarity, dissimilarity, distance, \\(\\beta\\)-diversity metrics based (site-species) co-occurrence matrix. section, focus several functions provided packages adespatial, betapart, ecodist, vegan. table displays main differences packages terms dissimilarity metric computation. bioregion package one allows computation several metrics returned data.frame network format. also supports use custom formulas based , b, c, , B C components. flexibility also available vegan via designdist function. bioregion also allows computation , b, c, , B C components. Users can choose extract none components, three abc components, three ABC components, six components. components (abc ABC separately) can also accessed adespatial using beta.div.comp function, betapart using betapart.core betapart.core.abund. Finally, vegan package, via designdist function, also allows extraction , b, c, , B C components separately.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"basic-comparison-jaccard-and-bray-curtis","dir":"Articles","previous_headings":"4. Comparison with other R packages","what":"4.1 Basic comparison (Jaccard and Bray-Curtis)","title":"3. Pairwise similarity/dissimilarity metrics","text":"first present basic comparison computation two well-known metrics, Jaccard Bray-Curtis, based small co-occurrence matrix.","code":"nbsite <- 100 nbsp <- 200  set.seed(1) comat <- matrix(runif(nbsite*nbsp), nbsite, nbsp) rownames(comat) <- paste0(\"s\", 1:nbsite) colnames(comat) <- paste0(\"sp\", 1:nbsp)  comatbin <- comat comatbin[comat > 0.7] <- 1 comatbin[comat <= 0.7] <- 0"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"jaccard","dir":"Articles","previous_headings":"4. Comparison with other R packages > 4.1 Basic comparison (Jaccard and Bray-Curtis)","what":"4.1.1 Jaccard","title":"3. Pairwise similarity/dissimilarity metrics","text":"propose comparison computation time generating Jaccard dissimilarity matrix based comatbin defined . noted output beta.div dissimilarityrequires additional step obtain dissimilarity matrix. Specifically, beta.div returns root mean square desired quantity, shown , dissimilarity outputs metric network (data.frame) format, supports computation multiple metrics. beta.pair function used betapart package. Two functions, distance bcdist, used ecodist package. also use two available functions, vegdist designdist, vegan package. ensuring functions return dissimilarity matrix, proceed comparison computation times. small example, functions vegan outperform others terms computation time. followed bcdist beta.pair. dissimilarity function performs slightly slower, partly due additional reformatting step (matrix network back). distance beta.div functions rank significantly lower terms speed.","code":"dissim <- list()  comp_j <- microbenchmark(      adespatial = { d <- beta.div(comatbin,                                 method = \"jaccard\",                                samp = FALSE,                                nperm = 1,                                save.D = TRUE)    d <- as.matrix(d$D)   d <- d*d   dissim$adespatial <- d},      betapart = { d <- beta.pair(comatbin,                                index.family = \"jaccard\")   d <- as.matrix(d$beta.jac)   dissim$betapart <- d},      bioregion = { d <- dissimilarity(comatbin,                                     metric = \"Jaccard\")   d <- net_to_mat(d,                      weight = TRUE,                   squared = TRUE,                   symmetrical = TRUE)   dissim$bioregion <- d },      ecodist_dist = { d <- distance(comatbin,                                   method = \"jaccard\")   d <- as.matrix(d)   dissim$ecodist_dist <- d },      ecodist_bcdist = { d <- bcdist(comatbin)   d <- as.matrix(d)   dissim$ecodist_bcdist <- d },      vegan_veg = { d <- vegdist(comatbin,                              method = \"jaccard\")   d <- as.matrix(d)   dissim$vegan_veg <- d },      vegan_design = { d <- designdist(comatbin,                                    method = \"(A+B-2*J)/(A+B-J)\",                                    terms = \"binary\")   d <- as.matrix(d)   dissim$vegan_design <- d },      times = 10 ) all_identical <- all(   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$betapart, digits=4)),   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$bioregion, digits=4)),   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$ecodist_dist , digits=4)),   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$ecodist_bcdist , digits=4)),   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$vegan_veg, digits=4)),   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$vegan_design, digits=4)) ) print(all_identical) ## [1] TRUE comp_j ## Unit: milliseconds ##            expr        min         lq       mean     median         uq ##      adespatial 278.361300 282.417925 284.298731 284.549580 285.318104 ##        betapart   1.690182   1.858807   1.931732   1.917421   1.953393 ##       bioregion   9.720939  10.328312  15.670676  15.468984  16.662715 ##    ecodist_dist 128.795487 140.296275 178.942631 158.144101 169.140758 ##  ecodist_bcdist   3.353584   3.562975   3.569997   3.600143   3.619380 ##       vegan_veg   1.220436   1.319902   1.945842   2.315764   2.319255 ##    vegan_design   1.265480   1.309703   1.402998   1.363172   1.465303 ##         max neval ##  289.475436    10 ##    2.326809    10 ##   30.425983    10 ##  401.860850    10 ##    3.655207    10 ##    2.355874    10 ##    1.740887    10"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"bray-curtis","dir":"Articles","previous_headings":"4. Comparison with other R packages > 4.1 Basic comparison (Jaccard and Bray-Curtis)","what":"4.1.2 Bray-Curtis","title":"3. Pairwise similarity/dissimilarity metrics","text":"present similar example using Bray-Curtis dissimilarity metric, based comat defined . ensuring functions return dissimilarity matrix, proceed comparison computation times. functions vegan continue outperform others. followed bcdist, dissimilarity function remains slightly slower. distance beta.div functions, joined beta.pair.abund, rank significantly lower terms computation speed.","code":"dissim <- list()  comp_bc <- microbenchmark(      adespatial = { d <- beta.div(comat,                                 method = \"percentdiff\",                                samp = FALSE,                                nperm = 1,                                save.D = TRUE)    d <- as.matrix(d$D)   d <- d*d   dissim$adespatial <- d},      betapart = { d <- beta.pair.abund(comat,                                      index.family = \"bray\")   d <- as.matrix(d$beta.bray)   dissim$betapart <- d},      bioregion = { d <- dissimilarity(comatbin,                                     metric = \"Bray\")   d <- net_to_mat(d,                      weight = TRUE,                   squared = TRUE,                   symmetrical = TRUE)   dissim$bioregion <- d },      ecodist_dist = { d <- distance(comat,                                   method = \"bray-curtis\")   d <- as.matrix(d)   dissim$ecodist_dist <- d },      ecodist_bcdist = { d <- bcdist(comat)   d <- as.matrix(d)   dissim$ecodist_bcdist <- d },      vegan_veg = { d <- vegdist(comatbin,                              method = \"bray\")   d <- as.matrix(d)   dissim$vegan_veg <- d },      vegan_design = { d <- designdist(comat,                                    method = \"(A+B-2*J)/(A+B)\",                                    terms = \"minimum\")   d <- as.matrix(d)   dissim$vegan_design <- d },      times = 10 ) all_identical <- all(   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$betapart, digits=4)),   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$bioregion, digits=4)),   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$ecodist_dist , digits=4)),   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$ecodist_bcdist , digits=4)),   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$vegan_veg, digits=4)),   identical(trunc(dissim$adespatial, digits=4),              trunc(dissim$vegan_design, digits=4)) ) print(all_identical) ## [1] TRUE comp_bc ## Unit: milliseconds ##            expr        min         lq       mean     median         uq ##      adespatial 278.313571 282.195981 286.878285 286.685649 290.191452 ##        betapart 310.581959 315.747072 343.248173 331.987705 362.278036 ##       bioregion  10.120624  10.488972  11.224555  10.602408  10.974026 ##    ecodist_dist  84.219526  94.783447 106.637512  99.443281 126.623456 ##  ecodist_bcdist   5.988960   6.009608   6.099689   6.103248   6.189293 ##       vegan_veg   1.210778   1.244550   1.678732   1.296292   2.319004 ##    vegan_design   1.267815   1.316666   1.462292   1.387653   1.662831 ##         max neval ##  294.072319    10 ##  421.239420    10 ##   13.859187    10 ##  131.488129    10 ##    6.198580    10 ##    2.336427    10 ##    1.751406    10"},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"systematic-comparison-jaccard-and-bray-curtis","dir":"Articles","previous_headings":"4. Comparison with other R packages","what":"4.2 Systematic comparison (Jaccard and Bray-Curtis)","title":"3. Pairwise similarity/dissimilarity metrics","text":"differences computation times become noticeable (site-species) co-occurrence matrix objects significant size. better understand computation times matrices, perform similar experiment using subset functions (beta.pair beta.pair.abund, dissimilarity, bcdist, vegdist, designdist) datasets varying numbers sites species. plot shows results obtained Jaccard dissimilarity metric based 16 combinations numbers sites species (chosen among 500, 1000, 2000, 5000), averaged three replications. also include results single simulation 10,000 sites species. similar plot showing results obtained Bray-Curtis dissimilarity metric available . case, results based single simulation 10,000 sites species exclude beta.pair.abund took much time compute.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a3_pairwise_metrics.html","id":"importing-pairwise-dissimilarity-metrics-from-other-packages-into-bioregion","dir":"Articles","previous_headings":"","what":"5. Importing pairwise (dis)similarity metrics from other packages into bioregion","title":"3. Pairwise similarity/dissimilarity metrics","text":"enable conversion (dis)similarity metrics stored base R objects outputs packages bioregion.pairwise.metric object compatible bioregion package, developed as_bioregion_pairwise() function. function can take input matrix, dist object, list also outputs several functions provided packages adespatial, betapart, ecodist vegan described . includes outputs beta.div beta.div.comp adespatial package. beta.pair, beta.pair.abund, betapart.core betapart.core.abund betapart package. distance bcdist ecodist package. finally vegdist designdist vegan.","code":"dissim1 <- dissimilarity(vegemat,                           metric = \"Euclidean\") dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  3697  ##  - Number of rows:  255255  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2 Euclidean ## 2     35    36 3262.6011 ## 3     35    37 1378.7897 ## 4     35    38 1275.4031 ## 5     35    39  485.7993 ## 6     35    84   66.2948 ## 7     35    85  354.5885 ## 8     35    86 2311.7883 ## 9     35    87 2039.7632 ## 10    35    88 2239.1117 ## 11    35    89  226.8237 dissim2 <- as_bioregion_pairwise(dist(vegemat),                                  metric_name = \"Euclidean\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  NA  ##  - Number of rows:  255255  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2 Euclidean ## 2     35    36 3262.6011 ## 3     35    37 1378.7897 ## 4     35    38 1275.4031 ## 5     35    39  485.7993 ## 6     35    84   66.2948 ## 7     35    85  354.5885 ## 8     35    86 2311.7883 ## 9     35    87 2039.7632 ## 10    35    88 2239.1117 ## 11    35    89  226.8237 dissim1 <- dissimilarity(comat,                           metric = \"Euclidean\") dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  200  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2 Euclidean ## 2     s1    s2  5.663259 ## 3     s1    s3  6.174723 ## 4     s1    s4  6.273630 ## 5     s1    s5  6.143276 ## 6     s1    s6  5.545510 ## 7     s1    s7  6.024138 ## 8     s1    s8  6.124431 ## 9     s1    s9  5.548479 ## 10    s1   s10  6.362439 ## 11    s1   s11  6.001393 dissim2 <- as_bioregion_pairwise(beta.div(comat,                                           method = \"euclidean\",                                           save.D = TRUE),                                  pkg = \"adespatial\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2 euclidean ## 2     s1    s2  5.663259 ## 3     s1    s3  6.174723 ## 4     s1    s4  6.273630 ## 5     s1    s5  6.143276 ## 6     s1    s6  5.545510 ## 7     s1    s7  6.024138 ## 8     s1    s8  6.124431 ## 9     s1    s9  5.548479 ## 10    s1   s10  6.362439 ## 11    s1   s11  6.001393 dissim1 <- dissimilarity(comatbin,                           metric = c(\"Jaccard\",\"abc\")) dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  200  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2   Jaccard  a  b  c ## 2     s1    s2 0.7708333 22 37 37 ## 3     s1    s3 0.8666667 14 45 46 ## 4     s1    s4 0.8679245 14 45 47 ## 5     s1    s5 0.8543689 15 44 44 ## 6     s1    s6 0.7843137 22 37 43 ## 7     s1    s7 0.8392857 18 41 53 ## 8     s1    s8 0.8256881 19 40 50 ## 9     s1    s9 0.8105263 18 41 36 ## 10    s1   s10 0.8842105 11 48 36 ## 11    s1   s11 0.8666667 14 45 46 dissim2 <- as_bioregion_pairwise(beta.div.comp(comatbin,                                                save.abc = TRUE),                                  pkg = \"adespatial\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2 Podani family, Jaccard  a  b  c ## 2     s1    s2              0.7708333 22 37 37 ## 3     s1    s3              0.8666667 14 45 46 ## 4     s1    s4              0.8679245 14 45 47 ## 5     s1    s5              0.8543689 15 44 44 ## 6     s1    s6              0.7843137 22 37 43 ## 7     s1    s7              0.8392857 18 41 53 ## 8     s1    s8              0.8256881 19 40 50 ## 9     s1    s9              0.8105263 18 41 36 ## 10    s1   s10              0.8842105 11 48 36 ## 11    s1   s11              0.8666667 14 45 46 dissim1 <- dissimilarity(comatbin,                           metric = c(\"Jaccard\",\"Jaccardturn\")) dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  200  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  2  ##  ##  ##    Site1 Site2   Jaccard Jaccardturn ## 2     s1    s2 0.7708333   0.7708333 ## 3     s1    s3 0.8666667   0.8653846 ## 4     s1    s4 0.8679245   0.8653846 ## 5     s1    s5 0.8543689   0.8543689 ## 6     s1    s6 0.7843137   0.7708333 ## 7     s1    s7 0.8392857   0.8200000 ## 8     s1    s8 0.8256881   0.8080808 ## 9     s1    s9 0.8105263   0.8000000 ## 10    s1   s10 0.8842105   0.8674699 ## 11    s1   s11 0.8666667   0.8653846 dissim2 <- as_bioregion_pairwise(beta.pair(comatbin,                                            index.family = \"jaccard\"),                                  pkg = \"betapart\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  3  ##  ##  ##    Site1 Site2  beta.jtu    beta.jne  beta.jac ## 2     s1    s2 0.7708333 0.000000000 0.7708333 ## 3     s1    s3 0.8653846 0.001282051 0.8666667 ## 4     s1    s4 0.8653846 0.002539913 0.8679245 ## 5     s1    s5 0.8543689 0.000000000 0.8543689 ## 6     s1    s6 0.7708333 0.013480392 0.7843137 ## 7     s1    s7 0.8200000 0.019285714 0.8392857 ## 8     s1    s8 0.8080808 0.017607265 0.8256881 ## 9     s1    s9 0.8000000 0.010526316 0.8105263 ## 10    s1   s10 0.8674699 0.016740647 0.8842105 ## 11    s1   s11 0.8653846 0.001282051 0.8666667 dissim1 <- dissimilarity(comat,                           metric = c(\"Brayturn\",\"Bray\")) dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  200  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  2  ##  ##  ##    Site1 Site2      Bray  Brayturn ## 1     s1    s2 0.3109486 0.2907499 ## 2     s1    s3 0.3551275 0.3484112 ## 3     s1    s4 0.3662292 0.3527945 ## 4     s1    s5 0.3644193 0.3607606 ## 5     s1    s6 0.3053786 0.3002943 ## 6     s1    s7 0.3455313 0.3324551 ## 7     s1    s8 0.3469113 0.3299002 ## 8     s1    s9 0.3184678 0.3143748 ## 9     s1   s10 0.4017243 0.3617546 ## 10    s1   s11 0.3523224 0.3505070 dissim2 <- as_bioregion_pairwise(beta.pair.abund(comat,                                                  index.family = \"bray\"),                                  pkg = \"betapart\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  3  ##  ##  ##    Site1 Site2 beta.bray.bal beta.bray.gra beta.bray ## 2     s1    s2     0.2907499   0.020198660 0.3109486 ## 3     s1    s3     0.3484112   0.006716346 0.3551275 ## 4     s1    s4     0.3527945   0.013434676 0.3662292 ## 5     s1    s5     0.3607606   0.003658700 0.3644193 ## 6     s1    s6     0.3002943   0.005084275 0.3053786 ## 7     s1    s7     0.3324551   0.013076199 0.3455313 ## 8     s1    s8     0.3299002   0.017011065 0.3469113 ## 9     s1    s9     0.3143748   0.004093053 0.3184678 ## 10    s1   s10     0.3617546   0.039969771 0.4017243 ## 11    s1   s11     0.3505070   0.001815369 0.3523224 dissim1 <- dissimilarity(comatbin,                           metric = \"abc\",                          formula = c(\"pmin(b,c)\",\"pmax(b,c)\",\"b+c\")) dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  200  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  3  ##  ##  ##    Site1 Site2  a  b  c pmin(b,c) pmax(b,c) b+c ## 2     s1    s2 22 37 37        37        37  74 ## 3     s1    s3 14 45 46        45        46  91 ## 4     s1    s4 14 45 47        45        47  92 ## 5     s1    s5 15 44 44        44        44  88 ## 6     s1    s6 22 37 43        37        43  80 ## 7     s1    s7 18 41 53        41        53  94 ## 8     s1    s8 19 40 50        40        50  90 ## 9     s1    s9 18 41 36        36        41  77 ## 10    s1   s10 11 48 36        36        48  84 ## 11    s1   s11 14 45 46        45        46  91 dissim2 <- as_bioregion_pairwise(betapart.core(comatbin),                                  pkg = \"betapart\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  3  ##  ##  ##    Site1 Site2  a  b  c min(b,c) max(b,c) sum(b,c) ## 2     s1    s2 22 37 37       37       37       74 ## 3     s1    s3 14 45 46       45       46       91 ## 4     s1    s4 14 45 47       45       47       92 ## 5     s1    s5 15 44 44       44       44       88 ## 6     s1    s6 22 37 43       37       43       80 ## 7     s1    s7 18 41 53       41       53       94 ## 8     s1    s8 19 40 50       40       50       90 ## 9     s1    s9 18 41 36       36       41       77 ## 10    s1   s10 11 48 36       36       48       84 ## 11    s1   s11 14 45 46       45       46       91 dissim1 <- dissimilarity(comat,                           metric = \"ABC\",                          formula = c(\"pmin(B,C)\",\"pmax(B,C)\",\"B+C\")) dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  200  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  3  ##  ##  ##    Site1 Site2        A        B        C pmin(B,C) pmax(B,C)      B+C ## 2     s1    s2 70.62846 28.95342 34.79166  28.95342  34.79166 63.74508 ## 3     s1    s3 64.88645 34.69544 36.76973  34.69544  36.76973 71.46517 ## 4     s1    s4 64.44994 35.13194 39.35382  35.13194  39.35382 74.48576 ## 5     s1    s5 62.93214 36.64975 35.51632  35.51632  36.64975 72.16607 ## 6     s1    s6 69.67801 29.90388 31.36165  29.90388  31.36165 61.26553 ## 7     s1    s7 66.47538 33.10650 37.08577  33.10650  37.08577 70.19227 ## 8     s1    s8 66.72980 32.85209 38.03973  32.85209  38.03973 70.89181 ## 9     s1    s9 67.46550 32.11639 30.93447  30.93447  32.11639 63.05086 ## 10    s1   s10 56.06630 43.51559 31.77812  31.77812  43.51559 75.29371 ## 11    s1   s11 64.31719 35.26470 34.70958  34.70958  35.26470 69.97427 dissim2 <- as_bioregion_pairwise(betapart.core.abund(comat),                                  pkg = \"betapart\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  3  ##  ##  ##    Site1 Site2        A min(B,C) max(B,C) sum(B,C) ## 2     s1    s2 70.62846 28.95342 34.79166 63.74508 ## 3     s1    s3 64.88645 34.69544 36.76973 71.46517 ## 4     s1    s4 64.44994 35.13194 39.35382 74.48576 ## 5     s1    s5 62.93214 35.51632 36.64975 72.16607 ## 6     s1    s6 69.67801 29.90388 31.36165 61.26553 ## 7     s1    s7 66.47538 33.10650 37.08577 70.19227 ## 8     s1    s8 66.72980 32.85209 38.03973 70.89181 ## 9     s1    s9 67.46550 30.93447 32.11639 63.05086 ## 10    s1   s10 56.06630 31.77812 43.51559 75.29371 ## 11    s1   s11 64.31719 34.70958 35.26470 69.97427 dissim1 <- dissimilarity(comatbin,                           metric = \"Jaccard\") dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  200  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2   Jaccard ## 2     s1    s2 0.7708333 ## 3     s1    s3 0.8666667 ## 4     s1    s4 0.8679245 ## 5     s1    s5 0.8543689 ## 6     s1    s6 0.7843137 ## 7     s1    s7 0.8392857 ## 8     s1    s8 0.8256881 ## 9     s1    s9 0.8105263 ## 10    s1   s10 0.8842105 ## 11    s1   s11 0.8666667 dissim2 <- as_bioregion_pairwise(distance(comatbin,                                           method=\"jaccard\"),                                  pkg = \"ecodist\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2   jaccard ## 2     s1    s2 0.7708333 ## 3     s1    s3 0.8666667 ## 4     s1    s4 0.8679245 ## 5     s1    s5 0.8543689 ## 6     s1    s6 0.7843137 ## 7     s1    s7 0.8392857 ## 8     s1    s8 0.8256881 ## 9     s1    s9 0.8105263 ## 10    s1   s10 0.8842105 ## 11    s1   s11 0.8666667 dissim1 <- dissimilarity(comat,                           metric = \"Bray\") dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  200  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2      Bray ## 1     s1    s2 0.3109486 ## 2     s1    s3 0.3551275 ## 3     s1    s4 0.3662292 ## 4     s1    s5 0.3644193 ## 5     s1    s6 0.3053786 ## 6     s1    s7 0.3455313 ## 7     s1    s8 0.3469113 ## 8     s1    s9 0.3184678 ## 9     s1   s10 0.4017243 ## 10    s1   s11 0.3523224 dissim2 <- as_bioregion_pairwise(bcdist(comat),                                  pkg = \"ecodist\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2 bray-curtis ## 2     s1    s2   0.3109486 ## 3     s1    s3   0.3551275 ## 4     s1    s4   0.3662292 ## 5     s1    s5   0.3644193 ## 6     s1    s6   0.3053786 ## 7     s1    s7   0.3455313 ## 8     s1    s8   0.3469113 ## 9     s1    s9   0.3184678 ## 10    s1   s10   0.4017243 ## 11    s1   s11   0.3523224 dissim1 <- dissimilarity(comatbin,                           metric = \"Jaccard\") dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  200  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2   Jaccard ## 2     s1    s2 0.7708333 ## 3     s1    s3 0.8666667 ## 4     s1    s4 0.8679245 ## 5     s1    s5 0.8543689 ## 6     s1    s6 0.7843137 ## 7     s1    s7 0.8392857 ## 8     s1    s8 0.8256881 ## 9     s1    s9 0.8105263 ## 10    s1   s10 0.8842105 ## 11    s1   s11 0.8666667 dissim2 <- as_bioregion_pairwise(vegdist(comatbin,                                          method=\"jaccard\"),                                  pkg = \"vegan\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2   jaccard ## 2     s1    s2 0.7708333 ## 3     s1    s3 0.8666667 ## 4     s1    s4 0.8679245 ## 5     s1    s5 0.8543689 ## 6     s1    s6 0.7843137 ## 7     s1    s7 0.8392857 ## 8     s1    s8 0.8256881 ## 9     s1    s9 0.8105263 ## 10    s1   s10 0.8842105 ## 11    s1   s11 0.8666667 dissim1 <- dissimilarity(comat,                           metric = \"Bray\",                          formula = \"(B + C) / (2*A + B + C)\") dissim1[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  200  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  2  ##  ##  ##    Site1 Site2      Bray (B + C) / (2*A + B + C) ## 1     s1    s2 0.3109486               0.3109486 ## 2     s1    s3 0.3551275               0.3551275 ## 3     s1    s4 0.3662292               0.3662292 ## 4     s1    s5 0.3644193               0.3644193 ## 5     s1    s6 0.3053786               0.3053786 ## 6     s1    s7 0.3455313               0.3455313 ## 7     s1    s8 0.3469113               0.3469113 ## 8     s1    s9 0.3184678               0.3184678 ## 9     s1   s10 0.4017243               0.4017243 ## 10    s1   s11 0.3523224               0.3523224 dissim2 <- as_bioregion_pairwise(designdist(comat,                                             method = \"(A+B-2*J)/(A+B)\",                                             terms = \"minimum\"),                                  pkg = \"vegan\") dissim2[1:10,] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  100  ##  - Total number of species:  NA  ##  - Number of rows:  4950  ##  - Number of dissimilarity metrics:  1  ##  ##  ##    Site1 Site2 minimum (A+B-2*J)/(A+B) ## 2     s1    s2               0.3109486 ## 3     s1    s3               0.3551275 ## 4     s1    s4               0.3662292 ## 5     s1    s5               0.3644193 ## 6     s1    s6               0.3053786 ## 7     s1    s7               0.3455313 ## 8     s1    s8               0.3469113 ## 9     s1    s9               0.3184678 ## 10    s1   s10               0.4017243 ## 11    s1   s11               0.3523224"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"compute-dissimilarity-indices-from-input-data","dir":"Articles","previous_headings":"","what":"1. Compute dissimilarity indices from input data","title":"4.1 Hierarchical clustering","text":"initiate hierarchical clustering procedure, need provide pairwise distances sites. pairwise distances sites can obtained running dissimilarity() species-site matrix, presence-absence abundance matrix. example , use vegetation dataset package compute distance metrics. going compute \\(\\beta_{sim}\\) diversity metric, presence-absence dissimilarity index. formula follows: \\(\\beta_{sim} = min(b, c) / (+min(b, c))\\) number species shared sites; b number species occurring first site; c number species occurring second site. typically choose metric bioregionalization, turnover component Sorensen index (Baselga, 2012) (nutshell, tells us sites different distinct species), less dependent species richness Jaccard turnover (Leprieur & Oikonomou, 2014). Alternatively, given abundance data , also use Bray-Curtis turnover index (Baselga, 2013). choice distance metric important outcome clustering procedure, recommend choose carefully depending research question. default, Simpson index computed, options available metric argument dissimilarity(). Furthermore, users can also write formula compute index want argument formula, see ?dissimilarity(). now ready start hierarchical clustering procedure object dissim just created. Alternatively, can also use types objects hclu_hierarclust(), distance matrix object (class dist) data.frame crafting (make sure read required format carefully ?hclu_hierarclust).","code":"library(\"bioregion\")  # Work with the vegetation dataset we include in the package data(vegemat)  # This is an abundance matrix where sites are in rows and species in columns vegemat[1:10, 1:10] ##     Species ## Site 10001 10002 10003 10004 10005 10006 10007 10008 10009 10010 ##   35     0     0     0     0     0     0     0     0     0     0 ##   36     2     0     0     0     0     0     1    12     0     0 ##   37     0     0     0     0     0     0     0     0     0     0 ##   38     0     0     0     0     0     0     0     0     0     0 ##   39     5     0     0     0     0     0     0     2     0     0 ##   84     0     0     0     0     0     0     0     0     0     0 ##   85     3     0     0     0     0     0     1     7     0     0 ##   86     0     0     0     2     0     0     2    22     0     0 ##   87    16     0     0     0     0     0     2    54     0     0 ##   88   228     0     0     0     0     0     0     5     0     0 dissim <- dissimilarity(vegemat)  head(dissim) ## Data.frame of dissimilarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  3697  ##  - Number of rows:  255255  ##  - Number of dissimilarity metrics:  1  ##  ##  ##   Site1 Site2    Simpson ## 2    35    36 0.02325581 ## 3    35    37 0.03100775 ## 4    35    38 0.05426357 ## 5    35    39 0.05426357 ## 6    35    84 0.72093023 ## 7    35    85 0.08527132"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"hierarchical-clustering-with-basic-parameters","dir":"Articles","previous_headings":"","what":"2. Hierarchical clustering with basic parameters","title":"4.1 Hierarchical clustering","text":"Hierarchical clustering, associated hierarchical tree, can constructed two ways: - agglomerative, sites initially assigned bioregion progressively grouped together - divisive, sites initially belong unique bioregion progressively divided different bioregions Subsections 2.1 2.3 detail functioning agglomerative hierarchical clustering, sub-section 2.4. illustrates divisive method.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"basic-usage","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters","what":"2.1 Basic usage","title":"4.1 Hierarchical clustering","text":"basic use function follows: function gives us information proceeds. Notably, talks randomization dissimilarity matrix - important feature hierarchical clustering strongly influenced order sites distance matrix. Therefore, default, function performs randomization order sites distance matrix 30 trials (information randomization section). also tells us among trials selected tree highest cophenetic correlation coefficient, value 0.69. can see type name object console see information: last line tells us clustering procedure incomplete: tree built, yet cut - clusters object yet. cut tree, can use cut_tree() function: , asked 3 clusters, algorithm automatically finds height 3 clusters found (h = 0.562). type name object console, gives us results clustering: 1 partition: partition clustering result. cut tree , 1 partition moment 4 clusters: number clusters partition. asked 3, obtained 3, good. Sometimes, however, get number clusters asked - case outcome indicated. height cut 0.562: height cut can obtain 4 clusters tree. can make quick plot partitioned tree  Let’s see looks like map:  Now, hierarchical tree, cutting (= 1 partition) oversimplifies result tree. cut multiple times? example, make deep, intermediate, shallow cuts tree, likewise Ficetola et al. (2017), allow us see broad- fine-scale relationships among sites tree. can specify, e.g. 4, 10 20 clusters: However, may useful choose heights cut, rather number clusters. , example, cut tree heights 0.4 (shallow cut), 0.5 (intermediate cut) 0.6 (deep cut):  plot easy read large number sites. can rather extract information directly object: result, can read deep cut partition (h = 0.6) clusters, intermediate cut partition (h = 0.5) 6 clusters shallow cut partition (h = 0.4) 23 clusters. maps look like:  next section see default settings chose , see find optimal numbers clusters.","code":"tree1 <- hclu_hierarclust(dissim) ## Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. ##  ## Final tree has a 0.6863 cophenetic correlation coefficient with the initial dissimilarity matrix tree1 ## Clustering results for algorithm : hclu_hierarclust  ##  (hierarchical clustering based on a dissimilarity matrix) ##  - Number of sites:  715  ##  - Name of dissimilarity metric:  Simpson  ##  - Tree construction method:  average  ##  - Randomization of the dissimilarity matrix:  yes, number of trials 100  ##  - Method to compute the final tree:  Iterative consensus hierarchical tree  ##  - Cophenetic correlation coefficient:  0.686  ## Clustering procedure incomplete - no clusters yet # Ask for 3 clusters tree1 <- cut_tree(tree1,                   n_clust = 3) ## Determining the cut height to reach 3 groups... ## --> 0.5625 tree1 ## Clustering results for algorithm : hclu_hierarclust  ##  (hierarchical clustering based on a dissimilarity matrix) ##  - Number of sites:  715  ##  - Name of dissimilarity metric:  Simpson  ##  - Tree construction method:  average  ##  - Randomization of the dissimilarity matrix:  yes, number of trials 100  ##  - Method to compute the final tree:  Iterative consensus hierarchical tree  ##  - Cophenetic correlation coefficient:  0.686  ##  - Number of clusters requested by the user:  3  ## Clustering results: ##  - Number of partitions:  1  ##  - Number of clusters:  3  ##  - Height of cut of the hierarchical tree: 0.562 # We reduced the size of text labels with cex = .2, because there are too many sites plot(tree1, cex = .2) data(vegesf) library(sf) ## Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE map_bioregions(tree1$clusters[, c(\"ID\", \"K_3\")], vegesf) # Ask for 4, 10 and 20 clusters tree1 <- cut_tree(tree1,                   n_clust = c(2, 3, 12)) ## Determining the cut height to reach 2 groups... ## --> 0.625 ## Determining the cut height to reach 3 groups... ## --> 0.5625 ## Determining the cut height to reach 12 groups... ## --> 0.4453125 plot(tree1, cex = .2) tree1 <- cut_tree(tree1,                   cut_height = c(.4, .5, .6))  plot(tree1, cex = .2) tree1 ## Clustering results for algorithm : hclu_hierarclust  ##  (hierarchical clustering based on a dissimilarity matrix) ##  - Number of sites:  715  ##  - Name of dissimilarity metric:  Simpson  ##  - Tree construction method:  average  ##  - Randomization of the dissimilarity matrix:  yes, number of trials 100  ##  - Method to compute the final tree:  Iterative consensus hierarchical tree  ##  - Cophenetic correlation coefficient:  0.686  ##  - Heights of cut requested by the user:  0.4 0.5 0.6  ## Clustering results: ##  - Number of partitions:  3  ##  - Partitions are not hierarchical ##  - Number of clusters:  2 6 23  ##  - Height of cut of the hierarchical tree: 0.6 0.5 0.4 for(i in 2:ncol(tree1$clusters)){   map_bioregions(tree1$clusters[, c(1, i)], vegesf) }"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"exploring-the-outputs","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters","what":"2.2 Exploring the outputs","title":"4.1 Hierarchical clustering","text":"explore object, can use str() see object structure: show different slots object, can access . example, want access clusters slot, type tree1$clusters. name: name method using args: arguments selected tree inputs: mostly internal use package, provides info nature input data methods algorithm: slot contains detailed information hierarchical clustering. example, can access raw tree , hclust format. access , can type tree1$algorithm$final.tree clusters: data.frame containing partitions. first column sites, columns partitions. cluster_info: small data.frame help link requests clusters data.frame. content varies depending choices; example, case, looks like : shows name partition (corresponding column names tree1$clusters), number clusters partition, cut height initially requested.","code":"str(tree1) ## List of 6 ##  $ name        : chr \"hclu_hierarclust\" ##  $ args        :List of 14 ##   ..$ index              : chr \"Simpson\" ##   ..$ method             : chr \"average\" ##   ..$ randomize          : logi TRUE ##   ..$ n_runs             : num 100 ##   ..$ optimal_tree_method: chr \"iterative_consensus_tree\" ##   ..$ keep_trials        : logi FALSE ##   ..$ n_clust            : NULL ##   ..$ cut_height         : num [1:3] 0.4 0.5 0.6 ##   ..$ find_h             : logi TRUE ##   ..$ h_max              : num 1 ##   ..$ h_min              : num 0 ##   ..$ consensus_p        : num 0.5 ##   ..$ verbose            : logi TRUE ##   ..$ dynamic_tree_cut   : logi FALSE ##  $ inputs      :List of 7 ##   ..$ bipartite      : logi FALSE ##   ..$ weight         : logi TRUE ##   ..$ pairwise       : logi TRUE ##   ..$ pairwise_metric: chr \"Simpson\" ##   ..$ dissimilarity  : logi TRUE ##   ..$ nb_sites       : int 715 ##   ..$ hierarchical   : logi FALSE ##  $ algorithm   :List of 6 ##   ..$ final.tree         :List of 5 ##   .. ..- attr(*, \"class\")= chr \"hclust\" ##   ..$ final.tree.coph.cor: num 0.686 ##   ..$ final.tree.msd     : num 0.023 ##   ..$ trials             : chr \"Trials not stored in output\" ##   ..$ output_n_clust     : Named int [1:3] 2 6 23 ##   .. ..- attr(*, \"names\")= chr [1:3] \"h_0.6\" \"h_0.5\" \"h_0.4\" ##   ..$ output_cut_height  : num [1:3] 0.6 0.5 0.4 ##  $ clusters    :'data.frame':    715 obs. of  4 variables: ##   ..$ ID  : chr [1:715] \"1003\" \"1004\" \"1005\" \"1006\" ... ##   ..$ K_2 : chr [1:715] \"1\" \"1\" \"1\" \"1\" ... ##   ..$ K_6 : chr [1:715] \"1\" \"1\" \"1\" \"1\" ... ##   ..$ K_23: chr [1:715] \"1\" \"1\" \"1\" \"1\" ... ##  $ cluster_info:'data.frame':    3 obs. of  3 variables: ##   ..$ partition_name      : chr [1:3] \"K_2\" \"K_6\" \"K_23\" ##   ..$ n_clust             : int [1:3] 2 6 23 ##   ..$ requested_cut_height: num [1:3] 0.6 0.5 0.4 ##  - attr(*, \"class\")= chr [1:2] \"bioregion.clusters\" \"list\" tree1$cluster_info ##       partition_name n_clust requested_cut_height ## h_0.6            K_2       2                  0.6 ## h_0.5            K_6       6                  0.5 ## h_0.4           K_23      23                  0.4"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"randomization","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters > 2.3 Explanation of the default settings and how to change them","what":"2.3.1 Randomization of the distance matrix","title":"4.1 Hierarchical clustering","text":"order sites distance matrix influences outcome hierarchical tree. Let’s see example:  tree looks like matrix randomized. Now let’s randomize regenerate tree:  See tree looks different? problematic means outcome heavily influenced order sites distance matrix. address issue, developed iterative algorithm reconstruct entire tree top bottom, selecting branch majority decision among multiple randomizations distance matrix (100 times default, can increased). method called Iterative Hierarchical Consensus Tree (argument optimal_tree_method = \"iterative_consensus_tree\", default value) ensures obtain consensus tree find majority decision branch tree. tree produced method generally better topology individual tree. estimate performance topology cophenetic correlation coefficient, correlation initial distance \\(\\beta_{sim}\\) among sites cophenetic distance, distance sites connected tree. tells us representative tree initial distance matrix. Although method performs better available method, comes computing cost: needs randomize distance matrix multiple times branching tree. Therefore, recommend using obtain robust tree - patient case. Otherwise, need fast look good tree, can simply select single best tree among multiple randomization trials. never good Iterative Hierarchical Consensus Tree, best choice fast exploration. , choose optimal_tree_method = \"best\". select tree best represents distance matrix; .e., one highest cophenetic correlation coefficient among trials. Let’s see example optimal_tree_method = \"best\". can also ask function keep individual trees exploration (keep_trials = TRUE). Another possible approach build simple consensus tree among trials. However, generally recommend constructing consensus tree, topology simple consensus trees can problematic lot ties distance matrix. Let’s see action : See cophenetic correlation coefficient consensus tree terrible compared IHCT best tree ? consensus tree almost correlation initial distance matrix. topology terribly wrong, see tree looks like:  Booo, just large rake, tree!!!","code":"# Compute the tree without randomizing the distance matrix tree2 <- hclu_hierarclust(dissim,                           randomize = FALSE) ## Output tree has a 0.6849 cophenetic correlation coefficient with the initial ##                    dissimilarity matrix plot(tree2, cex = .1) # This line randomizes the order of rows in the distance matrix dissim_random <- dissim[sample(1:nrow(dissim)), ]  # Recompute the tree tree3 <- hclu_hierarclust(dissim_random,                           randomize = FALSE) ## Output tree has a 0.6778 cophenetic correlation coefficient with the initial ##                    dissimilarity matrix plot(tree3, cex = .1) tree_best <- hclu_hierarclust(dissim_random,                               randomize = TRUE,                               optimal_tree_method = \"best\",                               keep_trials = TRUE) ## Randomizing the dissimilarity matrix with 100 trials ##  -- range of cophenetic correlation coefficients among trials: 0.6669 - 0.6974 ##  ## Final tree has a 0.6974 cophenetic correlation coefficient with the initial dissimilarity matrix tree_consensus <- hclu_hierarclust(dissim_random,                                    randomize = TRUE,                                    optimal_tree_method = \"consensus\",                                    keep_trials = TRUE) ## Randomizing the dissimilarity matrix with 100 trials ##  ## Final tree has a 0.202 cophenetic correlation coefficient with the initial dissimilarity matrix plot(tree_consensus)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"tree-construction-algorithm","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters > 2.3 Explanation of the default settings and how to change them","what":"2.3.2 Tree construction algorithm","title":"4.1 Hierarchical clustering","text":"default, function uses UPGMA method (Unweighted Pair Group Method Arithmetic Mean) recommended bioregionalization better performance approaches (Kreft & Jetz, 2010). can change method changing argument method; methods implemented stats::hclust() available. Note current height distances methods method = \"ward.D\" method = \"ward.D2\" may differ calculations stats::hclust(), due iterative nature algorithm. addition, using method method = \"single\" much slower approaches, yet implemented workaround make faster (hesitate contact us need faster implementation idea make run faster).","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"cutting-the-tree","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters > 2.3 Explanation of the default settings and how to change them","what":"2.3.3 Cutting the tree","title":"4.1 Hierarchical clustering","text":"three ways cutting tree: Specify expected number clusters: can request specific number clusters (n_clust = 5 example). can also request multiple partitions, number clusters (n_clust = c(5, 10, 15)) example. Note: specify number clusters, function search associated height cut automatically; can disable parameter find_h = FALSE. search h value h_max (default 1) h_min (default 0). arguments can adjusted working indices whose values range 0 1. Specify height cut: can request height want cut tree (e.g., cut_height = 0.5). can also request multiple partitions, cut height (cut_height = c(0.4, 0.5, 0.6)) example. Use dynamic tree cut method: Rather cutting entire tree , alternative approach consists cutting individual branches different heights. method can requested using dynamic_tree_cut = TRUE, based dynamicTreeCut R package.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"id_2-4-","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters","what":"2.4. Divisive clustering","title":"4.1 Hierarchical clustering","text":"agglomerative hierarchical clustering previous subsections followed bottom-approach, divisive clustering follows top-approach. means first step clustering, sites belong bioregion, sites iteratively divided different bioregions sites belong unique bioregion. Divisive clustering following DIvisive ANAlysis (DIANA) clustering algorithm described (Kaufman & Rousseeuw, 2009). step, algorithm splits largest cluster identifying dissimilar observation (.e. site) putting sites closer dissimilar observation ‘old party’ group splinter group. result large cluster split two clusters. function hclu_diana performs Diana divisive clustering.","code":"# Compute the tree with the Diana algorithm tree_diana <- hclu_diana(dissim) ## Output tree has a 0.41 cophenetic correlation coefficient with the initial dissimilarity matrix plot(tree_diana)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"optimaln","dir":"Articles","previous_headings":"","what":"3. How to find an optimal number of clusters?","title":"4.1 Hierarchical clustering","text":"Step 1. Build tree hclu_hierarclust() Step 2. Explore range partitions, minimum (e.g., starting 2 clusters) maximum (e.g. \\(n-1\\) clusters \\(n\\) number sites). Step 3. Calculate one several metrics partition, used basis evaluation plots. Step 4. Search one several optimal number(s) clusters using evaluation plots. Different criteria can applied identify optimal number(s) clusters. Step 5. Export optimal partitions cluster object.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"a-practical-example","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters?","what":"3.1 A practical example","title":"4.1 Hierarchical clustering","text":"example compute evaluation metric used Holt et al. (2013), compares total dissimilarity distance matrix (sum distances) inter-cluster dissimilarity (sum distances clusters). choose optimal number clusters elbow evaluation plot.   allergic lines code, also simply recut tree identified optimal number cut-offs cut_tree().","code":"data(vegemat)  # Calculate dissimilarities dissim <- dissimilarity(vegemat)  # Step 1 & 2. Compute the tree and cut it into many different partitions tree4 <- hclu_hierarclust(dissim,                           n_clust = 2:100) ## Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. ##  ## Final tree has a 0.6842 cophenetic correlation coefficient with the initial dissimilarity matrix ## Warning in cut_tree(outputs, n_clust = n_clust, cut_height = cut_height, : The ## requested number of cluster could not be found for k = 4. Closest number found: ## 5 ## Warning in cut_tree(outputs, n_clust = n_clust, cut_height = cut_height, : The ## requested number of cluster could not be found for k = 67. Closest number ## found: 66 # Step 3. Calculate the same evaluation metric as Holt et al. 2013 eval_tree4 <- bioregionalization_metrics(   tree4,    dissimilarity = dissim, # Provide distances to compute the metrics   eval_metric = \"pc_distance\") ## Computing similarity-based metrics... ##   - pc_distance OK # Step 4. Find the optimal number of clusters opti_n_tree4 <- find_optimal_n(eval_tree4) ## Number of bioregionalizations: 99 ## Searching for potential optimal number(s) of clusters based on the elbow method ##    * elbow found at: ## pc_distance 19 ## Plotting results... opti_n_tree4 ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  elbow  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 19 # Step 5. Extract the optimal number of clusters # We get the name of the correct partition in the next line K_name <- opti_n_tree4$evaluation_df$K[opti_n_tree4$evaluation_df$optimal_n_pc_distance] # Look at the site-cluster table head(tree4$clusters[, c(\"ID\", K_name)]) ##        ID K_19 ## 1003 1003    1 ## 1004 1004    1 ## 1005 1005    1 ## 1006 1006    1 ## 1007 1007    1 ## 1008 1008    1 # Make a map of the clusters data(\"vegesf\") library(\"sf\") map_bioregions(tree4$clusters[, c(\"ID\", K_name)], vegesf)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"evaluation-metrics","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters?","what":"3.2 Evaluation metrics","title":"4.1 Hierarchical clustering","text":"Currently, four evaluation metrics available package: pc_distance: \\(\\sum{-cluster\\beta_{sim }} / \\sum{\\beta_{sim}}\\) metric metric computed Holt et al. (2013). anosim: statistic used Analysis Similarities, suggested Castro-Insua et al. (2018). compares -cluster dissimilarities within-cluster dissimilarities. based difference mean ranks groups within groups following formula: \\(R=(r_B-r_W)/(N(N-1)/4)\\) \\(r_B\\) \\(r_W\\) average ranks within clusters respectively, \\(N\\) total number sites. avg_endemism: average percentage endemism clusters (Kreft & Jetz, 2010). calculated follows: \\(End_{mean} = \\frac{\\sum_{=1}^K E_i / S_i}{K}\\) \\(E_i\\) number endemic species cluster \\(\\), \\(S_i\\) number species cluster \\(\\), \\(K\\) maximum number clusters. tot_endemism: total endemism across clusters (Kreft & Jetz, 2010). calculated follows: \\(End_{tot} = E / C\\) \\(E\\) total number endemic species (.e., species occurring one cluster) \\(C\\) number non- endemic species. Important note able calculate pc_distance anosim, need provide dissimilarity object argument dissimilarity. addition, able calculate avg_endemism tot_endemism, need provide species-site network argument net (don’t panick species x site matrix! function make conversion). Let’s see practice. Depending size dataset, computing endemism-based metrics can take .","code":"# Calculate pc_distance and anosim bioregionalization_metrics(tree4,                             dissimilarity = dissim,                             eval_metric = c(\"pc_distance\", \"anosim\")) ## Computing similarity-based metrics... ##   - pc_distance OK ##   - anosim OK ## Partition metrics: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Requested metric(s):  pc_distance anosim  ##  - Metric summary: ##      pc_distance    anosim ## Min    0.4982831 0.6968281 ## Mean   0.8950634 0.8029604 ## Max    0.9823024 0.8669999 ##  ## Access the data.frame of metrics with your_object$evaluation_df # Calculate avg_endemism and tot_endemism # I have an abundance matrix, I need to convert it into network format first: vegenet <- mat_to_net(vegemat)  bioregionalization_metrics(tree4,                             net = vegenet,                             eval_metric = c(\"avg_endemism\", \"tot_endemism\")) ## Computing composition-based metrics... ##   - avg_endemism OK ##   - tot_endemism OK ## Partition metrics: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Requested metric(s):  avg_endemism tot_endemism  ##  - Metric summary: ##      avg_endemism tot_endemism ## Min   0.001177433   0.04895862 ## Mean  0.008144637   0.08297200 ## Max   0.181513150   0.31539086 ##  ## Access the data.frame of metrics with your_object$evaluation_df ## Details of endemism % for each bioregionalization are available in  ##         your_object$endemism_results"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"criteria-to-choose-an-optimal-number-of-clusters","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters?","what":"3.2 Criteria to choose an optimal number of clusters","title":"4.1 Hierarchical clustering","text":"Choosing optimal number clusters long-standing issue literature, absolute objective answer question. plethora methods proposed years, best approach tackle issue probably compare results multiple approaches make informed decision. bioregion package, implemented several methods specifically suited bioregionalization analysis. example, standard criterion used identifying optimal number clusters elbow method, default criterion find_optimal_n(). However, recommend moving beyond paradigm single optimal number clusters, likely oversimplification hierarchy tree. recommend considering multiple cuts tree, provide several methods : identifying large steps curve using multiple cutoffs. Additionally, implement approaches, using maximum minimum value metrics, finding break points curve segmented model. look different methods, compute evaluation metrics store eval_tree4:","code":"vegenet <- mat_to_net(vegemat) eval_tree4 <- bioregionalization_metrics(tree4,                                           dissimilarity = dissim,                                           net = vegenet,                                           eval_metric = c(\"pc_distance\", \"anosim\",                                                          \"avg_endemism\", \"tot_endemism\")) ## Computing similarity-based metrics... ##   - pc_distance OK ##   - anosim OK ## Computing composition-based metrics... ##   - avg_endemism OK ##   - tot_endemism OK"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"elbow-method","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.1 Elbow method","title":"4.1 Hierarchical clustering","text":"elbow method consists find ‘elbow’ form metric-cluster relationship. method typically work metrics L-shaped form (typically, pc_distance endemism metrics), metrics (e.g. form anosim necessarily follow L-shape). rationale behind elbow method find cutoff metric values stop increasing significantly, adding new clusters provide much significant improvement metric. elbow method default method find_optimal_n(). parameters adjust . curve elbow-shaped, may give spurious results.   example , optimal number clusters varies depending metric, minimum 9 maximum 24. final choice depends metric preferences respect metrics, objectives clustering. Alternatively, two cut-offs used, deep cut-based endemism metrics e.g. value 9, shallow cutoff based pc_distance, 19.","code":"find_optimal_n(eval_tree4) ## Number of bioregionalizations: 99 ## Searching for potential optimal number(s) of clusters based on the elbow method ##    * elbow found at: ## pc_distance 19 ## anosim 24 ## avg_endemism 9 ## tot_endemism 12 ## Warning in find_optimal_n(eval_tree4): The elbow method is likely not suitable ## for the ANOSIM metric. You should rather look for leaps in the curve (see ## criterion = 'increasing_step' or decreasing_step) ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  pc_distance anosim avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  elbow  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 19 ## anosim - 24 ## avg_endemism - 9 ## tot_endemism - 12"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"step-method","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.2 Step method","title":"4.1 Hierarchical clustering","text":"step method consists identifying largest “steps” metrics, .e., largest increases decreases value metric. , function calculates successive differences metrics partitions. keep largest positive differences (increasing_step) negative differences (decreasing_step). increasing_step increasing metrics (pc_distance) decreasing_step decreasing metrics (avg_endemism tot_endemism). anosim values can either increase decrease depending dataset, explore ways. default, function selects top 1% steps:   However, can adjust two different ways. First, choose number steps select, e.g. select largest 3 steps, use step_levels = 3:  Note steps generally correspond large jumps tree, like approach fits well hierarchical nature tree. Second, can set quantile steps select, e.g. select 5% largest steps set quantile 0.95 (step_quantile = 0.95):  Finally, question may arise cluster number select large step occurs. example, largest step occurs partitions 4 5 clusters, keep partition 4 clusters, partition 5 clusters? default, function keeps partition \\(N + 1\\) (5 clusters example ). can change setting step_round_above = FALSE:","code":"find_optimal_n(eval_tree4,                metrics_to_use = c(\"anosim\", \"pc_distance\"),                criterion = \"increasing_step\") ## Number of bioregionalizations: 99 ## Searching for potential optimal number(s) of clusters based on the increasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  anosim pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  increasing_step  ##    (step quantile chosen:  0.99  (i.e., only the top 1 %  increase  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## anosim - 19 ## pc_distance - 12 find_optimal_n(eval_tree4,                metrics_to_use = c(\"avg_endemism\", \"tot_endemism\"),                criterion = \"decreasing_step\") ## Number of bioregionalizations: 99 ## Searching for potential optimal number(s) of clusters based on the decreasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  decreasing_step  ##    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## avg_endemism - 5 ## tot_endemism - 5 find_optimal_n(eval_tree4,                metrics_to_use = c(\"anosim\", \"pc_distance\"),                criterion = \"increasing_step\",                step_levels = 3) ## Number of bioregionalizations: 99 ## Searching for potential optimal number(s) of clusters based on the increasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  anosim pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  increasing_step  ##    (step quantile chosen:  0.99  (i.e., only the top 1 %  increase  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## anosim - 5 12 19 ## pc_distance - 5 12 19 find_optimal_n(eval_tree4,                metrics_to_use = c(\"anosim\", \"pc_distance\"),                criterion = \"increasing_step\",                step_quantile = 0.95) ## Number of bioregionalizations: 99 ## Searching for potential optimal number(s) of clusters based on the increasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  anosim pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  increasing_step  ##    (step quantile chosen:  0.95  (i.e., only the top 5 %  increase  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## anosim - 5 12 19 24 93 ## pc_distance - 3 5 12 19 68 find_optimal_n(eval_tree4,                metrics_to_use = c(\"avg_endemism\", \"tot_endemism\"),                criterion = \"decreasing_step\",                step_round_above = FALSE) ## Number of bioregionalizations: 99 ## Searching for potential optimal number(s) of clusters based on the decreasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  decreasing_step  ##    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## avg_endemism - 3 ## tot_endemism - 3"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"cutting-at-different-cut-off-values","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.3 Cutting at different cut-off values","title":"4.1 Hierarchical clustering","text":"idea method select specific metric values number clusters used. example, study, Holt et al. (2013) used different cutoffs pc_distance find global biogeographic regions: 0.90, 0.95, 0.99, 0.999. higher value, -diversity explained, also clusters . Therefore, choice trade-total -diversity explained number clusters. Eventually, choice values depends different factors: geographic scope study. global scale study can use large cutoffs like Holt et al. (2013) end reasonable number clusters, whereas regional local scale studies less endemism taxa shared among clusters, values high, cutoffs explored, 0.5 0.75. characteristics study increase decrease degree endemism among clusters: dispersal capacities taxonomic group, connectivity/barriers study area, etc. Use lower cutoffs large number widespread species, use higher cutoffs high degrees endemism. Using abundance phylogenetic data compute -diversity metrics may allow better distinguish clusters, turn allow use higher cutoffs. example, case, regional-scale study vegetation, can use three cutoffs: 0.6 (deep cutoff), 0.8 (intermediate cutoff), 0.9 (shallow cutoff).","code":"find_optimal_n(eval_tree4,                metrics_to_use = \"pc_distance\",                criterion = \"cutoff\",                metric_cutoffs = c(.6, .8, .9)) ## Number of bioregionalizations: 99 ## Searching for potential optimal number(s) of clusters based on the cutoff method ##  - Cutoff method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  cutoff  ##    --> cutoff(s) chosen:  0.6 0.8 0.9  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 5 12 29"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"cutting-at-the-maximum-or-minimum-metric-value","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.4 Cutting at the maximum or minimum metric value","title":"4.1 Hierarchical clustering","text":"criterion finds maximum (criterion = \"max\") minimum (criterion = \"min\") value metric list partitions selects corresponding partition. criterion can interesting case anosim, probably much less useful metrics implemented package.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"finding-break-points-in-the-curve","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.5 Finding break points in the curve","title":"4.1 Hierarchical clustering","text":"criterion consists applying segmented regression model formula evaluation metric ~ number clusters. user can define number breaks identified curve. Note model likely require minimum number points find appropriate number clusters. example , make 100 cuts tree enough values.  can ask higher number breaks: 2 breaks  3 breaks  Increasing number breaks can useful situations , example, non-linear silhouettes metric ~ n clusters.","code":"tree5 <- cut_tree(tree4,                   cut_height = seq(0, max(tree4$algorithm$final.tree$height),                                     length = 100))   eval_tree5 <- bioregionalization_metrics(tree5,                                           dissimilarity = dissim,                                           net = vegenet,                                           eval_metric = c(\"pc_distance\", \"anosim\",                                                          \"avg_endemism\", \"tot_endemism\")) ## Computing similarity-based metrics... ##   - pc_distance OK ##   - anosim OK ## Computing composition-based metrics... ##   - avg_endemism OK ##   - tot_endemism OK find_optimal_n(eval_tree5,                criterion = \"breakpoints\") ## Number of bioregionalizations: 100 ## Searching for potential optimal number(s) of clusters based on the breakpoints method ## Exact break point not in the list of bioregionalizations: finding the closest bioregionalization... ## Plotting results... ##    (the red line is the prediction from the segmented regression) ## Warning: Removed 1 row containing missing values or values outside the scale range ## (`geom_line()`). ## Search for an optimal number of clusters: ##  - 100  partition(s) evaluated ##  - Range of clusters explored: from  1  to  701  ##  - Evaluated metric(s):  pc_distance anosim avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  breakpoints  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 16 ## anosim - 111 ## avg_endemism - 2 ## tot_endemism - 2 find_optimal_n(eval_tree5,                criterion = \"breakpoints\",                n_breakpoints = 2) ## Number of bioregionalizations: 100 ## Searching for potential optimal number(s) of clusters based on the breakpoints method ## Exact break point not in the list of bioregionalizations: finding the closest bioregionalization... ## Plotting results... ##    (the red line is the prediction from the segmented regression) ## Warning: Removed 1 row containing missing values or values outside the scale range ## (`geom_line()`). ## Search for an optimal number of clusters: ##  - 100  partition(s) evaluated ##  - Range of clusters explored: from  1  to  701  ##  - Evaluated metric(s):  pc_distance anosim avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  breakpoints  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 13 92 ## anosim - 25 183 ## avg_endemism - 2 16 ## tot_endemism - 2 92 find_optimal_n(eval_tree5,                criterion = \"breakpoints\",                n_breakpoints = 3) ## Number of bioregionalizations: 100 ## Searching for potential optimal number(s) of clusters based on the breakpoints method ## Exact break point not in the list of bioregionalizations: finding the closest bioregionalization... ## Plotting results... ##    (the red line is the prediction from the segmented regression) ## Warning: Removed 1 row containing missing values or values outside the scale range ## (`geom_line()`). ## Search for an optimal number of clusters: ##  - 100  partition(s) evaluated ##  - Range of clusters explored: from  1  to  701  ##  - Evaluated metric(s):  pc_distance anosim avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  breakpoints  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 2 16 100 ## anosim - 25 183 566 ## avg_endemism - 2 13 56 ## tot_endemism - 2 14 111"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"optics-as-a-semi-hierarchical-clustering-approach","dir":"Articles","previous_headings":"","what":"4. OPTICS as a semi-hierarchical clustering approach","title":"4.1 Hierarchical clustering","text":"OPTICS (Ordering Points Identify Clustering Structure) semi-hierarchical clustering approach orders points datasets closest points become neighbors, calculates ‘reachability’ distance point, extracts clusters reachability distance hierarchical manner. However, hierarchical nature clusters directly provided algorithm tree-like output. Hence, users explore ‘reachability plot’ understand hierarchical nature OPTICS clusters, read related publication understand method (Hahsler et al., 2019). run optics algorithm, use hclu_optics() function:","code":"data(vegemat)  # Calculate dissimilarities dissim <- dissimilarity(vegemat)  clust1 <- hclu_optics(dissim)  clust1 ## Clustering results for algorithm : hclu_optics  ##  - Number of sites:  715  ## Clustering results: ##  - Number of partitions:  1  ##  - Number of clusters:  9"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"dissimilarity-indices","dir":"Articles","previous_headings":"","what":"1. Dissimilarity indices","title":"4.2 Non-hierarchical clustering","text":"Pairwise distances sites can obtained running dissimilarity() site-species matrix. example , use fish dataset package compute distance metrics. going compute \\(\\beta_{sim}\\) diversity metric, presence-absence dissimilarity index. formula follows:\\(\\beta_{sim} = min(b, c) / (+min(b, c))\\) number species shared sites; b number species occurring first site; c number species occurring second site. typically choose metric bioregionalization, turnover component Sorensen index (Baselga, 2012) (nutshell, tells us sites different distinct species), less dependence species richness Jaccard turnover (Leprieur & Oikonomou, 2014).  choice distance metric important outcome clustering procedure, recommend choose carefully depending research question. default, Simpson index computed, options available metric argument dissimilarity(). Furthermore, users can also write formula compute index wish argument formula, see ?dissimilarity(). now ready start non-hierarchical clustering procedure object dissim just created. Alternatively, can also use types objects distance matrix object (class dist) data.frame crafting (make sure read required format carefully explained help function).","code":"library(\"bioregion\") data(\"fishmat\")  # It is a presence/absence matrix with sites in rows and species in columns fishmat[1:3, 1:3] ##          Abramis brama Alburnus alburnus Barbatula barbatula ## Aa                   1                 1                   1 ## Abula                0                 0                   0 ## Acheloos             0                 0                   0 dissim <- dissimilarity(fishmat, metric = \"Simpson\")  dissim[1:3, ] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  338  ##  - Total number of species:  195  ##  - Number of rows:  56953  ##  - Number of dissimilarity metrics:  1  ##  ##  ##   Site1    Site2   Simpson ## 2    Aa    Abula 0.3333333 ## 3    Aa Acheloos 1.0000000 ## 4    Aa    Adige 0.7692308"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"centroid-based-clustering","dir":"Articles","previous_headings":"","what":"2. Centroid-based clustering","title":"4.2 Non-hierarchical clustering","text":"core idea algorithms place points cluster central-point closest. central-point can either centroid cluster, .e. mean x y coordinates points belonging cluster, medoid. medoid centrally located data point cluster, words least dissimilar point points cluster. objective minimize sum squared distances points assigned centroids/medoids.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"kmeans","dir":"Articles","previous_headings":"2. Centroid-based clustering","what":"2.1. Kmeans","title":"4.2 Non-hierarchical clustering","text":"K-means clustering perhaps famous method non-hierarchical clustering. uses centroids clusters. algorithm usually follows iterative framework : initialization step creates k centroids random placements. every point, Euclidean distance centroids calculated. point assigned nearest centroid. points assigned centroid form cluster. clusters formed, new centroids cluster calculated taking mean x y coordinates points belonging cluster. re-assignment step calculates new centroids based membership cluster. Steps 2 3 repeated solution converges, .e. centroid positions longer change. Finding optimal solution K-means computationally intensive implementation rely efficient heuristic algorithms quickly converge local optimum. Side-note k-means algorithm can become ‘stuck’ local optima. Repeating clustering algorithm adding noise data can help evaluate robustness solution. function compute K-means clustering bioregion nhclu_kmeans(). illustrate functions works example applied dissimilarity matrix calculated . chose 3 clusters. steps come arguments can tweaked. Specifically, iter_max determines maximum number iterations allowed (.e. many times steps described run) nstart specifies many random sets n_clust selected starting points.  Several heuristic algorithms can also used along K-means method can parameterized using algorithm argument. default, algorithm Hartigan-Wong (Hartigan & Wong (1979)) used. Let’s start setting iter_max nstart 1. asking one iteration , function displays message saying algorithm converge. therefore need increase value iter_max. Like functions bioregion package, class object specific package (bioregion.clusters) contains several parts. clusters assigned site accessible $clusters part output: , see 142 sites assigned cluster 1, 93 cluster 2 103 cluster 3. assignment can change depending two main arguments functions, iter_max nstart. shown , distribution sites among three clusters appears quite homogeneous three examples discrepancies emerge. Overall, increasing iter_max nstart increases chances convergence algorithm also increases computation time.","code":"ex_kmeans <- nhclu_kmeans(dissim, index = \"Simpson\", n_clust = 3, iter_max = 1,                           nstart = 1, algorithm = \"Hartigan-Wong\") ex_kmeans <- nhclu_kmeans(dissim, index = \"Simpson\", n_clust = 3, iter_max = 3,                           nstart = 1, algorithm = \"Hartigan-Wong\") ex_kmeans$clusters[1:3, ] ##                ID K_3 ## Aa             Aa   3 ## Abula       Abula   1 ## Acheloos Acheloos   2 table(ex_kmeans$clusters$K_3) ##  ##   1   2   3  ## 142  93 103 ex_kmeans2 <- nhclu_kmeans(dissim, index = \"Simpson\", n_clust = 3,                            iter_max = 100, nstart = 1,                            algorithm = \"Hartigan-Wong\")  ex_kmeans3 <- nhclu_kmeans(dissim, index = \"Simpson\", n_clust = 3,                            iter_max = 3, nstart = 100,                            algorithm = \"Hartigan-Wong\") table(ex_kmeans$clusters$K_3, ex_kmeans2$clusters$K_3) ##     ##       1   2   3 ##   1   1  12 129 ##   2  77  16   0 ##   3   0   9  94 table(ex_kmeans$clusters$K_3, ex_kmeans3$clusters$K_3) ##     ##       1   2   3 ##   1 111  29   2 ##   2   0   0  93 ##   3   0 102   1"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"section22","dir":"Articles","previous_headings":"2. Centroid-based clustering","what":"2.2. K-medoids","title":"4.2 Non-hierarchical clustering","text":"Instead using mean cluster, medoid can also used partition data points. comparison centroid used K-means, medoid less sensitive outliers data. partitions can also use types distances rely Euclidean distance . Several heuristics exist solve K-medoids problem, famous ones Partition Around Medoids (PAM), extensions CLARA CLARANS.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"partitioning-around-medoids-pam","dir":"Articles","previous_headings":"2. Centroid-based clustering > 2.2. K-medoids","what":"2.2.1. Partitioning Around Medoids (PAM)","title":"4.2 Non-hierarchical clustering","text":"PAM fast heuristic find solution k-medoids problem. k clusters, decomposes following steps:  1. Randomly pick k points initial medoids Assign point nearest medoid x Calculate objective function (sum dissimilarities points nearest medoids) Randomly select point y Swap x y swap reduces objective function Repeat 3-6 change nhclu_pam() function, several arguments tweak. number clusters n_clust defined well number starting positions medoids nstart. Several variants PAM algorithm available can changed argument variant (see cluster::pam() details). 2 clusters, see 258 sites assigned cluster 1 80 cluster 2.","code":"ex_pam <- nhclu_pam(dissim, index = \"Simpson\", n_clust = 2:25, nstart = 1,                     variant = \"faster\", cluster_only = FALSE) table(ex_pam$clusters$K_2) ##  ##   1   2  ## 258  80"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"clustering-large-applications-clara","dir":"Articles","previous_headings":"2. Centroid-based clustering > 2.2. K-medoids","what":"2.2.2. Clustering Large Applications (CLARA)","title":"4.2 Non-hierarchical clustering","text":"CLARA (Clustering Large Applications, (Kaufman Rousseeuw 1990)) extension k-medoids (PAM) methods deal data containing large number objects (several thousand observations) order reduce computational time RAM storage problem. achieved using sampling approach.","code":"ex_clara <- nhclu_clara(dissim, index = \"Simpson\",                         n_clust = 5,                         maxiter = 0L, initializer = \"LAB\", fasttol = 1,                         numsamples = 5L, sampling = 0.25, independent = FALSE,                         seed = 123456789L) table(ex_clara$clusters$K_5) ##  ##   1   2   3   4   5  ## 241  21  16  50  10"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"clustering-large-applications-based-on-randomized-search-clarans","dir":"Articles","previous_headings":"2. Centroid-based clustering > 2.2. K-medoids","what":"2.2.3. Clustering Large Applications based on RANdomized Search (CLARANS)","title":"4.2 Non-hierarchical clustering","text":"CLARANS (Clustering Large Applications based RANdomized Search, (Ng Han 2002)) extension k-medoids (PAM) methods combined CLARA algorithm.","code":"ex_clarans <- nhclu_clarans(dissim, index = \"Simpson\",                         n_clust = 5,                         numlocal = 2L, maxneighbor = 0.025,                         seed = 123456789L) table(ex_clara$clusters$K_5) ##  ##   1   2   3   4   5  ## 241  21  16  50  10"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"density-based-clustering","dir":"Articles","previous_headings":"","what":"3. Density-based clustering","title":"4.2 Non-hierarchical clustering","text":"Density-based clustering another type non-hierarchical clustering. connects areas high density clusters. allows arbitrary-shaped distributions long dense areas can connected. algorithms can however difficulty data varying densities high dimensions.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"dbscan","dir":"Articles","previous_headings":"3. Density-based clustering","what":"3.1. DBSCAN","title":"4.2 Non-hierarchical clustering","text":"Density-based Spatial Clustering Applications Noise (DBSCAN) (Hahsler et al. (2019)) famous density-based clustering approach.  operates locating points dataset surrounded significant number points. points regarded part dense zone, algorithm next attempt extend region encompass cluster’s points. DBSCAN uses two following parameters: Epsilon (eps): maximum distance two points considered neighboring points (belonging cluster). Minimum Points (minPts): minimum number neighboring points given point needs considered core data point. includes point . example, minimum number points set 4, given point needs 3 neighboring data points considered core data point. minimum number points meet epsilon distance requirement considered cluster. set two parameters, algorithm works like : Decide value eps minPts. point: Calculate distance points. distance less equal eps mark point neighbor x. point gets neighboring count greater equal minPts, mark core point visited. core point, already assigned cluster create new cluster. Recursively find neighboring points assign cluster core point. Continue steps unvisited points covered. algorithm can called function nhclu_dbscan(). user define two arguments presented , minPts eps, function provide knee curve helping search optimal eps value.  , see can set eps 1. set parameters, get one cluster. decrease eps value increase minPts, can get clusters.","code":"ex_dbscan <- nhclu_dbscan(dissim, index = \"Simpson\", minPts = NULL, eps = NULL,                           plot = TRUE) ## Trying to find a knee in the curve to search for an optimal eps value... ##        NOTE: this automatic identification of the knee may not work properly ##        if the curve has knees and elbows. Please adjust eps manually by ##        inspecting the curve, identifying a knee as follows: ##  ##                            / ##                  curve    / ##               ___________/  <- knee ##   elbow ->   / ##             / ##            / ex_dbscan2 <- nhclu_dbscan(dissim, index = \"Simpson\", minPts = NULL, eps = 1,                            plot = FALSE) table(ex_dbscan2$clusters$K_1) ##  ##   1  ## 338 ex_dbscan3 <- nhclu_dbscan(dissim, index = \"Simpson\", minPts = 4, eps = 0.5,                            plot = FALSE)  table(ex_dbscan3$clusters$K_2) ## < table of extent 0 >"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"section4","dir":"Articles","previous_headings":"","what":"4. Affinity propagation","title":"4.2 Non-hierarchical clustering","text":"algorithm based paper Frey & Dueck (2007) relies R package apcluster Unlike previous algorithms vignette, algorithm associated function use similarity matrix.","code":"# Similarity matrix sim <- dissimilarity_to_similarity(dissim)  # Algorithm clust1 <- nhclu_affprop(sim)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"section5","dir":"Articles","previous_headings":"","what":"5. Optimal number of clusters","title":"4.2 Non-hierarchical clustering","text":"Previous methods help determining optimal number bioregions structuring site-species matrix. purpose, can combine functions bioregionalization_metrics() find_optimal_n(). bioregionalization_metrics() calcultes several metrics based previous clustering attempts. *Note two metrics tot_endemism avg_endemism, also need provide site-species matrix. bioregionalization_metrics() function calculated partitioning metrics, can call find_optimal_n() get optimal number clusters.  Based metric selected, optimal number clusters can vary.","code":"bioregionalization_metrics(ex_pam, dissimilarity = dissim,                            eval_metric = \"pc_distance\") ## Partition metrics: ##  - 24  partition(s) evaluated ##  - Range of clusters explored: from  2  to  25  ##  - Requested metric(s):  pc_distance  ##  - Metric summary: ##      pc_distance ## Min    0.5464742 ## Mean   0.8022971 ## Max    0.8949633 ##  ## Access the data.frame of metrics with your_object$evaluation_df a <- bioregionalization_metrics(ex_pam, dissimilarity = dissim, net = fishdf,                                 species_col = \"Species\", site_col = \"Site\",                                 eval_metric = c(\"tot_endemism\", \"avg_endemism\",                                                 \"pc_distance\", \"anosim\")) find_optimal_n(a) ## Number of bioregionalizations: 24 ## Searching for potential optimal number(s) of clusters based on the elbow method ##    * elbow found at: ## tot_endemism 4 ## avg_endemism 4 ## pc_distance 7 ## anosim 2 ## Plotting results... ## Search for an optimal number of clusters: ##  - 24  partition(s) evaluated ##  - Range of clusters explored: from  2  to  25  ##  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  elbow  ##  - Optimal partition(s) of clusters for each metric: ## tot_endemism - 4 ## avg_endemism - 4 ## pc_distance - 7 ## anosim - 2"},{"path":[]},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"input-data","dir":"Articles","previous_headings":"1 Introduction","what":"1.1 Input data","title":"4.3 Network clustering","text":"network algorithms work network format, .e. data.frame 3 columns: sites, species abundance given species given site. type object can obtained site x species matrix use mat_to_net(). vignette, directly load network format distribution fish European basins. network algorithms work similarity matrix pair sites.","code":"library(\"bioregion\") data(\"fishdf\") data(\"fishmat\") fish_simil <- similarity(fishmat, metric = \"Simpson\")"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"main-arguments","dir":"Articles","previous_headings":"1 Introduction","what":"1.2 Main arguments","title":"4.3 Network clustering","text":"algorithms presented specific parameters can tweaked arguments common functions. Among common arguments following: * weight boolean indicating weights considered * index name number column use weight. default, third column name network data.frame used * site_col name number column site nodes (.e. primary nodes). * species_col = name number column species nodes (.e. feature nodes) * return_node_type character indicating types nodes (“sites”, “species” “”) returned output (keep_nodes_type=“” default). * algorithm_in_output boolean indicating original output communities returned output (see Value). three algorithms relying executable binary files, following arguments needed: * delete_temp boolean indicating temporary folder removed * path_temp character indicating path temporary folder * binpath character indicating path bin folder","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"binary-files","dir":"Articles","previous_headings":"","what":"2. Binary files","title":"4.3 Network clustering","text":"","code":"install_binaries(binpath = \"tempdir\", infomap_version = c(\"2.1.0\", \"2.6.0\"))"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"infomap","dir":"Articles","previous_headings":"2. Binary files","what":"2.1 Infomap","title":"4.3 Network clustering","text":"Rosvall & Bergstrom (2008) nbmod penalize solutions differ number (0 default preferred number modules). markovtime scales link flow change cost moving modules, higher values results fewer modules (default 1). seed random number generator (NULL random default) numtrials number trials picking best solution. twolevel boolean indicating algorithm optimize two-level partition network (default multi-level). show_hierarchy boolean specifying hierarchy community identifiable outputs (FALSE default).","code":"set.seed(1) ex_infomap <- netclu_infomap(fish_simil,                              weight = TRUE,                              index = names(fish_simil)[3],                              nbmod = 0,                              markovtime = 1,                              seed = NULL,                              numtrials = 1,                              twolevel = FALSE,                              show_hierarchy = FALSE,                              directed = FALSE,                              bipartite_version = FALSE,                              bipartite = FALSE,                              site_col = 1,                              species_col = 2,                              return_node_type = \"both\",                              version = \"2.6.0\",                              binpath = \"tempdir\",                              path_temp = \"infomap_temp\",                              delete_temp = TRUE)  table(ex_infomap$clusters$K_5) ##  ##   1   2   3   4   5  ## 290  14  23   9   2"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"oslom","dir":"Articles","previous_headings":"2. Binary files","what":"2.2 OSLOM","title":"4.3 Network clustering","text":"OSLOM stands Order Statistics Local Optimization Method. Similarity-based algorithm. Lancichinetti et al. (2011) reassign string indicating nodes belonging several community reassign method used (see Note). * r number runs first hierarchical level (10 default). * hr number runs higher hierarchical level (50 default, 0 interested hierarchies). * seed random number generator (NULL random default). * t p-value, default value 0.10, increase value get modules. * cp kind resolution parameter used decide taking modules union (default value 0.5, bigger value leads bigger clusters).","code":"set.seed(1) ex_oslom <- netclu_oslom(fish_simil,                          weight = TRUE,                          index = names(fish_simil)[3],                          reassign = \"no\",                          r = 10,                          hr = 50,                          seed = NULL,                          t = 0.1,                          cp = 0.5,                          directed = FALSE,                          bipartite = FALSE,                          site_col = 1,                          species_col = 2,                          return_node_type = \"both\",                          binpath = \"tempdir\",                          path_temp = \"oslom_temp\",                          delete_temp = TRUE)  table(ex_oslom$clusters$K_338)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"louvain","dir":"Articles","previous_headings":"2. Binary files","what":"2.3 Louvain","title":"4.3 Network clustering","text":"Blondel et al. (2008) q quality function used compute partition graph (modularity chosen default, see Details). c parameter Owsinski-Zadrozny quality function (0 1, 0.5 chosen default) k kappa_min value Shi-Malik quality function (must > 0, 1 chosen default)","code":"set.seed(1) ex_louvain <- netclu_louvain(fishdf,                              weight = TRUE,                              index = names(fishdf)[3],                              lang = \"cpp\",                              q = 0,                              c = 0.5,                              k = 1,                              bipartite = FALSE,                              site_col = 1,                              species_col = 2,                              return_node_type = \"both\",                              binpath = \"tempdir\",                              path_temp = \"louvain_temp\",                              delete_temp = TRUE,                              algorithm_in_output = TRUE) table(ex_louvain$clusters$K_23) ## < table of extent 0 >"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"fastgreedy","dir":"Articles","previous_headings":"3. Functions from the igraph package","what":"3.1 Fastgreedy","title":"4.3 Network clustering","text":"Clauset et al. (2004)","code":"set.seed(1) ex_greedy <- netclu_greedy(fishdf,                            weight = TRUE,                            index = names(fishdf)[3],                            bipartite = FALSE,                            site_col = 1,                            species_col = 2,                            return_node_type = \"both\",                            algorithm_in_output = TRUE) table(ex_greedy$clusters$K_5) ##  ##   1   2   3   4   5  ## 138  61 144 132  58"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"label-propagation","dir":"Articles","previous_headings":"3. Functions from the igraph package","what":"3.2 Label propagation","title":"4.3 Network clustering","text":"Raghavan et al. (2007)","code":"set.seed(1) ex_labelprop <- netclu_labelprop(fishdf,                                  weight = TRUE,                                  index = names(fishdf)[3],                                  bipartite = FALSE,                                  site_col = 1,                                  species_col = 2,                                  return_node_type = \"both\",                                  algorithm_in_output = TRUE) table(ex_labelprop$clusters$K_11) ## < table of extent 0 >"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"leiden-algorithm","dir":"Articles","previous_headings":"3. Functions from the igraph package","what":"3.3 Leiden algorithm","title":"4.3 Network clustering","text":"Traag et al. (2019)","code":"set.seed(1) ex_leiden <- netclu_leiden(fishdf,                            weight = TRUE,                            index = names(fishdf)[3],                            objective_function = \"CPM\",                            resolution_parameter = 1,                            beta = 0.01,                            n_iterations = 2,                            vertex_weights = NULL,                            bipartite = TRUE,                            site_col = 1,                            species_col = 2,                            return_node_type = \"both\",                            algorithm_in_output = TRUE) length(unique(ex_leiden$clusters$K_505)) ## [1] 0"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"leading-eigenvector","dir":"Articles","previous_headings":"3. Functions from the igraph package","what":"3.4 Leading eigenvector","title":"4.3 Network clustering","text":"Newman (2006)","code":"set.seed(1) ex_leadingeigen <- netclu_leadingeigen(fishdf,                                        weight = TRUE,                                        index = names(fishdf)[3],                                        bipartite = FALSE,                                        site_col = 1,                                        species_col = 2,                                        return_node_type = \"both\",                                        algorithm_in_output = TRUE) table(ex_leadingeigen$clusters$K_17) ## < table of extent 0 >"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"walktrap","dir":"Articles","previous_headings":"3. Functions from the igraph package","what":"3.5 Walktrap","title":"4.3 Network clustering","text":"Pons & Latapy (2005)","code":"set.seed(1) ex_walktrap <- netclu_walktrap(fishdf,                                weight = TRUE,                                index = names(fishdf)[3],                                steps = 4,                                bipartite = FALSE,                                site_col = 1,                                species_col = 2,                                return_node_type = \"both\",                                algorithm_in_output = TRUE) table(ex_walktrap$clusters$K_14) ##  ##   1  10  11  12  13  14   2   3   4   5   6   7   8   9  ##  11  47  10   2   6  17  84   5  37  16   5 270   4  19"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"beckett","dir":"Articles","previous_headings":"4 Function from the bipartite package","what":"4.1 Beckett","title":"4.3 Network clustering","text":"Update QuanBiMo algorithm developed Dormann & Strauss (2014). Beckett (2016)","code":"set.seed(1) ex_beckett <- netclu_beckett(fishdf,                              weight = TRUE,                              index = names(fishdf)[3],                              site_col = 1,                              species_col = 2,                              return_node_type = \"both\",                              forceLPA = TRUE,                              algorithm_in_output = TRUE) ex_beckett$clusters$K_23 ##   [1] \"4\"  \"1\"  \"2\"  \"3\"  \"4\"  \"4\"  \"3\"  \"3\"  \"16\" \"13\" \"1\"  \"1\"  \"8\"  \"1\"  \"16\" ##  [16] \"5\"  \"4\"  \"3\"  \"4\"  \"8\"  \"4\"  \"1\"  \"4\"  \"4\"  \"5\"  \"4\"  \"4\"  \"1\"  \"13\" \"1\"  ##  [31] \"4\"  \"3\"  \"1\"  \"3\"  \"4\"  \"4\"  \"4\"  \"4\"  \"3\"  \"3\"  \"4\"  \"3\"  \"1\"  \"5\"  \"3\"  ##  [46] \"3\"  \"6\"  \"4\"  \"3\"  \"4\"  \"1\"  \"4\"  \"1\"  \"4\"  \"4\"  \"4\"  \"7\"  \"8\"  \"4\"  \"9\"  ##  [61] \"4\"  \"4\"  \"4\"  \"4\"  \"10\" \"10\" \"1\"  \"4\"  \"5\"  \"1\"  \"5\"  \"4\"  \"8\"  \"8\"  \"4\"  ##  [76] \"1\"  \"3\"  \"1\"  \"16\" \"13\" \"12\" \"1\"  \"22\" \"4\"  \"3\"  \"1\"  \"3\"  \"1\"  \"13\" \"4\"  ##  [91] \"4\"  \"8\"  \"4\"  \"8\"  \"15\" \"15\" \"15\" \"15\" \"4\"  \"1\"  \"8\"  \"4\"  \"1\"  \"8\"  \"4\"  ## [106] \"8\"  \"4\"  \"1\"  \"1\"  \"4\"  \"1\"  \"15\" \"1\"  \"1\"  \"5\"  \"1\"  \"16\" \"8\"  \"1\"  \"1\"  ## [121] \"1\"  \"13\" \"1\"  \"8\"  \"1\"  \"8\"  \"17\" \"18\" \"1\"  \"1\"  \"1\"  \"8\"  \"1\"  \"19\" \"1\"  ## [136] \"1\"  \"8\"  \"4\"  \"4\"  \"4\"  \"4\"  \"5\"  \"4\"  \"1\"  \"1\"  \"1\"  \"4\"  \"4\"  \"5\"  \"5\"  ## [151] \"3\"  \"8\"  \"1\"  \"11\" \"1\"  \"4\"  \"1\"  \"1\"  \"1\"  \"1\"  \"13\" \"16\" \"4\"  \"1\"  \"1\"  ## [166] \"1\"  \"1\"  \"1\"  \"1\"  \"3\"  \"8\"  \"5\"  \"5\"  \"20\" \"5\"  \"4\"  \"3\"  \"1\"  \"4\"  \"1\"  ## [181] \"4\"  \"1\"  \"6\"  \"1\"  \"13\" \"3\"  \"8\"  \"8\"  \"4\"  \"3\"  \"1\"  \"8\"  \"1\"  \"4\"  \"8\"  ## [196] \"1\"  \"3\"  \"4\"  \"1\"  \"4\"  \"8\"  \"4\"  \"1\"  \"1\"  \"4\"  \"1\"  \"16\" \"1\"  \"4\"  \"8\"  ## [211] \"1\"  \"3\"  \"15\" \"1\"  \"1\"  \"16\" \"13\" \"1\"  \"3\"  \"1\"  \"1\"  \"1\"  \"3\"  \"1\"  \"21\" ## [226] \"1\"  \"4\"  \"1\"  \"1\"  \"1\"  \"1\"  \"1\"  \"4\"  \"1\"  \"1\"  \"1\"  \"8\"  \"4\"  \"4\"  \"4\"  ## [241] \"1\"  \"22\" \"1\"  \"1\"  \"1\"  \"4\"  \"1\"  \"5\"  \"1\"  \"4\"  \"1\"  \"1\"  \"1\"  \"8\"  \"15\" ## [256] \"4\"  \"1\"  \"4\"  \"4\"  \"1\"  \"4\"  \"4\"  \"4\"  \"8\"  \"3\"  \"4\"  \"8\"  \"3\"  \"4\"  \"1\"  ## [271] \"1\"  \"13\" \"1\"  \"4\"  \"22\" \"1\"  \"1\"  \"3\"  \"3\"  \"5\"  \"5\"  \"4\"  \"4\"  \"1\"  \"4\"  ## [286] \"4\"  \"4\"  \"4\"  \"3\"  \"11\" \"4\"  \"3\"  \"4\"  \"1\"  \"1\"  \"1\"  \"1\"  \"8\"  \"4\"  \"4\"  ## [301] \"4\"  \"4\"  \"3\"  \"1\"  \"5\"  \"1\"  \"1\"  \"4\"  \"5\"  \"8\"  \"1\"  \"1\"  \"1\"  \"1\"  \"1\"  ## [316] \"5\"  \"1\"  \"4\"  \"1\"  \"1\"  \"14\" \"10\" \"8\"  \"4\"  \"1\"  \"4\"  \"4\"  \"4\"  \"4\"  \"3\"  ## [331] \"1\"  \"1\"  \"5\"  \"4\"  \"8\"  \"8\"  \"4\"  \"23\" \"4\"  \"4\"  \"4\"  \"8\"  \"8\"  \"1\"  \"4\"  ## [346] \"4\"  \"4\"  \"13\" \"1\"  \"4\"  \"4\"  \"1\"  \"16\" \"16\" \"2\"  \"16\" \"2\"  \"2\"  \"2\"  \"16\" ## [361] \"2\"  \"16\" \"3\"  \"4\"  \"3\"  \"3\"  \"3\"  \"3\"  \"3\"  \"3\"  \"3\"  \"3\"  \"4\"  \"5\"  \"4\"  ## [376] \"4\"  \"3\"  \"3\"  \"12\" \"16\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" ## [391] \"13\" \"13\" \"13\" \"8\"  \"8\"  \"16\" \"16\" \"5\"  \"20\" \"15\" \"5\"  \"5\"  \"4\"  \"3\"  \"3\"  ## [406] \"8\"  \"15\" \"5\"  \"5\"  \"5\"  \"5\"  \"5\"  \"5\"  \"13\" \"8\"  \"13\" \"9\"  \"3\"  \"3\"  \"3\"  ## [421] \"5\"  \"6\"  \"19\" \"6\"  \"6\"  \"7\"  \"7\"  \"7\"  \"7\"  \"7\"  \"8\"  \"7\"  \"7\"  \"7\"  \"7\"  ## [436] \"21\" \"21\" \"7\"  \"21\" \"7\"  \"7\"  \"7\"  \"7\"  \"7\"  \"7\"  \"8\"  \"10\" \"8\"  \"10\" \"9\"  ## [451] \"9\"  \"9\"  \"9\"  \"10\" \"9\"  \"9\"  \"8\"  \"10\" \"22\" \"9\"  \"9\"  \"9\"  \"10\" \"9\"  \"8\"  ## [466] \"10\" \"9\"  \"9\"  \"4\"  \"10\" \"10\" \"8\"  \"10\" \"10\" \"15\" \"5\"  \"5\"  \"11\" \"11\" \"15\" ## [481] \"13\" \"13\" \"22\" \"22\" \"13\" \"22\" \"12\" \"12\" \"22\" \"13\" \"13\" \"15\" \"15\" \"14\" \"15\" ## [496] \"15\" \"15\" \"15\" \"15\" \"5\"  \"16\" \"17\" \"18\" \"18\" \"18\" \"18\" \"23\" \"19\" \"19\" \"13\" ## [511] \"20\" \"13\" \"22\" \"13\" \"13\" \"13\" \"3\"  \"21\" \"21\" \"21\" \"21\" \"21\" \"21\" \"4\"  \"22\" ## [526] \"22\" \"5\"  \"22\" \"22\" \"22\" \"5\"  \"10\" \"23\""},{"path":[]},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_4_microbenchmark.html","id":"vegemat","dir":"Articles","previous_headings":"1. Datasets","what":"1.1. Vegemat","title":"4.4 Microbenchmark","text":"first dataset comes available bioregion analyzed article. contains abundance 3,697 plant species distributed 715 sites French Mediterranean area. dataset use two following files: vegedf data.frame 460,878 rows 3 columns (Site, Species Abundance) vegemat co-occurrence matrix containing information gathered matrix 715 rows 3,697 columns.","code":"data(\"vegedf\") data(\"vegemat\")  vegemat_dissim <- dissimilarity(vegemat,  metric = c(\"abc\", \"Simpson\")) vegemat_df <- mat_to_net(vegemat, weight = TRUE, remove_zeroes = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_4_microbenchmark.html","id":"european-fish","dir":"Articles","previous_headings":"1. Datasets","what":"1.2. European fish","title":"4.4 Microbenchmark","text":"second dataset also comes available bioregion contains distribution 195 freshwater fish distributed basins Europe.","code":"data(\"fishmat\") fishdissim <- dissimilarity(fishmat, metric = \"all\") data(\"fishdf\")"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_4_microbenchmark.html","id":"aravo","dir":"Articles","previous_headings":"1. Datasets","what":"1.3. Aravo","title":"4.4 Microbenchmark","text":"third dataset, called aravo, retrieved package ade4. contains distribution 82 alpine plants 75 sites distributed French Alps.","code":"data(\"aravo\") aravo <- as.matrix(aravo$spe) dim(aravo) ## [1] 75 82 ara_dissim <- dissimilarity(aravo, metric = \"all\")  ara_df <- mat_to_net(aravo, weight = TRUE, remove_zeroes = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_4_microbenchmark.html","id":"microbenchmark","dir":"Articles","previous_headings":"","what":"2. Microbenchmark","title":"4.4 Microbenchmark","text":"assess time needed clustering algorithm three datasets loaded . Plotting results.   OSLOM Beckett slow, ran far Vegetation data.","code":"install_binaries()  mbm <- suppressMessages(   microbenchmark(     # aravo     ara_nhclu_dbscan = nhclu_dbscan(dissimilarity = ara_dissim,                                     index = \"Simpson\", plot = FALSE),     ara_nhclu_kmeans = nhclu_kmeans(ara_dissim, n_clust = 2:10,                                     index = \"Simpson\"),     ara_nhclu_pam = nhclu_pam(ara_dissim, n_clust = 2:10, index = \"Simpson\"),     ara_hclu_hierarclust = hclu_hierarclust(dissimilarity = ara_dissim,                                             n_clust = 5,                                             optimal_tree_method = \"best\"),     ara_hclu_optics = hclu_optics(ara_dissim, index = \"Simpson\"),     ara_netclu_beckett = netclu_beckett(ara_df),     ara_netclu_greedy = netclu_greedy(ara_df),     ara_netclu_labelprop = netclu_labelprop(ara_df),     ara_netclu_leadingeigen = netclu_leadingeigen(ara_df),     ara_netclu_oslom = netclu_oslom(ara_df),     ara_netclu_walktrap = netclu_walktrap(ara_df),     ara_netclu_infomap = netclu_infomap(ara_df),     ara_netclu_louvain = netclu_louvain(ara_df),          # fish vertebrates     fish_nhclu_dbscan = nhclu_dbscan(dissimilarity = fishdissim,                                      index = \"Simpson\", plot = FALSE),     fish_nhclu_kmeans = nhclu_kmeans(fishdissim, n_clust = 2:10,                                      index = \"Simpson\"),     fish_nhclu_pam = nhclu_pam(fishdissim, n_clust = 2:10, index = \"Simpson\"),     fish_hclu_hierarclust = hclu_hierarclust(dissimilarity = fishdissim,                                              n_clust = 5,                                              optimal_tree_method = \"best\"),     fish_hclu_optics = hclu_optics(fishdissim, index = \"Simpson\"),     fish_netclu_beckett = netclu_beckett(fishdf),     fish_netclu_greedy = netclu_greedy(fishdf),     fish_netclu_labelprop = netclu_labelprop(fishdf),     fish_netclu_leadingeigen = netclu_leadingeigen(fishdf),     fish_netclu_oslom = netclu_oslom(fishdf),     fish_netclu_walktrap = netclu_walktrap(fishdf),     fish_netclu_infomap = netclu_infomap(fishdf),     fish_netclu_louvain = netclu_louvain(fishdf),          # vegetation     veg_nhclu_dbscan = nhclu_dbscan(dissimilarity = vegemat_dissim,                                     index = \"Simpson\", plot = FALSE),     veg_nhclu_kmeans = nhclu_kmeans(vegemat_dissim, n_clust = 2:10,                                     index = \"Simpson\"),     veg_nhclu_pam = nhclu_pam(vegemat_dissim, n_clust = 2:10,                               index = \"Simpson\"),     veg_hclu_hierarclust = hclu_hierarclust(dissimilarity = vegemat_dissim,                                             n_clust = 5,                                             optimal_tree_method = \"best\"),     veg_hclu_optics = hclu_optics(vegemat_dissim, index = \"Simpson\"),     # veg_netclu_beckett = netclu_beckett(vegemat_df),     veg_netclu_greedy = netclu_greedy(vegemat_df),     veg_netclu_labelprop = netclu_labelprop(vegemat_df),     veg_netclu_leadingeigen = netclu_leadingeigen(vegemat_df),     # veg_netclu_oslom = netclu_oslom(vegemat_df),     veg_netclu_walktrap = netclu_walktrap(vegemat_df),     veg_netclu_infomap = netclu_infomap(vegemat_df),     veg_netclu_louvain = netclu_louvain(vegemat_df),          times = 2))  mbm_plot <- data.frame(mbm) mbm_plot$expr <- as.character(mbm_plot$expr) mbm_plot$dataset <- ifelse(   grepl(\"ara_\", mbm_plot$expr),   paste0(\"Aravo (\", nrow(aravo) * ncol(aravo), \" cells)\"),   ifelse(grepl(\"fish\", mbm_plot$expr),          paste0(\"Fish (\", nrow(fishmat) * ncol(fishmat), \" cells)\"),          paste0(\"Vegetation (\", nrow(vegemat) * ncol(vegemat), \" cells)\")))  mbm_plot$algorithm <- gsub( \".*_\", \"\", mbm_plot$expr)  # Time in minutes mbm_plot$time_min <- mbm_plot$time / 60e9 # Time in seconds mbm_plot$time_sec <- mbm_plot$time / 1e9 ggplot(mbm_plot[which(mbm_plot$dataset == \"Aravo (6150 cells)\"), ],        aes(reorder(algorithm, time_sec), time_sec)) +   geom_boxplot(aes(color = reorder(algorithm, time_sec),                    fill = reorder(algorithm, time_sec)), show.legend = FALSE) +   scale_color_viridis_d(\"Algorithm\") +   scale_fill_viridis_d(\"Algorithm\") +   labs(title = \"Aravo (6,510 cells)\", x = \"\", y = \"Time (seconds)\") +   theme_classic() +   theme(panel.border = element_rect(fill = NA),         axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) ggplot(mbm_plot[which(mbm_plot$dataset == \"Fish (65910 cells)\"), ],        aes(reorder(algorithm, time_sec), time_sec)) +   geom_boxplot(aes(color = reorder(algorithm, time_sec),                    fill = reorder(algorithm, time_sec)), show.legend = FALSE) +   scale_color_viridis_d(\"Algorithm\") +   scale_fill_viridis_d(\"Algorithm\") +   labs(title = \"European fish (65,910 cells)\",        x = \"\", y = \"Time (seconds)\") +   theme_classic() +   theme(panel.border = element_rect(fill = NA),         axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) ggplot(mbm_plot[which(mbm_plot$dataset == \"Vegetation (2643355 cells)\"), ],        aes(reorder(algorithm, time_min), time_min)) +   geom_boxplot(aes(color = reorder(algorithm, time_min),                    fill = reorder(algorithm, time_min)), show.legend = FALSE) +   scale_color_viridis_d(\"Algorithm\") +   scale_fill_viridis_d(\"Algorithm\") +   labs(title = \"Vegetation (2,643,355 cells)\", x = \"\", y = \"Time (minutes)\") +   theme_classic() +   theme(panel.border = element_rect(fill = NA),         axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"data","dir":"Articles","previous_headings":"","what":"1. Data","title":"5.1 Visualization","text":"vignette, rely dataset describing distribution vascular plants Mediterranean part France. first load matrix format dataset, computes dissimilarity matrix also load data.frame format data. Since aim plotting result, also need object fishsf linking site dataset geometry. also import world coastlines, available rnaturalearth R package.","code":"data(vegemat) vegedissim <- dissimilarity(vegemat, metric = \"all\") data(vegedf) data(vegesf) world <- rnaturalearth::ne_coastline(returnclass = \"sf\", scale = \"medium\") # Align the CRS of both objects vegesf <- st_transform(vegesf, crs = st_crs(world))"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"plots","dir":"Articles","previous_headings":"","what":"2. Plots","title":"5.1 Visualization","text":"section, show three ways plot results.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"map_bioregions","dir":"Articles","previous_headings":"2. Plots","what":"2.1 map_bioregions()","title":"5.1 Visualization","text":"first possibility use function map_bioregions() package. function can directly provide plot site colored according cluster belong .  Let’s take example K-means clustering, number clusters set 3. map_bioregions() function can now simply takes object fish_nhclu_kmeans, bioregion.clusters class, spatial distribution sites, stored fishsf.","code":"set.seed(1) vege_nhclu_kmeans <- nhclu_kmeans(vegedissim, n_clust = 3, index = \"Simpson\") map_bioregions(vege_nhclu_kmeans, geometry = vegesf, plot = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"custom-plot","dir":"Articles","previous_headings":"2. Plots","what":"2.2 Custom plot","title":"5.1 Visualization","text":"want customize plot simply rely default option, map_bioregions() gives possibility extract site well geometry cluster number. purpose, can set arguments like chunk :","code":"custom <- map_bioregions(vege_nhclu_kmeans, geometry = vegesf,                          write_clusters = TRUE, plot = FALSE) custom ## Simple feature collection with 715 features and 2 fields ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 1.686171 ymin: 42.29604 xmax: 7.798711 ymax: 45.13742 ## Geodetic CRS:  WGS 84 ## First 10 features: ##    ID K_3                       geometry ## 1  35   2 POLYGON ((6.098099 45.13742... ## 2  36   2 POLYGON ((6.22521 45.13381,... ## 3  37   2 POLYGON ((6.352304 45.13007... ## 4  38   2 POLYGON ((6.47938 45.12617,... ## 5  39   2 POLYGON ((6.606438 45.12213... ## 6  84   2 POLYGON ((6.093117 45.04745... ## 7  85   2 POLYGON ((6.220024 45.04385... ## 8  86   2 POLYGON ((6.346914 45.04011... ## 9  87   2 POLYGON ((6.473786 45.03622... ## 10 88   2 POLYGON ((6.600641 45.03219... # Crop world coastlines to the extent of the sf object of interest europe <- sf::st_crop(world, sf::st_bbox(custom))  # Plot ggplot(custom) +   geom_sf(aes(fill = K_3), show.legend = FALSE) +   geom_sf(data = europe) +   scale_fill_viridis_d() +   labs(title = \"Kmeans with 3 clusters\") +   theme_void()"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"plot-with-facets","dir":"Articles","previous_headings":"2. Plots","what":"2.3 Plot with facets","title":"5.1 Visualization","text":"Finally, can interested plotting several bioregionalizations . purpose, can build single data.frame gathering bioregions obtained distinct algorithms take advantage facets implemented ggplot2. first compute bioregionalizations dataset using algorithms. can now make single data.frame extra-column indicating algorithm used. now convert data.frame long-format data.frame. now add back geometry extra column make object spatial. Now long-format spatial data.frame, can take advantage facets implemented ggplot2.  can refine map : * reordering 3 bioregions follow order * add background Mediterranean sea mainland * crop cells mainland * adjust labels","code":"# Hierarchical clustering set.seed(1) vege_hclu_hierarclust <- hclu_hierarclust(dissimilarity = vegedissim,                                           index = names(vegedissim)[6],                                           method = \"mcquitty\", n_clust = 3,                                           optimal_tree_method = \"best\") vege_hclu_hierarclust$cluster_info ##   partition_name n_clust requested_n_clust output_cut_height ## 1            K_3       3                 3             0.625 # Walktrap network bioregionalization vegesim <- dissimilarity_to_similarity(vegedissim) set.seed(1) vege_netclu_walktrap <- netclu_walktrap(vegesim,                                         index = names(vegesim)[6]) vege_netclu_walktrap$cluster_info # 3 ##     partition_name n_clust ## K_3            K_3       3 vege_kmeans <- vege_nhclu_kmeans$clusters colnames(vege_kmeans)<- c(\"ID\", \"NHCLU_KMEANS\") vege_hieraclust <- vege_hclu_hierarclust$clusters colnames(vege_hieraclust)<- c(\"ID\", \"HCLU_HIERARCLUST\") vege_walktrap <- vege_netclu_walktrap$clusters colnames(vege_walktrap)<- c(\"ID\", \"NETCLU_Walktrap\")  all_clusters <- dplyr::left_join(vege_kmeans, vege_hieraclust, by = \"ID\") all_clusters <- dplyr::left_join(all_clusters, vege_walktrap, by = \"ID\") all_long <- tidyr::pivot_longer(data = all_clusters,                                 cols = dplyr::contains(\"_\"),                                 names_to = \"Algorithm\",                                 values_to = \"Clusters\") all_long <- as.data.frame(all_long) all_long_sf <- dplyr::left_join(all_long,                                 vegesf[, c(\"ID\", \"geometry\")],                                 by = \"ID\") all_long_sf <- sf::st_as_sf(all_long_sf) ggplot(all_long_sf) +   geom_sf(aes(color = Clusters, fill = Clusters)) +   geom_sf(data = europe, fill = \"gray80\") +   scale_color_viridis_d() +   scale_fill_viridis_d() +   theme_void() +   facet_wrap(~ Algorithm) world_countries <- rnaturalearth::ne_countries(scale = \"medium\",                                                returnclass = \"sf\")  # Background box xmin <- st_bbox(world)[[\"xmin\"]]; xmax <- st_bbox(world)[[\"xmax\"]] ymin <- st_bbox(world)[[\"ymin\"]]; ymax <- st_bbox(world)[[\"ymax\"]] bb <- sf::st_union(sf::st_make_grid(st_bbox(c(xmin = xmin,                                               xmax = xmax,                                               ymax = ymax,                                               ymin = ymin),                                             crs = st_crs(4326)),                                     n = 100))  # Crop world coastlines to the extent of the sf object of interest vegesf <- st_transform(vegesf, crs = st_crs(world)) larger_bbox <- sf::st_bbox(vegesf) larger_bbox[[1]] <- 1.5 larger_bbox[[2]] <- 42.15 larger_bbox[[3]] <- 8.1 larger_bbox[[4]] <- 45.3  europe <- sf::st_crop(world, larger_bbox) sf_use_s2(FALSE) europe_countries <- sf::st_crop(world_countries, larger_bbox) europe_bb <- sf::st_crop(bb, larger_bbox)  plot_basis <- ggplot(europe) +   geom_sf(data = europe_bb, fill = \"aliceblue\") +   geom_sf(data = europe_countries, fill = \"ivory\", color = \"gray50\") +   theme_void()  # Reordering bioregions all_long_sf$bioregion <- all_long_sf$Clusters  all_long_sf[which(all_long_sf$Algorithm == \"NHCLU_KMEANS\" &                     all_long_sf$Clusters == \"2\"), ]$bioregion <- \"3\" all_long_sf[which(all_long_sf$Algorithm == \"NHCLU_KMEANS\" &                     all_long_sf$Clusters == \"3\"), ]$bioregion <- \"2\"  all_long_sf[which(all_long_sf$Algorithm == \"NETCLU_Walktrap\" &                     all_long_sf$Clusters == \"1\"), ]$bioregion <- \"2\" all_long_sf[which(all_long_sf$Algorithm == \"NETCLU_Walktrap\" &                     all_long_sf$Clusters == \"2\"), ]$bioregion <- \"3\" all_long_sf[which(all_long_sf$Algorithm == \"NETCLU_Walktrap\" &                     all_long_sf$Clusters == \"3\"), ]$bioregion <- \"1\"  # More readable labels for algorithms all_long_sf$Algo <-   ifelse(all_long_sf$Algorithm == \"NHCLU_KMEANS\", \"K-Means\",          ifelse(all_long_sf$Algorithm == \"NHCLU_PAM\", \"PAM\",                 ifelse(all_long_sf$Algorithm == \"HCLU_HIERARCLUST\",                        \"Hierarchical Clustering\", \"Walktrap\")))  # Cropping with borders of France all_long_sf_france <-   st_intersection(all_long_sf,                   europe_countries[which(europe_countries$sovereignt == \"France\"), ])  # Plot final_plot <- plot_basis +   geom_sf(data = all_long_sf_france,           aes(color = bioregion, fill = bioregion), show.legend = TRUE) +   geom_sf(data = st_union(all_long_sf_france), fill = \"NA\", color = \"gray50\") +   geom_sf(data = europe, fill = \"gray50\", linewidth = 0.1) +   scale_color_viridis_d(\"Bioregion\", option = \"magma\", direction = -1) +   scale_fill_viridis_d(\"Bioregion\", option = \"magma\", direction = -1) +   theme_void() +   theme(legend.position = \"bottom\") +   facet_wrap(~ Algo) final_plot"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_compare_bioregionalizations.html","id":"data","dir":"Articles","previous_headings":"","what":"1. Data","title":"5.2 Compare bioregionalizations","text":"use vegetation dataset comes bioregion.","code":"data(\"vegedf\") data(\"vegemat\")  # Calculation of (dis)similarity matrices vegedissim <- dissimilarity(vegemat, metric = c(\"Simpson\")) vegesim <- dissimilarity_to_similarity(vegedissim)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_compare_bioregionalizations.html","id":"bioregionalization","dir":"Articles","previous_headings":"","what":"2. Bioregionalization","title":"5.2 Compare bioregionalizations","text":"use three bioregionalization algorithms visualization vignette, .e. non-hierarchical, hierarchical network bioregionalizations. chose 3 bioregions non-hierarchical hierarchical bioregionalizations.","code":"# Non hierarchical bioregionalization vege_nhclu_kmeans <- nhclu_kmeans(vegedissim, n_clust = 3, index = \"Simpson\") vege_nhclu_kmeans$cluster_info # 3 ##     partition_name n_clust ## K_3            K_3       3 # Hierarchical bioregionalization set.seed(1) vege_hclu_hierarclust <- hclu_hierarclust(dissimilarity = vegedissim,                                           method = \"mcquitty\", n_clust = 3,                                           optimal_tree_method = \"best\") vege_hclu_hierarclust$cluster_info # 3 ##   partition_name n_clust requested_n_clust output_cut_height ## 1            K_3       3                 3             0.625 # Network bioregionalization set.seed(1) vege_netclu_walktrap <- netclu_walktrap(vegesim,                                         index = names(vegesim)[3]) vege_netclu_walktrap$cluster_info # 3 ##     partition_name n_clust ## K_3            K_3       3"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_compare_bioregionalizations.html","id":"compare-the-bioregionalizations","dir":"Articles","previous_headings":"","what":"3. Compare the bioregionalizations","title":"5.2 Compare bioregionalizations","text":"comparing bioregionalizations, build common data.frame containing three distinct bioregionalizations. can now run function compare_bioregionalizations(). compare_bioregionalizations() produces several outputs : - look within bioregionalization sites assigned bioregions - compare different bioregionalizations analysing whether produce similar pairwise memberships Let’s first look pairwise membership within bioregionalization.","code":"comp <- dplyr::left_join(vege_hclu_hierarclust$clusters,                          vege_netclu_walktrap$clusters,                          by = \"ID\") colnames(comp) <- c(\"ID\", \"K_3_hclu\", \"K_3_netclu\") comp <- dplyr::left_join(comp,                          vege_nhclu_kmeans$clusters,                          by = \"ID\") colnames(comp) <- c(\"ID\", \"K_3_hclu\", \"K_3_netclu\", \"K_3_nhclu\")  head(comp) ##     ID K_3_hclu K_3_netclu K_3_nhclu ## 1  512        1          1         1 ## 2  799        1          3         1 ## 3  375        2          1         2 ## 4  476        2          1         2 ## 5  971        1          3         1 ## 6 1282        1          3         1 hclu_vs_netclu <- compare_bioregionalizations(   bioregionalizations = comp[, c(\"K_3_hclu\", \"K_3_netclu\", \"K_3_nhclu\")],   store_pairwise_membership = TRUE,   cor_frequency = TRUE,   store_confusion_matrix = TRUE)  str(hclu_vs_netclu) ## List of 7 ##  $ args                         :List of 4 ##   ..$ indices                  : chr [1:2] \"rand\" \"jaccard\" ##   ..$ cor_frequency            : logi TRUE ##   ..$ store_pairwise_membership: logi TRUE ##   ..$ store_confusion_matrix   : logi TRUE ##  $ inputs                       : Named int [1:2] 715 3 ##   ..- attr(*, \"names\")= chr [1:2] \"number_items\" \"number_bioregionalizations\" ##  $ pairwise_membership          : logi [1:255255, 1:3] TRUE FALSE FALSE TRUE TRUE TRUE ... ##   ..- attr(*, \"dimnames\")=List of 2 ##   .. ..$ : chr [1:255255] \"1_2\" \"1_3\" \"1_4\" \"1_5\" ... ##   .. ..$ : chr [1:3] \"K_3_hclu\" \"K_3_netclu\" \"K_3_nhclu\" ##  $ freq_item_pw_membership      : Named num [1:255255] 2 1 1 2 2 2 2 2 2 2 ... ##   ..- attr(*, \"names\")= chr [1:255255] \"1_2\" \"1_3\" \"1_4\" \"1_5\" ... ##  $ bioregionalization_freq_cor  : Named num [1:3] 0.851 0.737 0.893 ##   ..- attr(*, \"names\")= chr [1:3] \"K_3_hclu\" \"K_3_netclu\" \"K_3_nhclu\" ##  $ confusion_matrix             :List of 3 ##   ..$ K_3_hclu%K_3_netclu : Named int [1:4] 63316 41892 36800 113247 ##   .. ..- attr(*, \"names\")= chr [1:4] \"a\" \"b\" \"c\" \"d\" ##   ..$ K_3_hclu%K_3_nhclu  : Named int [1:4] 85543 19665 11248 138799 ##   .. ..- attr(*, \"names\")= chr [1:4] \"a\" \"b\" \"c\" \"d\" ##   ..$ K_3_netclu%K_3_nhclu: Named int [1:4] 66314 33802 30477 124662 ##   .. ..- attr(*, \"names\")= chr [1:4] \"a\" \"b\" \"c\" \"d\" ##  $ bioregionalization_comparison:'data.frame':   3 obs. of  3 variables: ##   ..$ bioregionalization_comparison: chr [1:3] \"K_3_hclu%K_3_netclu\" \"K_3_hclu%K_3_nhclu\" \"K_3_netclu%K_3_nhclu\" ##   ..$ rand                         : num [1:3] 0.692 0.879 0.748 ##   ..$ jaccard                      : num [1:3] 0.446 0.735 0.508 ##  - attr(*, \"class\")= chr [1:2] \"bioregion.bioregionalization.comparison\" \"list\""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_compare_bioregionalizations.html","id":"pairwise-membership","dir":"Articles","previous_headings":"3. Compare the bioregionalizations","what":"3.1 Pairwise membership","title":"5.2 Compare bioregionalizations","text":"number pairwise combinations \\(n\\) sites equals \\(n(n-1)/2\\). case, 715 sites, end 2.55255^{5} pairwise combinations. Pairwise memberships look pairs site whether assigned different bioregion. Let’s look sites 1 9 across different bioregionalization: can see sites 1 9 classified bioregion first two bioregionalizations, third one. $pairwise_membership output compare_bioregionalizations() shows TRUE/FALSE statement. number times pair sites clustered together (.e. sum rows table $pairwise_membership) available $freq_item_pw_membership output: sites 1 2 never classified bioregion across three bioregionalizations. Sites 1 9 classified bioregion two bioregionalizations. look total frequencies: see dominant situation sites never assigned bioregion.","code":"nrow(hclu_vs_netclu$pairwise_membership) == nrow(comp)*(nrow(comp)-1)/2 ## [1] TRUE comp[c(1, 9), ] ##    ID K_3_hclu K_3_netclu K_3_nhclu ## 1 512        1          1         1 ## 9 948        1          3         1 hclu_vs_netclu$pairwise_membership[8:10, ] ##      K_3_hclu K_3_netclu K_3_nhclu ## 1_9      TRUE      FALSE      TRUE ## 1_10     TRUE      FALSE      TRUE ## 1_11     TRUE      FALSE      TRUE hclu_vs_netclu$freq_item_pw_membership[c(1, 8)] ## 1_2 1_9  ##   2   2 table(hclu_vs_netclu$freq_item_pw_membership) ##  ##      0      1      2      3  ## 111723  41539  45403  56590"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_compare_bioregionalizations.html","id":"confusion-matrix","dir":"Articles","previous_headings":"3. Compare the bioregionalizations","what":"3.2 Confusion matrix","title":"5.2 Compare bioregionalizations","text":"confusion matrix allows compare different bioregionalizations looking similarity pairwise memberships. , function computes confusion matrix four elements: . \\(\\) number pairs sites grouped bioregionalization 1 bioregionalization 2 . \\(b\\) number pairs sites grouped bioregionalization 1 bioregionalization 2 . \\(c\\) number pairs sites grouped bioregionalization 1 grouped bioregionalization 2 . \\(d\\) number pairs sites grouped bioregionalization 1 & 2 Based confusion matrices, can compute range indices indicate agreement among bioregionalizations. now, implemented:Rand index \\((+d)/(+b+c+d)\\) Rand index measures agreement among bioregionalizations accounting pairs sites grouped, also pairs sites grouped.Jaccard index  \\(/(+b+c)\\) Jaccard index measures agreement among bioregionalizations accounting pairs sites grouped. two metrics complementary, Jaccard index tell bioregionalizations similar clustering structure, whereas Rand index tell bioregionalizations similar pairs items clustered together, also terms pairs sites clustered together. example, take two bioregionalizations never group together pairs sites. Jaccard index 0, whereas Rand index can > 0 due sites grouped together. Additional indices can manually computed users basis list confusion matrices. cases, users may interested finding bioregionalizations representative bioregionalizations find , can compare pairwise membership bioregionalization total frequency pairwise membership across bioregionalizations. correlation can requested cor_frequency = TRUE. third bioregionalization representative bioregionalizations.","code":"hclu_vs_netclu$confusion_matrix ## $`K_3_hclu%K_3_netclu` ##      a      b      c      d  ##  63316  41892  36800 113247  ##  ## $`K_3_hclu%K_3_nhclu` ##      a      b      c      d  ##  85543  19665  11248 138799  ##  ## $`K_3_netclu%K_3_nhclu` ##      a      b      c      d  ##  66314  33802  30477 124662 hclu_vs_netclu$bioregionalization_freq_cor ##   K_3_hclu K_3_netclu  K_3_nhclu  ##  0.8507872  0.7365956  0.8934004"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_summary_metrics.html","id":"data","dir":"Articles","previous_headings":"","what":"1. Data","title":"5.3 Summary metrics","text":"use vegetation dataset comes bioregion.","code":"data(\"vegedf\") data(\"vegemat\")  # Calculation of (dis)similarity matrices vegedissim <- dissimilarity(vegemat, metric = c(\"Simpson\")) vegesim <- dissimilarity_to_similarity(vegedissim)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_summary_metrics.html","id":"bioregionalization","dir":"Articles","previous_headings":"","what":"2. Bioregionalization","title":"5.3 Summary metrics","text":"use three bioregionalization algorithms visualization vignette, .e. non-hierarchical, hierarchical network bioregionalizations. chose 3 bioregions non-hierarchical hierarchical bioregionalizations.","code":"# Non hierarchical bioregionalization vege_nhclu_kmeans <- nhclu_kmeans(vegedissim, n_clust = 3, index = \"Simpson\") vege_nhclu_kmeans$cluster_info # 3 ##     partition_name n_clust ## K_3            K_3       3 # Hierarchical bioregionalization set.seed(1) vege_hclu_hierarclust <- hclu_hierarclust(dissimilarity = vegedissim,                                           index = names(vegedissim)[3],                                           method = \"average\", n_clust = 3,                                           optimal_tree_method = \"best\") vege_hclu_hierarclust$cluster_info # 3 ##   partition_name n_clust requested_n_clust output_cut_height ## 1            K_3       3                 3            0.5625 # Network bioregionalization set.seed(1) vege_netclu_walktrap <- netclu_walktrap(vegesim,                                         index = names(vegesim)[3]) vege_netclu_walktrap$cluster_info # 3 ##     partition_name n_clust ## K_3            K_3       3"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_summary_metrics.html","id":"bioregion-metrics","dir":"Articles","previous_headings":"","what":"3. Bioregion metrics","title":"5.3 Summary metrics","text":"Number sites belonging bioregion, many species sites contain. Number endemic proportion endemism also calculated. Endemic species species present sites assigned particular bioregion.","code":"bioregion_summary <- bioregion_metrics(bioregionalization = vege_nhclu_kmeans,                                        comat = vegemat) bioregion_summary ##   Bioregion Site_number Species_number Endemics Percentage_Endemic ## 1         3         146           2666      121           4.538635 ## 2         2         210           3102       57           1.837524 ## 3         1         359           2824      407          14.412181"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_summary_metrics.html","id":"species-metrics","dir":"Articles","previous_headings":"","what":"4. Species metrics","title":"5.3 Summary metrics","text":"Different summary statistics available species level.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_summary_metrics.html","id":"contribution-rho","dir":"Articles","previous_headings":"4. Species metrics","what":"4.1 Contribution (\\(\\rho\\))","title":"5.3 Summary metrics","text":"contribution index \\(\\rho\\) calculated species x bioregion combination, following (Lenormand et al., 2019).  formula following: \\[\\rho_{ij} = \\frac{n_{ij} - \\frac{n_i n_j}{n}}{\\sqrt{\\frac{n - n_j}{n-1} (1-\\frac{n_j}{n}) \\frac{n_i n_j}{n}}}\\] \\(n\\) number sites, \\(n_i\\) number sites species \\(\\) present, \\(n_j\\) number sites belonging bioregion \\(j\\), \\(n_ij\\) number occurrences species \\(\\) sites belonging bioregion \\(j\\).","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_summary_metrics.html","id":"individual-contributions","dir":"Articles","previous_headings":"4. Species metrics","what":"4.2 Individual contributions","title":"5.3 Summary metrics","text":"Affinity, fidelity individual contributions describe species linked bioregions. metrics presented (Bernardo-Madrid et al., 2019). Affinity species region: \\[A_i = \\frac{R_i}{Z}\\] \\(R_i\\) occurrence/range size species \\(\\) associated bioregion, \\(Z\\) total size (number sites) bioregion. high affinity means species occupying sites associated bioregion. Fidelity species region: \\[F_i = \\frac{R_i}{D_i}\\] \\(R_i\\) occurrence/range size species \\(\\) associated bioregion, \\(D_i\\) total occurrence/range size. high fidelity means species present bioregions associated one. Indicator Value species: \\[IndVal = F_i \\times A_i\\]","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_summary_metrics.html","id":"bipartite-metrics","dir":"Articles","previous_headings":"","what":"5. Bipartite metrics","title":"5.3 Summary metrics","text":"running community detection algorithm site x species matrix, sites species get bioregion assigned. degree affinity types nodes can therefore directly assessed, metrics like coefficient participation C within-bioregion degree z.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_summary_metrics.html","id":"cz-statistics","dir":"Articles","previous_headings":"5. Bipartite metrics","what":"5.1 Cz statistics","title":"5.3 Summary metrics","text":"Cz metrics derived (Guimerà & Amaral, 2005). respective formula : \\[C_i = 1 - \\sum_{s=1}^{N_M}{{(\\frac{k_is}{k_i}})^2}\\] \\(k_{}\\) number links node (species site) \\(\\) nodes bioregion \\(s\\), \\(k_i\\) total degree node \\(\\). participation coefficient node therefore close 1 links uniformly distributed among bioregions 0 links within bioregion. : \\[z_i = \\frac{k_i - \\overline{k_{si}}}{\\sigma_{k_{si}}}\\] \\(k_i\\) number links node (species site) \\(\\) nodes bioregion \\(s_i\\), \\(\\overline{k_{si}}\\) average \\(k\\) nodes \\(s_i\\), \\(\\sigma_{k_{si}}\\) standard deviation \\(k\\) \\(s_i\\). within-bioregion degree z-score measures well-connected node \\(\\) nodes bioregion.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_summary_metrics.html","id":"running-the-site_species_metrics-function","dir":"Articles","previous_headings":"5. Bipartite metrics","what":"5.2 Running the site_species_metrics function","title":"5.3 Summary metrics","text":"can now run function site_species_metrics(). site_species_metrics() outputs data.frame contribution metrics available species level.","code":"contrib_kmeans <- site_species_metrics(vege_nhclu_kmeans, vegemat,                                        indices = \"rho\") contrib_hclu <- site_species_metrics(vege_hclu_hierarclust, vegemat,                                      indices = \"rho\") contrib_netclu <- site_species_metrics(vege_netclu_walktrap, vegemat,                                        indices = \"rho\")  # Cz indices clust_bip <- netclu_greedy(vegedf, bipartite = TRUE) cz_netclu <- site_species_metrics(bioregionalization = clust_bip,  comat = vegemat,                                   net = vegedf, indices = \"Cz\")"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_summary_metrics.html","id":"spatial-coherence","dir":"Articles","previous_headings":"","what":"6. Spatial coherence","title":"5.3 Summary metrics","text":"use metric spatial coherence (Divíšek et al., 2016), except replace number pixels per bioregion area coherent part. spatial coherence expressed percentage, following formula: \\[SC_j = 100 \\times \\frac{LargestPatch_j}{Area_j}\\] \\(j\\) bioregion. example vegetation dataset. bioregion 4 almost constituted one homogeneous block, spatial coherence close 100 %.","code":"# Spatial coherence vegedissim <- dissimilarity(vegemat) hclu <- nhclu_kmeans(dissimilarity = vegedissim, n_clust = 4) vegemap <- map_bioregions(hclu, vegesf, write_clusters = TRUE, plot = FALSE)  bioregion_metrics(bioregionalization = hclu, comat = vegemat, map = vegemap, col_bioregion = 2) ##   Bioregion Site_number Species_number Endemics Percentage_Endemic Coherence ## 1         2         128           2527       90           3.561535  49.21875 ## 2         1         169           2983       45           1.508548  56.21302 ## 3         4         298           2936       56           1.907357  98.99329 ## 4         3         120           2262       67           2.961981  79.16667 ggplot(vegemap) +   geom_sf(aes(fill = as.factor(K_4))) +   scale_fill_viridis_d(\"Bioregion\") +   theme_bw() +   theme(legend.position = \"bottom\")"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"brief-introduction","dir":"Articles","previous_headings":"","what":"0. Brief introduction","title":"Tutorial for bioregion","text":"tutorial aims describing different features R package bioregion. main purpose bioregion‘s package propose transparent methodological framework compare bioregionalization methods. typical flow chart bioregions’ identification based site-species bipartite network co-occurrence matrix bioregion (Figure 1). workflow can divided four main steps: Preprocess data (matrix network formats) Compute similarity/dissimilarity metrics sites based species composition Run different algorithms identify different set bioregions Evaluate visualize results","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"install-binary-files","dir":"Articles","previous_headings":"","what":"1. Install binary files","title":"Tutorial for bioregion","text":"functions least part (listed ) require binary files run. netclu_infomap netclu_louvain (Cpp version) netclu_oslom Please check tutorial page get instructions regarding installation binary files.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"matrix-or-network-formats","dir":"Articles","previous_headings":"","what":"2. Matrix or network formats","title":"Tutorial for bioregion","text":"bioregion’s package takes input site-species information stored bipartite network co-occurrence matrix. Relying function mat_to_net net_to_mat , handles matrix network formats throughout workflow. Please look tutorial page better understand two functions work.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"pairwise-similaritydissimilarity-metrics","dir":"Articles","previous_headings":"","what":"3. Pairwise similarity/dissimilarity metrics","title":"Tutorial for bioregion","text":"functions similarity dissimilarity compute respectively pairwise similarity dissimilarity metrics based (site-species) co-occurrence matrix. resulting data.frame stored bioregion.pairwise.metric object containing requested metrics pair sites. functions dissimilarity_to_similarity similarity_to_dissimilarity can used transform similarity object dissimilarity object vice versa. function as_bioregion_pairwise allows convert (dis)similarity matrix list matrices bioregion.pairwise.metric object compatible bioregion package. input can come base R, dist objects, outputs packages. Please look tutorial page better understand functions work.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"bioregionalization-algorithms","dir":"Articles","previous_headings":"","what":"4. Bioregionalization algorithms","title":"Tutorial for bioregion","text":"bioregion R package gathers several methods allowing group sites species similar entities called bioregions. methods can lead several partitions sites species, .e. different bioregionalizations.  Bioregionalization methods can based hierarchical clustering algorithms, non-hierarchical clustering algorithms network algorithms.  functions package related three families produce output specific class, namely bioregion.clusters class.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"hierarchical-clustering","dir":"Articles","previous_headings":"4. Bioregionalization algorithms","what":"4.1 Hierarchical clustering","title":"Tutorial for bioregion","text":"functions relying hierarchical clustering start prefix hclu_. algorithms, bioregions placed dendrogram ranges two extremes: sites belong bioregion (top tree) sites belong different bioregion (bottom tree). See following tutorial page details.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"non-hierarchical-clustering","dir":"Articles","previous_headings":"4. Bioregionalization algorithms","what":"4.2 Non-hierarchical clustering","title":"Tutorial for bioregion","text":"functions relying hierarchical clustering start prefix nhclu_. algorithms, user needs predefine number clusters, although number can determined estimating optimal bioregionalization. See tutorial page details.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"network-clustering","dir":"Articles","previous_headings":"4. Bioregionalization algorithms","what":"4.3 Network clustering","title":"Tutorial for bioregion","text":"functions relying network clustering start prefix netclu_. Site-species matrices can seen (bipartite) networks nodes either sites species links occurrences species within sites. networks, modularity algorithms can applied, leading bioregionalization. following tutorial page details clustering functions relying network algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"microbenchmark","dir":"Articles","previous_headings":"4. Bioregionalization algorithms","what":"4.4 Microbenchmark","title":"Tutorial for bioregion","text":"different bioregionalization methods listed package rely less computationally intensive algorithms. following page estimates time required run method data sets different sizes.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"visualization","dir":"Articles","previous_headings":"","what":"5.1 Visualization","title":"Tutorial for bioregion","text":"sites geographic coordinates, bioregionalization can visualized function map_bioregions(). tutorial page details different ways plot bioregionalization.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"compare-bioregionalizations","dir":"Articles","previous_headings":"","what":"5.2 Compare bioregionalizations","title":"Tutorial for bioregion","text":"section, look sites assigned bioregions within single bioregionalization also compare assignment across different bioregionalizations. following page illustrates .","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"summary-metrics","dir":"Articles","previous_headings":"","what":"5.3 Summary metrics","title":"Tutorial for bioregion","text":"section, compute summary statistics different scales, either bioregion site species level. Related functions detailed page.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/citations.html","id":"section","dir":"Articles","previous_headings":"","what":"2025","title":"Citing articles","text":"Souza Oliveira M, Lenormand M, Luque S, Zamora NA, Alleaume S, Aguilar Porras AC, Castillo MU, Chacón-Madrigal E, Delgado D, Hernández Sánchez LG, Ngo Bieng M-, Quesada RM, Solano GS & Zúñiga PM (2025) Unlocking tropical forest complexity: tree assemblages secondary forests boost biodiversity conservation. arXiv preprint arXiv:2503.02523. Lenormand M, Féret JB, Papuga G, Alleaume S & Luque S (2025) Coupling situ remote sensing data assess α- β-diversity biogeographic gradients. Ecography (early view). Noori S, Rödder D, Yusefi GH, Hawlitschek O, Wanke D, Husemann M & Rajaei H (2025) Biogeographic Patterns Iranian Lepidoptera: Framework Conservation. Diversity Distributions 31, e70010.","code":""},{"path":"https://bioRgeo.github.io/bioregion/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Maxime Lenormand. Author, maintainer. Boris Leroy. Author. Pierre Denelle. Author.","code":""},{"path":"https://bioRgeo.github.io/bioregion/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Denelle P, Leroy B & Lenormand M (2025) Bioregionalization analyses bioregion R package. Methods Ecology Evolution 16, 496-506.","code":"@Article{,   author = {{Denelle} and {P.} and {Leroy} and {B.} and {Lenormand} and {M.}},   title = {Bioregionalization analyses with the bioregion R package},   journal = {Methods in Ecology and Evolution},   year = {2025},   pages = {496-506},   volume = {16},   doi = {10.1111/2041-210X.14496}, }"},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"bioregion-","dir":"","previous_headings":"","what":"Comparison of Bioregionalization Methods","title":"Comparison of Bioregionalization Methods","text":"R package gathers comprehensive set algorithms perform bioregionalization analyses. Bioregionalization methods can based hierarchical clustering algorithms, non-hierarchical clustering algorithms network algorithms.","code":""},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"arrow_double_down-installation","dir":"","previous_headings":"","what":"⏬ Installation","title":"Comparison of Bioregionalization Methods","text":"package can installed following command line R session: CRAN GitHub","code":"install.packages(\"bioregion\") # install.packages(\"devtools\") devtools::install_github(\"bioRgeo/bioregion\")"},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"scroll-vignettes","dir":"","previous_headings":"","what":"📜 Vignettes","title":"Comparison of Bioregionalization Methods","text":"wrote several vignettes help using bioregion R package. Vignettes available following ones: 1. Installation executable binary files 2. Matrix network formats 3. Pairwise similarity/dissimilarity metrics 4.1 Hierarchical clustering 4.2 Non-hierarchical clustering 4.3 Network clustering 4.4 Microbenchmark 5.1 Visualization 5.2 Compare bioregionalizations 5.3 Summary metrics Alternatively, prefer view vignettes R, can install package build_vignettes = TRUE. aware vignettes can slow generate.","code":"remotes::install_github(\"bioRgeo/bioregion\",                         dependencies = TRUE,                          upgrade = \"ask\",                          build_vignettes = TRUE)  vignette(\"bioregion\")"},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"desktop_computer-functions","dir":"","previous_headings":"","what":"🖥️ Functions","title":"Comparison of Bioregionalization Methods","text":"overview functions data given .","code":""},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"bug-find-a-bug","dir":"","previous_headings":"","what":"🐛 Find a bug?","title":"Comparison of Bioregionalization Methods","text":"Thank finding . Head GitHub Issues tab let us know . Alternatively, can also send us e-mail. try get soon can!","code":""},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"references-and-dependencies","dir":"","previous_headings":"","what":"References and dependencies","title":"Comparison of Bioregionalization Methods","text":"bioregion depends ape, apcluster, bipartite, cluster, data.table, dbscan, dynamicTreeCut, earth, fastcluster, ggplot2, grDevices, httr, igraph, mathjaxr, Matrix, phangorn, Rdpack, rlang, rmarkdown, segmented,sf, stats, tidyr utils.","code":""},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Comparison of Bioregionalization Methods","text":"Denelle P, Leroy B & Lenormand M (2025) Bioregionalization analyses bioregion R package. Methods Ecology Evolution 16, 496-506.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/as_bioregion_pairwise.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a matrix or list of matrices to a bioregion (dis)similarity object — as_bioregion_pairwise","title":"Convert a matrix or list of matrices to a bioregion (dis)similarity object — as_bioregion_pairwise","text":"Converts (dis)similarity matrix list matrices bioregion.pairwise.metric object compatible bioregion package. input can come base R, dist objects, outputs packages.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/as_bioregion_pairwise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a matrix or list of matrices to a bioregion (dis)similarity object — as_bioregion_pairwise","text":"","code":"as_bioregion_pairwise(   mat,   metric_name = NULL,   pkg = NULL,   is_similarity = FALSE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/as_bioregion_pairwise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a matrix or list of matrices to a bioregion (dis)similarity object — as_bioregion_pairwise","text":"mat matrix, dist object, list representing pairwise similarity dissimilarity values convert bioregion.pairwise.metric object. function can also directly handle outputs R packages (see pkg argument). metric_name Optional character vector single character string specifying name (dis)similarity metric(s), appear column names output (see Note). pkg optional character string indicating name package mat generated (NULL default, see Details). Available options \"adespatial\", \"betapart\", \"ecodist\", \"vegan\". is_similarity logical value indicating whether input data represents similarity (TRUE) dissimilarity (FALSE).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/as_bioregion_pairwise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a matrix or list of matrices to a bioregion (dis)similarity object — as_bioregion_pairwise","text":"dissimilarity similarity object class bioregion.pairwise.metric, compatible bioregion package.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/as_bioregion_pairwise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert a matrix or list of matrices to a bioregion (dis)similarity object — as_bioregion_pairwise","text":"function can directly handle outputs ten functions across four packages: adespatial: beta.div, beta.div.comp betapart: beta.pair, beta.pair.abund, betapart.core, betapart.core.abund ecodist: distance, bcdist vegan: vegdist, designdist See documentation packages information: https://cran.r-project.org/package=adespatial https://cran.r-project.org/package=betapart https://cran.r-project.org/package=ecodist https://cran.r-project.org/package=vegan","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/as_bioregion_pairwise.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert a matrix or list of matrices to a bioregion (dis)similarity object — as_bioregion_pairwise","text":"specific package specified (.e., pkg = NULL), site names based row names first matrix. row names NULL, generated automatically. mat named list, names used column names metric_name = NULL.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/as_bioregion_pairwise.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert a matrix or list of matrices to a bioregion (dis)similarity object — as_bioregion_pairwise","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/as_bioregion_pairwise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a matrix or list of matrices to a bioregion (dis)similarity object — as_bioregion_pairwise","text":"","code":"mat <- matrix(runif(100), 10, 10) rownames(mat) <- paste0(\"s\",1:10)  pair <- as_bioregion_pairwise(list(mat,mat,mat),                                metric_name = NULL,                               pkg = NULL,                               is_similarity = FALSE)                                pair #> Data.frame of dissimilarity between sites #>  - Total number of sites:  10  #>  - Total number of species:  NA  #>  - Number of rows:  45  #>  - Number of dissimilarity metrics:  3  #>  #>  #>    Site1 Site2    Metric1    Metric2    Metric3 #> 2     s1    s2 0.87460066 0.87460066 0.87460066 #> 3     s1    s3 0.28989230 0.28989230 0.28989230 #> 4     s1    s4 0.03123033 0.03123033 0.03123033 #> 5     s1    s5 0.68016292 0.68016292 0.68016292 #> 6     s1    s6 0.46118646 0.46118646 0.46118646 #> 7     s1    s7 0.82519942 0.82519942 0.82519942 #> 8     s1    s8 0.44670247 0.44670247 0.44670247 #> 9     s1    s9 0.52791704 0.52791704 0.52791704 #> 10    s1   s10 0.99706914 0.99706914 0.99706914 #> 13    s2    s3 0.67838043 0.67838043 0.67838043 #> 14    s2    s4 0.22556253 0.22556253 0.22556253 #> 15    s2    s5 0.49884561 0.49884561 0.49884561 #> 16    s2    s6 0.31524175 0.31524175 0.31524175 #> 17    s2    s7 0.27381825 0.27381825 0.27381825 #> 18    s2    s8 0.37151118 0.37151118 0.37151118 #> 19    s2    s9 0.60063752 0.60063752 0.60063752 #> 20    s2   s10 0.14903547 0.14903547 0.14903547 #> 24    s3    s4 0.30083081 0.30083081 0.30083081 #> 25    s3    s5 0.64167935 0.64167935 0.64167935 #> 26    s3    s6 0.17467589 0.17467589 0.17467589 #> 27    s3    s7 0.57004495 0.57004495 0.57004495 #> 28    s3    s8 0.02806097 0.02806097 0.02806097 #> 29    s3    s9 0.26137136 0.26137136 0.26137136 #> 30    s3   s10 0.51855664 0.51855664 0.51855664 #> 35    s4    s5 0.66028435 0.66028435 0.66028435 #> 36    s4    s6 0.53157354 0.53157354 0.53157354 #> 37    s4    s7 0.33571908 0.33571908 0.33571908 #> 38    s4    s8 0.46598719 0.46598719 0.46598719 #> 39    s4    s9 0.29005016 0.29005016 0.29005016 #> 40    s4   s10 0.84612005 0.84612005 0.84612005 #> 46    s5    s6 0.49363702 0.49363702 0.49363702 #> 47    s5    s7 0.59626279 0.59626279 0.59626279 #> 48    s5    s8 0.39003139 0.39003139 0.39003139 #> 49    s5    s9 0.48007517 0.48007517 0.48007517 #> 50    s5   s10 0.71826972 0.71826972 0.71826972 #> 57    s6    s7 0.19151803 0.19151803 0.19151803 #> 58    s6    s8 0.02006522 0.02006522 0.02006522 #> 59    s6    s9 0.92000555 0.92000555 0.92000555 #> 60    s6   s10 0.24131402 0.24131402 0.24131402 #> 68    s7    s8 0.37697093 0.37697093 0.37697093 #> 69    s7    s9 0.40072018 0.40072018 0.40072018 #> 70    s7   s10 0.54704337 0.54704337 0.54704337 #> 79    s8    s9 0.21317271 0.21317271 0.21317271 #> 80    s8   s10 0.83480182 0.83480182 0.83480182 #> 90    s9   s10 0.02795603 0.02795603 0.02795603"},{"path":"https://bioRgeo.github.io/bioregion/reference/betapart_to_bioregion.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert betapart dissimilarity to bioregion dissimilarity (DEPRECATED) — betapart_to_bioregion","title":"Convert betapart dissimilarity to bioregion dissimilarity (DEPRECATED) — betapart_to_bioregion","text":"function converts dissimilarity results produced betapart package (packages using betapart, phyloregion) dissimilarity object compatible bioregion package. function converts object types make compatible bioregion; modify beta-diversity values. function allows inclusion phylogenetic beta diversity compute bioregions bioregion.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/betapart_to_bioregion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert betapart dissimilarity to bioregion dissimilarity (DEPRECATED) — betapart_to_bioregion","text":"","code":"betapart_to_bioregion(betapart_result)"},{"path":"https://bioRgeo.github.io/bioregion/reference/betapart_to_bioregion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert betapart dissimilarity to bioregion dissimilarity (DEPRECATED) — betapart_to_bioregion","text":"betapart_result object produced betapart package (e.g., using beta.pair function).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/betapart_to_bioregion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert betapart dissimilarity to bioregion dissimilarity (DEPRECATED) — betapart_to_bioregion","text":"dissimilarity object class bioregion.pairwise.metric, compatible bioregion package.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/betapart_to_bioregion.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert betapart dissimilarity to bioregion dissimilarity (DEPRECATED) — betapart_to_bioregion","text":"Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/betapart_to_bioregion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert betapart dissimilarity to bioregion dissimilarity (DEPRECATED) — betapart_to_bioregion","text":"","code":"comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  if (FALSE) { # \\dontrun{ beta_div <- betapart::beta.pair.abund(comat) betapart_to_bioregion(beta_div) } # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate contribution metrics for bioregions — bioregion_metrics","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"function calculates number sites per bioregion, well number species sites , number endemic species, proportion endemism.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"","code":"bioregion_metrics(bioregionalization, comat, map = NULL, col_bioregion = NULL)"},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"bioregionalization bioregion.clusters object. comat co-occurrence matrix sites rows species columns. map spatial sf data.frame sites bioregions. output function map_bioregions. NULL default. col_bioregion integer specifying column position bioregion.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"data.frame 5 columns, 6 spatial coherence computed.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"Endemic species species found sites belonging one bioregion.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") clust <- netclu_louvain(net)  bioregion_metrics(bioregionalization = clust,                    comat = comat)  #>   Bioregion Site_number Species_number Endemics Percentage_Endemic #> 1         1           5             10       10                100"},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate metrics for one or several bioregionalizations — bioregionalization_metrics","title":"Calculate metrics for one or several bioregionalizations — bioregionalization_metrics","text":"function calculates metrics one several bioregionalizations, typically based outputs netclu_, hclu_, nhclu_ functions. metrics may require users provide either similarity dissimilarity matrix, initial species-site table.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate metrics for one or several bioregionalizations — bioregionalization_metrics","text":"","code":"bioregionalization_metrics(   bioregionalization,   dissimilarity = NULL,   dissimilarity_index = NULL,   net = NULL,   site_col = 1,   species_col = 2,   eval_metric = \"all\" )"},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate metrics for one or several bioregionalizations — bioregionalization_metrics","text":"bioregionalization bioregion.clusters object. dissimilarity dist object bioregion.pairwise.metric object (output similarity_to_dissimilarity()). Required eval_metric includes \"pc_distance\" tree bioregion.hierar.tree object. dissimilarity_index character string indicating dissimilarity (beta-diversity) index use dissimilarity data.frame multiple dissimilarity indices. net site-species network (.e., bipartite network). provided data.frame eval_metric includes \"avg_endemism\" \"tot_endemism\". site_col name index column representing site nodes (.e., primary nodes). provided eval_metric includes \"avg_endemism\" \"tot_endemism\". species_col name index column representing species nodes (.e., feature nodes). provided eval_metric includes \"avg_endemism\" \"tot_endemism\". eval_metric character vector single character string indicating metric(s) calculated assess effect different numbers clusters. Available options \"pc_distance\", \"anosim\", \"avg_endemism\", \"tot_endemism\". \"\" specified, metrics calculated.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate metrics for one or several bioregionalizations — bioregionalization_metrics","text":"list class bioregion.bioregionalization.metrics two three elements: args: Input arguments. evaluation_df: data.frame containing eval_metric values explored numbers clusters. endemism_results: endemism calculations requested, list endemism results bioregionalization.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate metrics for one or several bioregionalizations — bioregionalization_metrics","text":"Evaluation metrics: pc_distance: metric, used Holt et al. (2013), ratio -cluster sum dissimilarities (beta-diversity) total sum dissimilarities full dissimilarity matrix. calculated two steps: Compute total sum dissimilarities summing elements dissimilarity matrix. Compute -cluster sum dissimilarities setting within-cluster dissimilarities zero summing matrix. pc_distance ratio obtained dividing -cluster sum dissimilarities total sum dissimilarities. anosim: metric statistic used Analysis Similarities, described Castro-Insua et al. (2018). compares -cluster within-cluster dissimilarities. statistic computed : R = (r_B - r_W) / (N (N-1) / 4), r_B r_W average ranks -cluster within-cluster dissimilarities, respectively, N total number sites. Note: function estimate significance; significance testing, use vegan::anosim(). avg_endemism: metric average percentage endemism clusters, recommended Kreft & Jetz (2010). calculated : End_mean = sum_i (E_i / S_i) / K, E_i number endemic species cluster , S_i number species cluster , K total number clusters. tot_endemism: metric total endemism across clusters, recommended Kreft & Jetz (2010). calculated : End_tot = E / C, E total number endemic species (.e., species found one cluster) C number non-endemic species.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate metrics for one or several bioregionalizations — bioregionalization_metrics","text":"Castro-Insua , Gómez-Rodríguez C & Baselga (2018) Dissimilarity measures affected richness differences yield biased delimitations biogeographic realms. Nature Communications 9, 9-11. Holt BG, Lessard J, Borregaard MK, Fritz SA, Araújo MB, Dimitrov D, Fabre P, Graham CH, Graves GR, Jønsson Ka, Nogués-Bravo D, Wang Z, Whittaker RJ, Fjeldså J & Rahbek C (2013) update Wallace's zoogeographic regions world. Science 339, 74-78. Kreft H & Jetz W (2010) framework delineating biogeographical regions based species distributions. Journal Biogeography 37, 2029-2053.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate metrics for one or several bioregionalizations — bioregionalization_metrics","text":"Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate metrics for one or several bioregionalizations — bioregionalization_metrics","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  comnet <- mat_to_net(comat)  dissim <- dissimilarity(comat, metric = \"all\")  # User-defined number of clusters tree1 <- hclu_hierarclust(dissim,                            n_clust = 10:15,                            index = \"Simpson\") #> Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. #> Error in if (nrow(dist_matrix) > 2) {    subclusters <- stable_binary_split(dist_matrix, method = method,         n_runs = n_runs, binsplit = \"tree\")} else {    subclusters <- list(attr(dist_matrix, \"Labels\")[1], attr(dist_matrix,         \"Labels\")[2])}: argument is of length zero tree1 #> Error: object 'tree1' not found  a <- bioregionalization_metrics(tree1,                                  dissimilarity = dissim,                                  net = comnet,                                 site_col = \"Node1\",                                  species_col = \"Node2\",                                 eval_metric = c(\"tot_endemism\",                                                  \"avg_endemism\",                                                 \"pc_distance\",                                                  \"anosim\")) #> Error: object 'tree1' not found a #> Error: object 'a' not found"},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"function computes pairwise comparisons several bioregionalizations, usually outputs netclu_, hclu_, nhclu_ functions. also provides confusion matrix pairwise comparisons, enabling user compute additional comparison metrics.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"","code":"compare_bioregionalizations(   bioregionalizations,   indices = c(\"rand\", \"jaccard\"),   cor_frequency = FALSE,   store_pairwise_membership = TRUE,   store_confusion_matrix = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"bioregionalizations data.frame object row corresponds site, column bioregionalization. indices NULL character. Indices compute pairwise comparison bioregionalizations. Currently available metrics \"rand\" \"jaccard\". cor_frequency boolean. TRUE, computes correlation bioregionalization total frequency co-membership items across bioregionalizations. useful identifying bioregionalization(s) () representative computed bioregionalizations. store_pairwise_membership boolean. TRUE, stores pairwise membership items output object. store_confusion_matrix boolean. TRUE, stores confusion matrices pairwise bioregionalization comparisons output object.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"list containing 4 7 elements: args: list user-provided arguments. inputs: list containing information input bioregionalizations, number items clustered. pairwise_membership (optional): store_pairwise_membership = TRUE, boolean matrix TRUE indicates two items cluster, FALSE indicates . freq_item_pw_membership: numeric vector containing number times item pair clustered together, corresponding sum rows pairwise_membership. bioregionalization_freq_cor (optional): cor_frequency = TRUE, numeric vector correlations individual bioregionalizations total frequency pairwise membership. confusion_matrix (optional): store_confusion_matrix = TRUE, list confusion matrices pair bioregionalizations. bioregionalization_comparison: data.frame containing comparison results, first column indicates bioregionalizations compared, remaining columns contain requested indices.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"function operates two main steps: Within bioregionalization, function compares pairs items documents whether clustered together (TRUE) separately (FALSE). example, site 1 site 2 clustered cluster bioregionalization 1, pairwise membership site1_site2 TRUE. output stored pairwise_membership slot store_pairwise_membership = TRUE. Across bioregionalizations, function compares pairwise memberships determine similarity. pair bioregionalizations, computes confusion matrix following elements: : Number item pairs grouped bioregionalizations. b: Number item pairs grouped first second bioregionalization. c: Number item pairs grouped second first bioregionalization. d: Number item pairs grouped either bioregionalization. confusion matrix stored confusion_matrix store_confusion_matrix = TRUE. Based confusion matrices, various indices can computed measure agreement among bioregionalizations. currently implemented indices : Rand index: (+ d) / (+ b + c + d) Measures agreement considering grouped ungrouped item pairs. Jaccard index: / (+ b + c) Measures agreement based grouped item pairs. indices complementary: Jaccard index evaluates clustering similarity, Rand index considers clustering separation. example, two bioregionalizations never group pairs, Jaccard index 0, Rand index may > 0 due ungrouped pairs. Users can compute additional indices manually using list confusion matrices. identify bioregionalization representative others, function can compute correlation pairwise membership bioregionalization total frequency pairwise membership across bioregionalizations. enabled setting cor_frequency = TRUE.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"","code":"# We here compare three different bioregionalizations comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"Simpson\") bioregion1 <- nhclu_kmeans(dissim, n_clust = 3, index = \"Simpson\")  net <- similarity(comat, metric = \"Simpson\") bioregion2 <- netclu_greedy(net) bioregion3 <- netclu_walktrap(net)  # Make one single data.frame with the bioregionalizations to compare compare_df <- merge(bioregion1$clusters, bioregion2$clusters, by = \"ID\") compare_df <- merge(compare_df, bioregion3$clusters, by = \"ID\") colnames(compare_df) <- c(\"Site\", \"Hclu\", \"Greedy\", \"Walktrap\") rownames(compare_df) <- compare_df$Site compare_df <- compare_df[, c(\"Hclu\", \"Greedy\", \"Walktrap\")]  # Running the function compare_bioregionalizations(compare_df) #> 2025-06-17 15:01:53.874682 - Computing pairwise membership comparisons for each bioregionalization... #> 2025-06-17 15:01:53.876702 - Comparing memberships among bioregionalizations... #> 2025-06-17 15:01:53.877392 - Computing Rand index... #> 2025-06-17 15:01:53.877774 - Computing Jaccard index... #> $args #> $args$indices #> [1] \"rand\"    \"jaccard\" #>  #> $args$cor_frequency #> [1] FALSE #>  #> $args$store_pairwise_membership #> [1] TRUE #>  #> $args$store_confusion_matrix #> [1] TRUE #>  #>  #> $inputs #>               number_items number_bioregionalizations  #>                         20                          3  #>  #> $pairwise_membership #>        Hclu Greedy Walktrap #> 1_2   FALSE   TRUE     TRUE #> 1_3   FALSE   TRUE     TRUE #> 1_4    TRUE   TRUE     TRUE #> 1_5   FALSE   TRUE     TRUE #> 1_6    TRUE   TRUE     TRUE #> 1_7   FALSE   TRUE     TRUE #> 1_8    TRUE   TRUE     TRUE #> 1_9   FALSE   TRUE     TRUE #> 1_10  FALSE   TRUE     TRUE #> 1_11   TRUE   TRUE     TRUE #> 1_12  FALSE   TRUE     TRUE #> 1_13  FALSE   TRUE     TRUE #> 1_14  FALSE   TRUE     TRUE #> 1_15  FALSE   TRUE     TRUE #> 1_16  FALSE   TRUE     TRUE #> 1_17  FALSE   TRUE     TRUE #> 1_18  FALSE  FALSE     TRUE #> 1_19  FALSE   TRUE     TRUE #> 1_20   TRUE   TRUE     TRUE #> 2_3    TRUE   TRUE     TRUE #> 2_4   FALSE   TRUE     TRUE #> 2_5   FALSE   TRUE     TRUE #> 2_6   FALSE   TRUE     TRUE #> 2_7    TRUE   TRUE     TRUE #> 2_8   FALSE   TRUE     TRUE #> 2_9   FALSE   TRUE     TRUE #> 2_10   TRUE   TRUE     TRUE #> 2_11  FALSE   TRUE     TRUE #> 2_12  FALSE   TRUE     TRUE #> 2_13  FALSE   TRUE     TRUE #> 2_14   TRUE   TRUE     TRUE #> 2_15  FALSE   TRUE     TRUE #> 2_16   TRUE   TRUE     TRUE #> 2_17  FALSE   TRUE     TRUE #> 2_18   TRUE  FALSE     TRUE #> 2_19   TRUE   TRUE     TRUE #> 2_20  FALSE   TRUE     TRUE #> 3_4   FALSE   TRUE     TRUE #> 3_5   FALSE   TRUE     TRUE #> 3_6   FALSE   TRUE     TRUE #> 3_7    TRUE   TRUE     TRUE #> 3_8   FALSE   TRUE     TRUE #> 3_9   FALSE   TRUE     TRUE #> 3_10   TRUE   TRUE     TRUE #> 3_11  FALSE   TRUE     TRUE #> 3_12  FALSE   TRUE     TRUE #> 3_13  FALSE   TRUE     TRUE #> 3_14   TRUE   TRUE     TRUE #> 3_15  FALSE   TRUE     TRUE #> 3_16   TRUE   TRUE     TRUE #> 3_17  FALSE   TRUE     TRUE #> 3_18   TRUE  FALSE     TRUE #> 3_19   TRUE   TRUE     TRUE #> 3_20  FALSE   TRUE     TRUE #> 4_5   FALSE   TRUE     TRUE #> 4_6    TRUE   TRUE     TRUE #> 4_7   FALSE   TRUE     TRUE #> 4_8    TRUE   TRUE     TRUE #> 4_9   FALSE   TRUE     TRUE #> 4_10  FALSE   TRUE     TRUE #> 4_11   TRUE   TRUE     TRUE #> 4_12  FALSE   TRUE     TRUE #> 4_13  FALSE   TRUE     TRUE #> 4_14  FALSE   TRUE     TRUE #> 4_15  FALSE   TRUE     TRUE #> 4_16  FALSE   TRUE     TRUE #> 4_17  FALSE   TRUE     TRUE #> 4_18  FALSE  FALSE     TRUE #> 4_19  FALSE   TRUE     TRUE #> 4_20   TRUE   TRUE     TRUE #> 5_6   FALSE   TRUE     TRUE #> 5_7   FALSE   TRUE     TRUE #> 5_8   FALSE   TRUE     TRUE #> 5_9    TRUE   TRUE     TRUE #> 5_10  FALSE   TRUE     TRUE #> 5_11  FALSE   TRUE     TRUE #> 5_12   TRUE   TRUE     TRUE #> 5_13   TRUE   TRUE     TRUE #> 5_14  FALSE   TRUE     TRUE #> 5_15   TRUE   TRUE     TRUE #> 5_16  FALSE   TRUE     TRUE #> 5_17   TRUE   TRUE     TRUE #> 5_18  FALSE  FALSE     TRUE #> 5_19  FALSE   TRUE     TRUE #> 5_20  FALSE   TRUE     TRUE #> 6_7   FALSE   TRUE     TRUE #> 6_8    TRUE   TRUE     TRUE #> 6_9   FALSE   TRUE     TRUE #> 6_10  FALSE   TRUE     TRUE #> 6_11   TRUE   TRUE     TRUE #> 6_12  FALSE   TRUE     TRUE #> 6_13  FALSE   TRUE     TRUE #> 6_14  FALSE   TRUE     TRUE #> 6_15  FALSE   TRUE     TRUE #> 6_16  FALSE   TRUE     TRUE #> 6_17  FALSE   TRUE     TRUE #> 6_18  FALSE  FALSE     TRUE #> 6_19  FALSE   TRUE     TRUE #> 6_20   TRUE   TRUE     TRUE #> 7_8   FALSE   TRUE     TRUE #> 7_9   FALSE   TRUE     TRUE #> 7_10   TRUE   TRUE     TRUE #> 7_11  FALSE   TRUE     TRUE #> 7_12  FALSE   TRUE     TRUE #> 7_13  FALSE   TRUE     TRUE #> 7_14   TRUE   TRUE     TRUE #> 7_15  FALSE   TRUE     TRUE #> 7_16   TRUE   TRUE     TRUE #> 7_17  FALSE   TRUE     TRUE #> 7_18   TRUE  FALSE     TRUE #> 7_19   TRUE   TRUE     TRUE #> 7_20  FALSE   TRUE     TRUE #> 8_9   FALSE   TRUE     TRUE #> 8_10  FALSE   TRUE     TRUE #> 8_11   TRUE   TRUE     TRUE #> 8_12  FALSE   TRUE     TRUE #> 8_13  FALSE   TRUE     TRUE #> 8_14  FALSE   TRUE     TRUE #> 8_15  FALSE   TRUE     TRUE #> 8_16  FALSE   TRUE     TRUE #> 8_17  FALSE   TRUE     TRUE #> 8_18  FALSE  FALSE     TRUE #> 8_19  FALSE   TRUE     TRUE #> 8_20   TRUE   TRUE     TRUE #> 9_10  FALSE   TRUE     TRUE #> 9_11  FALSE   TRUE     TRUE #> 9_12   TRUE   TRUE     TRUE #> 9_13   TRUE   TRUE     TRUE #> 9_14  FALSE   TRUE     TRUE #> 9_15   TRUE   TRUE     TRUE #> 9_16  FALSE   TRUE     TRUE #> 9_17   TRUE   TRUE     TRUE #> 9_18  FALSE  FALSE     TRUE #> 9_19  FALSE   TRUE     TRUE #> 9_20  FALSE   TRUE     TRUE #> 10_11 FALSE   TRUE     TRUE #> 10_12 FALSE   TRUE     TRUE #> 10_13 FALSE   TRUE     TRUE #> 10_14  TRUE   TRUE     TRUE #> 10_15 FALSE   TRUE     TRUE #> 10_16  TRUE   TRUE     TRUE #> 10_17 FALSE   TRUE     TRUE #> 10_18  TRUE  FALSE     TRUE #> 10_19  TRUE   TRUE     TRUE #> 10_20 FALSE   TRUE     TRUE #> 11_12 FALSE   TRUE     TRUE #> 11_13 FALSE   TRUE     TRUE #> 11_14 FALSE   TRUE     TRUE #> 11_15 FALSE   TRUE     TRUE #> 11_16 FALSE   TRUE     TRUE #> 11_17 FALSE   TRUE     TRUE #> 11_18 FALSE  FALSE     TRUE #> 11_19 FALSE   TRUE     TRUE #> 11_20  TRUE   TRUE     TRUE #> 12_13  TRUE   TRUE     TRUE #> 12_14 FALSE   TRUE     TRUE #> 12_15  TRUE   TRUE     TRUE #> 12_16 FALSE   TRUE     TRUE #> 12_17  TRUE   TRUE     TRUE #> 12_18 FALSE  FALSE     TRUE #> 12_19 FALSE   TRUE     TRUE #> 12_20 FALSE   TRUE     TRUE #> 13_14 FALSE   TRUE     TRUE #> 13_15  TRUE   TRUE     TRUE #> 13_16 FALSE   TRUE     TRUE #> 13_17  TRUE   TRUE     TRUE #> 13_18 FALSE  FALSE     TRUE #> 13_19 FALSE   TRUE     TRUE #> 13_20 FALSE   TRUE     TRUE #> 14_15 FALSE   TRUE     TRUE #> 14_16  TRUE   TRUE     TRUE #> 14_17 FALSE   TRUE     TRUE #> 14_18  TRUE  FALSE     TRUE #> 14_19  TRUE   TRUE     TRUE #> 14_20 FALSE   TRUE     TRUE #> 15_16 FALSE   TRUE     TRUE #> 15_17  TRUE   TRUE     TRUE #> 15_18 FALSE  FALSE     TRUE #> 15_19 FALSE   TRUE     TRUE #> 15_20 FALSE   TRUE     TRUE #> 16_17 FALSE   TRUE     TRUE #> 16_18  TRUE  FALSE     TRUE #> 16_19  TRUE   TRUE     TRUE #> 16_20 FALSE   TRUE     TRUE #> 17_18 FALSE  FALSE     TRUE #> 17_19 FALSE   TRUE     TRUE #> 17_20 FALSE   TRUE     TRUE #> 18_19  TRUE  FALSE     TRUE #> 18_20 FALSE  FALSE     TRUE #> 19_20 FALSE   TRUE     TRUE #>  #> $freq_item_pw_membership #>   1_2   1_3   1_4   1_5   1_6   1_7   1_8   1_9  1_10  1_11  1_12  1_13  1_14  #>     2     2     3     2     3     2     3     2     2     3     2     2     2  #>  1_15  1_16  1_17  1_18  1_19  1_20   2_3   2_4   2_5   2_6   2_7   2_8   2_9  #>     2     2     2     1     2     3     3     2     2     2     3     2     2  #>  2_10  2_11  2_12  2_13  2_14  2_15  2_16  2_17  2_18  2_19  2_20   3_4   3_5  #>     3     2     2     2     3     2     3     2     2     3     2     2     2  #>   3_6   3_7   3_8   3_9  3_10  3_11  3_12  3_13  3_14  3_15  3_16  3_17  3_18  #>     2     3     2     2     3     2     2     2     3     2     3     2     2  #>  3_19  3_20   4_5   4_6   4_7   4_8   4_9  4_10  4_11  4_12  4_13  4_14  4_15  #>     3     2     2     3     2     3     2     2     3     2     2     2     2  #>  4_16  4_17  4_18  4_19  4_20   5_6   5_7   5_8   5_9  5_10  5_11  5_12  5_13  #>     2     2     1     2     3     2     2     2     3     2     2     3     3  #>  5_14  5_15  5_16  5_17  5_18  5_19  5_20   6_7   6_8   6_9  6_10  6_11  6_12  #>     2     3     2     3     1     2     2     2     3     2     2     3     2  #>  6_13  6_14  6_15  6_16  6_17  6_18  6_19  6_20   7_8   7_9  7_10  7_11  7_12  #>     2     2     2     2     2     1     2     3     2     2     3     2     2  #>  7_13  7_14  7_15  7_16  7_17  7_18  7_19  7_20   8_9  8_10  8_11  8_12  8_13  #>     2     3     2     3     2     2     3     2     2     2     3     2     2  #>  8_14  8_15  8_16  8_17  8_18  8_19  8_20  9_10  9_11  9_12  9_13  9_14  9_15  #>     2     2     2     2     1     2     3     2     2     3     3     2     3  #>  9_16  9_17  9_18  9_19  9_20 10_11 10_12 10_13 10_14 10_15 10_16 10_17 10_18  #>     2     3     1     2     2     2     2     2     3     2     3     2     2  #> 10_19 10_20 11_12 11_13 11_14 11_15 11_16 11_17 11_18 11_19 11_20 12_13 12_14  #>     3     2     2     2     2     2     2     2     1     2     3     3     2  #> 12_15 12_16 12_17 12_18 12_19 12_20 13_14 13_15 13_16 13_17 13_18 13_19 13_20  #>     3     2     3     1     2     2     2     3     2     3     1     2     2  #> 14_15 14_16 14_17 14_18 14_19 14_20 15_16 15_17 15_18 15_19 15_20 16_17 16_18  #>     2     3     2     2     3     2     2     3     1     2     2     2     2  #> 16_19 16_20 17_18 17_19 17_20 18_19 18_20 19_20  #>     3     2     1     2     2     2     1     2  #>  #> $confusion_matrix #> $confusion_matrix$`Hclu%Greedy` #>   a   b   c   d  #>  51   7 120  12  #>  #> $confusion_matrix$`Hclu%Walktrap` #>   a   b   c   d  #>  58   0 132   0  #>  #> $confusion_matrix$`Greedy%Walktrap` #>   a   b   c   d  #> 171   0  19   0  #>  #>  #> $bioregionalization_comparison #>   bioregionalization_comparison      rand   jaccard #> 1                   Hclu%Greedy 0.3315789 0.2865169 #> 2                 Hclu%Walktrap 0.3052632 0.3052632 #> 3               Greedy%Walktrap 0.9000000 0.9000000 #>  #> attr(,\"class\") #> [1] \"bioregion.bioregionalization.comparison\" #> [2] \"list\"                                     # Find out which bioregionalizations are most representative compare_bioregionalizations(compare_df,                             cor_frequency = TRUE) #> 2025-06-17 15:01:53.881258 - Computing pairwise membership comparisons for each bioregionalization... #> 2025-06-17 15:01:53.882777 - Comparing memberships among bioregionalizations... #> 2025-06-17 15:01:53.88341 - Computing Rand index... #> 2025-06-17 15:01:53.883743 - Computing Jaccard index... #> 2025-06-17 15:01:53.884049 - Computing the correlation between each bioregionalization and the vector of frequency of pairwise membership... #> $args #> $args$indices #> [1] \"rand\"    \"jaccard\" #>  #> $args$cor_frequency #> [1] TRUE #>  #> $args$store_pairwise_membership #> [1] TRUE #>  #> $args$store_confusion_matrix #> [1] TRUE #>  #>  #> $inputs #>               number_items number_bioregionalizations  #>                         20                          3  #>  #> $pairwise_membership #>        Hclu Greedy Walktrap #> 1_2   FALSE   TRUE     TRUE #> 1_3   FALSE   TRUE     TRUE #> 1_4    TRUE   TRUE     TRUE #> 1_5   FALSE   TRUE     TRUE #> 1_6    TRUE   TRUE     TRUE #> 1_7   FALSE   TRUE     TRUE #> 1_8    TRUE   TRUE     TRUE #> 1_9   FALSE   TRUE     TRUE #> 1_10  FALSE   TRUE     TRUE #> 1_11   TRUE   TRUE     TRUE #> 1_12  FALSE   TRUE     TRUE #> 1_13  FALSE   TRUE     TRUE #> 1_14  FALSE   TRUE     TRUE #> 1_15  FALSE   TRUE     TRUE #> 1_16  FALSE   TRUE     TRUE #> 1_17  FALSE   TRUE     TRUE #> 1_18  FALSE  FALSE     TRUE #> 1_19  FALSE   TRUE     TRUE #> 1_20   TRUE   TRUE     TRUE #> 2_3    TRUE   TRUE     TRUE #> 2_4   FALSE   TRUE     TRUE #> 2_5   FALSE   TRUE     TRUE #> 2_6   FALSE   TRUE     TRUE #> 2_7    TRUE   TRUE     TRUE #> 2_8   FALSE   TRUE     TRUE #> 2_9   FALSE   TRUE     TRUE #> 2_10   TRUE   TRUE     TRUE #> 2_11  FALSE   TRUE     TRUE #> 2_12  FALSE   TRUE     TRUE #> 2_13  FALSE   TRUE     TRUE #> 2_14   TRUE   TRUE     TRUE #> 2_15  FALSE   TRUE     TRUE #> 2_16   TRUE   TRUE     TRUE #> 2_17  FALSE   TRUE     TRUE #> 2_18   TRUE  FALSE     TRUE #> 2_19   TRUE   TRUE     TRUE #> 2_20  FALSE   TRUE     TRUE #> 3_4   FALSE   TRUE     TRUE #> 3_5   FALSE   TRUE     TRUE #> 3_6   FALSE   TRUE     TRUE #> 3_7    TRUE   TRUE     TRUE #> 3_8   FALSE   TRUE     TRUE #> 3_9   FALSE   TRUE     TRUE #> 3_10   TRUE   TRUE     TRUE #> 3_11  FALSE   TRUE     TRUE #> 3_12  FALSE   TRUE     TRUE #> 3_13  FALSE   TRUE     TRUE #> 3_14   TRUE   TRUE     TRUE #> 3_15  FALSE   TRUE     TRUE #> 3_16   TRUE   TRUE     TRUE #> 3_17  FALSE   TRUE     TRUE #> 3_18   TRUE  FALSE     TRUE #> 3_19   TRUE   TRUE     TRUE #> 3_20  FALSE   TRUE     TRUE #> 4_5   FALSE   TRUE     TRUE #> 4_6    TRUE   TRUE     TRUE #> 4_7   FALSE   TRUE     TRUE #> 4_8    TRUE   TRUE     TRUE #> 4_9   FALSE   TRUE     TRUE #> 4_10  FALSE   TRUE     TRUE #> 4_11   TRUE   TRUE     TRUE #> 4_12  FALSE   TRUE     TRUE #> 4_13  FALSE   TRUE     TRUE #> 4_14  FALSE   TRUE     TRUE #> 4_15  FALSE   TRUE     TRUE #> 4_16  FALSE   TRUE     TRUE #> 4_17  FALSE   TRUE     TRUE #> 4_18  FALSE  FALSE     TRUE #> 4_19  FALSE   TRUE     TRUE #> 4_20   TRUE   TRUE     TRUE #> 5_6   FALSE   TRUE     TRUE #> 5_7   FALSE   TRUE     TRUE #> 5_8   FALSE   TRUE     TRUE #> 5_9    TRUE   TRUE     TRUE #> 5_10  FALSE   TRUE     TRUE #> 5_11  FALSE   TRUE     TRUE #> 5_12   TRUE   TRUE     TRUE #> 5_13   TRUE   TRUE     TRUE #> 5_14  FALSE   TRUE     TRUE #> 5_15   TRUE   TRUE     TRUE #> 5_16  FALSE   TRUE     TRUE #> 5_17   TRUE   TRUE     TRUE #> 5_18  FALSE  FALSE     TRUE #> 5_19  FALSE   TRUE     TRUE #> 5_20  FALSE   TRUE     TRUE #> 6_7   FALSE   TRUE     TRUE #> 6_8    TRUE   TRUE     TRUE #> 6_9   FALSE   TRUE     TRUE #> 6_10  FALSE   TRUE     TRUE #> 6_11   TRUE   TRUE     TRUE #> 6_12  FALSE   TRUE     TRUE #> 6_13  FALSE   TRUE     TRUE #> 6_14  FALSE   TRUE     TRUE #> 6_15  FALSE   TRUE     TRUE #> 6_16  FALSE   TRUE     TRUE #> 6_17  FALSE   TRUE     TRUE #> 6_18  FALSE  FALSE     TRUE #> 6_19  FALSE   TRUE     TRUE #> 6_20   TRUE   TRUE     TRUE #> 7_8   FALSE   TRUE     TRUE #> 7_9   FALSE   TRUE     TRUE #> 7_10   TRUE   TRUE     TRUE #> 7_11  FALSE   TRUE     TRUE #> 7_12  FALSE   TRUE     TRUE #> 7_13  FALSE   TRUE     TRUE #> 7_14   TRUE   TRUE     TRUE #> 7_15  FALSE   TRUE     TRUE #> 7_16   TRUE   TRUE     TRUE #> 7_17  FALSE   TRUE     TRUE #> 7_18   TRUE  FALSE     TRUE #> 7_19   TRUE   TRUE     TRUE #> 7_20  FALSE   TRUE     TRUE #> 8_9   FALSE   TRUE     TRUE #> 8_10  FALSE   TRUE     TRUE #> 8_11   TRUE   TRUE     TRUE #> 8_12  FALSE   TRUE     TRUE #> 8_13  FALSE   TRUE     TRUE #> 8_14  FALSE   TRUE     TRUE #> 8_15  FALSE   TRUE     TRUE #> 8_16  FALSE   TRUE     TRUE #> 8_17  FALSE   TRUE     TRUE #> 8_18  FALSE  FALSE     TRUE #> 8_19  FALSE   TRUE     TRUE #> 8_20   TRUE   TRUE     TRUE #> 9_10  FALSE   TRUE     TRUE #> 9_11  FALSE   TRUE     TRUE #> 9_12   TRUE   TRUE     TRUE #> 9_13   TRUE   TRUE     TRUE #> 9_14  FALSE   TRUE     TRUE #> 9_15   TRUE   TRUE     TRUE #> 9_16  FALSE   TRUE     TRUE #> 9_17   TRUE   TRUE     TRUE #> 9_18  FALSE  FALSE     TRUE #> 9_19  FALSE   TRUE     TRUE #> 9_20  FALSE   TRUE     TRUE #> 10_11 FALSE   TRUE     TRUE #> 10_12 FALSE   TRUE     TRUE #> 10_13 FALSE   TRUE     TRUE #> 10_14  TRUE   TRUE     TRUE #> 10_15 FALSE   TRUE     TRUE #> 10_16  TRUE   TRUE     TRUE #> 10_17 FALSE   TRUE     TRUE #> 10_18  TRUE  FALSE     TRUE #> 10_19  TRUE   TRUE     TRUE #> 10_20 FALSE   TRUE     TRUE #> 11_12 FALSE   TRUE     TRUE #> 11_13 FALSE   TRUE     TRUE #> 11_14 FALSE   TRUE     TRUE #> 11_15 FALSE   TRUE     TRUE #> 11_16 FALSE   TRUE     TRUE #> 11_17 FALSE   TRUE     TRUE #> 11_18 FALSE  FALSE     TRUE #> 11_19 FALSE   TRUE     TRUE #> 11_20  TRUE   TRUE     TRUE #> 12_13  TRUE   TRUE     TRUE #> 12_14 FALSE   TRUE     TRUE #> 12_15  TRUE   TRUE     TRUE #> 12_16 FALSE   TRUE     TRUE #> 12_17  TRUE   TRUE     TRUE #> 12_18 FALSE  FALSE     TRUE #> 12_19 FALSE   TRUE     TRUE #> 12_20 FALSE   TRUE     TRUE #> 13_14 FALSE   TRUE     TRUE #> 13_15  TRUE   TRUE     TRUE #> 13_16 FALSE   TRUE     TRUE #> 13_17  TRUE   TRUE     TRUE #> 13_18 FALSE  FALSE     TRUE #> 13_19 FALSE   TRUE     TRUE #> 13_20 FALSE   TRUE     TRUE #> 14_15 FALSE   TRUE     TRUE #> 14_16  TRUE   TRUE     TRUE #> 14_17 FALSE   TRUE     TRUE #> 14_18  TRUE  FALSE     TRUE #> 14_19  TRUE   TRUE     TRUE #> 14_20 FALSE   TRUE     TRUE #> 15_16 FALSE   TRUE     TRUE #> 15_17  TRUE   TRUE     TRUE #> 15_18 FALSE  FALSE     TRUE #> 15_19 FALSE   TRUE     TRUE #> 15_20 FALSE   TRUE     TRUE #> 16_17 FALSE   TRUE     TRUE #> 16_18  TRUE  FALSE     TRUE #> 16_19  TRUE   TRUE     TRUE #> 16_20 FALSE   TRUE     TRUE #> 17_18 FALSE  FALSE     TRUE #> 17_19 FALSE   TRUE     TRUE #> 17_20 FALSE   TRUE     TRUE #> 18_19  TRUE  FALSE     TRUE #> 18_20 FALSE  FALSE     TRUE #> 19_20 FALSE   TRUE     TRUE #>  #> $freq_item_pw_membership #>   1_2   1_3   1_4   1_5   1_6   1_7   1_8   1_9  1_10  1_11  1_12  1_13  1_14  #>     2     2     3     2     3     2     3     2     2     3     2     2     2  #>  1_15  1_16  1_17  1_18  1_19  1_20   2_3   2_4   2_5   2_6   2_7   2_8   2_9  #>     2     2     2     1     2     3     3     2     2     2     3     2     2  #>  2_10  2_11  2_12  2_13  2_14  2_15  2_16  2_17  2_18  2_19  2_20   3_4   3_5  #>     3     2     2     2     3     2     3     2     2     3     2     2     2  #>   3_6   3_7   3_8   3_9  3_10  3_11  3_12  3_13  3_14  3_15  3_16  3_17  3_18  #>     2     3     2     2     3     2     2     2     3     2     3     2     2  #>  3_19  3_20   4_5   4_6   4_7   4_8   4_9  4_10  4_11  4_12  4_13  4_14  4_15  #>     3     2     2     3     2     3     2     2     3     2     2     2     2  #>  4_16  4_17  4_18  4_19  4_20   5_6   5_7   5_8   5_9  5_10  5_11  5_12  5_13  #>     2     2     1     2     3     2     2     2     3     2     2     3     3  #>  5_14  5_15  5_16  5_17  5_18  5_19  5_20   6_7   6_8   6_9  6_10  6_11  6_12  #>     2     3     2     3     1     2     2     2     3     2     2     3     2  #>  6_13  6_14  6_15  6_16  6_17  6_18  6_19  6_20   7_8   7_9  7_10  7_11  7_12  #>     2     2     2     2     2     1     2     3     2     2     3     2     2  #>  7_13  7_14  7_15  7_16  7_17  7_18  7_19  7_20   8_9  8_10  8_11  8_12  8_13  #>     2     3     2     3     2     2     3     2     2     2     3     2     2  #>  8_14  8_15  8_16  8_17  8_18  8_19  8_20  9_10  9_11  9_12  9_13  9_14  9_15  #>     2     2     2     2     1     2     3     2     2     3     3     2     3  #>  9_16  9_17  9_18  9_19  9_20 10_11 10_12 10_13 10_14 10_15 10_16 10_17 10_18  #>     2     3     1     2     2     2     2     2     3     2     3     2     2  #> 10_19 10_20 11_12 11_13 11_14 11_15 11_16 11_17 11_18 11_19 11_20 12_13 12_14  #>     3     2     2     2     2     2     2     2     1     2     3     3     2  #> 12_15 12_16 12_17 12_18 12_19 12_20 13_14 13_15 13_16 13_17 13_18 13_19 13_20  #>     3     2     3     1     2     2     2     3     2     3     1     2     2  #> 14_15 14_16 14_17 14_18 14_19 14_20 15_16 15_17 15_18 15_19 15_20 16_17 16_18  #>     2     3     2     2     3     2     2     3     1     2     2     2     2  #> 16_19 16_20 17_18 17_19 17_20 18_19 18_20 19_20  #>     3     2     1     2     2     2     1     2  #>  #> $bioregionalization_freq_cor #>      Hclu    Greedy  Walktrap  #> 0.8304884 0.5184878 0.0000000  #>  #> $confusion_matrix #> $confusion_matrix$`Hclu%Greedy` #>   a   b   c   d  #>  51   7 120  12  #>  #> $confusion_matrix$`Hclu%Walktrap` #>   a   b   c   d  #>  58   0 132   0  #>  #> $confusion_matrix$`Greedy%Walktrap` #>   a   b   c   d  #> 171   0  19   0  #>  #>  #> $bioregionalization_comparison #>   bioregionalization_comparison      rand   jaccard #> 1                   Hclu%Greedy 0.3315789 0.2865169 #> 2                 Hclu%Walktrap 0.3052632 0.3052632 #> 3               Greedy%Walktrap 0.9000000 0.9000000 #>  #> attr(,\"class\") #> [1] \"bioregion.bioregionalization.comparison\" #> [2] \"list\""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut a hierarchical tree — cut_tree","title":"Cut a hierarchical tree — cut_tree","text":"function designed work hierarchical tree cut user-selected heights. works outputs either hclu_hierarclust hclust objects. function allows cutting tree based chosen number(s) clusters specified height(s). Additionally, includes procedure automatically determine cutting height requested number(s) clusters.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut a hierarchical tree — cut_tree","text":"","code":"cut_tree(   tree,   n_clust = NULL,   cut_height = NULL,   find_h = TRUE,   h_max = 1,   h_min = 0,   dynamic_tree_cut = FALSE,   dynamic_method = \"tree\",   dynamic_minClusterSize = 5,   dissimilarity = NULL,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut a hierarchical tree — cut_tree","text":"tree bioregion.hierar.tree hclust object. n_clust integer vector single integer indicating number clusters obtained hierarchical tree, output bioregionalization_metrics(). used concurrently cut_height. cut_height numeric vector specifying height(s) tree cut. used concurrently n_clust optim_method. find_h boolean indicating whether cutting height determined requested n_clust. h_max numeric value indicating maximum possible tree height determining cutting height find_h = TRUE. h_min numeric value specifying minimum possible height tree determining cutting height find_h = TRUE. dynamic_tree_cut boolean indicating whether dynamic tree cut method used. TRUE, n_clust cut_height ignored. dynamic_method character string specifying method used dynamically cutting tree: either \"tree\" (clusters searched within tree) \"hybrid\" (clusters searched tree dissimilarity matrix). dynamic_minClusterSize integer indicating minimum cluster size dynamic tree cut method (see dynamicTreeCut::cutreeDynamic()). dissimilarity Relevant dynamic_method = \"hybrid\". Provide dissimilarity data.frame used build tree. ... Additional arguments passed dynamicTreeCut::cutreeDynamic() customize dynamic tree cut method.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut a hierarchical tree — cut_tree","text":"tree output hclu_hierarclust(), object returned updated content (.e., args clusters). tree hclust object, data.frame containing clusters returned.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cut a hierarchical tree — cut_tree","text":"function supports two main methods cutting tree. First, tree can cut uniform height (specified cut_height determined automatically requested n_clust). Second, dynamic tree cut method (Langfelder et al., 2008) can applied, adapts shape branches tree, cutting varying heights based cluster positions. dynamic tree cut method two variants: tree-based variant (dynamic_method = \"tree\") uses top-approach, relying solely tree order clustered objects. hybrid variant (dynamic_method = \"hybrid\") employs bottom-approach, leveraging tree dissimilarity matrix identify clusters based dissimilarity among sites. approach useful detecting outliers within clusters.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Cut a hierarchical tree — cut_tree","text":"find_h argument ignored dynamic_tree_cut = TRUE, cutting heights determined case.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cut a hierarchical tree — cut_tree","text":"Langfelder P, Zhang B & Horvath S (2008) Defining clusters hierarchical cluster tree: Dynamic Tree Cut package R. BIOINFORMATICS 24, 719-720.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cut a hierarchical tree — cut_tree","text":"Pierre Denelle (pierre.denelle@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut a hierarchical tree — cut_tree","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\", 1:20) colnames(comat) <- paste0(\"Species\", 1:25)  simil <- similarity(comat, metric = \"all\") dissimilarity <- similarity_to_dissimilarity(simil)  # User-defined number of clusters tree1 <- hclu_hierarclust(dissimilarity,                           n_clust = 5) #> Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. #> Error in if (nrow(dist_matrix) > 2) {    subclusters <- stable_binary_split(dist_matrix, method = method,         n_runs = n_runs, binsplit = \"tree\")} else {    subclusters <- list(attr(dist_matrix, \"Labels\")[1], attr(dist_matrix,         \"Labels\")[2])}: argument is of length zero tree2 <- cut_tree(tree1, cut_height = .05) #> Error: object 'tree1' not found tree3 <- cut_tree(tree1, n_clust = c(3, 5, 10)) #> Error: object 'tree1' not found tree4 <- cut_tree(tree1, cut_height = c(.05, .1, .15, .2, .25)) #> Error: object 'tree1' not found tree5 <- cut_tree(tree1, n_clust = c(3, 5, 10), find_h = FALSE) #> Error: object 'tree1' not found  hclust_tree <- tree2$algorithm$final.tree #> Error: object 'tree2' not found clusters_2 <- cut_tree(hclust_tree, n_clust = 10) #> Error: object 'hclust_tree' not found  cluster_dynamic <- cut_tree(tree1, dynamic_tree_cut = TRUE,                             dissimilarity = dissimilarity) #> Error: object 'tree1' not found"},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"function generates data.frame row provides one several dissimilarity metrics pairs sites, based co-occurrence matrix sites rows species columns.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"","code":"dissimilarity(comat, metric = \"Simpson\", formula = NULL, method = \"prodmat\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"comat co-occurrence matrix sites rows species columns. metric character vector single character string specifying metrics compute (see Details). Available options \"abc\", \"ABC\", \"Jaccard\", \"Jaccardturn\", \"Sorensen\", \"Simpson\", \"Bray\", \"Brayturn\", \"Euclidean\". \"\" specified, metrics calculated. Can set NULL formula used. formula character vector single character string specifying custom formula(s) based , b, c, , B, C quantities (see Details). default NULL. method character string specifying method compute abc (see Details). default \"prodmat\", efficient memory-intensive. Alternatively, \"loops\" less memory-intensive slower.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"data.frame additional class bioregion.pairwise.metric, containing one several dissimilarity metrics pairs sites. first two columns represent pairs sites. one column per similarity metric provided metric formula, except abc ABC metrics, stored three separate columns (one letter).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"number species shared pair sites, b species present first site  c species present second site. Jaccard = (b + c) / (+ b + c) Jaccardturn = 2min(b, c) / (+ 2min(b, c)) (Baselga, 2012) Sorensen = (b + c) / (2a + b + c) Simpson = min(b, c) / (+ min(b, c)) abundances data available, Bray-Curtis turnover component can also computed following equation: Bray = (B + C) / (2A + B + C) Brayturn = min(B, C)/(+ min(B, C)) (Baselga, 2013) sum lesser values common species shared pair sites. B C total number specimens counted sites minus . formula can used compute customized metrics terms , b, c, , B, C. example formula = c(\"pmin(b,c) / (+ pmin(b,c))\", \"(B + C) / (2*+ B + C)\") compute Simpson Bray-Curtis dissimilarity metrics, respectively. Note pmin used Simpson formula , b, c, , B C numeric vectors. Euclidean computes Euclidean distance pair sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"Baselga, . (2012) Relationship Species Replacement, Dissimilarity Derived Nestedness, Nestedness. Global Ecology Biogeography, 21(12), 1223–1232. Baselga, . (2013) Separating two components abundance-based dissimilarity: balanced changes abundance vs. abundance gradients. Methods Ecology Evolution, 4(6), 552–557.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"","code":"comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  dissim <- dissimilarity(comat, metric = c(\"abc\", \"ABC\", \"Simpson\", \"Brayturn\"))  dissim <- dissimilarity(comat, metric = \"all\", formula = \"1 - (b + c) / (a + b + c)\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"function converts data.frame dissimilarity metrics (beta diversity) sites similarity metrics.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"","code":"dissimilarity_to_similarity(dissimilarity, include_formula = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(). include_formula boolean indicating whether metrics based custom formula(s) also converted (see Details). default TRUE.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"data.frame additional class bioregion.pairwise.metric, providing similarity metrics pair sites based dissimilarity object.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"behavior function changes depending column names. Columns Site1 Site2 copied identically. columns called , b, c, , B, C also copied identically. columns based formula (argument formula dissimilarity()) original list dissimilarity metrics (argument metrics dissimilarity()) argument include_formula set FALSE, also copied identically. Otherwise going converted like columns (default behavior). column called Euclidean, similarity calculated based following formula: Euclidean similarity = 1 / (1 - Euclidean distance) Otherwise, columns transformed dissimilarity following formula: similarity = 1 - dissimilarity","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"","code":"comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  dissimil <- dissimilarity(comat, metric = \"all\") dissimil #> Data.frame of dissimilarity between sites #>  - Total number of sites:  5  #>  - Total number of species:  10  #>  - Number of rows:  10  #>  - Number of dissimilarity metrics:  7  #>  #>  #>    Site1 Site2   Jaccard Jaccardturn   Sorensen   Simpson      Bray  Brayturn #> 2  Site1 Site2 0.3000000   0.2222222 0.17647059 0.1250000 0.6544697 0.5451220 #> 3  Site1 Site3 0.3000000   0.2222222 0.17647059 0.1250000 0.2486222 0.2453875 #> 4  Site1 Site4 0.2222222   0.2222222 0.12500000 0.1250000 0.6690404 0.6271963 #> 5  Site1 Site5 0.3000000   0.2222222 0.17647059 0.1250000 0.7832099 0.7323171 #> 8  Site2 Site3 0.2000000   0.2000000 0.11111111 0.1111111 0.5817844 0.4464945 #> 9  Site2 Site4 0.1111111   0.0000000 0.05882353 0.0000000 0.5018811 0.2414057 #> 10 Site2 Site5 0.2000000   0.2000000 0.11111111 0.1111111 0.7727987 0.7601660 #> 14 Site3 Site4 0.3000000   0.2222222 0.17647059 0.1250000 0.5345826 0.4782277 #> 15 Site3 Site5 0.0000000   0.0000000 0.00000000 0.0000000 0.8463826 0.8093481 #> 20 Site4 Site5 0.3000000   0.2222222 0.17647059 0.1250000 0.6004302 0.4323911 #>    Euclidean a b c    A    B    C #> 2  1299.4052 7 1 2  746  894 1932 #> 3   437.8402 7 1 2 1227  413  399 #> 4   929.3487 7 1 1  488 1152  821 #> 5  1543.3081 7 1 2  439 1201 1971 #> 8  1161.0469 8 1 1  900 1778  726 #> 9   981.0520 8 1 0  993 1685  316 #> 10 1691.5100 8 1 1  578 2100 1832 #> 14  796.4477 7 2 1  683  943  626 #> 15 1550.0813 9 0 0  310 1316 2100 #> 20 1236.3426 7 1 2  743  566 1667  similarity <- dissimilarity_to_similarity(dissimil) similarity #> Data.frame of similarity between sites #>  - Total number of sites:  5  #>  - Total number of species:  10  #>  - Number of rows:  10  #>  - Number of similarity metrics:  7  #>  #>  #>    Site1 Site2   Jaccard Jaccardturn  Sorensen   Simpson      Bray  Brayturn #> 2  Site1 Site2 0.7000000   0.7777778 0.8235294 0.8750000 0.3455303 0.4548780 #> 3  Site1 Site3 0.7000000   0.7777778 0.8235294 0.8750000 0.7513778 0.7546125 #> 4  Site1 Site4 0.7777778   0.7777778 0.8750000 0.8750000 0.3309596 0.3728037 #> 5  Site1 Site5 0.7000000   0.7777778 0.8235294 0.8750000 0.2167901 0.2676829 #> 8  Site2 Site3 0.8000000   0.8000000 0.8888889 0.8888889 0.4182156 0.5535055 #> 9  Site2 Site4 0.8888889   1.0000000 0.9411765 1.0000000 0.4981189 0.7585943 #> 10 Site2 Site5 0.8000000   0.8000000 0.8888889 0.8888889 0.2272013 0.2398340 #> 14 Site3 Site4 0.7000000   0.7777778 0.8235294 0.8750000 0.4654174 0.5217723 #> 15 Site3 Site5 1.0000000   1.0000000 1.0000000 1.0000000 0.1536174 0.1906519 #> 20 Site4 Site5 0.7000000   0.7777778 0.8235294 0.8750000 0.3995698 0.5676089 #>       Euclidean a b c    A    B    C #> 2  0.0007689911 7 1 2  746  894 1932 #> 3  0.0022787340 7 1 2 1227  413  399 #> 4  0.0010748658 7 1 1  488 1152  821 #> 5  0.0006475392 7 1 2  439 1201 1971 #> 8  0.0008605504 8 1 1  900 1778  726 #> 9  0.0010182760 8 1 0  993 1685  316 #> 10 0.0005908385 8 1 1  578 2100 1832 #> 14 0.0012540007 7 2 1  683  943  626 #> 15 0.0006447115 9 0 0  310 1316 2100 #> 20 0.0008081836 7 1 2  743  566 1667"},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Search for an optimal number of clusters in a list of bioregionalizations — find_optimal_n","title":"Search for an optimal number of clusters in a list of bioregionalizations — find_optimal_n","text":"function aims optimize one several criteria set ordered bioregionalizations. typically used find one optimal cluster counts hierarchical trees cut ranges bioregionalizations k-means PAM. Users exercise caution cases (e.g., unordered bioregionalizations unrelated bioregionalizations).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Search for an optimal number of clusters in a list of bioregionalizations — find_optimal_n","text":"","code":"find_optimal_n(   bioregionalizations,   metrics_to_use = \"all\",   criterion = \"elbow\",   step_quantile = 0.99,   step_levels = NULL,   step_round_above = TRUE,   metric_cutoffs = c(0.5, 0.75, 0.9, 0.95, 0.99, 0.999),   n_breakpoints = 1,   plot = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Search for an optimal number of clusters in a list of bioregionalizations — find_optimal_n","text":"bioregionalizations bioregion.bioregionalization.metrics object (output bioregionalization_metrics()) data.frame first two columns named K (bioregionalization name) n_clusters (number clusters), followed columns numeric evaluation metrics. metrics_to_use character vector single string specifying metrics bioregionalizations calculating optimal clusters. Defaults \"\" (uses metrics). criterion character string specifying criterion identify optimal clusters. Options include \"elbow\", \"increasing_step\", \"decreasing_step\", \"cutoff\", \"breakpoints\", \"min\", \"max\". Defaults \"elbow\". See Details. step_quantile \"increasing_step\" \"decreasing_step\", specifies quantile differences consecutive bioregionalizations cutoff identify significant steps eval_metric. step_levels \"increasing_step\" \"decreasing_step\", specifies number largest steps retain cutoffs. step_round_above boolean indicating whether optimal clusters (TRUE) (FALSE) identified steps. Defaults TRUE. metric_cutoffs criterion = \"cutoff\", specifies cutoffs eval_metric extract cluster counts. n_breakpoints Specifies number breakpoints find curve. Defaults 1. plot boolean indicating plot first eval_metric identified optimal clusters drawn.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Search for an optimal number of clusters in a list of bioregionalizations — find_optimal_n","text":"list class bioregion.optimal.n elements: args: Input arguments. evaluation_df: input evaluation data.frame, appended boolean columns optimal cluster counts. optimal_nb_clusters: list optimal cluster counts metric \"metrics_to_use\", based chosen criterion. plot: plot (requested).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Search for an optimal number of clusters in a list of bioregionalizations — find_optimal_n","text":"function explores evaluation metric ~ cluster relationships, applying criteria find optimal cluster counts. Note criteria: Several criteria can return multiple optimal cluster counts, emphasizing hierarchical nested bioregionalizations. approach aligns modern recommendations biological datasets, seen Ficetola et al. (2017)'s reanalysis Holt et al. (2013). Criteria optimal clusters: elbow: Identifies \"elbow\" point evaluation metric curve, incremental improvements diminish. Based method find maximum distance straight line linking curve endpoints. increasing_step decreasing_step: Highlights significant increases decreases metrics analyzing pairwise differences bioregionalizations. Users specify step_quantile step_levels. cutoffs: Derives clusters specified metric cutoffs, e.g., Holt et al. (2013). Adjust cutoffs based spatial scale. breakpoints: Uses segmented regression find breakpoints. Requires specifying n_breakpoints. min & max: Selects clusters minimum maximum metric values.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Search for an optimal number of clusters in a list of bioregionalizations — find_optimal_n","text":"Please note finding optimal number clusters procedure normally requires decisions users, can hardly fully automatized. Users strongly advised read references indicated look guidance choose optimal number(s) clusters. Consider \"optimal\" numbers clusters returned function first approximation best numbers bioregionalization.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Search for an optimal number of clusters in a list of bioregionalizations — find_optimal_n","text":"Holt BG, Lessard J, Borregaard MK, Fritz SA, Araújo MB, Dimitrov D, Fabre P, Graham CH, Graves GR, Jønsson Ka, Nogués-Bravo D, Wang Z, Whittaker RJ, Fjeldså J & Rahbek C (2013) update Wallace's zoogeographic regions world. Science 339, 74-78. Ficetola GF, Mazel F & Thuiller W (2017) Global determinants zoogeographical boundaries. Nature Ecology & Evolution 1, 0089.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Search for an optimal number of clusters in a list of bioregionalizations — find_optimal_n","text":"Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Search for an optimal number of clusters in a list of bioregionalizations — find_optimal_n","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"all\")  # User-defined number of clusters tree <- hclu_hierarclust(dissim,                           optimal_tree_method = \"best\",                           n_clust = 5:10) #> Randomizing the dissimilarity matrix with 100 trials #>  -- range of cophenetic correlation coefficients among trials: 0.8084 - 0.8097 #>  #> Final tree has a 0.8097 cophenetic correlation coefficient with the initial dissimilarity matrix #> Determining the cut height to reach 5 groups... #> --> 0.2734375 #> Determining the cut height to reach 6 groups... #> --> 0.265625 #> Determining the cut height to reach 7 groups... #> --> 0.25 #> Determining the cut height to reach 8 groups... #> --> 0.21875 #> Determining the cut height to reach 9 groups... #> --> 0.1953125 #> Determining the cut height to reach 10 groups... #> --> 0.1875 tree #> Clustering results for algorithm : hclu_hierarclust  #> \t(hierarchical clustering based on a dissimilarity matrix) #>  - Number of sites:  20  #>  - Name of dissimilarity metric:  Jaccard  #>  - Tree construction method:  average  #>  - Randomization of the dissimilarity matrix:  yes, number of trials 100  #>  - Method to compute the final tree:  Tree with the best cophenetic correlation coefficient  #>  - Cophenetic correlation coefficient:  0.81  #>  - Number of clusters requested by the user:  5  #> Clustering results: #>  - Number of partitions:  6  #>  - Partitions are hierarchical #>  - Number of clusters:  5 6 7 8 9 10  #>  - Height of cut of the hierarchical tree: 0.273 0.266 0.25 0.219 0.195 0.188   a <- bioregionalization_metrics(tree,                                 dissimilarity = dissim,                                 species_col = \"Node2\",                                 site_col = \"Node1\",                                 eval_metric = \"anosim\") #> Computing similarity-based metrics... #>   - anosim OK                                     find_optimal_n(a, criterion = 'increasing_step', plot = FALSE) #> Number of bioregionalizations: 6 #> ...Caveat: be cautious with the interpretation of metric analyses with such a low number of bioregionalizations #> Searching for potential optimal number(s) of clusters based on the increasing_step method #>  - Step method #> Search for an optimal number of clusters: #>  - 6  partition(s) evaluated #>  - Range of clusters explored: from  5  to  10  #>  - Evaluated metric(s):  anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  increasing_step  #>    (step quantile chosen:  0.99  (i.e., only the top 1 %  increase  in evaluation metrics  are used as break points for the number of clusters) #>  - Optimal partition(s) of clusters for each metric: #> anosim - 8"},{"path":"https://bioRgeo.github.io/bioregion/reference/fishdf.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of fish in Europe (data.frame) — fishdf","title":"Spatial distribution of fish in Europe (data.frame) — fishdf","text":"dataset containing abundance 195 species 338 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishdf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of fish in Europe (data.frame) — fishdf","text":"","code":"fishdf"},{"path":"https://bioRgeo.github.io/bioregion/reference/fishdf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of fish in Europe (data.frame) — fishdf","text":"data.frame 2,703 rows 3 columns: Site Unique site identifier (corresponding field ID fishsf) Species Unique species identifier Abundance Species abundance","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of fish in Europe (co-occurrence matrix) — fishmat","title":"Spatial distribution of fish in Europe (co-occurrence matrix) — fishmat","text":"dataset containing abundance 195 species 338 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of fish in Europe (co-occurrence matrix) — fishmat","text":"","code":"fishmat"},{"path":"https://bioRgeo.github.io/bioregion/reference/fishmat.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of fish in Europe (co-occurrence matrix) — fishmat","text":"co-occurrence matrix sites rows species columns. element matrix represents abundance species site.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishsf.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of fish in Europe — fishsf","title":"Spatial distribution of fish in Europe — fishsf","text":"dataset containing geometry 338 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishsf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of fish in Europe — fishsf","text":"","code":"fishsf"},{"path":"https://bioRgeo.github.io/bioregion/reference/fishsf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of fish in Europe — fishsf","text":"ID Unique site identifier geometry Geometry site","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":null,"dir":"Reference","previous_headings":"","what":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"function computes divisive hierarchical clustering dissimilarity (beta-diversity) data.frame, calculates cophenetic correlation coefficient, can generate clusters tree requested user. function implements randomization dissimilarity matrix generate tree, selection method based optimal cophenetic correlation coefficient. Typically, dissimilarity data.frame bioregion.pairwise.metric object obtained running similarity similarity followed similarity_to_dissimilarity.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"","code":"hclu_diana(   dissimilarity,   index = names(dissimilarity)[3],   n_clust = NULL,   cut_height = NULL,   find_h = TRUE,   h_max = 1,   h_min = 0 )"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), remaining column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. n_clust integer vector single integer indicating number clusters obtained hierarchical tree, output bioregionalization_metrics. used concurrently cut_height. cut_height numeric vector indicating height(s) tree cut. used concurrently n_clust. find_h boolean indicating whether cutting height determined requested n_clust. h_max numeric value indicating maximum possible tree height chosen index. h_min numeric value indicating minimum possible height tree chosen index.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"list class bioregion.clusters five slots: name: character string containing name algorithm. args: list input arguments provided user. inputs: list describing characteristics clustering process. algorithm: list containing objects associated clustering procedure, original cluster objects. clusters: data.frame containing clustering results.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"function based diana. Chapter 6 Kaufman & Rousseeuw (1990) fully details functioning diana algorithm. find optimal number clusters, see bioregionalization_metrics()","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"Kaufman L & Rousseeuw PJ (2009) Finding groups data: introduction cluster analysis. & Sons. JW (ed.), Finding groups data: introduction cluster analysis.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"all\")  data(\"fishmat\") fishdissim <- dissimilarity(fishmat) fish_diana <- hclu_diana(fishdissim, index = \"Simpson\") #> Output tree has a 0.51 cophenetic correlation coefficient with the initial dissimilarity matrix"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":null,"dir":"Reference","previous_headings":"","what":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"function generates hierarchical tree dissimilarity (beta-diversity) data.frame, calculates cophenetic correlation coefficient, optionally retrieves clusters tree upon user request. function includes randomization process dissimilarity matrix generate tree, two methods available constructing final tree. Typically, dissimilarity data.frame bioregion.pairwise.metric object obtained running similarity, running similarity followed similarity_to_dissimilarity.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"","code":"hclu_hierarclust(   dissimilarity,   index = names(dissimilarity)[3],   method = \"average\",   randomize = TRUE,   n_runs = 100,   keep_trials = FALSE,   optimal_tree_method = \"iterative_consensus_tree\",   n_clust = NULL,   cut_height = NULL,   find_h = TRUE,   h_max = 1,   h_min = 0,   consensus_p = 0.5,   verbose = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. method name hierarchical classification method, hclust. one \"ward.D\", \"ward.D2\", \"single\", \"complete\", \"average\" (= UPGMA), \"mcquitty\" (= WPGMA), \"median\" (= WPGMC), \"centroid\" (= UPGMC). randomize boolean indicating whether dissimilarity matrix randomized account order sites dissimilarity matrix. n_runs number trials randomizing dissimilarity matrix. keep_trials boolean indicating whether random trial results stored output object. Set FALSE save space dissimilarity object large. Note set TRUE optimal_tree_method = \"iterative_consensus_tree\". optimal_tree_method character string indicating final tree obtained trials. Possible values \"iterative_consensus_tree\" (default), \"best\", \"consensus\". recommend \"iterative_consensus_tree\". See Details. n_clust integer vector single integer indicating number clusters obtained hierarchical tree, output bioregionalization_metrics. parameter used simultaneously cut_height. cut_height numeric vector indicating height(s) tree cut. parameter used simultaneously n_clust. find_h boolean indicating whether height cut found requested n_clust. h_max numeric value indicating maximum possible tree height chosen index. h_min numeric value indicating minimum possible height tree chosen index. consensus_p numeric value (applicable optimal_tree_method = \"consensus\") indicating threshold proportion trees must support region/cluster included final consensus tree. verbose boolean (applicable optimal_tree_method = \"iterative_consensus_tree\") indicating whether display progress messages. Set FALSE suppress messages.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"list class bioregion.clusters five slots: name: character string containing name algorithm. args: list input arguments provided user. inputs: list describing characteristics clustering process. algorithm: list containing objects associated clustering procedure, original cluster objects. clusters: data.frame containing clustering results. algorithm slot, users can find following elements: trials: list containing randomization trials. trial includes dissimilarity matrix randomized site order, associated tree, cophenetic correlation coefficient (Spearman) tree. final.tree: hclust object representing final hierarchical tree used. final.tree.coph.cor: cophenetic correlation coefficient initial dissimilarity matrix final.tree.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"function based hclust. default method hierarchical tree average, .e. UPGMA recommended best method generate tree beta diversity dissimilarity (Kreft & Jetz, 2010). Clusters can obtained two methods: Specifying desired number clusters n_clust Specifying one several heights cut cut_height find optimal number clusters, see bioregionalization_metrics() important pay attention fact order rows input distance matrix influences tree topology explained Dapporto (2013). address , function generates multiple trees randomizing distance matrix. Two methods available obtain final tree: optimal_tree_method = \"iterative_consensus_tree\": Iterative Hierarchical Consensus Tree (IHCT) method reconstructs consensus tree iteratively splitting dataset two subclusters based pairwise dissimilarity sites across n_runs trees based n_runs randomizations distance matrix. iteration, identifies majority membership sites two stable groups across trees, calculates height based selected linkage method (method), enforces monotonic constraints node heights produce coherent tree structure. approach provides robust, hierarchical representation site relationships, balancing cluster stability hierarchical constraints. optimal_tree_method = \"best\": method selects one tree among highest cophenetic correlation coefficient, representing best fit hierarchical structure original distance matrix. optimal_tree_method = \"consensus\": method constructs consensus tree using phylogenetic methods function consensus. using option, must set consensus_p parameter, indicates proportion trees must contain region/cluster included final consensus tree. Consensus trees lack inherent height represent majority structure rather actual hierarchical clustering. assign heights, use non-negative least squares method (nnls.tree) based initial distance matrix, ensuring consensus tree preserves approximate distances among clusters. recommend using \"iterative_consensus_tree\" branches tree always reflect majority decision among many randomized versions distance matrix. method inspired Dapporto et al. (2015), also used majority decision among many randomized versions distance matrix, expands reconstruct entire topology tree iteratively. recommend using basic consensus method many contexts provides inconsistent results, meaningless tree topology low cophenetic correlation coefficient. fast exploration tree, recommend using best method select tree highest cophenetic correlation coefficient among randomized versions distance matrix.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"Kreft H & Jetz W (2010) framework delineating biogeographical regions based species distributions. Journal Biogeography 37, 2029-2053. Dapporto L, Ramazzotti M, Fattorini S, Talavera G, Vila R & Dennis, RLH (2013) Recluster: unbiased clustering procedure beta-diversity turnover. Ecography 36, 1070–1075. Dapporto L, Ciolli G, Dennis RLH, Fox R & Shreeve TG (2015) new procedure extrapolating turnover regionalization mid-small spatial scales, tested British butterflies. Methods Ecology Evolution 6 , 1287–1297.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"Simpson\")  # User-defined number of clusters tree1 <- hclu_hierarclust(dissim,                            n_clust = 5) #> Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. #> Error in if (nrow(dist_matrix) > 2) {    subclusters <- stable_binary_split(dist_matrix, method = method,         n_runs = n_runs, binsplit = \"tree\")} else {    subclusters <- list(attr(dist_matrix, \"Labels\")[1], attr(dist_matrix,         \"Labels\")[2])}: argument is of length zero tree1 #> Error: object 'tree1' not found plot(tree1) #> Error: object 'tree1' not found str(tree1) #> Error: object 'tree1' not found tree1$clusters #> Error: object 'tree1' not found  # User-defined height cut # Only one height tree2 <- hclu_hierarclust(dissim,                            cut_height = .05) #> Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. #> Error in if (nrow(dist_matrix) > 2) {    subclusters <- stable_binary_split(dist_matrix, method = method,         n_runs = n_runs, binsplit = \"tree\")} else {    subclusters <- list(attr(dist_matrix, \"Labels\")[1], attr(dist_matrix,         \"Labels\")[2])}: argument is of length zero tree2 #> Error: object 'tree2' not found tree2$clusters #> Error: object 'tree2' not found  # Multiple heights tree3 <- hclu_hierarclust(dissim,                            cut_height = c(.05, .15, .25)) #> Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. #> Error in if (nrow(dist_matrix) > 2) {    subclusters <- stable_binary_split(dist_matrix, method = method,         n_runs = n_runs, binsplit = \"tree\")} else {    subclusters <- list(attr(dist_matrix, \"Labels\")[1], attr(dist_matrix,         \"Labels\")[2])}: argument is of length zero  tree3$clusters # Mind the order of height cuts: from deep to shallow cuts #> Error: object 'tree3' not found # Info on each partition can be found in table cluster_info tree3$cluster_info #> Error: object 'tree3' not found plot(tree3) #> Error: object 'tree3' not found"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":null,"dir":"Reference","previous_headings":"","what":"OPTICS hierarchical clustering algorithm — hclu_optics","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"function performs semi-hierarchical clustering based dissimilarity using OPTICS algorithm (Ordering Points Identify Clustering Structure).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"","code":"hclu_optics(   dissimilarity,   index = names(dissimilarity)[3],   minPts = NULL,   eps = NULL,   xi = 0.05,   minimum = FALSE,   show_hierarchy = FALSE,   algorithm_in_output = TRUE,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. minPts numeric value specifying minPts argument dbscan. minPts minimum number points required form dense region. default, set natural logarithm number sites dissimilarity. eps numeric value specifying eps argument optics. defines upper limit size epsilon neighborhood. Limiting neighborhood size improves performance little impact ordering long set low. specified (default behavior), largest minPts-distance dataset used, gives result infinity. xi numeric value specifying steepness threshold identify clusters hierarchically using Xi method (see optics). minimum boolean specifying whether hierarchy pruned output retain clusters \"minimal\" level, .e., leaf / non-overlapping clusters. TRUE, argument show_hierarchy set FALSE. show_hierarchy boolean specifying whether hierarchy clusters included output. default, hierarchy visible clusters obtained OPTICS; can visualized plotting OPTICS object. show_hierarchy = TRUE, output cluster data.frame contain additional columns showing hierarchy clusters. algorithm_in_output boolean indicating whether original output dbscan returned output (TRUE default, see Value). ... Additional arguments passed optics() (see optics).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"list class bioregion.clusters five slots: name: character string containing name algorithm. args: list input arguments provided user. inputs: list describing characteristics clustering process. algorithm: list containing objects associated clustering procedure, original cluster objects. clusters: data.frame containing clustering results. algorithm slot, algorithm_in_output = TRUE, users can find output optics.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"OPTICS (Ordering points identify clustering structure) semi-hierarchical clustering algorithm orders points dataset points closest become neighbors, calculates reachability distance point. , clusters can extracted hierarchical manner reachability distance, identifying clusters depending changes relative cluster density. reachability plot explored understand clusters hierarchical nature, running plot output function algorithm_in_output = TRUE: plot(object$algorithm). recommend reading (Hahsler et al., 2019) grasp algorithm, works, clusters mean. extract clusters, use extractXi function based steepness reachability plot (see optics)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"Hahsler M, Piekenbrock M & Doran D (2019) Dbscan: Fast density-based clustering R. Journal Statistical Software 91, 1–30.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"","code":"dissim <- dissimilarity(fishmat, metric = \"all\")    clust1 <- hclu_optics(dissim, index = \"Simpson\") clust1 #> Clustering results for algorithm : hclu_optics  #>  - Number of sites:  338  #> Clustering results: #>  - Number of partitions:  1  #>  - Number of clusters:  4   # Visualize the optics plot (the hierarchy of clusters is illustrated at the # bottom) plot(clust1$algorithm)   # Extract the hierarchy of clusters clust1 <- hclu_optics(dissim, index = \"Simpson\", show_hierarchy = TRUE) clust1 #> Clustering results for algorithm : hclu_optics  #>  - Number of sites:  338  #> Clustering results: #>  - Number of partitions:  2  #>  - Partitions are hierarchical #>  - Number of clusters:  2 4"},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":null,"dir":"Reference","previous_headings":"","what":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"function downloads unzips 'bin' folder required run certain functions bioregion package. also verifies files necessary permissions executed programs. Finally, tests whether binary files running correctly.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"","code":"install_binaries(   binpath = \"tempdir\",   download_only = FALSE,   infomap_version = c(\"2.1.0\", \"2.6.0\", \"2.7.1\", \"2.8.0\") )"},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"binpath character string specifying path folder host bin folder containing binary files (see Details). download_only logical value indicating whether function download bin.zip file perform entire process (see Details). infomap_version character vector single character string specifying Infomap version(s) install.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"return value.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"default, binary files installed R's temporary directory (binpath = \"tempdir\"). case, bin folder automatically removed end R session. Alternatively, binary files can installed bioregion package folder (binpath = \"pkgfolder\"). custom folder path can also specified. case, case, download_only can set TRUE, must ensure files required permissions executed programs. cases, PLEASE MAKE SURE update binpath check_install parameters accordingly netclu_infomap, netclu_louvain, netclu_oslom.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"Currently, Infomap versions 2.1.0, 2.6.0, 2.7.1, 2.8.0 available.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a map of bioregions — map_bioregions","title":"Create a map of bioregions — map_bioregions","text":"plot function can used visualize bioregions based bioregion.clusters object combined geometry (sf objects).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a map of bioregions — map_bioregions","text":"","code":"map_bioregions(clusters, geometry, write_clusters = FALSE, plot = TRUE, ...)"},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a map of bioregions — map_bioregions","text":"clusters object class bioregion.clusters data.frame. data.frame used, first column represent sites' ID, subsequent column(s) represent clusters. geometry spatial object can handled sf package. first attribute correspond sites' ID (see Details). write_clusters boolean indicating clusters added geometry. plot boolean indicating plot drawn. ... arguments passed sf::plot().","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a map of bioregions — map_bioregions","text":"One several maps bioregions plot = TRUE geometry additional clusters' attributes write_clusters = TRUE.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a map of bioregions — map_bioregions","text":"clusters geometry site IDs correspond. type (.e., character clusters bioregion.clusters object) sites clusters included sites geometry.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a map of bioregions — map_bioregions","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a map of bioregions — map_bioregions","text":"","code":"data(fishmat) data(fishsf)  net <- similarity(fishmat, metric = \"Simpson\") clu <- netclu_greedy(net) map <- map_bioregions(clu, fishsf, write_clusters = TRUE, plot = FALSE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a data.frame from a contingency table — mat_to_net","title":"Create a data.frame from a contingency table — mat_to_net","text":"function generates two- three-column data.frame, row represents interaction two nodes (e.g., site species) optional third column indicates weight interaction (weight = TRUE). input contingency table, rows representing one set entities (e.g., site) columns representing another set (e.g., species).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a data.frame from a contingency table — mat_to_net","text":"","code":"mat_to_net(   mat,   weight = FALSE,   remove_zeroes = TRUE,   include_diag = TRUE,   include_lower = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a data.frame from a contingency table — mat_to_net","text":"mat contingency table (.e., matrix). weight logical value indicating whether values matrix interpreted interaction weights. remove_zeroes logical value determining whether interactions weight equal 0 excluded output. include_diag logical value indicating whether diagonal (self-interactions) included output. applies square matrices. include_lower logical value indicating whether lower triangular part matrix included output. applies square matrices.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a data.frame from a contingency table — mat_to_net","text":"data.frame row represents interaction two nodes. weight = TRUE, data.frame includes third column representing weight interaction.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a data.frame from a contingency table — mat_to_net","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a data.frame from a contingency table — mat_to_net","text":"","code":"mat <- matrix(sample(1000, 50), 5, 10) rownames(mat) <- paste0(\"Site\", 1:5) colnames(mat) <- paste0(\"Species\", 1:10)  net <- mat_to_net(mat, weight = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a contingency table from a data.frame — net_to_mat","title":"Create a contingency table from a data.frame — net_to_mat","text":"function generates contingency table two- three-column data.frame, row represents interaction two nodes (e.g., site species) optional third column indicates weight interaction (weight = TRUE).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a contingency table from a data.frame — net_to_mat","text":"","code":"net_to_mat(   net,   weight = FALSE,   squared = FALSE,   symmetrical = FALSE,   missing_value = 0 )"},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a contingency table from a data.frame — net_to_mat","text":"net two- three-column data.frame row represents interaction two nodes (e.g., site species), optional third column indicating weight interaction. weight logical value indicating whether weight column considered. squared logical value indicating whether output matrix square (.e., containing nodes rows columns). symmetrical logical value indicating whether resulting matrix symmetrical. applies squared = TRUE. Note different weights associated opposite pairs already present net preserved. missing_value value assign pairs nodes present net. Defaults 0.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a contingency table from a data.frame — net_to_mat","text":"matrix first nodes (first column net) rows second nodes (second column net) columns. squared = TRUE, rows columns number elements, corresponding unique union objects first second columns net. squared = TRUE symmetrical = TRUE, matrix forced symmetrical based upper triangular part matrix.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a contingency table from a data.frame — net_to_mat","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a contingency table from a data.frame — net_to_mat","text":"","code":"net <- data.frame(   Site = c(rep(\"A\", 2), rep(\"B\", 3), rep(\"C\", 2)),   Species = c(\"a\", \"b\", \"a\", \"c\", \"d\", \"b\", \"d\"),   Weight = c(10, 100, 1, 20, 50, 10, 20) )  mat <- net_to_mat(net, weight = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":null,"dir":"Reference","previous_headings":"","what":"Community structure detection in weighted bipartite networks via modularity optimization — netclu_beckett","title":"Community structure detection in weighted bipartite networks via modularity optimization — netclu_beckett","text":"function takes bipartite weighted graph computes modules applying Newman’s modularity measure bipartite weighted version.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Community structure detection in weighted bipartite networks via modularity optimization — netclu_beckett","text":"","code":"netclu_beckett(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   seed = NULL,   forceLPA = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Community structure detection in weighted bipartite networks via modularity optimization — netclu_beckett","text":"net data.frame representing bipartite network first two columns representing undirected links pairs nodes, next column(s) representing weights links. weight boolean indicating whether weights considered two columns (see Note). cut_weight minimal weight value. weight TRUE, links weights strictly lower value considered (0 default). index name number column use weight. default, third column name net used. seed seed random number generator (NULL random default). forceLPA boolean indicating whether even faster pure LPA-algorithm Beckett used. DIRT-LPA (default) less likely get trapped local minimum slightly slower. Defaults FALSE. site_col name number column site nodes (.e., primary nodes). species_col name number column species nodes (.e., feature nodes). return_node_type character indicating types nodes (\"site\", \"species\", \"\") returned output (\"\" default). algorithm_in_output boolean indicating whether original output computeModules returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Community structure detection in weighted bipartite networks via modularity optimization — netclu_beckett","text":"list class bioregion.clusters five slots: name: character containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm_in_output = TRUE, users can find output computeModules algorithm slot.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Community structure detection in weighted bipartite networks via modularity optimization — netclu_beckett","text":"function based modularity optimization algorithm provided Stephen Beckett (Beckett, 2016) implemented bipartite package (computeModules).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Community structure detection in weighted bipartite networks via modularity optimization — netclu_beckett","text":"Beckett's algorithm designed handle weighted bipartite networks. weight = FALSE, weight 1 assigned pair nodes. Ensure site_col species_col arguments correctly identify respective columns site nodes (primary nodes) species nodes (feature nodes). type nodes returned output can selected using return_node_type argument: \"\" include node types, \"site\" return site nodes, \"species\" return species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Community structure detection in weighted bipartite networks via modularity optimization — netclu_beckett","text":"Beckett SJ (2016) Improved community detection weighted bipartite networks. Royal Society Open Science 3, 140536.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Community structure detection in weighted bipartite networks via modularity optimization — netclu_beckett","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Community structure detection in weighted bipartite networks via modularity optimization — netclu_beckett","text":"","code":"net <- data.frame(   Site = c(rep(\"A\", 2), rep(\"B\", 3), rep(\"C\", 2)),   Species = c(\"a\", \"b\", \"a\", \"c\", \"d\", \"b\", \"d\"),   Weight = c(10, 100, 1, 20, 50, 10, 20))  com <- netclu_beckett(net)"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":null,"dir":"Reference","previous_headings":"","what":"Community structure detection via greedy optimization of modularity — netclu_greedy","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"function finds communities (un)weighted undirected network via greedy optimization modularity.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"","code":"netclu_greedy(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (0 default). index name number column use weight. default, third column name net used. bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (site, species ) returned output (return_node_type = \"\" default). algorithm_in_output boolean indicating original output cluster_fast_greedy returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"list class bioregion.clusters five slots: name: character containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find output cluster_fast_greedy.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"function based fast greedy modularity optimization algorithm (Clauset et al., 2004) implemented igraph package (cluster_fast_greedy).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal keep types nodes, sites preserve sites nodes species preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"Clauset , Newman MEJ & Moore C (2004) Finding community structure large networks. Phys. Rev. E 70, 066111.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_greedy(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_greedy(net_bip, bipartite = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":null,"dir":"Reference","previous_headings":"","what":"Infomap community finding — netclu_infomap","title":"Infomap community finding — netclu_infomap","text":"function finds communities (un)weighted (un)directed network based Infomap algorithm (https://github.com/mapequation/infomap).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Infomap community finding — netclu_infomap","text":"","code":"netclu_infomap(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   seed = NULL,   nbmod = 0,   markovtime = 1,   numtrials = 1,   twolevel = FALSE,   show_hierarchy = FALSE,   directed = FALSE,   bipartite_version = FALSE,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   version = \"2.8.0\",   binpath = \"tempdir\",   check_install = TRUE,   path_temp = \"infomap_temp\",   delete_temp = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Infomap community finding — netclu_infomap","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (0 default). index name number column use weight. default, third column name net used. seed seed random number generator (NULL random default). nbmod Penalize solutions differ number (0 default preferred number modules). markovtime Scales link flow change cost moving modules, higher values result fewer modules (1 default). numtrials number trials picking best solution. twolevel boolean indicating algorithm optimize two-level partition network (FALSE default multi-level). show_hierarchy boolean specifying hierarchy community identifiable outputs (FALSE default). directed boolean indicating network directed (column 1 column 2). bipartite_version boolean indicating bipartite version Infomap used (see Note). bipartite boolean indicating network bipartite (see Note). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"site\", \"species\", \"\") returned output (\"\" default). version character indicating Infomap version use. binpath character indicating path bin folder (see install_binaries Details). check_install boolean indicating function check Infomap properly installed (see install_binaries Details). path_temp character indicating path temporary folder (see Details). delete_temp boolean indicating temporary folder removed (see Details).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Infomap community finding — netclu_infomap","text":"list class bioregion.clusters five slots: name: character containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects. clusters: data.frame containing clustering results. algorithm slot, users can find following elements: cmd: command line used run Infomap. version: Infomap version. web: Infomap's GitHub repository.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Infomap community finding — netclu_infomap","text":"Infomap network clustering algorithm based Map equation proposed Rosvall & Bergstrom (2008) finds communities (un)weighted (un)directed networks. function based C++ version Infomap (https://github.com/mapequation/infomap/releases). function needs binary files run. can installed install_binaries. changed default path bin folder running install_binaries PLEASE MAKE SURE set binpath accordingly. use install_binaries change permissions test binary files PLEASE MAKE SURE set check_install accordingly. C++ version Infomap generates temporary folders /files stored path_temp folder (\"infomap_temp\" unique timestamp located bin folder binpath default). temporary folder removed default (delete_temp = TRUE). Several versions Infomap available package. See install_binaries details.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Infomap community finding — netclu_infomap","text":"Infomap designed deal bipartite networks. use functionality, set bipartite_version argument TRUE order approximate two-step random walker (see https://www.mapequation.org/infomap/ information). Note bipartite network can also considered unipartite network (bipartite = TRUE). cases, forget indicate first two columns dedicated site nodes (.e., primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"site\" preserve site nodes, \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Infomap community finding — netclu_infomap","text":"Rosvall M & Bergstrom CT (2008) Maps random walks complex networks reveal community structure. Proceedings National Academy Sciences 105, 1118-1123.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Infomap community finding — netclu_infomap","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Infomap community finding — netclu_infomap","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_infomap(net) #> Infomap 2.8.0 is not installed... Please have a look at https//bioRgeo.github.io/bioregion/articles/a1_install_binary_files.html for more details. #> It should be located in /tmp/RtmpGDJ7Uv/bin/INFOMAP/2.8.0/"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":null,"dir":"Reference","previous_headings":"","what":"Finding communities based on propagating labels — netclu_labelprop","title":"Finding communities based on propagating labels — netclu_labelprop","text":"function finds communities (un)weighted undirected network based propagating labels.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finding communities based on propagating labels — netclu_labelprop","text":"","code":"netclu_labelprop(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   seed = NULL,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finding communities based on propagating labels — netclu_labelprop","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (0 default). index name number column use weight. default, third column name net used. seed seed random number generator (NULL random default). bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"site\", \"species\", \"\") returned output (\"\" default). algorithm_in_output boolean indicating original output cluster_label_prop returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finding communities based on propagating labels — netclu_labelprop","text":"list class bioregion.clusters five slots: name: character containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm slot, algorithm_in_output = TRUE, users can find \"communities\" object, output cluster_label_prop.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finding communities based on propagating labels — netclu_labelprop","text":"function based propagating labels (Raghavan et al., 2007) implemented igraph package (cluster_label_prop).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Finding communities based on propagating labels — netclu_labelprop","text":"Although algorithm primarily designed deal bipartite networks, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e., primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"site\" preserve site nodes, \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Finding communities based on propagating labels — netclu_labelprop","text":"Raghavan UN, Albert R & Kumara S (2007) Near linear time algorithm detect community structures large-scale networks. Physical Review E 76, 036106.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finding communities based on propagating labels — netclu_labelprop","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finding communities based on propagating labels — netclu_labelprop","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_labelprop(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_labelprop(net_bip, bipartite = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":null,"dir":"Reference","previous_headings":"","what":"Finding communities based on the leading eigenvector of the community matrix — netclu_leadingeigen","title":"Finding communities based on the leading eigenvector of the community matrix — netclu_leadingeigen","text":"function finds communities (un)weighted undirected network based leading eigenvector community matrix.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finding communities based on the leading eigenvector of the community matrix — netclu_leadingeigen","text":"","code":"netclu_leadingeigen(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finding communities based on the leading eigenvector of the community matrix — netclu_leadingeigen","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (0 default). index name number column use weight. default, third column name net used. bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e., primary nodes). species_col name number column species nodes (.e., feature nodes). return_node_type character indicating types nodes (\"site\", \"species\", \"\") returned output (\"\" default). algorithm_in_output boolean indicating original output cluster_leading_eigen returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finding communities based on the leading eigenvector of the community matrix — netclu_leadingeigen","text":"list class bioregion.clusters five slots: name: character containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm slot, algorithm_in_output = TRUE, users can find output cluster_leading_eigen.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finding communities based on the leading eigenvector of the community matrix — netclu_leadingeigen","text":"function based leading eigenvector community matrix (Newman, 2006) implemented igraph package (cluster_leading_eigen).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Finding communities based on the leading eigenvector of the community matrix — netclu_leadingeigen","text":"Although algorithm primarily designed deal bipartite networks, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e., primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"site\" preserve site nodes, \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Finding communities based on the leading eigenvector of the community matrix — netclu_leadingeigen","text":"Newman MEJ (2006) Finding community structure networks using eigenvectors matrices. Physical Review E 74, 036104.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finding communities based on the leading eigenvector of the community matrix — netclu_leadingeigen","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finding communities based on the leading eigenvector of the community matrix — netclu_leadingeigen","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_leadingeigen(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_leadingeigen(net_bip, bipartite = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":null,"dir":"Reference","previous_headings":"","what":"Finding communities using the Leiden algorithm — netclu_leiden","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"function finds communities (un)weighted undirected network based Leiden algorithm Traag, van Eck & Waltman.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"","code":"netclu_leiden(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   seed = NULL,   objective_function = \"CPM\",   resolution_parameter = 1,   beta = 0.01,   n_iterations = 2,   vertex_weights = NULL,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (0 default). index name number column use weight. default, third column name net used. seed random number generator seed (NULL random default). objective_function string indicating objective function use, either Constant Potts Model (\"CPM\") \"modularity\" (\"CPM\" default). resolution_parameter resolution parameter use. Higher resolutions lead smaller communities, lower resolutions lead larger communities. beta parameter affecting randomness Leiden algorithm. affects refinement step algorithm. n_iterations number iterations Leiden algorithm. iteration may improve partition. vertex_weights vertex weights used Leiden algorithm. provided, automatically determined based objective_function. Please see details function understand interpret vertex weights. bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e., primary nodes). species_col name number column species nodes (.e., feature nodes). return_node_type character indicating types nodes (\"site\", \"species\", \"\") returned output (\"\" default). algorithm_in_output boolean indicating original output cluster_leiden returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"list class bioregion.clusters five slots: name: character containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm slot, algorithm_in_output = TRUE, users can find output cluster_leiden.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"function based Leiden algorithm (Traag et al., 2019) implemented igraph package (cluster_leiden).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"Although algorithm primarily designed deal bipartite networks, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e., primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"site\" preserve site nodes, \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"Traag VA, Waltman L & Van Eck NJ (2019) Louvain Leiden: guaranteeing well-connected communities. Scientific reports 9, 5233.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_leiden(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_leiden(net_bip, bipartite = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":null,"dir":"Reference","previous_headings":"","what":"Louvain community finding — netclu_louvain","title":"Louvain community finding — netclu_louvain","text":"function finds communities (un)weighted undirected network based Louvain algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Louvain community finding — netclu_louvain","text":"","code":"netclu_louvain(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   lang = \"igraph\",   resolution = 1,   seed = NULL,   q = 0,   c = 0.5,   k = 1,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   binpath = \"tempdir\",   check_install = TRUE,   path_temp = \"louvain_temp\",   delete_temp = TRUE,   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Louvain community finding — netclu_louvain","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (0 default). index name number column use weight. default, third column name net used. lang string indicating version Louvain used (\"igraph\" \"cpp\", see Details). resolution resolution parameter adjust modularity (1 chosen default, see Details). seed random number generator seed (lang = \"igraph\", NULL random default). q quality function used compute partition graph (modularity chosen default, see Details). c parameter Owsinski-Zadrozny quality function (0 1, 0.5 chosen default). k kappa_min value Shi-Malik quality function (must > 0, 1 chosen default). bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e., primary nodes). species_col name number column species nodes (.e., feature nodes). return_node_type character indicating types nodes (\"site\", \"species\", \"\") returned output (\"\" default). binpath character indicating path bin folder (see install_binaries Details). check_install boolean indicating function check Louvain properly installed (see install_binaries Details). path_temp character indicating path temporary folder (see Details). delete_temp boolean indicating temporary folder removed (see Details). algorithm_in_output boolean indicating original output cluster_louvain returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Louvain community finding — netclu_louvain","text":"list class bioregion.clusters five slots: name: character containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm slot, algorithm_in_output = TRUE, users can find output cluster_louvain lang = \"igraph\" following element lang = \"cpp\": cmd: command line used run Louvain. version: Louvain version. web: Louvain's website.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Louvain community finding — netclu_louvain","text":"Louvain network community detection algorithm proposed (Blondel et al., 2008). function offers two implementations Louvain algorithm (controlled lang parameter): igraph implementation (cluster_louvain) C++ implementation (https://sourceforge.net/projects/louvain/, version 0.3). igraph implementation allows adjustment resolution parameter modularity function (resolution argument) used internally algorithm. Lower values typically yield fewer, larger clusters. original definition modularity recovered resolution parameter set 1 (default). C++ implementation provides several quality functions: q = 0 classical Newman-Girvan criterion (Modularity), q = 1 Zahn-Condorcet criterion, q = 2 Owsinski-Zadrozny criterion (parameterized c), q = 3 Goldberg Density criterion, q = 4 -weighted Condorcet criterion, q = 5 Deviation Indetermination criterion, q = 6 Deviation Uniformity criterion, q = 7 Profile Difference criterion, q = 8 Shi-Malik criterion (parameterized k), q = 9 Balanced Modularity criterion. C++ version based version 0.3 (https://sourceforge.net/projects/louvain/). Binary files required run , can installed install_binaries. changed default path bin folder running install_binaries, PLEASE MAKE SURE set binpath accordingly. use install_binaries change permissions test binary files, PLEASE MAKE SURE set check_install accordingly. C++ version generates temporary folders /files path_temp folder (\"louvain_temp\" unique timestamp located bin folder binpath default). temporary folder removed default (delete_temp = TRUE).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Louvain community finding — netclu_louvain","text":"Although algorithm primarily designed deal bipartite networks, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e., primary nodes) species nodes (.e., feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"site\" preserve site nodes, \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Louvain community finding — netclu_louvain","text":"Blondel VD, Guillaume JL, Lambiotte R & Mech ELJS (2008) Fast unfolding communities large networks. J. Stat. Mech. 10, P10008.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Louvain community finding — netclu_louvain","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Louvain community finding — netclu_louvain","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_louvain(net, lang = \"igraph\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":null,"dir":"Reference","previous_headings":"","what":"OSLOM community finding — netclu_oslom","title":"OSLOM community finding — netclu_oslom","text":"function finds communities (un)weighted (un)directed network based OSLOM algorithm (http://oslom.org/, version 2.4).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OSLOM community finding — netclu_oslom","text":"","code":"netclu_oslom(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   seed = NULL,   reassign = \"no\",   r = 10,   hr = 50,   t = 0.1,   cp = 0.5,   directed = FALSE,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   binpath = \"tempdir\",   check_install = TRUE,   path_temp = \"oslom_temp\",   delete_temp = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OSLOM community finding — netclu_oslom","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (0 default). index Name number column use weight. default, third column name net used. seed random number generator (NULL random default). reassign character indicating nodes belonging several community reassigned method used (see Note). r number runs first hierarchical level (10 default). hr number runs higher hierarchical level (50 default, 0 interested hierarchies). t p-value, default value 0.10. Increase value want modules. cp Kind resolution parameter used decide taking modules union (default value 0.5; bigger value leads bigger clusters). directed boolean indicating network directed (column 1 column 2). bipartite boolean indicating network bipartite (see Details). site_col Name number column site nodes (.e. primary nodes). species_col Name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (site, species, ) returned output (return_node_type = \"\" default). binpath character indicating path bin folder (see install_binaries Details). check_install boolean indicating function check OSLOM properly installed (see install_binaries Details). path_temp character indicating path temporary folder (see Details). delete_temp boolean indicating temporary folder removed (see Details).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"OSLOM community finding — netclu_oslom","text":"list class bioregion.clusters five slots: name: character containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm slot, users can find following elements: cmd: command line used run OSLOM. version: OSLOM version. web: OSLOM's web site.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"OSLOM community finding — netclu_oslom","text":"OSLOM network community detection algorithm proposed Lancichinetti et al. (2011) finds statistically significant (overlapping) communities (un)weighted (un)directed networks. function based 2.4 C++ version OSLOM (http://www.oslom.org/software.htm). function needs files run. can installed install_binaries. changed default path bin folder running install_binaries, PLEASE MAKE SURE set binpath accordingly. use install_binaries change permissions test binary files, PLEASE MAKE SURE set check_install accordingly. C++ version OSLOM generates temporary folders /files stored path_temp folder (folder \"oslom_temp\" unique timestamp located bin folder binpath default). temporary folder removed default (delete_temp = TRUE).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"OSLOM community finding — netclu_oslom","text":"Although algorithm primarily designed deal bipartite networks, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal keep types nodes, sites preserve sites nodes, species preserve species nodes. Since OSLOM potentially returns overlapping communities, propose two methods reassign 'overlapping' nodes: randomly (reassign = \"random\") based closest candidate community (reassign = \"simil\") (weighted networks, case closest candidate community determined average similarity). default, reassign = \"\" information provided. number partitions depend number overlapping modules (three). suffix _semel, _bis, _ter added column names. first partition (_semel) assigns module node. value NA second (_bis) third (_ter) columns indicates overlapping module found node (.e. non-overlapping nodes).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"OSLOM community finding — netclu_oslom","text":"Lancichinetti , Radicchi F, Ramasco JJ & Fortunato S (2011) Finding statistically significant communities networks. PLOS ONE 6, e18961.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"OSLOM community finding — netclu_oslom","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OSLOM community finding — netclu_oslom","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_oslom(net) #> OSLOM is not installed... Please have a look at https://bioRgeo.github.io/bioregion/articles/a1_install_binary_files.html for more details. #> It should be located in /tmp/RtmpGDJ7Uv/bin/OSLOM/"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Community structure detection via short random walks — netclu_walktrap","title":"Community structure detection via short random walks — netclu_walktrap","text":"function finds communities (un)weighted undirected network via short random walks.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Community structure detection via short random walks — netclu_walktrap","text":"","code":"netclu_walktrap(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   steps = 4,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Community structure detection via short random walks — netclu_walktrap","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (0 default). index Name number column use weight. default, third column name net used. steps length random walks perform. bipartite boolean indicating network bipartite (see Details). site_col Name number column site nodes (.e. primary nodes). species_col Name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (site, species, ) returned output (return_node_type = \"\" default). algorithm_in_output boolean indicating original output cluster_walktrap returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Community structure detection via short random walks — netclu_walktrap","text":"list class bioregion.clusters five slots: name: character containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm slot, algorithm_in_output = TRUE, users can find output cluster_walktrap.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Community structure detection via short random walks — netclu_walktrap","text":"function based random walks (Pons & Latapy, 2005) implemented igraph package (cluster_walktrap).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Community structure detection via short random walks — netclu_walktrap","text":"Although algorithm primarily designed deal bipartite networks, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal keep types nodes, sites preserve site nodes, species preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Community structure detection via short random walks — netclu_walktrap","text":"Pons P & Latapy M (2005) Computing Communities Large Networks Using Random Walks. Yolum , Güngör T, Gürgen F, Özturan C (eds.), Computer Information Sciences - ISCIS 2005, Lecture Notes Computer Science, 284-293.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Community structure detection via short random walks — netclu_walktrap","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Community structure detection via short random walks — netclu_walktrap","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_walktrap(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_walktrap(net_bip, bipartite = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"function performs non-hierarchical clustering using Affinity Propagation algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"","code":"nhclu_affprop(   similarity,   index = names(similarity)[3],   seed = NULL,   p = NA,   q = NA,   maxits = 1000,   convits = 100,   lam = 0.9,   details = FALSE,   nonoise = FALSE,   K = NULL,   prc = NULL,   bimaxit = NULL,   exact = NULL,   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"similarity output object similarity() dissimilarity_to_similarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain similarity indices. index name number similarity column use. default, third column name similarity used. seed seed random number generator used nonoise = FALSE. p Input preference, can vector specifying individual preferences data point. scalar, value used data points. NA, exemplar preferences initialized based distribution non-Inf values similarity matrix, controlled q. q p = NA, exemplar preferences initialized according distribution non-Inf values similarity matrix. default, median used. value 0 1 specifies sample quantile, q = 0.5 results median. maxits maximum number iterations execute. convits algorithm terminates exemplars change convits iterations. lam damping factor, value range [0.5, 1). Higher values correspond heavier damping, may help prevent oscillations. details TRUE, detailed information algorithm's progress stored output object. nonoise TRUE, disables addition small amount noise similarity object, prevents degenerate cases. K desired number clusters. NULL, function apclusterK called. prc parameter needed K NULL. algorithm stops number clusters deviates less prc percent desired value K. Set 0 enforce exactly K clusters. bimaxit parameter needed K NULL. Specifies maximum number bisection steps perform. warning issued number clusters remains outside desired range. exact flag indicating whether compute initial preference range exactly. algorithm_in_output boolean indicating whether include original output apcluster result. Defaults TRUE.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"list class bioregion.clusters five slots: name: character string containing name algorithm. args: list input arguments provided user. inputs: list describing characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm_in_output = TRUE, algorithm slot includes output apcluster.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"function based apcluster package (apcluster).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"Frey B & Dueck D (2007) Clustering Passing Messages Data Points. Science 315, 972-976.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"","code":"comat_1 <- matrix(sample(0:1000, size = 10*12, replace = TRUE, prob = 1/1:1001), 10, 12) rownames(comat_1) <- paste0(\"Site\", 1:10) colnames(comat_1) <- paste0(\"Species\", 1:12) comat_1 <- cbind(comat_1,                  matrix(0, 10, 8,                         dimnames = list(paste0(\"Site\", 1:10),                                         paste0(\"Species\", 13:20))))                                          comat_2 <- matrix(sample(0:1000,                           size = 10*12,                           replace = TRUE,                           prob = 1/1:1001),                    10, 12) rownames(comat_2) <- paste0(\"Site\", 11:20) colnames(comat_2) <- paste0(\"Species\", 9:20) comat_2 <- cbind(matrix(0, 10, 8,                          dimnames = list(paste0(\"Site\", 11:20),                                         paste0(\"Species\", 1:8))),                  comat_2)                   comat <- rbind(comat_1, comat_2)  dissim <- dissimilarity(comat, metric = \"Simpson\") sim <- dissimilarity_to_similarity(dissim)  clust1 <- nhclu_affprop(sim)  clust2 <- nhclu_affprop(sim, q = 1)  # Fixed number of clusters  clust3 <- nhclu_affprop(sim, K = 2, prc = 10, bimaxit = 20, exact = FALSE) #> Trying p = 0.9936182  #>    Number of clusters: 1  #> Trying p = 0.9968091 (bisection step no. 1 ) #>    Number of clusters: 1  #> Trying p = 0.9984045 (bisection step no. 2 ) #>    Number of clusters: 1  #> Trying p = 0.9992023 (bisection step no. 3 ) #>    Number of clusters: 1  #> Trying p = 0.9996011 (bisection step no. 4 ) #>    Number of clusters: 1  #> Trying p = 0.9998006 (bisection step no. 5 ) #>    Number of clusters: 2  #>  #> Number of clusters: 2 for p = 0.9998006"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-hierarchical clustering: CLARA — nhclu_clara","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"function performs non-hierarchical clustering based dissimilarity using partitioning around medoids, implemented via Clustering Large Applications (CLARA) algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"","code":"nhclu_clara(   dissimilarity,   index = names(dissimilarity)[3],   seed = NULL,   n_clust = c(1, 2, 3),   maxiter = 0,   initializer = \"LAB\",   fasttol = 1,   numsamples = 5,   sampling = 0.25,   independent = FALSE,   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. seed value random number generator (set NULL random initialization default). n_clust integer vector single integer specifying desired number(s) clusters. maxiter integer defining maximum number iterations. initializer character string, either \"BUILD\" (used classic PAM algorithm) \"LAB\" (Linear Approximate BUILD). fasttol positive numeric value defining tolerance fast swapping behavior. Defaults 1. numsamples positive integer specifying number samples draw. sampling positive numeric value defining sampling rate. independent boolean indicating whether previous medoids excluded next sample. Defaults FALSE. algorithm_in_output boolean indicating whether original output fastclara included output. Defaults TRUE (see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"list class bioregion.clusters five components: name: character string containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm_in_output = TRUE, algorithm slot includes output fastclara.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"Based fastkmedoids package (fastclara).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"Schubert E & Rousseeuw PJ (2019) Faster k-Medoids Clustering: Improving PAM, CLARA, CLARANS Algorithms. Similarity Search Applications 11807, 171-187.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"all\")  #clust <- nhclu_clara(dissim, index = \"Simpson\", n_clust = 5)"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-hierarchical clustering: CLARANS — nhclu_clarans","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"function performs non-hierarchical clustering based dissimilarity using partitioning around medoids, implemented via Clustering Large Applications based RANdomized Search (CLARANS) algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"","code":"nhclu_clarans(   dissimilarity,   index = names(dissimilarity)[3],   seed = NULL,   n_clust = c(1, 2, 3),   numlocal = 2,   maxneighbor = 0.025,   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. seed value random number generator (NULL random initialization default). n_clust integer vector single integer specifying desired number(s) clusters. numlocal integer defining number local searches perform. maxneighbor positive numeric value defining maximum number neighbors consider local search. algorithm_in_output boolean indicating whether original output fastclarans included output. Defaults TRUE (see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"list class bioregion.clusters five components: name: character string containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm_in_output = TRUE, algorithm slot includes output fastclarans.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"Based fastkmedoids package (fastclarans).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"Schubert E & Rousseeuw PJ (2019) Faster k-Medoids Clustering: Improving PAM, CLARA, CLARANS Algorithms. Similarity Search Applications 11807, 171-187.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"all\")  #clust <- nhclu_clarans(dissim, index = \"Simpson\", n_clust = 5)"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"function performs non-hierarchical clustering based dissimilarity using Density-Based Spatial Clustering Applications Noise (DBSCAN) algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"","code":"nhclu_dbscan(   dissimilarity,   index = names(dissimilarity)[3],   minPts = NULL,   eps = NULL,   plot = TRUE,   algorithm_in_output = TRUE,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. minPts numeric vector single numeric value specifying minPts argument dbscan::dbscan(). minPts minimum number points form dense region. default, set natural logarithm number sites dissimilarity. See Details guidance choosing parameter. eps numeric vector single numeric value specifying eps argument dbscan::dbscan(). eps specifies similar points considered part cluster. See Details guidance choosing parameter. plot boolean indicating whether k-nearest neighbor distance plot displayed. algorithm_in_output boolean indicating whether original output dbscan::dbscan included output. Defaults TRUE (see Value). ... Additional arguments passed dbscan() (see dbscan::dbscan).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"list class bioregion.clusters five components: name: character string containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm_in_output = TRUE, algorithm slot includes output dbscan::dbscan.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"DBSCAN (Density-Based Spatial Clustering Applications Noise) algorithm clusters points based density neighbors around data point. requires two main arguments: minPts, minimum number points identify core, eps, radius used find neighbors. Choosing minPts: determines many points necessary form cluster. example, minimum number sites expected bioregion? Choose value sufficiently large dataset expectations. Choosing eps: determines similar sites form cluster. eps small, points considered distinct marked noise. eps large, clusters may merge. value eps depends minPts. recommended choose eps identifying knee k-nearest neighbor distance plot. default, function attempts find knee curve automatically, result uncertain. Users inspect graph modify eps accordingly. explore eps values, run function initially without defining eps, review recommendations, adjust needed based clustering results.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"Hahsler M, Piekenbrock M & Doran D (2019) Dbscan: Fast density-based clustering R. Journal Statistical Software, 91(1), 1–30.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"all\")  clust1 <- nhclu_dbscan(dissim, index = \"Simpson\") #> Trying to find a knee in the curve to search for an optimal eps value... #>        NOTE: this automatic identification of the knee may not work properly #>        if the curve has knees and elbows. Please adjust eps manually by #>        inspecting the curve, identifying a knee as follows: #>  #>                            / #>                  curve    / #>               ___________/  <- knee #>   elbow ->   / #>             / #>            /  clust2 <- nhclu_dbscan(dissim, index = \"Simpson\", eps = 0.2)  clust3 <- nhclu_dbscan(dissim, index = \"Simpson\", minPts = c(5, 10, 15, 20),      eps = c(.1, .15, .2, .25, .3))"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-hierarchical clustering: K-means analysis — nhclu_kmeans","title":"Non-hierarchical clustering: K-means analysis — nhclu_kmeans","text":"function performs non-hierarchical clustering based dissimilarity using k-means analysis.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-hierarchical clustering: K-means analysis — nhclu_kmeans","text":"","code":"nhclu_kmeans(   dissimilarity,   index = names(dissimilarity)[3],   seed = NULL,   n_clust = c(1, 2, 3),   iter_max = 10,   nstart = 10,   algorithm = \"Hartigan-Wong\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-hierarchical clustering: K-means analysis — nhclu_kmeans","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. seed value random number generator (NULL random default). n_clust integer vector single integer value specifying requested number(s) clusters. iter_max integer specifying maximum number iterations k-means method (see kmeans). nstart integer specifying many random sets n_clust selected starting points k-means analysis (see kmeans). algorithm character specifying algorithm use k-means (see kmeans). Available options Hartigan-Wong, Lloyd, Forgy, MacQueen. algorithm_in_output boolean indicating whether original output kmeans included output. Defaults TRUE (see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-hierarchical clustering: K-means analysis — nhclu_kmeans","text":"list class bioregion.clusters five components: name: character string containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm_in_output = TRUE, algorithm slot includes output kmeans.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-hierarchical clustering: K-means analysis — nhclu_kmeans","text":"method partitions data k groups sum squares Euclidean distances points assigned cluster centers minimized. K-means applied directly dissimilarity beta-diversity metrics distances Euclidean. Therefore, first requires transforming dissimilarity matrix using Principal Coordinate Analysis (PCoA) pcoa, applying k-means coordinates points PCoA. additional transformation alters initial dissimilarity matrix, partitioning around medoids method (nhclu_pam) preferred.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non-hierarchical clustering: K-means analysis — nhclu_kmeans","text":"Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-hierarchical clustering: K-means analysis — nhclu_kmeans","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  comnet <- mat_to_net(comat)  dissim <- dissimilarity(comat, metric = \"all\")  clust <- nhclu_kmeans(dissim, n_clust = 2:10, index = \"Simpson\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-hierarchical clustering: Partitioning Around Medoids — nhclu_pam","title":"Non-hierarchical clustering: Partitioning Around Medoids — nhclu_pam","text":"function performs non-hierarchical clustering based dissimilarity using partitioning around medoids (PAM).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-hierarchical clustering: Partitioning Around Medoids — nhclu_pam","text":"","code":"nhclu_pam(   dissimilarity,   index = names(dissimilarity)[3],   seed = NULL,   n_clust = c(1, 2, 3),   variant = \"faster\",   nstart = 1,   cluster_only = FALSE,   algorithm_in_output = TRUE,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-hierarchical clustering: Partitioning Around Medoids — nhclu_pam","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. seed value random number generator (NULL random default). n_clust integer vector single integer value specifying requested number(s) clusters. variant character string specifying PAM variant use. Defaults faster. Available options original, o_1, o_2, f_3, f_4, f_5, faster. See pam details. nstart integer specifying number random starts PAM algorithm. Defaults 1 (faster variant). cluster_only boolean specifying whether clustering results returned pam function. Setting TRUE makes function efficient. algorithm_in_output boolean indicating whether original output pam included result. Defaults TRUE (see Value). ... Additional arguments pass pam() (see pam).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-hierarchical clustering: Partitioning Around Medoids — nhclu_pam","text":"list class bioregion.clusters five components: name: character string containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm_in_output = TRUE, algorithm slot includes output pam.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-hierarchical clustering: Partitioning Around Medoids — nhclu_pam","text":"method partitions data chosen number clusters based input dissimilarity matrix. robust k-means minimizes sum dissimilarities cluster centers (medoids) points assigned cluster. contrast, k-means minimizes sum squared Euclidean distances, makes unsuitable dissimilarity matrices based Euclidean distances.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Non-hierarchical clustering: Partitioning Around Medoids — nhclu_pam","text":"Kaufman L & Rousseeuw PJ (2009) Finding groups data: introduction cluster analysis. & Sons. JW (ed.), Finding groups data: introduction cluster analysis.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non-hierarchical clustering: Partitioning Around Medoids — nhclu_pam","text":"Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-hierarchical clustering: Partitioning Around Medoids — nhclu_pam","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  comnet <- mat_to_net(comat) dissim <- dissimilarity(comat, metric = \"all\")  clust <- nhclu_pam(dissim, n_clust = 2:15, index = \"Simpson\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute similarity metrics between sites based on species composition — similarity","title":"Compute similarity metrics between sites based on species composition — similarity","text":"function generates data.frame row provides one several similarity metrics pairs sites, based co-occurrence matrix sites rows species columns.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute similarity metrics between sites based on species composition — similarity","text":"","code":"similarity(comat, metric = \"Simpson\", formula = NULL, method = \"prodmat\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute similarity metrics between sites based on species composition — similarity","text":"comat co-occurrence matrix sites rows species columns. metric character vector single character string specifying metrics compute (see Details). Available options \"abc\", \"ABC\", \"Jaccard\", \"Jaccardturn\", \"Sorensen\", \"Simpson\", \"Bray\", \"Brayturn\", \"Euclidean\". \"\" specified, metrics calculated. Can set NULL formula used. formula character vector single character string specifying custom formula(s) based , b, c, , B, C quantities (see Details). default NULL. method character string specifying method compute abc (see Details). default \"prodmat\", efficient memory-intensive. Alternatively, \"loops\" less memory-intensive slower.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute similarity metrics between sites based on species composition — similarity","text":"data.frame additional class bioregion.pairwise.metric, containing one several similarity metrics pairs sites. first two columns represent pairs sites. one column per similarity metric provided metric formula, except abc ABC metrics, stored three separate columns (one letter).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute similarity metrics between sites based on species composition — similarity","text":"number species shared pair sites, b species present first site c species present second site. Jaccard = 1 - (b + c) / (+ b + c) Jaccardturn = 1 - 2min(b, c) / (+ 2min(b, c)) (Baselga, 2012) Sorensen = 1 - (b + c) / (2a + b + c) Simpson = 1 - min(b, c) / (+ min(b, c)) abundances data available, Bray-Curtis turnover component can also computed following equation: Bray = 1 - (B + C) / (2A + B + C) Brayturn = 1 - min(B, C) / (+ min(B, C)) (Baselga, 2013) sum lesser values common species shared pair sites. B C total number specimens counted sites minus . formula can used compute customized metrics terms , b, c, , B, C. example formula = c(\"1 - pmin(b,c) / (+ pmin(b,c))\", \"1 - (B + C) / (2*+ B + C)\") compute Simpson Bray-Curtis similarity metrics, respectively. Note pmin used Simpson formula , b, c, , B C numeric vectors. Euclidean computes Euclidean similarity pair sites following equation: Euclidean = 1 / (1 + d_ij) d_ij Euclidean distance site site j terms species composition.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute similarity metrics between sites based on species composition — similarity","text":"Baselga (2012) Relationship Species Replacement, Dissimilarity Derived Nestedness, Nestedness. Global Ecology Biogeography 21, 1223–1232. Baselga (2013) Separating two components abundance-based dissimilarity: balanced changes abundance vs. abundance gradients. Methods Ecology Evolution 4, 552–557.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute similarity metrics between sites based on species composition — similarity","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute similarity metrics between sites based on species composition — similarity","text":"","code":"comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  sim <- similarity(comat, metric = c(\"abc\", \"ABC\", \"Simpson\", \"Brayturn\"))  sim <- similarity(comat, metric = \"all\", formula = \"1 - (b + c) / (a + b + c)\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"function converts data.frame similarity metrics sites dissimilarity metrics (beta diversity).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"","code":"similarity_to_dissimilarity(similarity, include_formula = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"similarity output object similarity() dissimilarity_to_similarity(). include_formula boolean indicating whether metrics based custom formula(s) also converted (see Details). default TRUE.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"data.frame additional class bioregion.pairwise.metric, providing dissimilarity metric(s) pair sites based similarity object.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"behavior function changes depending column names. Columns Site1 Site2 copied identically. columns called , b, c, , B, C also copied identically. columns based formula (argument formula similarity()) original list similarity metrics (argument metrics similarity()) argument include_formula set FALSE, also copied identically. Otherwise going converted like columns (default behavior). column called Euclidean, distance calculated based following formula: Euclidean distance = (1 - Euclidean similarity) / Euclidean similarity Otherwise, columns transformed dissimilarity following formula: dissimilarity = 1 - similarity","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"","code":"comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  simil <- similarity(comat, metric = \"all\") simil #> Data.frame of similarity between sites #>  - Total number of sites:  5  #>  - Total number of species:  10  #>  - Number of rows:  10  #>  - Number of similarity metrics:  7  #>  #>  #>    Site1 Site2   Jaccard Jaccardturn  Sorensen   Simpson       Bray   Brayturn #> 2  Site1 Site2 0.7000000   0.7777778 0.8235294 0.8750000 0.22441993 0.25213675 #> 3  Site1 Site3 0.8000000   0.8000000 0.8888889 0.8888889 0.31751996 0.35245047 #> 4  Site1 Site4 0.8000000   0.8000000 0.8888889 0.8888889 0.18467583 0.28119658 #> 5  Site1 Site5 0.8000000   0.8000000 0.8888889 0.8888889 0.25753705 0.32020330 #> 8  Site2 Site3 0.7000000   0.7777778 0.8235294 0.8750000 0.03556658 0.04483837 #> 9  Site2 Site4 0.8888889   1.0000000 0.9411765 1.0000000 0.46780893 0.61754626 #> 10 Site2 Site5 0.7000000   0.7777778 0.8235294 0.8750000 0.09973286 0.14231258 #> 14 Site3 Site4 0.8000000   0.8000000 0.8888889 0.8888889 0.06264916 0.10948905 #> 15 Site3 Site5 0.8000000   0.8000000 0.8888889 0.8888889 0.13631157 0.15120712 #> 20 Site4 Site5 0.8000000   0.8000000 0.8888889 0.8888889 0.23270440 0.47013977 #>       Euclidean a b c   A    B    C #> 2  0.0011451633 7 2 1 295  875 1164 #> 3  0.0011979205 8 1 1 338  832  621 #> 4  0.0008944035 8 1 1 329  841 2064 #> 5  0.0012432343 8 1 1 252  918  535 #> 8  0.0008641731 7 1 2  43 1416  916 #> 9  0.0011208034 8 0 1 901  558 1492 #> 10 0.0010267693 7 1 2 112 1347  675 #> 14 0.0007422345 8 1 1 105  854 2288 #> 15 0.0010031767 8 1 1 119  840  668 #> 20 0.0009457680 8 1 1 370 2023  417  dissimilarity <- similarity_to_dissimilarity(simil) dissimilarity #> Data.frame of dissimilarity between sites #>  - Total number of sites:  5  #>  - Total number of species:  10  #>  - Number of rows:  10  #>  - Number of dissimilarity metrics:  7  #>  #>  #>    Site1 Site2   Jaccard Jaccardturn   Sorensen   Simpson      Bray  Brayturn #> 2  Site1 Site2 0.3000000   0.2222222 0.17647059 0.1250000 0.7755801 0.7478632 #> 3  Site1 Site3 0.2000000   0.2000000 0.11111111 0.1111111 0.6824800 0.6475495 #> 4  Site1 Site4 0.2000000   0.2000000 0.11111111 0.1111111 0.8153242 0.7188034 #> 5  Site1 Site5 0.2000000   0.2000000 0.11111111 0.1111111 0.7424630 0.6797967 #> 8  Site2 Site3 0.3000000   0.2222222 0.17647059 0.1250000 0.9644334 0.9551616 #> 9  Site2 Site4 0.1111111   0.0000000 0.05882353 0.0000000 0.5321911 0.3824537 #> 10 Site2 Site5 0.3000000   0.2222222 0.17647059 0.1250000 0.9002671 0.8576874 #> 14 Site3 Site4 0.2000000   0.2000000 0.11111111 0.1111111 0.9373508 0.8905109 #> 15 Site3 Site5 0.2000000   0.2000000 0.11111111 0.1111111 0.8636884 0.8487929 #> 20 Site4 Site5 0.2000000   0.2000000 0.11111111 0.1111111 0.7672956 0.5298602 #>    Euclidean a b c   A    B    C #> 2   872.2379 7 2 1 295  875 1164 #> 3   833.7799 8 1 1 338  832  621 #> 4  1117.0636 8 1 1 329  841 2064 #> 5   803.3536 8 1 1 252  918  535 #> 8  1156.1756 7 1 2  43 1416  916 #> 9   891.2171 8 0 1 901  558 1492 #> 10  972.9286 7 1 2 112 1347  675 #> 14 1346.2830 8 1 1 105  854 2288 #> 15  995.8333 8 1 1 119  840  668 #> 20 1056.3418 8 1 1 370 2023  417"},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate contribution metrics of sites and species — site_species_metrics","title":"Calculate contribution metrics of sites and species — site_species_metrics","text":"function calculates metrics assess contribution given species site bioregion.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate contribution metrics of sites and species — site_species_metrics","text":"","code":"site_species_metrics(   bioregionalization,   comat,   indices = c(\"rho\"),   net = NULL,   site_col = 1,   species_col = 2 )"},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate contribution metrics of sites and species — site_species_metrics","text":"bioregionalization bioregion.clusters object. comat co-occurrence matrix sites rows species columns. indices character specifying contribution metric compute. Available options rho, affinity, fidelity, indicator_value Cz. net NULL default. Required Cz indices. data.frame row represents interaction two nodes optional third column indicating interaction's weight. site_col number indicating position column containing sites net. 1 default. species_col number indicating position column containing species net. 2 default.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate contribution metrics of sites and species — site_species_metrics","text":"data.frame columns Bioregion, Species, desired summary statistics, list data.frames Cz indices selected.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate contribution metrics of sites and species — site_species_metrics","text":"\\(\\rho\\) metric derived Lenormand et al. (2019) following formula: \\(\\rho_{ij} = \\frac{n_{ij} - \\frac{n_i n_j}{n}}{\\sqrt{\\left(\\frac{n - n_j}{ n-1}\\right) \\left(1-\\frac{n_j}{n}\\right) \\frac{n_i n_j}{n}}}\\) \\(n\\) number sites, \\(n_i\\) number sites species \\(\\) present, \\(n_j\\) number sites bioregion \\(j\\), \\(n_{ij}\\) number occurrences species \\(\\) sites bioregion \\(j\\). Affinity \\(\\), fidelity \\(F\\), individual contributions \\(IndVal\\) describe species linked bioregions. metrics described Bernardo-Madrid et al. (2019): Affinity species region: \\(A_i = \\frac{R_i}{Z}\\), \\(R_i\\) occurrence/range size species \\(\\) associated bioregion, \\(Z\\) total size (number sites) bioregion. High affinity indicates species occupies sites bioregion. Fidelity species region: \\(F_i = \\frac{R_i}{D_i}\\), \\(R_i\\) occurrence/range size species \\(\\) bioregion, \\(D_i\\) total range size. High fidelity indicates species present regions. Indicator Value species: \\(IndVal = F_i \\cdot A_i\\). Cz metrics derived Guimerà & Amaral (2005): Participation coefficient: \\(C_i = 1 - \\sum_{s=1}^{N_M}{\\left(\\frac{k_{}}{k_i}\\right)^2}\\), \\(k_{}\\) number links node \\(\\) nodes bioregion \\(s\\), \\(k_i\\) total degree node \\(\\). high value means links uniformly distributed; low value means links within node's bioregion. Within-bioregion degree z-score: \\(z_i = \\frac{k_i - \\overline{k_{si}}}{\\sigma_{k_{si}}}\\), \\(k_i\\) number links node \\(\\) nodes bioregion \\(s_i\\), \\(\\overline{k_{si}}\\) average degree nodes \\(s_i\\), \\(\\sigma_{k_{si}}\\) standard deviation degrees \\(s_i\\).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate contribution metrics of sites and species — site_species_metrics","text":"Bernardo-Madrid R, Calatayud J, González‐Suárez M, Rosvall M, Lucas P, Antonelli & Revilla E (2019) Human activity altering world’s zoogeographical regions. Ecology Letters 22, 1297–1305. Guimerà R & Amaral LAN (2005) Functional cartography complex metabolic networks. Nature 433, 895–900. Lenormand M, Papuga G, Argagnon O, Soubeyrand M, Alleaume S & Luque S (2019) Biogeographical network analysis plant species distribution Mediterranean region. Ecology Evolution 9, 237–250.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate contribution metrics of sites and species — site_species_metrics","text":"Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate contribution metrics of sites and species — site_species_metrics","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),                 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"Simpson\") clust1 <- nhclu_kmeans(dissim, n_clust = 3, index = \"Simpson\")  net <- similarity(comat, metric = \"Simpson\") com <- netclu_greedy(net)  site_species_metrics(bioregionalization = clust1, comat = comat, indices = \"rho\") #>    Bioregion   Species         rho #> 1          1  Species1 1515.511843 #> 2          1  Species2  364.794029 #> 3          1  Species3  171.937257 #> 4          1  Species4  714.327872 #> 5          1  Species5  453.213412 #> 6          1  Species6  450.241223 #> 7          1  Species7  660.588567 #> 8          1  Species8  834.441913 #> 9          1  Species9  285.287785 #> 10         1 Species10 1110.387912 #> 11         1 Species11 1791.976471 #> 12         1 Species12 1155.609692 #> 13         1 Species13 1107.664249 #> 14         1 Species14  482.090909 #> 15         1 Species15  840.849114 #> 16         1 Species16  773.914158 #> 17         1 Species17  314.177135 #> 18         1 Species18  614.034174 #> 19         1 Species19  712.064360 #> 20         1 Species20  816.170805 #> 21         1 Species21 1043.316688 #> 22         1 Species22  791.513661 #> 23         1 Species23  673.000000 #> 24         1 Species24 1133.842077 #> 25         1 Species25  739.426209 #> 26         2  Species1  174.724740 #> 27         2  Species2  741.049144 #> 28         2  Species3  652.263823 #> 29         2  Species4   86.970784 #> 30         2  Species5  754.613568 #> 31         2  Species6  100.418459 #> 32         2  Species7  775.715529 #> 33         2  Species8  482.091959 #> 34         2  Species9  427.633703 #> 35         2 Species10  791.389856 #> 36         2 Species11  416.199603 #> 37         2 Species12  393.430261 #> 38         2 Species13    5.153062 #> 39         2 Species14  718.691955 #> 40         2 Species15 1067.828448 #> 41         2 Species16  331.114167 #> 42         2 Species17  113.386253 #> 43         2 Species18  197.239056 #> 44         2 Species19  884.092160 #> 45         2 Species20  575.291145 #> 46         2 Species21   51.729780 #> 47         2 Species22  258.895528 #> 48         2 Species23  493.572183 #> 49         2 Species24  467.249282 #> 50         2 Species25   63.405401 #> 51         3  Species1  974.991715 #> 52         3  Species2  466.957908 #> 53         3  Species3  165.633736 #> 54         3  Species4   59.224257 #> 55         3  Species5  324.490831 #> 56         3  Species6  438.671957 #> 57         3  Species7    7.045180 #> 58         3  Species8  896.250294 #> 59         3  Species9  287.397031 #> 60         3 Species10   -2.431278 #> 61         3 Species11  809.583130 #> 62         3 Species12  100.776712 #> 63         3 Species13 1036.254154 #> 64         3 Species14 1207.029494 #> 65         3 Species15  477.044072 #> 66         3 Species16  563.920750 #> 67         3 Species17  115.202913 #> 68         3 Species18  775.846703 #> 69         3 Species19  182.023754 #> 70         3 Species20  129.307472 #> 71         3 Species21   77.379795 #> 72         3 Species22  695.157385 #> 73         3 Species23  518.916842 #> 74         3 Species24 1371.049071 #> 75         3 Species25   23.259566  # Contribution metrics site_species_metrics(bioregionalization = com, comat = comat, indices = c(\"rho\", \"affinity\", \"fidelity\", \"indicator_value\")) #>    Bioregion   Species           rho  affinity     fidelity       indval #> 1          1  Species1 20350.0617580 228.10526 240.77777778 5.492268e+04 #> 2          1  Species2 12189.1129075 133.10526 148.76470588 1.980137e+04 #> 3          1  Species3  4151.4822937  45.89474  51.29411765 2.354130e+03 #> 4          1  Species4  6112.8587148  63.05263  79.86666667 5.035804e+03 #> 5          1  Species5 11825.3094699 129.15789 144.35294118 1.864432e+04 #> 6          1  Species6  7299.9735616  72.57895  98.50000000 7.149026e+03 #> 7          1  Species7 11152.9595574 125.42105 132.38888889 1.660435e+04 #> 8          1  Species8 16928.2590207 184.52632 206.23529412 3.805584e+04 #> 9          1  Species9  6582.7806941  67.84211  85.93333333 5.829898e+03 #> 10         1 Species10 13634.0649949 134.94737 183.14285714 2.471465e+04 #> 11         1 Species11 21071.3106748 236.15789 249.27777778 5.886892e+04 #> 12         1 Species12 12279.6163621 138.00000 145.66666667 2.010200e+04 #> 13         1 Species13 16399.6918738 184.00000 194.22222222 3.573689e+04 #> 14         1 Species14 15076.9726142 173.89474 173.89473684 3.023938e+04 #> 15         1 Species15 18441.6813209 200.94737 224.58823529 4.513041e+04 #> 16         1 Species16 11369.8056370 127.84211 134.94444444 1.725158e+04 #> 17         1 Species17  4136.9301562  45.73684  51.11764706 2.337960e+03 #> 18         1 Species18 12174.5607699 132.94737 148.58823529 1.975441e+04 #> 19         1 Species19 10219.7236322 111.73684 124.88235294 1.395396e+04 #> 20         1 Species20 11614.0000000 123.05263 146.12500000 1.798107e+04 #> 21         1 Species21  8905.1805445  97.47368 108.94117647 1.061890e+04 #> 22         1 Species22 12761.4969825 139.31579 155.70588235 2.169229e+04 #> 23         1 Species23 12346.9253812 142.57895 142.57894737 2.032876e+04 #> 24         1 Species24 22814.0000000 240.94737 286.12500000 6.894107e+04 #> 25         1 Species25  6279.2615277  57.84211  91.58333333 5.297373e+03 #> 26         2  Species1     0.1081476   1.00000   0.05555556 5.555556e-02 #> 27         2  Species2    -0.9459053   0.00000   0.00000000 0.000000e+00 #> 28         2  Species3   815.8711445 734.00000  43.17647059 3.169153e+04 #> 29         2  Species4    99.8107859  85.00000   5.66666667 4.816667e+02 #> 30         2  Species5     9.0695626   9.00000   0.52941176 4.764706e+00 #> 31         2  Species6    62.9080962  52.00000   3.71428571 1.931429e+02 #> 32         2  Species7     1.1896238   2.00000   0.11111111 2.222222e-01 #> 33         2  Species8    17.9722008  17.00000   1.00000000 1.700000e+01 #> 34         2  Species9   264.4837739 224.00000  14.93333333 3.345067e+03 #> 35         2 Species10   224.7768819 184.00000  13.14285714 2.418286e+03 #> 36         2 Species11   458.6540313 425.00000  23.61111111 1.003472e+04 #> 37         2 Species12    77.9744298  73.00000   4.05555556 2.960556e+02 #> 38         2 Species13     0.1081476   1.00000   0.05555556 5.555556e-02 #> 39         2 Species14   806.3684211 767.00000  40.36842105 3.096258e+04 #> 40         2 Species15    -0.9459053   0.00000   0.00000000 0.000000e+00 #> 41         2 Species16   328.8768944 305.00000  16.94444444 5.168056e+03 #> 42         2 Species17     4.6182435   5.00000   0.29411765 1.470588e+00 #> 43         2 Species18    -0.9459053   0.00000   0.00000000 0.000000e+00 #> 44         2 Species19   809.1941659 728.00000  42.82352941 3.117553e+04 #> 45         2 Species20    19.7297531  18.00000   1.12500000 2.025000e+01 #> 46         2 Species21    -0.9459053   0.00000   0.00000000 0.000000e+00 #> 47         2 Species22   141.4963050 128.00000   7.52941176 9.637647e+02 #> 48         2 Species23   143.2105263 137.00000   7.21052632 9.878421e+02 #> 49         2 Species24    -0.9176629   0.00000   0.00000000 0.000000e+00 #> 50         2 Species25    -0.7947194   0.00000   0.00000000 0.000000e+00  # Cz indices net_bip <- mat_to_net(comat, weight = TRUE) clust_bip <- netclu_greedy(net_bip, bipartite = TRUE) site_species_metrics(bioregionalization = clust_bip, comat = comat,  net = net_bip, indices = \"Cz\") #>         Node Bioregion Category         C          z #> 1      Site1         1     site 0.8204159  0.5720776 #> 2      Site2         3     site 0.8254848  0.2070197 #> 3      Site3         1     site 0.8223140  0.5720776 #> 4      Site4         1     site 0.8254848 -0.8581163 #> 5      Site5         4     site 0.8223140 -0.7302967 #> 6      Site6         6     site 0.8264463  0.6437963 #> 7      Site7         6     site 0.8140496  0.6437963 #> 8      Site8         6     site 0.8027211  1.5021914 #> 9      Site9         1     site 0.8223140  0.5720776 #> 10    Site10         2     site 0.8204159  1.4031215 #> 11    Site11         2     site 0.8181818  1.4031215 #> 12    Site12         5     site 0.8204159  1.6561573 #> 13    Site13         3     site 0.8117914  1.6561573 #> 14    Site14         2     site 0.8223140  0.4677072 #> 15    Site15         5     site 0.8100000  0.2070197 #> 16    Site16         4     site 0.8033241 -0.7302967 #> 17    Site17         4     site 0.8150000 -0.7302967 #> 18    Site18         5     site 0.7977839  0.2070197 #> 19    Site19         3     site 0.8235294  0.2070197 #> 20    Site20         1     site 0.8200000 -0.8581163 #> 21  Species1         6  species 0.8333333 -0.2145988 #> 22  Species2         2  species 0.8096886 -1.4031215 #> 23  Species3         3  species 0.8096886 -1.2421180 #> 24  Species4         2  species 0.8266667 -0.4677072 #> 25  Species5         5  species 0.8096886  0.2070197 #> 26  Species6         6  species 0.8061224 -1.9313889 #> 27  Species7         3  species 0.8271605  0.2070197 #> 28  Species8         6  species 0.8027682 -0.2145988 #> 29  Species9         5  species 0.8000000  0.2070197 #> 30 Species11         2  species 0.8086420 -0.4677072 #> 31 Species12         6  species 0.8271605 -0.2145988 #> 32 Species13         1  species 0.8148148  0.5720776 #> 33 Species14         1  species 0.8199446  0.5720776 #> 34 Species15         3  species 0.8096886 -1.2421180 #> 35 Species16         1  species 0.8148148  0.5720776 #> 36 Species18         6  species 0.8235294 -0.2145988 #> 37 Species19         3  species 0.8027682  0.2070197 #> 38 Species20         4  species 0.7890625  1.0954451 #> 39 Species21         2  species 0.8166090 -0.4677072 #> 40 Species22         5  species 0.8096886 -1.2421180 #> 41 Species23         4  species 0.8199446  1.0954451 #> 42 Species24         1  species 0.7968750  0.5720776 #> 43 Species25         1  species 0.8194444 -2.2883102 #> 44 Species10         5  species 0.8163265 -1.2421180 #> 45 Species17         2  species 0.8304498 -0.4677072"},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"function extracts subset nodes based type (\"site\" \"species\") bioregion.clusters object, contains types nodes (sites species).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"","code":"site_species_subset(clusters, node_type = \"site\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"clusters object class bioregion.clusters. node_type character string indicating type nodes extract. Possible values \"site\" \"species\". default \"site\".","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"object class bioregion.clusters containing specified node type (sites species).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"Network clustering functions (prefixed netclu_) may return types nodes (sites species) applied bipartite networks (using bipartite argument). cases, type nodes included output can specified return_node_type argument. function allows extract particular type nodes (sites species) output adjust return_node_type attribute accordingly.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"","code":"net <- data.frame(   Site = c(rep(\"A\", 2), rep(\"B\", 3), rep(\"C\", 2)),   Species = c(\"a\", \"b\", \"a\", \"c\", \"d\", \"b\", \"d\"),   Weight = c(10, 100, 1, 20, 50, 10, 20) )  clusters <- netclu_louvain(net, lang = \"igraph\", bipartite = TRUE)  clusters_sites <- site_species_subset(clusters, node_type = \"site\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/vegedf.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","title":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","text":"dataset containing abundance 3,697 species 715 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegedf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","text":"","code":"vegedf"},{"path":"https://bioRgeo.github.io/bioregion/reference/vegedf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","text":"data.frame 460,878 rows 3 columns: Site Unique site identifier (corresponding field ID vegesp) Species Unique species identifier Abundance Species abundance","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegedf.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","text":"doi:10.1002/ece3.4718","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegemat.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","title":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","text":"dataset containing abundance 3,697 species 715 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegemat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","text":"","code":"vegemat"},{"path":"https://bioRgeo.github.io/bioregion/reference/vegemat.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","text":"co-occurrence matrix sites rows species columns. element matrix represents abundance species site.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegemat.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","text":"doi:10.1002/ece3.4718","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegesf.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","title":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","text":"dataset containing geometry 715 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegesf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","text":"","code":"vegesf"},{"path":"https://bioRgeo.github.io/bioregion/reference/vegesf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","text":"ID Unique site identifier geometry Geometry site","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegesf.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","text":"doi:10.1002/ece3.4718","code":""},{"path":"https://bioRgeo.github.io/bioregion/news/index.html","id":"bioregion-1209000","dir":"Changelog","previous_headings":"","what":"bioregion 1.2.0.9000","title":"bioregion 1.2.0.9000","text":"list changes made development/GitHub version package bioregion 1.2.0 (CRAN release 2025-01-31) next CRAN release. Added as_bioregion_pairwise() replace improve upon betapart_to_bioregion(), now deprecated. Added comparison R packages computation dissimilarity metrics tutorial 3 (Pairwise similarity/dissimilarity metrics).","code":""},{"path":"https://bioRgeo.github.io/bioregion/news/index.html","id":"bioregion-120","dir":"Changelog","previous_headings":"","what":"bioregion 1.2.0","title":"bioregion 1.2.0","text":"list changes made bioregion 1.1.1 (CRAN release 2024-04-19) bioregion 1.2.0 (CRAN release 2025-01-31). Added affinity propagation algorithm (nhclu_affprop()). Added new method hclu_hierarclust() construct consensus tree called Iterative Hierarchical Consensus Tree (IHCT). resolves issues related order sites distance matrix builds consensus hierarchical tree meaningful topology. Made many changes functions related hclu_hierarclust() due major update. Updated generic functions provide plot print methods hclu_diana(). Added site_species_metrics() package workflow. Added bioregion_metrics() package workflow. Renamed subset_node() site_species_subset(). Added indices Cz site_species_metrics(). Updated install_binaries(): Archive bin.zip now stored GitHub backed NextCloud. Added Infomap version 2.8.0. Added argument download_only execute download step.   Added check_install argument netclu_infomap(), netclu_louvain(), netclu_oslom(). Added betapart_to_bioregion() package. Added compare_bioregionalizations() package. Added bioregionalization_metrics() package. Updated documentation, vignettes, tests. Modified way seeds generated nhclu_clara() nhclu_clarans().","code":""},{"path":"https://bioRgeo.github.io/bioregion/news/index.html","id":"bioregion-111","dir":"Changelog","previous_headings":"","what":"bioregion 1.1.1","title":"bioregion 1.1.1","text":"list changes made bioregion 1.1.0 (CRAN release 2024-03-19) bioregion 1.1.1 (CRAN release 2024-04-19). Added hierarchy support Louvain (C++). Added seed argument stochastic algorithms (except Louvain C++). Added cut_weight argument netclu_* functions. Changed value sites without clusters 0 NA. Updated automated tests (code coverage > 60%). Standardized controls, inputs, outputs. Fixed bug find_optimal_n() cases partition metrics vary.","code":""},{"path":"https://bioRgeo.github.io/bioregion/news/index.html","id":"bioregion-110","dir":"Changelog","previous_headings":"","what":"bioregion 1.1.0","title":"bioregion 1.1.0","text":"list changes made bioregion 1.0.0 (CRAN release 2023-04-15) bioregion 1.1.0 (CRAN release 2024-03-19). Added resolution parameter igraph Louvain implementation. Added options mat_to_net() exclude diagonal lower triangular matrices using include_diag include_lower. Added function extract subset nodes (sites species) bioregion.clusters objects containing types. Added generic function maintain attributes bioregion.pairwise.metric objects track number sites species. Added new functions: nhclu_clara() nhclu_clarans(). Edited vignettes document new functions. Modified controls bioregion.pairwise.metric objects. Added include_formula argument similarity_dissimilarity_conversion() () select formula metrics. Allowed negative values similarity() Euclidean metric.","code":""},{"path":"https://bioRgeo.github.io/bioregion/news/index.html","id":"bioregion-100","dir":"Changelog","previous_headings":"","what":"bioregion 1.0.0","title":"bioregion 1.0.0","text":"First release CRAN","code":""}]
