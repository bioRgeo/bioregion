[{"path":"https://bioRgeo.github.io/bioregion/TODO.html","id":null,"dir":"","previous_headings":"","what":"bioregion","title":"bioregion","text":"list","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/TODO.html","id":"id_11-améliorations-générales","dir":"","previous_headings":"1. Package V1","what":"1.1 Améliorations générales","title":"bioregion","text":"Points à vérifier -> stop( , call. = FALSE) ->  pour le code dans les docs et ... dans les vignettes -> mettre un point “.” à la fin des phrases dans la documentation (?) -> dir.exists() ou file.exists() (win et lin) -> identifier package folder (lipPaths()) -> controls length (>1) glossaire ? Bien vérifier les packages importés (il y en aura à supprimer…)","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/TODO.html","id":"optics","dir":"","previous_headings":"1. Package V1 > 1.2 Amélirations spécifiques dans des fonctions","what":"optics","title":"bioregion","text":"permettre de lancer plusieurs optics avec différentes valeurs de paramètres ?","code":""},{"path":"https://bioRgeo.github.io/bioregion/TODO.html","id":"clustering_hierarchical","dir":"","previous_headings":"1. Package V1 > 1.2 Amélirations spécifiques dans des fonctions","what":"clustering_hierarchical","title":"bioregion","text":"Ajouter l’algorithme diana ?","code":""},{"path":"https://bioRgeo.github.io/bioregion/TODO.html","id":"partition_metrics","dir":"","previous_headings":"1. Package V1 > 1.2 Amélirations spécifiques dans des fonctions","what":"partition_metrics","title":"bioregion","text":"décider si MARS utile ou pas. Switcher vers segmented? Voir si rounding nécessaire avec la nouvelle version de elbow Implémenter la parallélisation de la recherche de clusters Ajouter d’autres métriques, basées par exemple sur l’abondance","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/TODO.html","id":"id_14-fonctions-génériques","dir":"","previous_headings":"1. Package V1","what":"1.4 Fonctions génériques","title":"bioregion","text":"Envisager une fonction générique plot qui s’adapte au type de cluster pour la classe bioregion.clusters","code":""},{"path":[]},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a1_install_binary_files.html","id":"run-install_binaries","dir":"Articles","previous_headings":"","what":"Run install_binaries()","title":"1. Installation of the binary files","text":"function install_binaries run prior using netclu_infomap, Cpp version netclu_louvain netclu_oslom follows. function two parameters. binpath indicating path folder host bin folder containing binary files. default, binary files installed R’s temporary directory (binpath = \"tempdir\"). case bin folder automatically removed end R session. Alternatively, binary files can installed bioregion’s package folder (binpath = \"pkgfolder\"). folder can chosen case PLEASE MAKE SURE update binpath argument netclu_infomap, netclu_louvain netclu_oslom accordingly. second parameter infomap_version indicating Infomap version(s) install. Infomap version 2.1.0 2.6.0 available now. installation binary files divided six steps:","code":"install_binaries(binpath = \"tempdir\" , infomap_version = c(\"2.1.0\", \"2.6.0\"))"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a1_install_binary_files.html","id":"known-issues","dir":"Articles","previous_headings":"","what":"Known issues","title":"1. Installation of the binary files","text":"OpenMP versions Infomap require libomp-dev Ubuntu (sudo apt-get install libomp-dev) libomp macOS (install Homebrew run brew install libomp).","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a2_matrix_and_network_formats.html","id":"load-data","dir":"Articles","previous_headings":"","what":"Load data","title":"2. Matrix and network formats","text":"bioregion’s package contains example dataset spatial distribution Mediterranean vegetation. dataset analyzed article contains abundance 3,697 species 715 sites. dataset composed three files, vegedf data.frame 460,878 rows 3 columns (Site, Species Abundance), vegemat co-occurrence matrix containing information gathered matrix 715 rows 3,697 columns, vegesf spatial object containing geometry 715 sites.","code":"data(vegedf) head(vegedf) ##   Site Species Abundance ## 1   35   10017         1 ## 2   35   10024        18 ## 3   35   10034         1 ## 4   35   10035         1 ## 5   35   10056         2 ## 6   35   10080         3 dim(vegedf) ## [1] 460878      3 sum(!duplicated(vegedf[,1])) ## [1] 715 sum(!duplicated(vegedf[,2])) ## [1] 3697 data(vegemat) vegemat[1:10,1:10] ##     Species ## Site 10001 10002 10003 10004 10005 10006 10007 10008 10009 10010 ##   35     0     0     0     0     0     0     0     0     0     0 ##   36     2     0     0     0     0     0     1    12     0     0 ##   37     0     0     0     0     0     0     0     0     0     0 ##   38     0     0     0     0     0     0     0     0     0     0 ##   39     5     0     0     0     0     0     0     2     0     0 ##   84     0     0     0     0     0     0     0     0     0     0 ##   85     3     0     0     0     0     0     1     7     0     0 ##   86     0     0     0     2     0     0     2    22     0     0 ##   87    16     0     0     0     0     0     2    54     0     0 ##   88   228     0     0     0     0     0     0     5     0     0 dim(vegemat) ## [1]  715 3697"},{"path":"https://bioRgeo.github.io/bioregion/articles/a2_matrix_and_network_formats.html","id":"from-matrix-to-network","dir":"Articles","previous_headings":"","what":"From matrix to network","title":"2. Matrix and network formats","text":"function mat_to_net transforms co-occurrence matrix vegemat network represented data.frame (vegedf case). weight = TRUE third column added values contained matrix. line network format, two first columns named Node1 Node2 default. remove_zeroes = TRUE pairs nodes weight equal 0 removed output.","code":"net <- mat_to_net(vegemat, weight = TRUE, remove_zeroes = FALSE) head(net) ##   Node1 Node2 Weight ## 1    35 10001      0 ## 2    35 10002      0 ## 3    35 10003      0 ## 4    35 10004      0 ## 5    35 10005      0 ## 6    35 10006      0 dim(net) ## [1] 2643355       3 net <- mat_to_net(vegemat, weight = TRUE, remove_zeroes = TRUE) head(net) ##    Node1 Node2 Weight ## 17    35 10017      1 ## 24    35 10024     18 ## 34    35 10034      1 ## 35    35 10035      1 ## 56    35 10056      2 ## 80    35 10080      3 dim(net) ## [1] 460878      3"},{"path":"https://bioRgeo.github.io/bioregion/articles/a2_matrix_and_network_formats.html","id":"from-network-to-matrix","dir":"Articles","previous_headings":"","what":"From network to matrix","title":"2. Matrix and network formats","text":"function net_to_mat opposite. transforms network represented two- three-columns data.frame (vegedf) co-occurrence matrix (vegemat case). squared = TRUE squared matrix generated, rownames colnames correspond concatenation without duplicates two first columns data.frame. argument missing_value defines value assign pairs nodes present input network. default value 0 numeric value can used. Finally, squared = TRUE possible get symmetrical matrix output (symmetrical = TRUE). case resulting squared matrix symmetrical, except symmetrical pairs nodes already present input network (35 <-> 36) example .","code":"mat <- net_to_mat(vegedf, weight = TRUE, squared = FALSE, symmetrical = FALSE, missing_value = 0) mat[1:5,1:5] ##    10017 10024 10034 10035 10056 ## 35     1    18     1     1     2 ## 36   252    57    72    19    75 ## 37    66     1    13    23    43 ## 38    17     1     5    89    27 ## 39    17    17    34     3     8 dim(mat) ## [1]  715 3697 mat <- net_to_mat(vegedf, weight = TRUE, squared = TRUE, symmetrical = FALSE, missing_value = 0) mat[1:5,1:5] ##    35 36 37 38 39 ## 35  0  0  0  0  0 ## 36  0  0  0  0  0 ## 37  0  0  0  0  0 ## 38  0  0  0  0  0 ## 39  0  0  0  0  0 dim(mat) ## [1] 4412 4412 temp <- data.frame(Site=c(\"35\",\"36\",\"36\",\"38\",\"39\"), Species=c(\"36\",\"35\",\"37\",\"37\",\"39\"), Abundance=c(1,2,3,4,0)) net <- rbind(temp,vegedf) mat <- net_to_mat(net, weight = TRUE, squared = TRUE, symmetrical = FALSE, missing_value = -1) mat[1:5,1:5] ##    35 36 38 39 37 ## 35 -1  1 -1 -1 -1 ## 36  2 -1 -1 -1  3 ## 38 -1 -1 -1 -1  4 ## 39 -1 -1 -1  0 -1 ## 37 -1 -1 -1 -1 -1 mat <- net_to_mat(net, weight = TRUE, squared = TRUE, symmetrical = TRUE, missing_value = 0) mat[1:5,1:5] ##    35 36 38 39 37 ## 35  0  1  0  0  0 ## 36  2  0  0  0  3 ## 38  0  0  0  0  4 ## 39  0  0  0  0  0 ## 37  0  3  4  0  0"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"compute-dissimilarity-indices-from-input-data","dir":"Articles","previous_headings":"","what":"1. Compute dissimilarity indices from input data","title":"4.1 Hierarchical clustering","text":"initiate hierarchical clustering procedure, need provide pairwise distances sites. pairwise distances sites can obtained running dissimilarity() species-site matrix, presence-absence abundance matrix. example , use vegetation dataset package compute distance metrics. going compute \\(\\beta_{sim}\\) diversity metric, presence-absence dissimilarity index. formula follows: \\(\\beta_{sim} = min(b, c) / (+min(b, c))\\) number species shared sites; b number species occurring first site; c number species occurring second site. typically choose metric bioregionalisation, turnover component Sorensen index (Baselga, 2012) (nutshell, tells us sites different distinct species), less dependent species richness Jaccard turnover (Leprieur & Oikonomou, 2014). Alternatively, given abundance data , also use Bray-Curtis turnover index (Baselga, 2013). choice distance metric important outcome clustering procedure, recommend choose carefully depending research question. default, Simpson index computed, options available metric argument dissimilarity(). Furthermore, users can also write formula compute index want argument formula, see ?dissimilarity(). now ready start hierarchical clustering procedure object dissim just created. Alternatively, can also use types objects hclu_hierarclust(), distance matrix object (class dist) data.frame crafting (make sure read required format carefully ?hclu_hierarclust).","code":"library(bioregion)  # Work with the vegetation dataset we include in the package data(vegemat)  # This is an abundance matrix where sites are in rows and species in columns vegemat[1:10, 1:10] ##     Species ## Site 10001 10002 10003 10004 10005 10006 10007 10008 10009 10010 ##   35     0     0     0     0     0     0     0     0     0     0 ##   36     2     0     0     0     0     0     1    12     0     0 ##   37     0     0     0     0     0     0     0     0     0     0 ##   38     0     0     0     0     0     0     0     0     0     0 ##   39     5     0     0     0     0     0     0     2     0     0 ##   84     0     0     0     0     0     0     0     0     0     0 ##   85     3     0     0     0     0     0     1     7     0     0 ##   86     0     0     0     2     0     0     2    22     0     0 ##   87    16     0     0     0     0     0     2    54     0     0 ##   88   228     0     0     0     0     0     0     5     0     0 dissim <- dissimilarity(vegemat)  head(dissim) ## Data.frame of dissimilarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  3697  ##  - Number of rows:  255255  ##  - Number of dissimilarity metrics:  1  ##  ##  ##   Site1 Site2    Simpson ## 2    35    36 0.02325581 ## 3    35    37 0.03100775 ## 4    35    38 0.05426357 ## 5    35    39 0.05426357 ## 6    35    84 0.72093023 ## 7    35    85 0.08527132"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"basic-usage","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters","what":"2.1 Basic usage","title":"4.1 Hierarchical clustering","text":"basic use function follows: function gives us information proceeds. Notably, talks randomization dissimilarity matrix - important feature hierarchical clustering strongly influenced order sites distance matrix. Therefore, default, function performs randomization order sites distance matrix 30 trials (information randomization section). also tells us among trials selected tree highest cophenetic correlation coefficient, value 0.71. can see type name object console see information: last line tells us clustering procedure incomplete: tree built, yet cut - clusters object yet. cut tree, can use cut_tree() function: , asked 4 clusters, algorithm automatically finds height 4 clusters found (h = 0.532). type name object console, gives us results clustering: 1 partition: partition clustering result. cut tree , 1 partition moment 4 clusters: number clusters partition. asked 4, obtained 4, good. Sometimes, however, get number clusters asked - case outcome indicated. **heigh cut 0.532: height cut can obtain 4 clusters tree. can make quick plot partitioned tree  Now, hierarchical tree, cutting (= 1 partition) oversimplifies result tree. cut multiple times? example, make deep, intermediate, shallow cuts tree, likewise Ficetola et al. (2017), allow us see broad- fine-scale relationships among sites tree. can specify, e.g. 4, 10 20 clusters: However, may useful choose heights cut, rather number clusters. , example, cut tree heights 0.4 (shallow cut), 0.5 (intermediate cut) 0.6 (deep cut):  plot easy read large number sites. can rather extract information directly object: result, can read deep cut partition (h = 0.6) clusters, intermediate cut partition (h = 0.5) 7 clusters shallow cut partition (h = 0.4) 20 clusters. next section see default settings chose , see find optimal numbers clusters.","code":"tree1 <- hclu_hierarclust(dissim) ## Randomizing the dissimilarity matrix with 30 trials ##  -- range of cophenetic correlation coefficients among ##                      trials: 0.68 - 0.71 ## Optimal tree has a 0.71 cophenetic correlation coefficient with the initial dissimilarity ##       matrix tree1 ## Clustering results for algorithm : hierarchical_clustering  ##  (hierarchical clustering based on a dissimilarity matrix) ##  - Number of sites:  715  ##  - Name of dissimilarity metric:  Simpson  ##  - Tree construction method:  average  ##  - Randomization of the dissimilarity matrix:  yes, number of trials 30  ##  - Cophenetic correlation coefficient:  0.71  ## Clustering procedure incomplete - no clusters yet # Ask for 4 clusters tree1 <- cut_tree(tree1,                   n_clust = 4) ## Determining the cut height to reach 4 groups... ## --> 0.5322265625 tree1 ## Clustering results for algorithm : hierarchical_clustering  ##  (hierarchical clustering based on a dissimilarity matrix) ##  - Number of sites:  715  ##  - Name of dissimilarity metric:  Simpson  ##  - Tree construction method:  average  ##  - Randomization of the dissimilarity matrix:  yes, number of trials 30  ##  - Cophenetic correlation coefficient:  0.71  ##  - Number of clusters requested by the user:  4  ## Clustering results: ##  - Number of partitions:  1  ##  - Number of clusters:  4  ##  - Height of cut of the hierarchical tree: 0.532 # We reduced the size of text labels with cex = .2, because there are too many sites plot(tree1, cex = .2) # Ask for 4, 10 and 20 clusters tree1 <- cut_tree(tree1,                   n_clust = c(4, 10, 20)) ## Determining the cut height to reach 4 groups... ## --> 0.5322265625 ## Determining the cut height to reach 10 groups... ## --> 0.4609375 ## Determining the cut height to reach 20 groups... ## --> 0.40625 plot(tree1, cex = .2) tree1 <- cut_tree(tree1,                   cut_height = c(.4, .5, .6))  plot(tree1, cex = .2) tree1 ## Clustering results for algorithm : hierarchical_clustering  ##  (hierarchical clustering based on a dissimilarity matrix) ##  - Number of sites:  715  ##  - Name of dissimilarity metric:  Simpson  ##  - Tree construction method:  average  ##  - Randomization of the dissimilarity matrix:  yes, number of trials 30  ##  - Cophenetic correlation coefficient:  0.71  ##  - Heights of cut requested by the user:  0.4 0.5 0.6  ## Clustering results: ##  - Number of partitions:  3  ##  - Partitions are not hierarchical ##  - Number of clusters:  2 7 20  ##  - Height of cut of the hierarchical tree: 0.6 0.5 0.4"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"exploring-the-outputs","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters","what":"2.2 Exploring the outputs","title":"4.1 Hierarchical clustering","text":"explore object, can use str() see object structure: show different slots object, can access . example, want access clusters slot, type tree1$clusters. name: name method using args: arguments selected tree inputs: mostly internal use package, provides info nature input data methods algorithm: slot contains detailed information hierarchical clustering. example, can access raw tree , hclust format. access , can type tree1$algorithm$final.tree clusters: data.frame containing partitions. first column sites, columns partitions. cluster_info: small data.frame help link requests clusters data.frame. content varies depending choices; example, case, looks like : shows name partition (corresponding column names tree1$clusters), number clusters partition, cut height initially requested.","code":"str(tree1) ## List of 6 ##  $ name        : chr \"hierarchical_clustering\" ##  $ args        :List of 11 ##   ..$ index              : chr \"Simpson\" ##   ..$ method             : chr \"average\" ##   ..$ randomize          : logi TRUE ##   ..$ n_runs             : num 30 ##   ..$ optimal_tree_method: chr \"best\" ##   ..$ n_clust            : NULL ##   ..$ cut_height         : num [1:3] 0.4 0.5 0.6 ##   ..$ find_h             : logi TRUE ##   ..$ h_max              : num 1 ##   ..$ h_min              : num 0 ##   ..$ dynamic_tree_cut   : logi FALSE ##  $ inputs      :List of 6 ##   ..$ bipartite      : logi FALSE ##   ..$ weight         : logi TRUE ##   ..$ pairwise_metric: logi TRUE ##   ..$ dissimilarity  : logi TRUE ##   ..$ nb_sites       : int 715 ##   ..$ hierarchical   : logi FALSE ##  $ algorithm   :List of 5 ##   ..$ trials             : chr \"Trials not stored in output\" ##   ..$ final.tree         :List of 7 ##   .. ..- attr(*, \"class\")= chr \"hclust\" ##   ..$ final.tree.coph.cor: num 0.71 ##   ..$ output_n_clust     : Named int [1:3] 2 7 20 ##   .. ..- attr(*, \"names\")= chr [1:3] \"h_0.6\" \"h_0.5\" \"h_0.4\" ##   ..$ output_cut_height  : num [1:3] 0.6 0.5 0.4 ##  $ clusters    :'data.frame':    715 obs. of  4 variables: ##   ..$ ID  : chr [1:715] \"808\" \"889\" \"806\" \"1373\" ... ##   ..$ K_2 : chr [1:715] \"1\" \"2\" \"1\" \"2\" ... ##   ..$ K_7 : chr [1:715] \"1\" \"2\" \"3\" \"4\" ... ##   ..$ K_20: chr [1:715] \"1\" \"2\" \"3\" \"4\" ... ##  $ cluster_info:'data.frame':    3 obs. of  3 variables: ##   ..$ partition_name      : chr [1:3] \"K_2\" \"K_7\" \"K_20\" ##   ..$ n_clust             : int [1:3] 2 7 20 ##   ..$ requested_cut_height: num [1:3] 0.6 0.5 0.4 ##  - attr(*, \"class\")= chr [1:2] \"bioregion.clusters\" \"list\" tree1$cluster_info ##       partition_name n_clust requested_cut_height ## h_0.6            K_2       2                  0.6 ## h_0.5            K_7       7                  0.5 ## h_0.4           K_20      20                  0.4"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"randomization","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters > 2.3 Explanation of the default settings and how to change them","what":"2.3.1 Randomization of the distance matrix","title":"4.1 Hierarchical clustering","text":"order sites distance matrix influences outcome hierarchical tree. Let’s see example:  tree looks like matrix randomized. Now let’s randomize regenerate tree:  See tree looks different? problematic means outcome heavily influenced order sites distance matrix. address issue, randomize distance matrix multiple times (30, default, can probably increase number 100 ) generate associated trees. individual tree, function calculates cophenetic correlation coefficient, correlation initial distance \\(\\beta_{sim}\\) among sites cophenetic distance, distance sites connected tree. tells us representative tree initial distance matrix. next question individual trees? default, package select tree best represents distance matrix; .e., one highest cophenetic correlation coefficient (argument optimal_tree_method = \"best\") Let’s see example higher number runs (n_runs = 100). can also ask function keep individual trees exploration (keep_trials = TRUE). Another approach build consensus tree individual trees, use tree, done example package recluster, yet available bioregion.","code":"# Compute the tree without randomizing the distance matrix tree2 <- hclu_hierarclust(dissim,                           randomize = FALSE) ## Output tree has a 0.7 cophenetic correlation coefficient with the initial ##                    dissimilarity matrix plot(tree2, cex = .1) # This line randomizes the order of rows in the distance matrix dissim_random <- dissim[sample(1:nrow(dissim)), ]  # Recompute the tree tree3 <- hclu_hierarclust(dissim_random,                           randomize = FALSE) ## Output tree has a 0.7 cophenetic correlation coefficient with the initial ##                    dissimilarity matrix plot(tree3, cex = .1) tree1 <- hclu_hierarclust(dissim_random,                           randomize = TRUE,                           n_runs = 100,                           keep_trials = TRUE) ## Randomizing the dissimilarity matrix with 100 trials ##  -- range of cophenetic correlation coefficients among ##                      trials: 0.66 - 0.71 ## Optimal tree has a 0.71 cophenetic correlation coefficient with the initial dissimilarity ##       matrix"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"tree-construction-algorithm","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters > 2.3 Explanation of the default settings and how to change them","what":"2.3.2 Tree construction algorithm","title":"4.1 Hierarchical clustering","text":"default, function uses UPGMA method (Unweighted Pair Group Method Arithmetic Mean) recommended bioregionalisation better performance approaches (Kreft & Jetz, 2010). can change method changing argument method; methods implemented stats::hclust() available.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"cutting-the-tree","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters > 2.3 Explanation of the default settings and how to change them","what":"2.3.3 Cutting the tree","title":"4.1 Hierarchical clustering","text":"three ways cutting tree: Specify expected number clusters: can request specific number clusters (n_clust = 5 example). can also request multiple partitions, number clusters (n_clust = c(5, 10, 15)) example. Note: specify number clusters, function search associated height cut automatically; can disable parameter find_h = FALSE. search h value h_max (default 1) h_min (default 0). arguments can adjusted working indices whose values range 0 1. Specify height cut: can request height want cut tree (e.g., cut_height = 0.5). can also request multiple partitions, cut height (cut_height = c(0.4, 0.5, 0.6)) example. Use dynamic tree cut method: Rather cutting entire tree , alternative approach consists cutting individual branches different heights. method can requested using dynamic_tree_cut = TRUE, based dynamicTreeCut R package.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"divisive-clustering","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters","what":"2.4. Divisive clustering","title":"4.1 Hierarchical clustering","text":"Top-approach hierarchical clustering instead bottom-approach.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"optimaln","dir":"Articles","previous_headings":"","what":"3. How to find an optimal number of clusters?","title":"4.1 Hierarchical clustering","text":"Step 1. Build tree hclu_hierarclust() Step 2. Explore range partitions, minimum (e.g., starting 2 clusters) maximum (e.g. \\(n-1\\) clusters \\(n\\) number sites). Step 3. Calculate one several metrics partition, used basis evaluation plots. Step 4. Search one several optimal number(s) clusters using evaluation plots. Different criteria can applied identify optimal number(s) clusters. Step 5. Export optimal partitions cluster object.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"a-practical-example","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters?","what":"3.1 A practical example","title":"4.1 Hierarchical clustering","text":"example compute evaluation metric used Holt et al. (2013), compares total dissimilarity distance matrix (sum distances) inter-cluster dissimilarity (sum distances clusters). choose optimal number clusters elbow evaluation plot.   allergic lines code, also simply recut tree identified optimal number cut-offs cut_tree().","code":"data(vegemat)  # Calculate dissimilarities dissim <- dissimilarity(vegemat)  # Step 1 & 2. Compute the tree and cut it into many different partitions tree4 <- hclu_hierarclust(dissim,                           n_clust = 2:100) ## Randomizing the dissimilarity matrix with 30 trials ##  -- range of cophenetic correlation coefficients among ##                      trials: 0.64 - 0.71 ## Optimal tree has a 0.71 cophenetic correlation coefficient with the initial dissimilarity ##       matrix # Step 3. Calculate the same evaluation metric as Holt et al. 2013 eval_tree4 <- partition_metrics(tree4,                                  dissimilarity = dissim, # Provide distances to compute the metrics                                 eval_metric = \"pc_distance\") ## Computing similarity-based metrics... ##   - pc_distance OK # Step 4. Find the optimal number of clusters opti_n_tree4 <- find_optimal_n(eval_tree4) ## [1] \"pc_distance\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the elbow method ##    * elbow found at: ## pc_distance 14 ## Plotting results... opti_n_tree4 ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  elbow  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 14 # Step 5. Extract the optimal number of clusters # We get the name of the correct partition in the next line K_name <- opti_n_tree4$evaluation_df$K[opti_n_tree4$evaluation_df$optimal_n_pc_distance] # Look at the site-cluster table head(tree4$clusters[, c(\"ID\", K_name)]) ##        ID K_14 ## 1183 1183    1 ## 1082 1082    1 ## 1137 1137    1 ## 653   653    1 ## 474   474    1 ## 1425 1425    2 # Make a map of the clusters data(vegesf) library(sf) ## Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE map_clusters(tree4$clusters[, c(\"ID\", K_name)],              vegesf)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"evaluation-metrics","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters?","what":"3.2 Evaluation metrics","title":"4.1 Hierarchical clustering","text":"Currently, four evaluation metrics available package: pc_distance: \\(\\sum{-cluster\\beta_{sim }} / \\sum{\\beta_{sim}}\\) metric metric computed Holt et al. (2013). anosim: statistic used Analysis Similarities, suggested Castro-Insua et al. (2018). compares -cluster dissimilarities within-cluster dissimilarities. based difference mean ranks groups within groups following formula: \\(R=(r_B-r_W)/(N(N-1)/4)\\) \\(r_B\\) \\(r_W\\) average ranks within clusters respectively, \\(N\\) total number sites. avg_endemism: average percentage endemism clusters (Kreft & Jetz, 2010). calculated follows: \\(End_{mean} = \\frac{\\sum_{=1}^K E_i / S_i}{K}\\) \\(E_i\\) number endemic species cluster \\(\\), \\(S_i\\) number species cluster \\(\\), \\(K\\) maximum number clusters. tot_endemism: total endemism across clusters (Kreft & Jetz, 2010). calculated follows: \\(End_{tot} = E / C\\) \\(E\\) total number endemic species (.e., species occurring one cluster) \\(C\\) number non- endemic species. Important note able calculate pc_distance anosim, need provide dissimilarity object argument dissimilarity. addition, able calculate avg_endemism tot_endemism, need provide species-site network argument net. Let’s see practice. Depending size dataset, computing endemism-based metrics can take .","code":"# Calculate pc_distance and anosim partition_metrics(tree4,                    dissimilarity = dissim,                    eval_metric = c(\"pc_distance\", \"anosim\")) ## Computing similarity-based metrics... ##   - pc_distance OK ##   - anosim OK ## Partition metrics: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Requested metric(s):  pc_distance anosim  ##  - Metric summary: ##      pc_distance    anosim ## Min    0.4950446 0.7048271 ## Mean   0.8971639 0.8038243 ## Max    0.9803559 0.8643644 ##  ## Access the data.frame of metrics with your_object$evaluation_df # Calculate avg_endemism and tot_endemism # I have an abundance matrix, I need to convert it into network format first: vegenet <- mat_to_net(vegemat)  partition_metrics(tree4,                    net = vegenet,                    eval_metric = c(\"avg_endemism\", \"tot_endemism\")) ## Computing composition-based metrics... ##   - avg_endemism OK ##   - tot_endemism OK ## Partition metrics: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Requested metric(s):  avg_endemism tot_endemism  ##  - Metric summary: ##      avg_endemism tot_endemism ## Min   0.001135830   0.04895862 ## Mean  0.008153968   0.07917968 ## Max   0.190019862   0.32756289 ##  ## Access the data.frame of metrics with your_object$evaluation_df ## Details of endemism % for each partition are available in  ##         your_object$endemism_results"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"criteria-to-choose-an-optimal-number-of-clusters","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters?","what":"3.2 Criteria to choose an optimal number of clusters","title":"4.1 Hierarchical clustering","text":"Choosing optimal number clusters long-standing issue literature, absolute objective answer question. plethora methods proposed years, best approach tackle issue probably compare results multiple approaches make informed decision. bioregion package, implemented several methods specifically suited bioregionalization analysis. example, standard criterion used identifying optimal number clusters elbow method, default criterion find_optimal_n(). However, recommend moving beyond paradigm single optimal number clusters, likely oversimplification hierarchy tree. recommend considering multiple cuts tree, provide several methods : identifying large steps curve using multiple cutoffs. Additionally, implement approaches, using maximum minimum value metrics, , experimentally, using MARS (multiple adaptive regression splines) model identify cutoff points curve. look different methods, compute evaluation metrics store eval_tree4:","code":"vegenet <- mat_to_net(vegemat) eval_tree4 <- partition_metrics(tree4,                                  dissimilarity = dissim,                                  net = vegenet,                                  eval_metric = c(\"pc_distance\", \"anosim\",                                                 \"avg_endemism\", \"tot_endemism\")) ## Computing similarity-based metrics... ##   - pc_distance OK ##   - anosim OK ## Computing composition-based metrics... ##   - avg_endemism OK ##   - tot_endemism OK"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"elbow-method","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.1 Elbow method","title":"4.1 Hierarchical clustering","text":"elbow method consists find ‘elbow’ form metric-cluster relationship. method typically work metrics L-shaped form (typically, pc_distance endemism metrics), metrics (e.g. form anosim necessarily follow L-shape). rationale behind elbow method find cutoff metric values stop increasing significantly, adding new clusters provide much significant improvement metric. elbow method default method find_optimal_n(). parameters adjust . curve elbow-shaped, may give spurious results.   example , optimal number clusters varies depending metric, minimum 10 maximum 14. final choice depends metric preferences respect metrics, objectives clustering. Alternatively, two cut-offs used, deep cut-based endemism metrics e.g. value 10, shallow cutoff based pc_distance, 14.","code":"find_optimal_n(eval_tree4) ## [1] \"pc_distance\"  \"anosim\"       \"avg_endemism\" \"tot_endemism\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the elbow method ##    * elbow found at: ## pc_distance 14 ## anosim 14 ## avg_endemism 10 ## tot_endemism 14 ## Warning in find_optimal_n(eval_tree4): The elbow method is likely not suitable ## for the ANOSIM metric. You should rather look for leaps in the curve (see ## criterion = 'increasing_step' or decreasing_step) ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  pc_distance anosim avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  elbow  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 14 ## anosim - 14 ## avg_endemism - 10 ## tot_endemism - 14 ## [1] \"pc_distance\"  \"anosim\"       \"avg_endemism\" \"tot_endemism\""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"step-method","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.2 Step method","title":"4.1 Hierarchical clustering","text":"step method consists identifying largest “steps” metrics, .e., largest increases decreases value metric. , function calculates successive differences metrics partitions. keep largest positive differences (increasing_step) negative differences (decreasing_step). increasing_step increasing metrics (pc_distance) decreasing_step decreasing metrics (avg_endemism tot_endemism). anosim values can either increase decrease depending dataset, explore ways. default, function selects top 1% steps:   However, can adjust two different ways. First, choose number steps select, e.g. select largest 3 steps, use step_levels = 3:  Second, can set quantile steps select, e.g. select 5% largest steps set quantile 0.90 (step_quantile = 0.95):  Finally, question may arise cluster number select large step occurs. example, largest step occurs partitions 4 5 clusters, keep partition 4 clusters, partition 5 clusters? default, function keeps partition \\(N + 1\\) (5 clusters example ). can change setting step_round_above = FALSE:","code":"find_optimal_n(eval_tree4,                metrics_to_use = c(\"anosim\", \"pc_distance\"),                criterion = \"increasing_step\") ## [1] \"anosim\"      \"pc_distance\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the increasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  anosim pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  increasing_step  ##    (step quantile chosen:  0.99  (i.e., only the top 1 %  increase  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## anosim - 14 ## pc_distance - 10 find_optimal_n(eval_tree4,                metrics_to_use = c(\"avg_endemism\", \"tot_endemism\"),                criterion = \"decreasing_step\") ## [1] \"avg_endemism\" \"tot_endemism\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the decreasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  decreasing_step  ##    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## avg_endemism - 4 ## tot_endemism - 4 find_optimal_n(eval_tree4,                metrics_to_use = c(\"anosim\", \"pc_distance\"),                criterion = \"increasing_step\",                step_levels = 3) ## [1] \"anosim\"      \"pc_distance\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the increasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  anosim pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  increasing_step  ##    (step quantile chosen:  0.99  (i.e., only the top 1 %  increase  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## anosim - 10 14 93 ## pc_distance - 4 10 14 find_optimal_n(eval_tree4,                metrics_to_use = c(\"anosim\", \"pc_distance\"),                criterion = \"increasing_step\",                step_quantile = 0.95) ## [1] \"anosim\"      \"pc_distance\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the increasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  anosim pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  increasing_step  ##    (step quantile chosen:  0.95  (i.e., only the top 5 %  increase  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## anosim - 10 14 33 46 93 ## pc_distance - 3 4 10 14 33 find_optimal_n(eval_tree4,                metrics_to_use = c(\"avg_endemism\", \"tot_endemism\"),                criterion = \"decreasing_step\",                step_round_above = FALSE) ## [1] \"avg_endemism\" \"tot_endemism\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the decreasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  decreasing_step  ##    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## avg_endemism - 3 ## tot_endemism - 3"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"cutting-at-different-cut-off-values","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.3 Cutting at different cut-off values","title":"4.1 Hierarchical clustering","text":"idea method select specific metric values number clusters used. example, study, Holt et al. (2013) used different cutoffs pc_distance find global biogeographic regions: 0.90, 0.95, 0.99, 0.999. higher value, -diversity explained, also clusters . Therefore, choice trade-total -diversity explained number clusters. Eventually, choice values depends different factors: geographic scope study. global scale study can use large cutoffs like Holt et al. (2013) end reasonable number clusters, whereas regional local scale studies less endemism taxa shared among clusters, values high, cutoffs explored, 0.5 0.75. characteristics study increase decrease degree endemism among clusters: dispersal capacities taxonomic group, connectivity/barriers study area, etc. Use lower cutoffs large number widespread species, use higher cutoffs high degrees endemism. Using abundance phylogenetic data compute -diversity metrics may allow better distinguish clusters, turn allow use higher cutoffs. example, case, regional-scale study vegetation, can use three cutoffs: 0.6 (deep cutoff), 0.8 (intermediate cutoff), 0.9 (shallow cutoff).","code":"find_optimal_n(eval_tree4,                metrics_to_use = \"pc_distance\",                criterion = \"cutoff\",                metric_cutoffs = c(.6, .8, .9)) ## [1] \"pc_distance\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the cutoff method ##  - Cutoff method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  cutoff  ##    --> cutoff(s) chosen:  0.6 0.8 0.9  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 4 12 33"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"cutting-at-the-maximum-or-minimum-metric-value","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.4 Cutting at the maximum or minimum metric value","title":"4.1 Hierarchical clustering","text":"criterion finds maximum (criterion = \"max\") minimum (criterion = \"min\") value metric list partitions selects corresponding partition. criterion can interesting case anosim, probably much less useful metrics implemented package.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"finding-break-points-in-the-curve","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.5 Finding break points in the curve","title":"4.1 Hierarchical clustering","text":"criterion consists applying segmented regression model formula evaluation metric ~ number clusters. user can define number breaks identified curve. Note model likely require minimum number points find appropriate number clusters. example , make 100 cuts tree enough values.  can ask higher number breaks: 2 breaks  3 breaks  Increasing number breaks can useful situations , example, non-linear silhouettes metric ~ n clusters.","code":"tree5 <- cut_tree(tree4,                   cut_height = seq(0, 0.67, # We cut the tree 100 times from 0 to 0.67                                     length = 100)) # (0.67 is the maximum height of my tree here)  eval_tree5 <- partition_metrics(tree5,                                  dissimilarity = dissim,                                  net = vegenet,                                  eval_metric = c(\"pc_distance\", \"anosim\",                                                 \"avg_endemism\", \"tot_endemism\")) ## Computing similarity-based metrics... ##   - pc_distance OK ##   - anosim OK ## Computing composition-based metrics... ##   - avg_endemism OK ##   - tot_endemism OK find_optimal_n(eval_tree5,                criterion = \"breakpoints\") ## [1] \"pc_distance\"  \"anosim\"       \"avg_endemism\" \"tot_endemism\" ## Number of partitions: 100 ## Searching for potential optimal number(s) of clusters based on the breakpoints method ## Exact break point not in the list of partitions: finding the closest partition... ## Plotting results... ##    (the red line is the prediction from the segmented regression) ## Search for an optimal number of clusters: ##  - 100  partition(s) evaluated ##  - Range of clusters explored: from  2  to  701  ##  - Evaluated metric(s):  pc_distance anosim avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  breakpoints  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 16 ## anosim - 106 ## avg_endemism - 4 ## tot_endemism - 5 find_optimal_n(eval_tree5,                criterion = \"breakpoints\",                n_breakpoints = 2) ## [1] \"pc_distance\"  \"anosim\"       \"avg_endemism\" \"tot_endemism\" ## Number of partitions: 100 ## Searching for potential optimal number(s) of clusters based on the breakpoints method ## Exact break point not in the list of partitions: finding the closest partition... ## Plotting results... ##    (the red line is the prediction from the segmented regression) ## Search for an optimal number of clusters: ##  - 100  partition(s) evaluated ##  - Range of clusters explored: from  2  to  701  ##  - Evaluated metric(s):  pc_distance anosim avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  breakpoints  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 13 85 ## anosim - 21 149 ## avg_endemism - 4 21 ## tot_endemism - 4 95 find_optimal_n(eval_tree5,                criterion = \"breakpoints\",                n_breakpoints = 3) ## [1] \"pc_distance\"  \"anosim\"       \"avg_endemism\" \"tot_endemism\" ## Number of partitions: 100 ## Searching for potential optimal number(s) of clusters based on the breakpoints method ## Exact break point not in the list of partitions: finding the closest partition... ## Plotting results... ##    (the red line is the prediction from the segmented regression) ## Search for an optimal number of clusters: ##  - 100  partition(s) evaluated ##  - Range of clusters explored: from  2  to  701  ##  - Evaluated metric(s):  pc_distance anosim avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  breakpoints  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 12 46 119 ## anosim - 21 136 602 ## avg_endemism - 4 13 52 ## tot_endemism - 4 16 126"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"optics-as-a-semi-hierarchical-clustering-approach","dir":"Articles","previous_headings":"","what":"4. OPTICS as a semi-hierarchical clustering approach","title":"4.1 Hierarchical clustering","text":"OPTICS (Ordering Points Identify Clustering Structure) semi-hierarchical clustering approach orders points datasets closest points become neighbors, calculates ‘reachability’ distance point, extracts clusters reachability distance hierarchical manner. However, hierarchical nature clusters directly provided algorithm tree-like output. Hence, users explore ‘reachability plot’ understand hierarchical nature OPTICS clusters, read related publication understand method (Hahsler et al., 2019). run optics algorithm, use hclu_optics() function:","code":"data(vegemat)  # Calculate dissimilarities dissim <- dissimilarity(vegemat)  clust1 <- hclu_optics(dissim)  clust1 ## Clustering results for algorithm : optics  ##  - Number of sites:  715  ## Clustering results: ##  - Number of partitions:  1  ##  - Number of clusters:  9"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"dissimilarity-indices","dir":"Articles","previous_headings":"","what":"1. Dissimilarity indices","title":"4.2 Non-hierarchical clustering","text":"Pairwise distances sites can obtained running dissimilarity() site-species matrix. example , use fish dataset package compute distance metrics. going compute \\(\\beta_{sim}\\) diversity metric, presence-absence dissimilarity index. formula follows:\\(\\beta_{sim} = min(b, c) / (+min(b, c))\\) number species shared sites; b number species occurring first site; c number species occurring second site. typically choose metric bioregionalisation, turnover component Sorensen index (Baselga, 2012) (nutshell, tells us sites different distinct species), less dependence species richness Jaccard turnover (Leprieur & Oikonomou, 2014).  choice distance metric important outcome clustering procedure, recommend choose carefully depending research question. default, Simpson index computed, options available metric argument dissimilarity(). Furthermore, users can also write formula compute index wish argument formula, see ?dissimilarity(). now ready start non-hierarchical clustering procedure object dissim just created. Alternatively, can also use types objects distance matrix object (class dist) data.frame crafting (make sure read required format carefully explained help function).","code":"library(bioregion) data(fishmat)  # It is a presence/absence matrix with sites in rows and species in columns fishmat[1:3, 1:3] ##          Abramis brama Alburnus alburnus Barbatula barbatula ## Aa                   1                 1                   1 ## Abula                0                 0                   0 ## Acheloos             0                 0                   0 dissim <- dissimilarity(fishmat, metric = \"Simpson\")  dissim[1:3, ] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  338  ##  - Total number of species:  195  ##  - Number of rows:  56953  ##  - Number of dissimilarity metrics:  1  ##  ##  ##   Site1    Site2   Simpson ## 2    Aa    Abula 0.3333333 ## 3    Aa Acheloos 1.0000000 ## 4    Aa    Adige 0.7692308"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"centroid-based-clustering","dir":"Articles","previous_headings":"","what":"2. Centroid-based clustering","title":"4.2 Non-hierarchical clustering","text":"core idea algorithms place points cluster central-point closest. central-point can either centroid cluster, .e. mean x y coordinates points belonging cluster, medoid. medoid centrally located data point cluster, words least dissimilar point points cluster. objective minimize sum squared distances points assigned centroids/medoids.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"kmeans","dir":"Articles","previous_headings":"2. Centroid-based clustering","what":"2.1. Kmeans","title":"4.2 Non-hierarchical clustering","text":"K-means clustering perhaps famous method non-hierarchical clustering. uses centroids clusters. algorithm usually follows iterative framework : initialization step creates k centroids random placements. every point, Euclidean distance centroids calculated. point assigned nearest centroid. points assigned centroid form cluster. clusters formed, new centroids cluster calculated taking mean x y coordinates points belonging cluster. re-assignment step calculates new centroids based membership cluster. Steps 2 3 repeated solution converges, .e. centroid positions longer change. Finding optimal solution K-means computationally intensive implementation rely efficient heuristic algorithms quickly converge local optimum. Side-note k-means algorithm can become ‘stuck’ local optima. Repeating clustering algorithm adding noise data can help evaluate robustness solution. function compute K-means clustering bioregion nhclu_kmeans(). illustrate functions works example applied dissimilarity matrix calculated . chose 3 clusters. steps come arguments can tweaked. Specifically, iter_max determines maximum number iterations allowed (.e. many times steps described run) nstart specifies many random sets n_clust selected starting points.  Several heuristic algorithms can also used along K-means method can parameterized using algorithm argument. default, algorithm Hartigan-Wong (Hartigan & Wong (1979)) used. Let’s start setting iter_max nstart 1. asking one iteration , function displays message saying algorithm converge. therefore need increase value iter_max. Like functions bioregion package, class object specific package (bioregion.clusters) contains several parts. clusters assigned site accessible $clusters part output: , see 34 sites assigned cluster 1, 237 cluster 2 67 cluster 3. assignment can change depending two main arguments functions, iter_max nstart. shown , distribution sites among three clusters appears quite homogeneous three examples discrepancies emerge. Overall, increasing iter_max nstart increases chances convergence algorithm also increases computation time.","code":"ex_kmeans <- nhclu_kmeans(dissim, index = \"Simpson\", n_clust = 3, iter_max = 1,                           nstart = 1, algorithm = \"Hartigan-Wong\") ex_kmeans <- nhclu_kmeans(dissim, index = \"Simpson\", n_clust = 3, iter_max = 3,                           nstart = 1, algorithm = \"Hartigan-Wong\") ex_kmeans$clusters[1:3, ] ##                ID K_3 ## Aa             Aa   2 ## Abula       Abula   2 ## Acheloos Acheloos   3 table(ex_kmeans$clusters$K_3) ##  ##   1   2   3  ##  34 237  67 ex_kmeans2 <- nhclu_kmeans(dissim, index = \"Simpson\", n_clust = 3,                            iter_max = 100, nstart = 1,                            algorithm = \"Hartigan-Wong\")  ex_kmeans3 <- nhclu_kmeans(dissim, index = \"Simpson\", n_clust = 3,                            iter_max = 3, nstart = 100,                            algorithm = \"Hartigan-Wong\") table(ex_kmeans$clusters$K_3, ex_kmeans2$clusters$K_3) ##     ##       1   2   3 ##   1   0  20  14 ##   2 111 126   0 ##   3   0   0  67 table(ex_kmeans$clusters$K_3, ex_kmeans3$clusters$K_3) ##     ##       1   2   3 ##   1  28   6   0 ##   2   1 125 111 ##   3  67   0   0"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"section22","dir":"Articles","previous_headings":"2. Centroid-based clustering","what":"2.2. K-medoids","title":"4.2 Non-hierarchical clustering","text":"Instead using mean cluster, medoid can also used partition data points. comparison centroid used K-means, medoid less sensitive outliers data. partitions can also use types distances rely Euclidean distance . Several heuristics exist solve K-medoids problem, famous ones Partition Around Medoids (PAM), extensions CLARA CLARANS.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"partitioning-around-medoids-pam","dir":"Articles","previous_headings":"2. Centroid-based clustering > 2.2. K-medoids","what":"2.2.1. Partitioning Around Medoids (PAM)","title":"4.2 Non-hierarchical clustering","text":"PAM fast heuristic find solution k-medoids problem. k clusters, decomposes following steps:  1. Randomly pick k points initial medoids Assign point nearest medoid x Calculate objective function (sum dissimilarities points nearest medoids) Randomly select point y Swap x y swap reduces objective function Repeat 3-6 change nhclu_pam() function, several arguments tweak. number clusters n_clust defined well number starting positions medoids nstart. Several variants PAM algorithm available can changed argument variant (see cluster::pam() details). 2 clusters, see 258 sites assigned cluster 1 80 cluster 2.","code":"ex_pam <- nhclu_pam(dissim, index = \"Simpson\", n_clust = 2:25, nstart = 1,                     variant = \"faster\", cluster_only = FALSE) table(ex_pam$clusters$K_2) ##  ##   1   2  ## 258  80"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"clustering-large-applications-clara","dir":"Articles","previous_headings":"2. Centroid-based clustering > 2.2. K-medoids","what":"2.2.2. Clustering Large Applications (CLARA)","title":"4.2 Non-hierarchical clustering","text":"CLARA (Clustering Large Applications, (Kaufman Rousseeuw 1990)) extension k-medoids (PAM) methods deal data containing large number objects (several thousand observations) order reduce computational time RAM storage problem. achieved using sampling approach.","code":"ex_clara <- nhclu_clara(dissim, index = \"Simpson\",                         n_clust = 5,                         maxiter = 0L, initializer = \"LAB\", fasttol = 1,                         numsamples = 5L, sampling = 0.25, independent = FALSE,                         seed = 123456789L) table(ex_clara$clusters$K_5) ##  ##   1   2   3   4   5  ## 241  21  16  50  10"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"clustering-large-applications-based-on-randomized-search-clarans","dir":"Articles","previous_headings":"2. Centroid-based clustering > 2.2. K-medoids","what":"2.2.3. Clustering Large Applications based on RANdomized Search (CLARANS)","title":"4.2 Non-hierarchical clustering","text":"CLARANS (Clustering Large Applications based RANdomized Search, (Ng Han 2002)) extension k-medoids (PAM) methods combined CLARA algorithm.","code":"ex_clarans <- nhclu_clarans(dissim, index = \"Simpson\",                         n_clust = 5,                         numlocal = 2L, maxneighbor = 0.025,                         seed = 123456789L) table(ex_clara$clusters$K_5) ##  ##   1   2   3   4   5  ## 241  21  16  50  10"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"density-based-clustering","dir":"Articles","previous_headings":"","what":"3. Density-based clustering","title":"4.2 Non-hierarchical clustering","text":"Density-based clustering another type non-hierarchical clustering. connects areas high density clusters. allows arbitrary-shaped distributions long dense areas can connected. algorithms can however difficulty data varying densities high dimensions.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"dbscan","dir":"Articles","previous_headings":"3. Density-based clustering","what":"3.1. DBSCAN","title":"4.2 Non-hierarchical clustering","text":"Density-based Spatial Clustering Applications Noise (DBSCAN) (Hahsler et al. (2019)) famous density-based clustering approach.  operates locating points dataset surrounded significant number points. points regarded part dense zone, algorithm next attempt extend region encompass cluster’s points. DBSCAN uses two following parameters: Epsilon (eps): maximum distance two points considered neighboring points (belonging cluster). Minimum Points (minPts): minimum number neighboring points given point needs considered core data point. includes point . example, minimum number points set 4, given point needs 3 neighboring data points considered core data point. minimum number points meet epsilon distance requirement considered cluster. set two parameters, algorithm works like : Decide value eps minPts. point: Calculate distance points. distance less equal eps mark point neighbor x. point gets neighboring count greater equal minPts, mark core point visited. core point, already assigned cluster create new cluster. Recursively find neighboring points assign cluster core point. Continue steps unvisited points covered. algorithm can called function nhclu_dbscan(). user define two arguments presented , minPts eps, function provide knee curve helping search optimal eps value.  , see can set eps 1. set parameters, get one cluster. decrease eps value increase minPts, can get clusters.","code":"ex_dbscan <- nhclu_dbscan(dissim, index = \"Simpson\", minPts = NULL, eps = NULL,                           plot = TRUE) ## Trying to find a knee in the curve to search for an optimal eps value... ##        NOTE: this automatic identification of the knee may not work properly ##        if the curve has knees and elbows. Please adjust eps manually by ##        inspecting the curve, identifying a knee as follows: ##  ##                            / ##                  curve    / ##               ___________/  <- knee ##   elbow ->   / ##             / ##            / ex_dbscan2 <- nhclu_dbscan(dissim, index = \"Simpson\", minPts = NULL, eps = 1,                            plot = FALSE) table(ex_dbscan2$clusters$K_1) ##  ##   1  ## 338 ex_dbscan3 <- nhclu_dbscan(dissim, index = \"Simpson\", minPts = 4, eps = 0.5,                            plot = FALSE)  table(ex_dbscan3$clusters$K_2) ##  ##   0   1  ##   4 334"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"section4","dir":"Articles","previous_headings":"","what":"4. Optimal number of clusters","title":"4.2 Non-hierarchical clustering","text":"Previous methods help determining optimal number bioregions structuring site-species matrix. purpose, can combine functions partition_metrics() find_optimal(). partition_metrics() calcultes several metrics based previous clustering attempts. *Note two metrics tot_endemism avg_endemism, also need provide site-species matrix. partition_metrics() function calculated partitioning metrics, can call find_optimal() get optimal number clusters.  Based metric selected, optimal number clusters can vary.","code":"partition_metrics(ex_pam, dissimilarity = dissim,                   eval_metric = \"pc_distance\") ## Partition metrics: ##  - 24  partition(s) evaluated ##  - Range of clusters explored: from  2  to  25  ##  - Requested metric(s):  pc_distance  ##  - Metric summary: ##      pc_distance ## Min    0.5464742 ## Mean   0.7986754 ## Max    0.8816465 ##  ## Access the data.frame of metrics with your_object$evaluation_df a <- partition_metrics(ex_pam, dissimilarity = dissim, net = fishdf,                        species_col = \"Species\", site_col = \"Site\",                        eval_metric = c(\"tot_endemism\", \"avg_endemism\",                                        \"pc_distance\", \"anosim\")) find_optimal_n(a) ## [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\" ## Number of partitions: 24 ## Searching for potential optimal number(s) of clusters based on the elbow method ##    * elbow found at: ## tot_endemism 4 ## avg_endemism 4 ## pc_distance 7 ## anosim 3 ## Plotting results... ## Search for an optimal number of clusters: ##  - 24  partition(s) evaluated ##  - Range of clusters explored: from  2  to  25  ##  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  elbow  ##  - Optimal partition(s) of clusters for each metric: ## tot_endemism - 4 ## avg_endemism - 4 ## pc_distance - 7 ## anosim - 3"},{"path":[]},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"input-data","dir":"Articles","previous_headings":"Introduction","what":"Input data","title":"4.3 Network clustering","text":"network algorithms work network format, .e. data.frame 3 columns: sites, species abundance given species given site. type object can obtained site x species matrix use mat_to_net(). vignette, directly load network format distribution fish European basins. network algorithms work similarity matrix pair sites.","code":"library(\"bioregion\") data(\"fishdf\") data(\"fishmat\") fish_simil <- similarity(fishmat, metric = \"Simpson\")"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"main-arguments","dir":"Articles","previous_headings":"Introduction","what":"Main arguments","title":"4.3 Network clustering","text":"algorithms presented specific parameters can tweaked arguments common functions. Among common arguments following: * weight boolean indicating weights considered * index name number column use weight. default, third column name network data.frame used * site_col name number column site nodes (.e. primary nodes). * species_col = name number column species nodes (.e. feature nodes) * return_node_type character indicating types nodes (“sites”, “species” “”) returned output (keep_nodes_type=“” default). * algorithm_in_output boolean indicating original output communities returned output (see Value). three algorithms relying executable binary files, following arguments needed: * delete_temp boolean indicating temporary folder removed * path_temp character indicating path temporary folder * binpath character indicating path bin folder","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"binary-files","dir":"Articles","previous_headings":"","what":"Binary files","title":"4.3 Network clustering","text":"","code":"install_binaries(binpath = \"tempdir\", infomap_version = c(\"2.1.0\", \"2.6.0\"))"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"infomap","dir":"Articles","previous_headings":"Binary files","what":"Infomap","title":"4.3 Network clustering","text":"Rosvall & Bergstrom (2008) nbmod penalize solutions differ number (0 default preferred number modules). markovtime scales link flow change cost moving modules, higher values results fewer modules (default 1). seed random number generator (0 random default) numtrials number trials picking best solution. twolevel boolean indicating algorithm optimize two-level partition network (default multi-level). show_hierarchy boolean specifying hierarchy community identifiable outputs (FALSE default).","code":"set.seed(1) ex_infomap <- netclu_infomap(fish_simil,                              weight = TRUE,                              index = names(fish_simil)[3],                              nbmod = 0,                              markovtime = 1,                              seed = 0,                              numtrials = 1,                              twolevel = FALSE,                              show_hierarchy = FALSE,                              directed = FALSE,                              bipartite_version = FALSE,                              bipartite = FALSE,                              site_col = 1,                              species_col = 2,                              return_node_type = \"both\",                              version = \"2.6.0\",                              binpath = \"tempdir\",                              path_temp = \"infomap_temp\",                              delete_temp = TRUE)  table(ex_infomap$clusters$K_5) ##  ##   1   2   3   4   5  ## 290  23  14   9   2"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"oslom","dir":"Articles","previous_headings":"Binary files","what":"OSLOM","title":"4.3 Network clustering","text":"OSLOM stands Order Statistics Local Optimization Method. Similarity-based algorithm. Lancichinetti et al. (2011) reassign string indicating nodes belonging several community reassign method used (see Note). * r number runs first hierarchical level (10 default). * hr number runs higher hierarchical level (50 default, 0 interested hierarchies). * seed random number generator (0 random default). * t p−value, default value 0.10, increase value get modules. * cp kind resolution parameter used decide taking modules union (default value 0.5, bigger value leads bigger clusters).","code":"set.seed(1) ex_oslom <- netclu_oslom(fish_simil,                          weight = TRUE,                          index = names(fish_simil)[3],                          reassign = \"no\",                          r = 10,                          hr = 50,                          seed = 0,                          t = 0.1,                          cp = 0.5,                          directed = FALSE,                          bipartite = FALSE,                          site_col = 1,                          species_col = 2,                          return_node_type = \"both\",                          binpath = \"tempdir\",                          path_temp = \"oslom_temp\",                          delete_temp = TRUE)  table(ex_oslom$clusters$K_338)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"louvain","dir":"Articles","previous_headings":"Binary files","what":"Louvain","title":"4.3 Network clustering","text":"Blondel et al. (2008) q quality function used compute partition graph (modularity chosen default, see Details). c parameter Owsinski-Zadrozny quality function (0 1, 0.5 chosen default) k kappa_min value Shi-Malik quality function (must > 0, 1 chosen default)","code":"set.seed(1) ex_louvain <- netclu_louvain(fishdf,                              weight = TRUE,                              index = names(fishdf)[3],                              lang = \"Cpp\",                              q = 0,                              c = 0.5,                              k = 1,                              bipartite = FALSE,                              site_col = 1,                              species_col = 2,                              return_node_type = \"both\",                              binpath = \"tempdir\",                              path_temp = \"louvain_temp\",                              delete_temp = TRUE,                              algorithm_in_output = TRUE) table(ex_louvain$clusters$K_23) ## < table of extent 0 >"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"fastgreedy","dir":"Articles","previous_headings":"Functions from the igraph package","what":"Fastgreedy","title":"4.3 Network clustering","text":"Clauset et al. (2004)","code":"set.seed(1) ex_greedy <- netclu_greedy(fishdf,                            weight = TRUE,                            index = names(fishdf)[3],                            bipartite = FALSE,                            site_col = 1,                            species_col = 2,                            return_node_type = \"both\",                            algorithm_in_output = TRUE) table(ex_greedy$clusters$K_5) ##  ##   1   2   3   4   5  ## 138  61 144 132  58"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"label-propagation","dir":"Articles","previous_headings":"Functions from the igraph package","what":"Label propagation","title":"4.3 Network clustering","text":"Raghavan et al. (2007)","code":"set.seed(1) ex_labelprop <- netclu_labelprop(fishdf,                                  weight = TRUE,                                  index = names(fishdf)[3],                                  bipartite = FALSE,                                  site_col = 1,                                  species_col = 2,                                  return_node_type = \"both\",                                  algorithm_in_output = TRUE) table(ex_labelprop$clusters$K_11) ##  ##   1  10  11   2   3   4   5   6   7   8   9  ## 369   3  10  26  47  29   4  17  18   6   4"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"leiden-algorithm","dir":"Articles","previous_headings":"Functions from the igraph package","what":"Leiden algorithm","title":"4.3 Network clustering","text":"Traag et al. (2019)","code":"set.seed(1) ex_leiden <- netclu_leiden(fishdf,                            weight = TRUE,                            index = names(fishdf)[3],                            objective_function = c(\"CPM\", \"modularity\"),                            resolution_parameter = 1,                            beta = 0.01,                            initial_membership = NULL,                            n_iterations = 2,                            vertex_weights = NULL,                            bipartite = TRUE,                            site_col = 1,                            species_col = 2,                            return_node_type = \"both\",                            algorithm_in_output = TRUE) length(unique(ex_leiden$clusters$K_505)) ## [1] 0"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"leading-eigenvector","dir":"Articles","previous_headings":"Functions from the igraph package","what":"Leading eigenvector","title":"4.3 Network clustering","text":"Newman (2006)","code":"set.seed(1) ex_leadingeigen <- netclu_leadingeigen(fishdf,                                        weight = TRUE,                                        index = names(fishdf)[3],                                        bipartite = FALSE,                                        site_col = 1,                                        species_col = 2,                                        return_node_type = \"both\",                                        algorithm_in_output = TRUE) table(ex_leadingeigen$clusters$K_17) ##  ##   1  10  11  12  13  14  15  16  17   2   3   4   5   6   7   8   9  ## 108   2   2   2   1   1   2   1   1 136  81  69  34  22  28   1  42"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"walktrap","dir":"Articles","previous_headings":"Functions from the igraph package","what":"Walktrap","title":"4.3 Network clustering","text":"Pons & Latapy (2005)","code":"set.seed(1) ex_walktrap <- netclu_walktrap(fishdf,                                weight = TRUE,                                index = names(fishdf)[3],                                steps = 4,                                bipartite = FALSE,                                site_col = 1,                                species_col = 2,                                return_node_type = \"both\",                                algorithm_in_output = TRUE) table(ex_walktrap$clusters$K_14) ##  ##   1  10  11  12  13  14   2   3   4   5   6   7   8   9  ##  11  47  10   2   6  17  84   5  37  16   5 270   4  19"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"beckett","dir":"Articles","previous_headings":"Function from the bipartite package","what":"Beckett","title":"4.3 Network clustering","text":"Update QuanBiMo algorithm developed Dormann & Strauss (2014). Beckett (2016)","code":"set.seed(1) ex_beckett <- netclu_beckett(fishdf,                              weight = TRUE,                              index = names(fishdf)[3],                              site_col = 1,                              species_col = 2,                              return_node_type = \"both\",                              forceLPA = TRUE,                              algorithm_in_output = TRUE) ex_beckett$clusters$K_23 ##   [1] \"4\"  \"1\"  \"2\"  \"3\"  \"4\"  \"4\"  \"3\"  \"3\"  \"16\" \"13\" \"1\"  \"1\"  \"8\"  \"1\"  \"16\" ##  [16] \"5\"  \"4\"  \"3\"  \"4\"  \"8\"  \"4\"  \"1\"  \"4\"  \"4\"  \"5\"  \"4\"  \"4\"  \"1\"  \"13\" \"1\"  ##  [31] \"4\"  \"3\"  \"1\"  \"3\"  \"4\"  \"4\"  \"4\"  \"4\"  \"3\"  \"3\"  \"4\"  \"3\"  \"1\"  \"5\"  \"3\"  ##  [46] \"3\"  \"6\"  \"4\"  \"3\"  \"4\"  \"1\"  \"4\"  \"1\"  \"4\"  \"4\"  \"4\"  \"7\"  \"8\"  \"4\"  \"9\"  ##  [61] \"4\"  \"4\"  \"4\"  \"4\"  \"10\" \"10\" \"1\"  \"4\"  \"5\"  \"1\"  \"5\"  \"4\"  \"8\"  \"8\"  \"4\"  ##  [76] \"1\"  \"3\"  \"1\"  \"16\" \"13\" \"12\" \"1\"  \"22\" \"4\"  \"3\"  \"1\"  \"3\"  \"1\"  \"13\" \"4\"  ##  [91] \"4\"  \"8\"  \"4\"  \"8\"  \"15\" \"15\" \"15\" \"15\" \"4\"  \"1\"  \"8\"  \"4\"  \"1\"  \"8\"  \"4\"  ## [106] \"8\"  \"4\"  \"1\"  \"1\"  \"4\"  \"1\"  \"15\" \"1\"  \"1\"  \"5\"  \"1\"  \"16\" \"8\"  \"1\"  \"1\"  ## [121] \"1\"  \"13\" \"1\"  \"8\"  \"1\"  \"8\"  \"17\" \"18\" \"1\"  \"1\"  \"1\"  \"8\"  \"1\"  \"19\" \"1\"  ## [136] \"1\"  \"8\"  \"4\"  \"4\"  \"4\"  \"4\"  \"5\"  \"4\"  \"1\"  \"1\"  \"1\"  \"4\"  \"4\"  \"5\"  \"5\"  ## [151] \"3\"  \"8\"  \"1\"  \"11\" \"1\"  \"4\"  \"1\"  \"1\"  \"1\"  \"1\"  \"13\" \"16\" \"4\"  \"1\"  \"1\"  ## [166] \"1\"  \"1\"  \"1\"  \"1\"  \"3\"  \"8\"  \"5\"  \"5\"  \"20\" \"5\"  \"4\"  \"3\"  \"1\"  \"4\"  \"1\"  ## [181] \"4\"  \"1\"  \"6\"  \"1\"  \"13\" \"3\"  \"8\"  \"8\"  \"4\"  \"3\"  \"1\"  \"8\"  \"1\"  \"4\"  \"8\"  ## [196] \"1\"  \"3\"  \"4\"  \"1\"  \"4\"  \"8\"  \"4\"  \"1\"  \"1\"  \"4\"  \"1\"  \"16\" \"1\"  \"4\"  \"8\"  ## [211] \"1\"  \"3\"  \"15\" \"1\"  \"1\"  \"16\" \"13\" \"1\"  \"3\"  \"1\"  \"1\"  \"1\"  \"3\"  \"1\"  \"21\" ## [226] \"1\"  \"4\"  \"1\"  \"1\"  \"1\"  \"1\"  \"1\"  \"4\"  \"1\"  \"1\"  \"1\"  \"8\"  \"4\"  \"4\"  \"4\"  ## [241] \"1\"  \"22\" \"1\"  \"1\"  \"1\"  \"4\"  \"1\"  \"5\"  \"1\"  \"4\"  \"1\"  \"1\"  \"1\"  \"8\"  \"15\" ## [256] \"4\"  \"1\"  \"4\"  \"4\"  \"1\"  \"4\"  \"4\"  \"4\"  \"8\"  \"3\"  \"4\"  \"8\"  \"3\"  \"4\"  \"1\"  ## [271] \"1\"  \"13\" \"1\"  \"4\"  \"22\" \"1\"  \"1\"  \"3\"  \"3\"  \"5\"  \"5\"  \"4\"  \"4\"  \"1\"  \"4\"  ## [286] \"4\"  \"4\"  \"4\"  \"3\"  \"11\" \"4\"  \"3\"  \"4\"  \"1\"  \"1\"  \"1\"  \"1\"  \"8\"  \"4\"  \"4\"  ## [301] \"4\"  \"4\"  \"3\"  \"1\"  \"5\"  \"1\"  \"1\"  \"4\"  \"5\"  \"8\"  \"1\"  \"1\"  \"1\"  \"1\"  \"1\"  ## [316] \"5\"  \"1\"  \"4\"  \"1\"  \"1\"  \"14\" \"10\" \"8\"  \"4\"  \"1\"  \"4\"  \"4\"  \"4\"  \"4\"  \"3\"  ## [331] \"1\"  \"1\"  \"5\"  \"4\"  \"8\"  \"8\"  \"4\"  \"23\" \"4\"  \"4\"  \"4\"  \"8\"  \"8\"  \"1\"  \"4\"  ## [346] \"4\"  \"4\"  \"13\" \"1\"  \"4\"  \"4\"  \"1\"  \"16\" \"16\" \"2\"  \"16\" \"2\"  \"2\"  \"2\"  \"16\" ## [361] \"2\"  \"16\" \"3\"  \"4\"  \"3\"  \"3\"  \"3\"  \"3\"  \"3\"  \"3\"  \"3\"  \"3\"  \"4\"  \"5\"  \"4\"  ## [376] \"4\"  \"3\"  \"3\"  \"12\" \"16\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" ## [391] \"13\" \"13\" \"13\" \"8\"  \"8\"  \"16\" \"16\" \"5\"  \"20\" \"15\" \"5\"  \"5\"  \"4\"  \"3\"  \"3\"  ## [406] \"8\"  \"15\" \"5\"  \"5\"  \"5\"  \"5\"  \"5\"  \"5\"  \"13\" \"8\"  \"13\" \"9\"  \"3\"  \"3\"  \"3\"  ## [421] \"5\"  \"6\"  \"19\" \"6\"  \"6\"  \"7\"  \"7\"  \"7\"  \"7\"  \"7\"  \"8\"  \"7\"  \"7\"  \"7\"  \"7\"  ## [436] \"21\" \"21\" \"7\"  \"21\" \"7\"  \"7\"  \"7\"  \"7\"  \"7\"  \"7\"  \"8\"  \"10\" \"8\"  \"10\" \"9\"  ## [451] \"9\"  \"9\"  \"9\"  \"10\" \"9\"  \"9\"  \"8\"  \"10\" \"22\" \"9\"  \"9\"  \"9\"  \"10\" \"9\"  \"8\"  ## [466] \"10\" \"9\"  \"9\"  \"4\"  \"10\" \"10\" \"8\"  \"10\" \"10\" \"15\" \"5\"  \"5\"  \"11\" \"11\" \"15\" ## [481] \"13\" \"13\" \"22\" \"22\" \"13\" \"22\" \"12\" \"12\" \"22\" \"13\" \"13\" \"15\" \"15\" \"14\" \"15\" ## [496] \"15\" \"15\" \"15\" \"15\" \"5\"  \"16\" \"17\" \"18\" \"18\" \"18\" \"18\" \"23\" \"19\" \"19\" \"13\" ## [511] \"20\" \"13\" \"22\" \"13\" \"13\" \"13\" \"3\"  \"21\" \"21\" \"21\" \"21\" \"21\" \"21\" \"4\"  \"22\" ## [526] \"22\" \"5\"  \"22\" \"22\" \"22\" \"5\"  \"10\" \"23\""},{"path":[]},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_4_microbenchmark.html","id":"vegemat","dir":"Articles","previous_headings":"1. Datasets","what":"1.1. Vegemat","title":"4.4 Microbenchmark","text":"first dataset comes available bioregion analyzed article. contains abundance 3,697 plant species distributed 715 sites French Mediterranean area. dataset use two following files: vegedf data.frame 460,878 rows 3 columns (Site, Species Abundance) vegemat co-occurrence matrix containing information gathered matrix 715 rows 3,697 columns.","code":"data(vegedf) data(vegemat)  vegemat_dissim <- dissimilarity(vegemat,  metric = c(\"abc\", \"Simpson\")) vegemat_df <- mat_to_net(vegemat, weight = TRUE, remove_zeroes = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_4_microbenchmark.html","id":"european-fish","dir":"Articles","previous_headings":"1. Datasets","what":"1.2. European fish","title":"4.4 Microbenchmark","text":"second dataset also comes available bioregion contains distribution 195 freshwater fish distributed basins Europe.","code":"data(fishmat) fishdissim <- dissimilarity(fishmat, metric = \"all\") data(fishdf)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_4_microbenchmark.html","id":"aravo","dir":"Articles","previous_headings":"1. Datasets","what":"1.3. Aravo","title":"4.4 Microbenchmark","text":"third dataset, called aravo, retrieved package ade4. contains distribution 82 alpine plants 75 sites distributed French Alps.","code":"data(aravo) aravo <- as.matrix(aravo$spe) dim(aravo) ## [1] 75 82 ara_dissim <- dissimilarity(aravo, metric = \"all\")  ara_df <- mat_to_net(aravo, weight = TRUE, remove_zeroes = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_4_microbenchmark.html","id":"microbenchmark","dir":"Articles","previous_headings":"","what":"2. Microbenchmark","title":"4.4 Microbenchmark","text":"assessing time needed clustering algorithm three datasets loaded . Plotting results.   OSLOM Beckett slow, ran far Vegetation data.","code":"install_binaries()  mbm <- suppressMessages(   microbenchmark(     # aravo     ara_nhclu_dbscan = nhclu_dbscan(dissimilarity = ara_dissim,                                     index = \"Simpson\", plot = FALSE),     ara_nhclu_kmeans = nhclu_kmeans(ara_dissim, n_clust = 2:10,                                     index = \"Simpson\"),     ara_nhclu_pam = nhclu_pam(ara_dissim, n_clust = 2:10, index = \"Simpson\"),     ara_hclu_hierarclust = hclu_hierarclust(dissimilarity = ara_dissim,                                             n_clust = 5),     ara_hclu_optics = hclu_optics(ara_dissim, index = \"Simpson\"),     ara_netclu_beckett = netclu_beckett(ara_df),     ara_netclu_greedy = netclu_greedy(ara_df),     ara_netclu_labelprop = netclu_labelprop(ara_df),     ara_netclu_leadingeigen = netclu_leadingeigen(ara_df),     ara_netclu_oslom = netclu_oslom(ara_df),     ara_netclu_walktrap = netclu_walktrap(ara_df),     ara_netclu_infomap = netclu_infomap(ara_df),     ara_netclu_louvain = netclu_louvain(ara_df),          # fish vertebrates     fish_nhclu_dbscan = nhclu_dbscan(dissimilarity = fishdissim,                                      index = \"Simpson\", plot = FALSE),     fish_nhclu_kmeans = nhclu_kmeans(fishdissim, n_clust = 2:10,                                      index = \"Simpson\"),     fish_nhclu_pam = nhclu_pam(fishdissim, n_clust = 2:10, index = \"Simpson\"),     fish_hclu_hierarclust = hclu_hierarclust(dissimilarity = fishdissim,                                              n_clust = 5),     fish_hclu_optics = hclu_optics(fishdissim, index = \"Simpson\"),     fish_netclu_beckett = netclu_beckett(fishdf),     fish_netclu_greedy = netclu_greedy(fishdf),     fish_netclu_labelprop = netclu_labelprop(fishdf),     fish_netclu_leadingeigen = netclu_leadingeigen(fishdf),     fish_netclu_oslom = netclu_oslom(fishdf),     fish_netclu_walktrap = netclu_walktrap(fishdf),     fish_netclu_infomap = netclu_infomap(fishdf),     fish_netclu_louvain = netclu_louvain(fishdf),          # vegetation     veg_nhclu_dbscan = nhclu_dbscan(dissimilarity = vegemat_dissim,                                     index = \"Simpson\", plot = FALSE),     veg_nhclu_kmeans = nhclu_kmeans(vegemat_dissim, n_clust = 2:10,                                     index = \"Simpson\"),     veg_nhclu_pam = nhclu_pam(vegemat_dissim, n_clust = 2:10,                               index = \"Simpson\"),     veg_hclu_hierarclust = hclu_hierarclust(dissimilarity = vegemat_dissim,                                             n_clust = 5),     veg_hclu_optics = hclu_optics(vegemat_dissim, index = \"Simpson\"),     # veg_netclu_beckett = netclu_beckett(vegemat_df),     veg_netclu_greedy = netclu_greedy(vegemat_df),     veg_netclu_labelprop = netclu_labelprop(vegemat_df),     veg_netclu_leadingeigen = netclu_leadingeigen(vegemat_df),     # veg_netclu_oslom = netclu_oslom(vegemat_df),     veg_netclu_walktrap = netclu_walktrap(vegemat_df),     veg_netclu_infomap = netclu_infomap(vegemat_df),     veg_netclu_louvain = netclu_louvain(vegemat_df),          times = 2))  mbm_plot <- data.frame(mbm) mbm_plot$expr <- as.character(mbm_plot$expr) mbm_plot$dataset <- ifelse(   grepl(\"ara_\", mbm_plot$expr),   paste0(\"Aravo (\", nrow(aravo) * ncol(aravo), \" cells)\"),   ifelse(grepl(\"fish\", mbm_plot$expr),          paste0(\"Fish (\", nrow(fishmat) * ncol(fishmat), \" cells)\"),          paste0(\"Vegetation (\", nrow(vegemat) * ncol(vegemat), \" cells)\")))  mbm_plot$algorithm <- gsub( \".*_\", \"\", mbm_plot$expr)  # Time in minutes mbm_plot$time_min <- mbm_plot$time / 60e9 # Time in seconds mbm_plot$time_sec <- mbm_plot$time / 1e9 ggplot(mbm_plot[which(mbm_plot$dataset == \"Aravo (6150 cells)\"), ],        aes(reorder(algorithm, time_sec), time_sec)) +   geom_boxplot(aes(color = reorder(algorithm, time_sec),                    fill = reorder(algorithm, time_sec)), show.legend = FALSE) +   scale_color_viridis_d(\"Algorithm\") +   scale_fill_viridis_d(\"Algorithm\") +   labs(title = \"Aravo (6,510 cells)\", x = \"\", y = \"Time (seconds)\") +   theme_classic() +   theme(panel.border = element_rect(fill = NA),         axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) ggplot(mbm_plot[which(mbm_plot$dataset == \"Fish (65910 cells)\"), ],        aes(reorder(algorithm, time_sec), time_sec)) +   geom_boxplot(aes(color = reorder(algorithm, time_sec),                    fill = reorder(algorithm, time_sec)), show.legend = FALSE) +   scale_color_viridis_d(\"Algorithm\") +   scale_fill_viridis_d(\"Algorithm\") +   labs(title = \"European fish (65,910 cells)\",        x = \"\", y = \"Time (seconds)\") +   theme_classic() +   theme(panel.border = element_rect(fill = NA),         axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) ggplot(mbm_plot[which(mbm_plot$dataset == \"Vegetation (2643355 cells)\"), ],        aes(reorder(algorithm, time_min), time_min)) +   geom_boxplot(aes(color = reorder(algorithm, time_min),                    fill = reorder(algorithm, time_min)), show.legend = FALSE) +   scale_color_viridis_d(\"Algorithm\") +   scale_fill_viridis_d(\"Algorithm\") +   labs(title = \"Vegetation (2,643,355 cells)\", x = \"\", y = \"Time (minutes)\") +   theme_classic() +   theme(panel.border = element_rect(fill = NA),         axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_visualization.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"5. Visualization","text":"vignette, rely dataset describing distribution fresh water fish Europe. first load matrix format dataset, computes dissimilarity matrix also load data.frame format data. Since aim plotting result, also need object fishsf linking site dataset geometry. also import world coastlines, available rnaturalearth R package.","code":"data(fishmat) fishdissim <- dissimilarity(fishmat, metric = \"all\") data(fishdf) data(fishsf) world <- rnaturalearth::ne_coastline(returnclass = \"sf\")"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_visualization.html","id":"plots","dir":"Articles","previous_headings":"","what":"Plots","title":"5. Visualization","text":"section, show three ways plot results.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_visualization.html","id":"map_clusters","dir":"Articles","previous_headings":"Plots","what":"map_clusters()","title":"5. Visualization","text":"first possibility use function map_clusters() package. function can directly provide plot site colored according cluster belong .  Let’s take example K-means clustering, number clusters set 5. map_clusters() function can now simply takes object fish_nhclu_kmeans, bioregion.clusters class, spatial distribution sites, stored fishsf.","code":"fish_nhclu_kmeans <- nhclu_kmeans(fishdissim, n_clust = 5, index = \"Simpson\") map_clusters(fish_nhclu_kmeans, geometry = fishsf, plot = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_visualization.html","id":"custom-plot","dir":"Articles","previous_headings":"Plots","what":"Custom plot","title":"5. Visualization","text":"want customize plot simply rely default option, map_clusters() gives possibility extract site well geometry cluster number. purpose, can set arguments like chunk :","code":"custom <- map_clusters(fish_nhclu_kmeans, geometry = fishsf,                        write_clusters = TRUE, plot = FALSE) custom ## Simple feature collection with 338 features and 2 fields (with 70 geometries empty) ## Geometry type: GEOMETRY ## Dimension:     XY ## Bounding box:  xmin: -9.299647 ymin: 36.46054 xmax: 37.75 ymax: 69.67881 ## Geodetic CRS:  +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## First 10 features: ##            ID K_5                       geometry ## 500        Aa   5 POLYGON ((2.09202 50.98091,... ## 2766    Abula   3       GEOMETRYCOLLECTION EMPTY ## 501  Acheloos   2 MULTIPOLYGON (((21.22557 38... ## 2277    Adige   4 POLYGON ((12.12917 47.07917... ## 504     Adour   5 POLYGON ((-0.06622891 44.10... ## 505      Agly   5 POLYGON ((2.761574 42.92824... ## 506      Agri   4 POLYGON ((16.52326 40.32881... ## 510   Albegna   2 POLYGON ((11.54804 42.5839,... ## 2278   Alfios   2 POLYGON ((21.29943 37.68212... ## 512  Aliakmon   5 POLYGON ((21.28508 40.75452... # Crop world coastlines to the extent of the sf object of interest europe <- sf::st_crop(world, sf::st_bbox(custom))  # Plot ggplot(custom) +   geom_sf(aes(fill = K_5), show.legend = FALSE) +   geom_sf(data = europe) +   scale_fill_viridis_d() +   labs(title = \"Kmeans with 5 clusters\") +   theme_void()"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_visualization.html","id":"plot-with-facets","dir":"Articles","previous_headings":"Plots","what":"Plot with facets","title":"5. Visualization","text":"Finally, can interested plotting several bioregionalisations . purpose, can build single data.frame gathering bioregions obtained distinct algorithms take advantage facets implemented ggplot2. first compute bioregionalisation dataset using algorithms. can now make single data.frame extra-column indicating algorithm used. now convert data.frame long-format data.frame. now add back geometry extra column make object spatial. Now long-format spatial data.frame, can take advantage facets implemented ggplot2.","code":"fish_nhclu_pam <- nhclu_pam(fishdissim, n_clust = 5, index = \"Simpson\") fish_hclu_hierarclust <- hclu_hierarclust(dissimilarity = fishdissim,                                           n_clust = 5) fish_netclu_greedy <- netclu_greedy(fishdf) fish_kmeans <- fish_nhclu_kmeans$clusters colnames(fish_kmeans)<- c(\"ID\", \"NHCLU_KMEANS\") fish_pam <- fish_nhclu_pam$clusters colnames(fish_pam)<- c(\"ID\", \"NHCLU_PAM\") fish_hieraclust <- fish_hclu_hierarclust$clusters colnames(fish_hieraclust)<- c(\"ID\", \"HCLU_HIERARCLUST\") fish_greedy <- fish_netclu_greedy$clusters colnames(fish_greedy)<- c(\"ID\", \"NET_GREEDY\")  all_clusters <- dplyr::left_join(fish_kmeans, fish_pam, by = \"ID\") all_clusters <- dplyr::left_join(all_clusters, fish_hieraclust, by = \"ID\") all_clusters <- dplyr::left_join(all_clusters, fish_greedy, by = \"ID\") all_long <- tidyr::pivot_longer(data = all_clusters,                                 cols = dplyr::contains(\"_\"),                                 names_to = \"Algorithm\",                                 values_to = \"Clusters\") all_long <- as.data.frame(all_long) all_long_sf <- dplyr::left_join(all_long,                                 custom[, c(\"ID\", \"geometry\")],                                 by = \"ID\") all_long_sf <- sf::st_as_sf(all_long_sf) ggplot(all_long_sf) +   geom_sf(aes(color = Clusters, fill = Clusters)) +   geom_sf(data = europe, fill = \"gray80\") +   scale_color_viridis_d() +   scale_fill_viridis_d() +   theme_void() +   facet_wrap(~ Algorithm)"},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"brief-introduction","dir":"Articles","previous_headings":"","what":"0. Brief introduction","title":"Tutorial for bioregion","text":"tutorial aims describing different features R package bioregion. main purpose bioregion‘s package propose transparent methodological framework compare bioregionalisation methods. typical flow chart bioregions’ identification based site-species bipartite network co-occurrence matrix bioregion (Figure 1). workflow can divided four main steps: Preprocess data (matrix network formats) Compute similarity/dissimilarity metrics sites based species composition Run different algorithms identify different set bioregions Evaluate visualize results","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"install-binary-files","dir":"Articles","previous_headings":"","what":"1. Install binary files","title":"Tutorial for bioregion","text":"functions least part (listed ) require binary files run. netclu_infomap netclu_louvain (Cpp version) netclu_oslom Please check tutorial page get instructions regarding installation binary files.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"matrix-or-network-formats","dir":"Articles","previous_headings":"","what":"2. Matrix or Network formats","title":"Tutorial for bioregion","text":"bioregion’s package takes input site-species information stored bipartite network co-occurrence matrix. Relying function mat_to_net net_to_mat , handles matrix network formats throughout workflow. Please look tutorial page better understand two functions work.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"pairwise-similaritydissimilarity-metrics","dir":"Articles","previous_headings":"","what":"3. Pairwise similarity/dissimilarity metrics","title":"Tutorial for bioregion","text":"functions similarity dissimilarity compute respectively pairwise similarity dissimilarity metrics based (site-species) co-occurrence matrix. resulting data.frame stored bioregion.pairwise.metric object containing requested metrics pair sites. functions dissimilarity_to_similarity similarity_to_dissimilarity can used transform similarity object dissimilarity object vice versa. Please look tutorial page better understand functions work.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"clustering-algorithms","dir":"Articles","previous_headings":"","what":"4. Clustering algorithms","title":"Tutorial for bioregion","text":"bioregion R package gathers several methods allowing group sites species similar entities called bioregions. methods can lead several partitions sites species, .e. different bioregionalisations.  Bioregionalisation methods can based hierarchical clustering algorithms, non-hierarchical clustering algorithms network algorithms.  functions package related three families produce output specific class, namely bioregion.clusters class.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"hierarchical-clustering","dir":"Articles","previous_headings":"4. Clustering algorithms","what":"4.1 Hierarchical clustering","title":"Tutorial for bioregion","text":"functions relying hierarchical clustering start prefix hclu_. algorithms, bioregions placed dendrogram ranges two extremes: sites belong bioregion (top tree) sites belong different bioregion (bottom tree). See following tutorial page details.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"non-hierarchical-clustering","dir":"Articles","previous_headings":"4. Clustering algorithms","what":"4.2 Non-hierarchical clustering","title":"Tutorial for bioregion","text":"functions relying hierarchical clustering start prefix nhclu_. algorithms, user needs predefine number clusters, although number can determined estimating optimal partition. See tutorial page details.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"network-clustering","dir":"Articles","previous_headings":"4. Clustering algorithms","what":"4.3 Network clustering","title":"Tutorial for bioregion","text":"functions relying network clustering start prefix netclu_. Site-species matrices can seen (bipartite) networks nodes either sites species links occurrences species within sites. networks, modularity algorithms can applied, leading bioregionalisation. following tutorial page details clustering functions relying network algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"microbenchmark","dir":"Articles","previous_headings":"4. Clustering algorithms","what":"4.4 Microbenchmark","title":"Tutorial for bioregion","text":"different bioregionalisation methods listed package rely less computationally intensive algorithms. following page estimates time required run method data sets different sizes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"visualization-and-evaluation-of-the-results","dir":"Articles","previous_headings":"","what":"5. Visualization and evaluation of the results","title":"Tutorial for bioregion","text":"sites geographic coordinates, bioregionalisation can visualized function map_clusters(). tutorial page details different ways plot bioregionalisation.","code":""},{"path":"https://bioRgeo.github.io/bioregion/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Maxime Lenormand. Author, maintainer. Boris Leroy. Author. Pierre Denelle. Author.","code":""},{"path":"https://bioRgeo.github.io/bioregion/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lenormand M, Leroy B, Denelle P (2023). bioregion: Comparison Bioregionalisation Methods. R package version 1.0.2,  https://bioRgeo.github.io/bioregion/, https://github.com/bioRgeo/bioregion.","code":"@Manual{,   title = {bioregion: Comparison of Bioregionalisation Methods},   author = {Maxime Lenormand and Boris Leroy and Pierre Denelle},   year = {2023},   note = {R package version 1.0.2,  https://bioRgeo.github.io/bioregion/},   url = {https://github.com/bioRgeo/bioregion}, }"},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"bioregion-","dir":"","previous_headings":"","what":"Comparison of Bioregionalisation Methods","title":"Comparison of Bioregionalisation Methods","text":"R package gathers comprehensive set algorithms perform bioregionalisation analyses. Bioregionalisation methods can based hierarchical clustering algorithms, non-hierarchical clustering algorithms network algorithms.","code":""},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"arrow_double_down-installation","dir":"","previous_headings":"","what":"⏬ Installation","title":"Comparison of Bioregionalisation Methods","text":"package can installed following command line R session: CRAN GitHub","code":"install.packages(\"bioregion\") # install.packages(\"devtools\") devtools::install_github(\"bioRgeo/bioregion\")"},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"scroll-vignettes","dir":"","previous_headings":"","what":"📜 Vignettes","title":"Comparison of Bioregionalisation Methods","text":"wrote several vignettes help using bioregion R package. Vignettes available following ones: 1. Installation executable binary files 2. Matrix network formats 3. Pairwise similarity/dissimilarity metrics 4.1 Hierarchical clustering 4.2 Non-hierarchical clustering 4.3 Network clustering 4.4 Microbenchmark 5. Visualization Alternatively, prefer view vignettes R, can install package build_vignettes = TRUE. aware vignettes can slow generate.","code":"remotes::install_github(\"bioRgeo/bioregion\",                         dependencies = TRUE, upgrade = \"ask\",                          build_vignettes = TRUE)  vignette(\"bioregion\")"},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"desktop_computer-functions","dir":"","previous_headings":"","what":"🖥️ Functions","title":"Comparison of Bioregionalisation Methods","text":"overview functions data given .","code":""},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"bug-find-a-bug","dir":"","previous_headings":"","what":"🐛 Find a bug?","title":"Comparison of Bioregionalisation Methods","text":"Thank finding . Head GitHub Issues tab let us know . Alternatively, can also send us e-mail. try get soon can!","code":""},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"references-and-dependencies","dir":"","previous_headings":"","what":"References and dependencies","title":"Comparison of Bioregionalisation Methods","text":"bioregion depends ape, bipartite, cluster, data.table, dbscan, dynamicTreeCut, earth, fastcluster, ggplot2, grDevices, igraph, mathjaxr, Matrix, Rcpp, Rdpack, rlang, rmarkdown, segmented,sf, stats, tidyr utils.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_partitions.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare cluster memberships among multiple partitions — compare_partitions","title":"Compare cluster memberships among multiple partitions — compare_partitions","text":"function aims computing pairwise comparisons several partitions, usually outputs netclu_, hclu_ nhclu_ functions. also provides confusion matrix pairwise comparisons, user can compute additional comparison metrics.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_partitions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare cluster memberships among multiple partitions — compare_partitions","text":"","code":"compare_partitions(   cluster_object,   sample_comparisons = NULL,   indices = c(\"rand\", \"jaccard\"),   cor_frequency = FALSE,   store_pairwise_membership = TRUE,   store_confusion_matrix = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_partitions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare cluster memberships among multiple partitions — compare_partitions","text":"cluster_object bioregion.clusters object data.frame list data.frame containing multiple partitions. least two partitions required. list data.frame provided, number rows (.e., items clustering partitions). sample_comparisons NULL positive integer. Reduce computation time sampling number pairwise comparisons cluster membership items. Useful number items clustered high. Suggested values 5000 10000. indices NULL character. Indices compute pairwise comparison partitions. Current available metrics \"rand\" \"jaccard\" cor_frequency boolean. TRUE, computes correlation partition total frequency co-membership items across partitions. Useful identify partition(s) () representative computed partitions. store_pairwise_membership boolean. TRUE, pairwise membership items stored output object. store_confusion_matrix boolean. TRUE, confusion matrices pairwise partition comparisons stored output object.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_partitions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare cluster memberships among multiple partitions — compare_partitions","text":"list 4 7 elements: args: arguments provided user inputs: information input partitions, number items clustered (facultative) pairwise_membership: store_pairwise_membership = TRUE. element contains pairwise memberships items partition, form boolean matrix TRUE means two items cluster, FALSE means two items cluster freq_item_pw_membership: numeric vector containing number times pair items clustered together. corresponds sum rows table pairwise_membership (facultative) partition_freq_cor:  cor_frequency = TRUE. numeric vector indicating correlation individual partitions total frequency pairwise membership across partitions. corresponds correlation individual columns pairwise_membership freq_item_pw_membership (facultative) confusion_matrix: store_confusion_matrix = TRUE. list containing confusion matrices pair partitions. partition_comparison: data.frame containing results comparison partitions, first column indicates partitions compared, next columns correspond requested indices.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_partitions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compare cluster memberships among multiple partitions — compare_partitions","text":"function proceeds two main steps: first step done within partition. compare pairs items document clustered together (TRUE) separately (FALSE) partition. example, site 1 site 2 clustered cluster partition 1, pairwise membership site1_site2 TRUE. output first step stored slot pairwise_membership store_pairwise_membership = TRUE. second step compares pairs partitions analysing pairwise memberships similar . , pair partitions, function computes confusion matrix four elements: : number pairs items grouped partition 1 partition 2 b: number pairs items grouped partition 1 partition 2 c: number pairs items grouped partition 1 grouped partition 2 d: number pairs items grouped partition 1 & 2 confusion matrix stored confusion_matrix store_confusion_matrix = TRUE. Based confusion matrices, can compute range indices indicate agreement among partitions. now, implemented: Rand index \\((+ d)/(+ b + c + d)\\) Rand index measures agreement among partitions accounting pairs sites grouped, also pairs sites grouped. Jaccard index \\(()/(+ b + c)\\) Jaccard index measures agreement among partitions accounting pairs sites grouped - two metrics complementary, Jaccard index tell partitions similar clustering structure, whereas Rand index tell partitions similar pairs items clustered together, also terms pairs sites clustered together. example, take two partitions never group together pairs sites. Jaccard index 0, whereas Rand index can > 0 due sites grouped together. Additional indices can manually computed users basis list confusion matrices. cases, users may interested finding partitions representative partitions. find , can compare pairwise membership partition total frequency pairwise membership across partitions. correlation can requested cor_frequency = TRUE","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_partitions.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compare cluster memberships among multiple partitions — compare_partitions","text":"Boris Leroy (leroy.boris@gmail.com), Maxime Lenormand (maxime.lenormand@inrae.fr) Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_partitions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare cluster memberships among multiple partitions — compare_partitions","text":"","code":"# A simple case with four partitions of four items partitions <- data.frame(matrix(nr = 4, nc = 4,                                  c(1,2,1,1,1,2,2,1,2,1,3,1,2,1,4,2),                                 byrow = TRUE)) partitions #>   X1 X2 X3 X4 #> 1  1  2  1  1 #> 2  1  2  2  1 #> 3  2  1  3  1 #> 4  2  1  4  2 compare_partitions(partitions) #> 2023-11-22 11:12:24.120855 - Computing pairwise membership comparisons for eachpartition... #> 2023-11-22 11:12:24.122689 - Comparing memberships among partitions... #> 2023-11-22 11:12:24.123452 - Computing Rand index... #> 2023-11-22 11:12:24.123805 - Computing Jaccard index... #> Partition comparison: #>  - 4 partitions compared #>  - 4 items in the clustering #>  - Requested indices:  rand jaccard  #>  - Metric summary: #>           rand jaccard #> Min  0.5000000    0.00 #> Mean 0.6388889    0.25 #> Max  1.0000000    1.00 #>  - Item pairwise membership  stored in outputs #>  - Confusion matrices of partition comparisons  stored in outputs  # Find out which partitions are most representative compare_partitions(partitions,                    cor_frequency = TRUE) #> 2023-11-22 11:12:24.126679 - Computing pairwise membership comparisons for eachpartition... #> 2023-11-22 11:12:24.127899 - Comparing memberships among partitions... #> 2023-11-22 11:12:24.128598 - Computing Rand index... #> 2023-11-22 11:12:24.128874 - Computing Jaccard index... #> 2023-11-22 11:12:24.129156 - Computing the correlation between each partition and the vector of frequency of pairwise membership... #> Partition comparison: #>  - 4 partitions compared #>  - 4 items in the clustering #>  - Requested indices:  rand jaccard  #>  - Metric summary: #>           rand jaccard #> Min  0.5000000    0.00 #> Mean 0.6388889    0.25 #> Max  1.0000000    1.00 #>  - Correlation between each partition and the total frequency of item  pairwise membership computed: #>    # Range:  0  -  0.883  #>    # Partition(s) most representative (i.e., highest correlation):  #>  X1, X2  #>  Correlation =  0.883  #>  - Item pairwise membership  stored in outputs #>  - Confusion matrices of partition comparisons  stored in outputs"},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut a hierarchical tree — cut_tree","title":"Cut a hierarchical tree — cut_tree","text":"functions designed work hierarchical tree cut user-selected heights. works either outputs hclu_hierarclust hclust objects. cuts tree chosen number(s) clusters selected height(s). also includes procedure automatically return height cut chosen number(s) clusters.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut a hierarchical tree — cut_tree","text":"","code":"cut_tree(   tree,   n_clust = NULL,   cut_height = NULL,   find_h = TRUE,   h_max = 1,   h_min = 0,   dynamic_tree_cut = FALSE,   dynamic_method = \"tree\",   dynamic_minClusterSize = 5,   dissimilarity = NULL,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut a hierarchical tree — cut_tree","text":"tree bioregion.hierar.tree hclust object n_clust integer vector integers indicating number clusters obtained hierarchical tree, output partition_metrics(). used time cut_height cut_height numeric vector indicating height(s) tree cut. used time n_clust optim_method find_h boolean indicating height cut found requested n_clust h_max numeric indicating maximum possible tree height finding height cut find_h = TRUE h_min numeric indicating minimum possible height tree finding height cut find_h = TRUE dynamic_tree_cut boolean indicating dynamic tree cut method used, case n_clust & cut_height ignored dynamic_method character vector indicating method used dynamically cut tree: either \"tree\" (clusters searched tree) \"hybrid\" (clusters searched tree dissimilarity matrix) dynamic_minClusterSize integer indicating minimum cluster size use dynamic tree cut method (see dynamicTreeCut::cutreeDynamic()) dissimilarity useful dynamic_method = \"hybrid\". Provide dissimilarity data.frame used build tree ... arguments passed dynamicTreeCut::cutreeDynamic() customize dynamic tree cut method.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut a hierarchical tree — cut_tree","text":"tree output hclu_hierarclust(), object returned content updated (.e., args clusters). tree hclust object, data.frame containing clusters returned.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cut a hierarchical tree — cut_tree","text":"function can cut tree two main methods. First, can cut entire tree height (either specified cut_height automatically defined chosen n_clust). Second, can use dynamic tree cut method (Langfelder et al. 2008) , case clusters detected adaptive method based shape branches tree (thus cuts happen multiple heights depending cluster positions tree). dynamic tree cut method two variants. tree-based variant (dynamic_method = \"tree\") top-approach relies tree follows order clustered objects hybrid variant (dynamic_method = \"hybrid\") bottom-approach relies tree dissimilarity matrix build clusters basis dissimilarity information among sites. method useful detect outlying members cluster.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Cut a hierarchical tree — cut_tree","text":"argument find_h ignored dynamic_tree_cut = TRUE, heights cut estimated case.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cut a hierarchical tree — cut_tree","text":"Langfelder P, Zhang B, Horvath S (2008). “Defining clusters hierarchical cluster tree: Dynamic Tree Cut package R.” BIOINFORMATICS, 24(5), 719--720.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cut a hierarchical tree — cut_tree","text":"Pierre Denelle (pierre.denelle@gmail.com), Maxime Lenormand (maxime.lenormand@inrae.fr) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut a hierarchical tree — cut_tree","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\", 1:20) colnames(comat) <- paste0(\"Species\", 1:25)  simil <- similarity(comat, metric = \"all\") dissimilarity <- similarity_to_dissimilarity(simil)  # User-defined number of clusters tree1 <- hclu_hierarclust(dissimilarity, n_clust = 5) #> Randomizing the dissimilarity matrix with 30 trials #>  -- range of cophenetic correlation coefficients among #>                      trials: 0.69 - 0.69 #> Optimal tree has a 0.69 cophenetic correlation coefficient with the initial dissimilarity #>       matrix #> Determining the cut height to reach 5 groups... #> --> 0.25 tree2 <- cut_tree(tree1, cut_height = .05) tree3 <- cut_tree(tree1, n_clust = c(3, 5, 10)) #> Determining the cut height to reach 3 groups... #> --> 0.28125 #> Determining the cut height to reach 5 groups... #> --> 0.25 #> Determining the cut height to reach 10 groups... #> --> 0.1875 tree4 <- cut_tree(tree1, cut_height = c(.05, .1, .15, .2, .25)) tree5 <- cut_tree(tree1, n_clust = c(3, 5, 10), find_h = FALSE)  hclust_tree <- tree2$algorithm$final.tree clusters_2 <- cut_tree(hclust_tree, n_clust = 10) #> Determining the cut height to reach 10 groups... #> --> 0.1875  cluster_dynamic <- cut_tree(tree1, dynamic_tree_cut = TRUE,                             dissimilarity = dissimilarity) #> Some sites were not assigned to any cluster. They will have a NA #>               in the cluster data.frame."},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute dissimilarity metrics (beta-diversity) between sites based on\nspecies composition — dissimilarity","title":"Compute dissimilarity metrics (beta-diversity) between sites based on\nspecies composition — dissimilarity","text":"function creates data.frame row provides one several dissimilarity metric(s) pair sites co-occurrence matrix sites rows species columns.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute dissimilarity metrics (beta-diversity) between sites based on\nspecies composition — dissimilarity","text":"","code":"dissimilarity(comat, metric = \"Simpson\", formula = NULL, method = \"prodmat\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute dissimilarity metrics (beta-diversity) between sites based on\nspecies composition — dissimilarity","text":"comat co-occurrence matrix sites rows species columns. metric vector string(s) indicating metrics chose (see Details). Available options abc, ABC, Jaccard, Jaccardturn, Sorensen, Simpson,  Bray, Brayturn Euclidean. \"\" specified, metrics calculated. Can set NULL formula used. formula vector string(s) formula based , b, c, , B, C quantities (see Details). formula set NULL default. method string indicating method used compute abc (see Details). method = \"prodmat\" default efficient can greedy memory method=\"loops\" less efficient less greedy memory.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute dissimilarity metrics (beta-diversity) between sites based on\nspecies composition — dissimilarity","text":"data.frame additional class bioregion.pairwise.metric, providing one several dissimilarity metric(s) pair sites. two first columns represent pair sites. One column per dissimilarity metric provided metric formula except metric abc ABC stored three columns (one letter).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute dissimilarity metrics (beta-diversity) between sites based on\nspecies composition — dissimilarity","text":"number species shared pair sites, b species present first site  c species present second site. \\(Jaccard = (b + c) / (+ b + c)\\) \\(Jaccardturn = 2min(b, c) / (+ 2min(b, c))\\)(Baselga 2012) \\(Sorensen = (b + c) / (2a + b + c)\\) \\(Simpson = min(b, c) / (+ min(b, c))\\) abundances data available, Bray-Curtis turnover component can also computed following equation: \\(Bray = (B + C) / (2A + B + C)\\) \\(Brayturn = min(B, C)/(+ min(B, C))\\) (Baselga 2013) sum lesser values common species shared pair sites. B C total number specimens counted sites minus . formula can used compute customized metrics terms , b, c, , B, C. example formula = c(\"(b + c) / (+ b + c)\", \"(B + C) / (2*+ B + C)\") compute Jaccard Bray-Curtis dissimilarity metrics, respectively. Euclidean computes Euclidean distance pair sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute dissimilarity metrics (beta-diversity) between sites based on\nspecies composition — dissimilarity","text":"Baselga (2012). “Relationship Species Replacement, Dissimilarity Derived Nestedness, Nestedness.” Global Ecology Biogeography, 21(12), 1223--1232. Baselga (2013). “Separating two components abundance-based dissimilarity: balanced changes abundance vs. abundance gradients.” Methods Ecology Evolution, 4(6), 552--557.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute dissimilarity metrics (beta-diversity) between sites based on\nspecies composition — dissimilarity","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute dissimilarity metrics (beta-diversity) between sites based on\nspecies composition — dissimilarity","text":"","code":"comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  dissim <- dissimilarity(comat, metric = c(\"abc\", \"ABC\", \"Simpson\", \"Brayturn\"))  dissim <- dissimilarity(comat, metric = \"all\", formula = \"1 - (b + c) / (a + b + c)\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"function converts data.frame dissimilarity metrics (beta diversity) sites similarity metrics.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"","code":"dissimilarity_to_similarity(dissimilarity, include_formula = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(). include_formula boolean indicating metrics based formula converted (see Details). argument set TRUE default.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"data.frame additional class bioregion.pairwise.metric, providing similarity metric(s) pair sites based dissimilarity object.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"behavior function changes depending column names. Columns Site1 Site2 copied identically. columns called , b, c, , B, C also copied identically. columns based formula (argument formula dissimilarity()) original list dissimilarity metrics (argument metrics dissimilarity()) argument include_formula set FALSE, also copied identically. Otherwise going converted like columns (default behavior). column called Euclidean, similarity calculated based following formula: \\(Euclidean similarity = 1 / (1 - Euclidean distance)\\) Otherwise, columns transformed dissimilarity following formula: \\(similarity = 1 - dissimilarity\\)","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Boris Leroy (leroy.boris@gmail.com) Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"","code":"comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  dissimil <- dissimilarity(comat, metric = \"all\") dissimil #> Data.frame of dissimilarity between sites #>  - Total number of sites:  5  #>  - Total number of species:  10  #>  - Number of rows:  10  #>  - Number of dissimilarity metrics:  7  #>  #>  #>    Site1 Site2   Jaccard Jaccardturn   Sorensen   Simpson      Bray   Brayturn #> 2  Site1 Site2 0.1111111   0.0000000 0.05882353 0.0000000 0.8678589 0.14743590 #> 3  Site1 Site3 0.4000000   0.4000000 0.25000000 0.2500000 0.8356322 0.08333333 #> 4  Site1 Site4 0.3000000   0.2222222 0.17647059 0.1250000 0.9038855 0.69871795 #> 5  Site1 Site5 0.3000000   0.2222222 0.17647059 0.1250000 0.8603736 0.54487179 #> 8  Site2 Site3 0.3000000   0.2222222 0.17647059 0.1250000 0.5431561 0.50378788 #> 9  Site2 Site4 0.2000000   0.2000000 0.11111111 0.1111111 0.8006719 0.67518248 #> 10 Site2 Site5 0.2000000   0.2000000 0.11111111 0.1111111 0.8337013 0.73751452 #> 14 Site3 Site4 0.3000000   0.2222222 0.17647059 0.1250000 0.8179551 0.73357664 #> 15 Site3 Site5 0.3000000   0.2222222 0.17647059 0.1250000 0.6891616 0.55865273 #> 20 Site4 Site5 0.0000000   0.0000000 0.00000000 0.0000000 0.8158051 0.81143552 #>    Euclidean a b c   A    B    C #> 2   812.0757 8 0 1 133   23 1724 #> 3   812.8210 6 2 2 143   13 1441 #> 4   525.6215 7 1 2  47  109  775 #> 5   441.3309 7 1 2  71   85  790 #> 8   816.2714 7 2 1 786 1071  798 #> 9   974.0796 8 1 1 267 1590  555 #> 10  946.5749 8 1 1 226 1631  635 #> 14  949.7452 7 1 2 219 1365  603 #> 15  874.5313 7 1 2 380 1204  481 #> 20  648.4528 9 0 0 155  667  706  similarity <- dissimilarity_to_similarity(dissimil) similarity #> Data.frame of similarity between sites #>  - Total number of sites:  5  #>  - Total number of species:  10  #>  - Number of rows:  10  #>  - Number of similarity metrics:  7  #>  #>  #>    Site1 Site2   Jaccard Jaccardturn  Sorensen   Simpson       Bray  Brayturn #> 2  Site1 Site2 0.8888889   1.0000000 0.9411765 1.0000000 0.13214108 0.8525641 #> 3  Site1 Site3 0.6000000   0.6000000 0.7500000 0.7500000 0.16436782 0.9166667 #> 4  Site1 Site4 0.7000000   0.7777778 0.8235294 0.8750000 0.09611452 0.3012821 #> 5  Site1 Site5 0.7000000   0.7777778 0.8235294 0.8750000 0.13962635 0.4551282 #> 8  Site2 Site3 0.7000000   0.7777778 0.8235294 0.8750000 0.45684394 0.4962121 #> 9  Site2 Site4 0.8000000   0.8000000 0.8888889 0.8888889 0.19932811 0.3248175 #> 10 Site2 Site5 0.8000000   0.8000000 0.8888889 0.8888889 0.16629875 0.2624855 #> 14 Site3 Site4 0.7000000   0.7777778 0.8235294 0.8750000 0.18204489 0.2664234 #> 15 Site3 Site5 0.7000000   0.7777778 0.8235294 0.8750000 0.31083845 0.4413473 #> 20 Site4 Site5 1.0000000   1.0000000 1.0000000 1.0000000 0.18419489 0.1885645 #>      Euclidean a b c   A    B    C #> 2  0.001229898 8 0 1 133   23 1724 #> 3  0.001228771 6 2 2 143   13 1441 #> 4  0.001898897 7 1 2  47  109  775 #> 5  0.002260751 7 1 2  71   85  790 #> 8  0.001223584 7 2 1 786 1071  798 #> 9  0.001025557 8 1 1 267 1590  555 #> 10 0.001055326 8 1 1 226 1631  635 #> 14 0.001051806 7 1 2 219 1365  603 #> 15 0.001142164 7 1 2 380 1204  481 #> 20 0.001539758 9 0 0 155  667  706"},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"function aims optimizing one several criteria set ordered partitions. usually applied find one (several) optimal number(s) clusters , example, hierarchical tree cut, range partitions obtained k-means PAM. Users advised careful applied cases (e.g., partitions ordered increasing decreasing sequence, partitions related ).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"","code":"find_optimal_n(   partitions,   metrics_to_use = \"all\",   criterion = \"elbow\",   step_quantile = 0.99,   step_levels = NULL,   step_round_above = TRUE,   metric_cutoffs = c(0.5, 0.75, 0.9, 0.95, 0.99, 0.999),   n_breakpoints = 1,   plot = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"partitions bioregion.partition.metrics object (output partition_metrics() data.frame first two columns named \"K\" (partition name) \"n_clusters\" (number clusters) following columns containing evaluation metrics (numeric values) metrics_to_use character string vector character strings indicating upon metric(s) partitions optimal number clusters calculated. Defaults \"\" means metrics available partitions used criterion character string indicating criterion used identify optimal number(s) clusters. Available methods currently include \"elbow\", \"increasing_step\", \"decreasing_step\", \"cutoff\", \"breakpoints\", \"min\" \"max\". Default \"elbow\". See details. step_quantile \"increasing_step\" \"decreasing_step\", specify quantile differences two consecutive k used cutoff identify important steps eval_metric step_levels \"increasing_step\" \"decreasing_step\", specify number largest steps keep cutoffs. step_round_above boolean indicating optimal number clusters picked identified steps. Indeed, step correspond sudden increase decrease partition X & partition X+1: optimal partition X+1 (step_round_above = TRUE) X (step_round_above = FALSE? Defaults TRUE metric_cutoffs criterion = \"cutoff\", specify cutoffs eval_metric number clusters extracted n_breakpoints specify number breakpoints look curve. Defaults 1 plot boolean indicating plot first eval_metric drawn identified optimal numbers cutoffs","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"list class bioregion.optimal.n three elements: args: input arguments evaluation_df: input evaluation data.frame appended boolean columns identifying optimal numbers clusters optimal_nb_clusters: list containing optimal number(s) cluster(s) metric specified \"metrics_to_use\", based chosen criterion plot: requested, plot stored slot","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"function explores relationship evaluation metric ~ number clusters, criterion applied search optimal number clusters. Please read note section following criteria. Foreword: implemented set criteria commonly found literature recommended bioregionalisation literature. Nevertheless, also advocate move beyond \"Search one optimal number clusters\" paradigm, consider investigating \"multiple optimal numbers clusters\". Indeed, using one optimal number clusters may simplify natural complexity biological datasets, , example, ignore often hierarchical / nested nature bioregionalisations. Using multiple partitions likely avoids oversimplification bias may convey information. See, example, reanalysis Holt et al. (2013) (Ficetola et al. 2017) , used deep, intermediate shallow cuts. Following rationale, several criteria implemented can/return multiple \"optimal\" numbers clusters, depending user choices. Criteria find optimal number(s) clusters elbow: method consists finding one elbow evaluation metric curve, commonly done clustering analyses. idea approximate number clusters evaluation metric longer increments.based fast method finding maximum distance curve straight line linking minimum maximum number points. code use based code written Esben Eickhardt available https://stackoverflow.com/questions/2018178/finding--best-trade--point---curve/42810075#42810075. code modified work increasing decreasing evaluation metrics. increasing_step decreasing_step: method consists identifying clusters important changes, steps, evaluation metric. objective can either look largest increases (increasing_step) largest decreases decreasing_step. Steps calculated based pairwise differences partitions. Therefore, relative distribution differences evaluation metric tested partitions. Specify step_quantile quantile cutoff steps selected important (default, 0.99, .e. largest 1\\ selected).Alternatively, can also choose specify number top steps keep, e.g. keep largest three steps, specify step_level = 3. Basically method emphasize important changes evaluation metric first approximation important cuts can chosen.**Please note choose increasing_step decreasing_step depending nature evaluation metrics. example, metrics monotonously decreasing (e.g., endemism metrics \"avg_endemism\" & \"tot_endemism\") number clusters n_clusters, choose decreasing_step. contrary, metrics monotonously increasing number clusters (e.g., \"pc_distance\"), choose increasing_step. ** cutoffs: method consists specifying cutoff value(s) evaluation metric number(s) clusters derived. method used (Holt et al. 2013) . Note, however, cut-offs suggested Holt et al. (0.9, 0.95, 0.99, 0.999) may relevant large spatial scales, lower cut-offs considered finer spatial scales. breakpoints: method consists finding break points curve using segmented regression. Users specify number expected break points n_breakpoints (defaults 1). Note since method relies regression model, probably applied low number partitions. min & max: Picks optimal partition(s) respectively minimum maximum value evaluation metric.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"Please note finding optimal number clusters procedure normally requires decisions users, can hardly fully automatized. Users strongly advised read references indicated look guidance choose optimal number(s) clusters. Consider \"optimal\" numbers clusters returned function first approximation best numbers bioregionalisation.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"Castro-Insua , Gómez-Rodríguez C, Baselga (2018). “Dissimilarity measures affected richness differences yield biased delimitations biogeographic realms.” Nature Communications, 9(1), 9--11. Ficetola GF, Mazel F, Thuiller W (2017). “Global determinants zoogeographical boundaries.” Nature Ecology & Evolution, 1, 0089. Holt BG, Lessard J, Borregaard MK, Fritz SA, Araújo MB, Dimitrov D, Fabre P, Graham CH, Graves GR, Jønsson Ka, Nogués-Bravo D, Wang Z, Whittaker RJ, Fjeldså J, Rahbek C (2013). “update Wallace's zoogeographic regions world.” Science, 339(6115), 74--78. Kreft H, Jetz W (2010). “framework delineating biogeographical regions based species distributions.” Journal Biogeography, 37, 2029--2053. Langfelder P, Zhang B, Horvath S (2008). “Defining clusters hierarchical cluster tree: Dynamic Tree Cut package R.” BIOINFORMATICS, 24(5), 719--720.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"Boris Leroy (leroy.boris@gmail.com), Maxime Lenormand (maxime.lenormand@inrae.fr) Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  comnet <- mat_to_net(comat)  dissim <- dissimilarity(comat, metric = \"all\")  # User-defined number of clusters tree1 <- hclu_hierarclust(dissim,                           n_clust = 2:15,                           index = \"Simpson\") #> Randomizing the dissimilarity matrix with 30 trials #>  -- range of cophenetic correlation coefficients among #>                      trials: 0.53 - 0.53 #> Optimal tree has a 0.53 cophenetic correlation coefficient with the initial dissimilarity #>       matrix #> Warning: The requested number of cluster could not be found #>                          for k = 14. Closest number found: 13 tree1 #> Clustering results for algorithm : hierarchical_clustering  #> \t(hierarchical clustering based on a dissimilarity matrix) #>  - Number of sites:  20  #>  - Name of dissimilarity metric:  Simpson  #>  - Tree construction method:  average  #>  - Randomization of the dissimilarity matrix:  yes, number of trials 30  #>  - Cophenetic correlation coefficient:  0.532  #>  - Number of clusters requested by the user:  2 3 4 5 6 7 8 9 10 11 ... (with 4 more values)  #> Clustering results: #>  - Number of partitions:  14  #>  - Partitions are hierarchical #>  - Number of clusters:  2 3 4 5 6 7 8 9 10 11 ... (with 4 more values)  #>  - Height of cut of the hierarchical tree: 0.125 0.109 0.101 0.098 0.094 0.078 0.07 0.064 0.062 0.055 ... (with 4 more values)   a <- partition_metrics(tree1,                    dissimilarity = dissim,                    net = comnet,                    species_col = \"Node2\",                    site_col = \"Node1\",                    eval_metric = c(\"tot_endemism\",                                    \"avg_endemism\",                                    \"pc_distance\",                                    \"anosim\")) #> Computing similarity-based metrics... #>   - pc_distance OK #>   - anosim OK #> Computing composition-based metrics... #>   - avg_endemism OK #>   - tot_endemism OK                                     find_optimal_n(a) #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 14 #> Searching for potential optimal number(s) of clusters based on the elbow method #>    * elbow found at: #> tot_endemism 4 #> avg_endemism 4 #> pc_distance 7 #> anosim 2 #> Warning: The elbow method is likely not suitable for the ANOSIM metric. You should rather look for leaps in the curve (see criterion = 'increasing_step' or decreasing_step) #> Plotting results...  #> Search for an optimal number of clusters: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  elbow  #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism - 4 #> avg_endemism - 4 #> pc_distance - 7 #> anosim - 2 find_optimal_n(a, criterion = \"increasing_step\") #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 14 #> Searching for potential optimal number(s) of clusters based on the increasing_step method #>  - Step method #> Warning: Criterion 'increasing_step' cannot work properly with metric 'tot_endemism', because this metric is usually monotonously decreasing. Consider using criterion = 'decreasing_step' instead. #> Plotting results...  #> Search for an optimal number of clusters: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  increasing_step  #>    (step quantile chosen:  0.99  (i.e., only the top 1 %  increase  in evaluation metrics  are used as break points for the number of clusters) #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism -  #> avg_endemism -  #> pc_distance - 4 #> anosim - 7 find_optimal_n(a, criterion = \"decreasing_step\") #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 14 #> Searching for potential optimal number(s) of clusters based on the decreasing_step method #>  - Step method #> Warning: Criterion 'decreasing_step' cannot work properly with metrics 'pc_distance' or 'avg_endemism', because these metrics are usually monotonously decreasing. Consider using criterion = 'increasing_step' instead. #> Plotting results...  #> Search for an optimal number of clusters: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  decreasing_step  #>    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism - 3 #> avg_endemism - 3 #> pc_distance - 13 #> anosim - 4 find_optimal_n(a, criterion = \"decreasing_step\",                step_levels = 3)  #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 14 #> Searching for potential optimal number(s) of clusters based on the decreasing_step method #>  - Step method #> Warning: Criterion 'decreasing_step' cannot work properly with metrics 'pc_distance' or 'avg_endemism', because these metrics are usually monotonously decreasing. Consider using criterion = 'increasing_step' instead. #> Warning: The number of optimal N for method 'tot_endemism' is suspiciously high, consider switching between 'increasing_step' and 'decreasing_step' #> Warning: The number of optimal N for method 'avg_endemism' is suspiciously high, consider switching between 'increasing_step' and 'decreasing_step' #> Plotting results...  #> Search for an optimal number of clusters: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  decreasing_step  #>    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism - 3 4 5 6 7 8 9 10 11 12 13 15 #> avg_endemism - 3 4 5 6 7 8 9 10 11 12 13 15 #> pc_distance - 13 15 #> anosim - 3 4 13 find_optimal_n(a, criterion = \"decreasing_step\",                step_quantile = .9)  #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 14 #> Searching for potential optimal number(s) of clusters based on the decreasing_step method #>  - Step method #> Warning: Criterion 'decreasing_step' cannot work properly with metrics 'pc_distance' or 'avg_endemism', because these metrics are usually monotonously decreasing. Consider using criterion = 'increasing_step' instead. #> Plotting results...  #> Search for an optimal number of clusters: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  decreasing_step  #>    (step quantile chosen:  0.9  (i.e., only the top 10 %  decrease  in evaluation metrics  are used as break points for the number of clusters) #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism - 3 4 #> avg_endemism - 3 4 #> pc_distance - 13 #> anosim - 3 4 find_optimal_n(a, criterion = \"decreasing_step\",                step_levels = 3)  #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 14 #> Searching for potential optimal number(s) of clusters based on the decreasing_step method #>  - Step method #> Warning: Criterion 'decreasing_step' cannot work properly with metrics 'pc_distance' or 'avg_endemism', because these metrics are usually monotonously decreasing. Consider using criterion = 'increasing_step' instead. #> Warning: The number of optimal N for method 'tot_endemism' is suspiciously high, consider switching between 'increasing_step' and 'decreasing_step' #> Warning: The number of optimal N for method 'avg_endemism' is suspiciously high, consider switching between 'increasing_step' and 'decreasing_step' #> Plotting results...  #> Search for an optimal number of clusters: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  decreasing_step  #>    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism - 3 4 5 6 7 8 9 10 11 12 13 15 #> avg_endemism - 3 4 5 6 7 8 9 10 11 12 13 15 #> pc_distance - 13 15 #> anosim - 3 4 13 find_optimal_n(a, criterion = \"decreasing_step\",                step_levels = 3)                  #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 14 #> Searching for potential optimal number(s) of clusters based on the decreasing_step method #>  - Step method #> Warning: Criterion 'decreasing_step' cannot work properly with metrics 'pc_distance' or 'avg_endemism', because these metrics are usually monotonously decreasing. Consider using criterion = 'increasing_step' instead. #> Warning: The number of optimal N for method 'tot_endemism' is suspiciously high, consider switching between 'increasing_step' and 'decreasing_step' #> Warning: The number of optimal N for method 'avg_endemism' is suspiciously high, consider switching between 'increasing_step' and 'decreasing_step' #> Plotting results...  #> Search for an optimal number of clusters: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  decreasing_step  #>    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism - 3 4 5 6 7 8 9 10 11 12 13 15 #> avg_endemism - 3 4 5 6 7 8 9 10 11 12 13 15 #> pc_distance - 13 15 #> anosim - 3 4 13 find_optimal_n(a, criterion = \"breakpoints\")              #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 14 #> Searching for potential optimal number(s) of clusters based on the breakpoints method #> Plotting results... #>    (the red line is the prediction from the segmented regression)  #> Search for an optimal number of clusters: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  breakpoints  #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism - 3 #> avg_endemism - 3 #> pc_distance - 6 #> anosim - 4"},{"path":"https://bioRgeo.github.io/bioregion/reference/fishdf.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of fish in Europe (data.frame) — fishdf","title":"Spatial distribution of fish in Europe (data.frame) — fishdf","text":"dataset containing abundance 195 species 338 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishdf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of fish in Europe (data.frame) — fishdf","text":"","code":"fishdf"},{"path":"https://bioRgeo.github.io/bioregion/reference/fishdf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of fish in Europe (data.frame) — fishdf","text":"data.frame 2,703 rows 3 columns: Site Unique site identifier (corresponding field ID fishsf). Species Unique species identifier. Abundance Species abundance","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of fish in Europe (co-occurrence matrix) — fishmat","title":"Spatial distribution of fish in Europe (co-occurrence matrix) — fishmat","text":"dataset containing abundance 195 species 338 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of fish in Europe (co-occurrence matrix) — fishmat","text":"","code":"fishmat"},{"path":"https://bioRgeo.github.io/bioregion/reference/fishmat.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of fish in Europe (co-occurrence matrix) — fishmat","text":"co-occurrence matrix sites rows species columns. element matrix represents abundance species site.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishsf.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of fish in Europe — fishsf","title":"Spatial distribution of fish in Europe — fishsf","text":"dataset containing geometry 338 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishsf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of fish in Europe — fishsf","text":"","code":"fishsf"},{"path":"https://bioRgeo.github.io/bioregion/reference/fishsf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of fish in Europe — fishsf","text":"ID Unique site identifier. geometry Geometry site.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":null,"dir":"Reference","previous_headings":"","what":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"function computes divisive hierarchical clustering dissimilarity (beta-diversity) data.frame, calculates cophenetic correlation coefficient, can get clusters tree requested user. function implements randomization dissimilarity matrix generate tree, selection method based optimal cophenetic correlation coefficient. Typically, dissimilarity data.frame bioregion.pairwise.metric object obtained running similarity similarity similarity_to_dissimilarity.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"","code":"hclu_diana(   dissimilarity,   index = names(dissimilarity)[3],   n_clust = NULL,   cut_height = NULL,   find_h = TRUE,   h_max = 1,   h_min = 0 )"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), next column(s) dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. n_clust integer vector integers indicating number clusters obtained hierarchical tree, output partition_metrics. used time cut_height. cut_height numeric vector indicating height(s) tree cut. used time n_clust. find_h boolean indicating height cut found requested n_clust. h_max numeric indicating maximum possible tree height chosen index. h_min numeric indicating minimum possible height tree chosen index.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects clusters: data.frame containing clustering results #'","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"Chapter 6 Kaufman Rousseeuw (1990) fully details functioning diana algorithm. find optimal number clusters, see partition_metrics()","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"Kaufman L, Rousseeuw PJ (2009). “Finding groups data: introduction cluster analysis.” & Sons. JW (ed.), Finding groups data: introduction cluster analysis..","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"Pierre Denelle (pierre.denelle@gmail.com), Boris Leroy (leroy.boris@gmail.com) Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"all\")  data(\"fishmat\") fishdissim <- dissimilarity(fishmat) fish_diana <- hclu_diana(fishdissim, index = \"Simpson\") #> Output tree has a 0.55 cophenetic correlation coefficient with the initial #>                    dissimilarity matrix  # fish_diana <- cluster::diana(fishmat, #dissim, #                              diss = FALSE, #inherits(fishdissim, \"dist\"), #                              metric = \"euclidean\", #                              stand = FALSE, #                              stop.at.k = FALSE, #                              # keep.diss = n < 100, #                              # keep.data = !diss, #                              trace.lev = 0)"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":null,"dir":"Reference","previous_headings":"","what":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"function generates hierarchical tree dissimilarity (beta-diversity) data.frame, calculates cophenetic correlation coefficient, can get clusters tree requested user. function implements randomization dissimilarity matrix generate tree, selection method based optimal cophenetic correlation coefficient. Typically, dissimilarity data.frame bioregion.pairwise.metric object obtained running similarity similarity similarity_to_dissimilarity.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"","code":"hclu_hierarclust(   dissimilarity,   index = names(dissimilarity)[3],   method = \"average\",   randomize = TRUE,   n_runs = 30,   keep_trials = FALSE,   optimal_tree_method = \"best\",   n_clust = NULL,   cut_height = NULL,   find_h = TRUE,   h_max = 1,   h_min = 0 )"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), next column(s) dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. method name hierarchical classification method, fastcluster::hclust(). one \"ward.D\", \"ward.D2\", \"single\", \"complete\", \"average\" (= UPGMA), \"mcquitty\" (= WPGMA), \"median\" (= WPGMC) \"centroid\" (= UPGMC). randomize boolean indicating dissimilarity matrix randomized, account order sites dissimilarity matrix. n_runs number trials randomize dissimilarity matrix. keep_trials boolean indicating random trial results. stored output object (set FALSE save space dissimilarity object large). optimal_tree_method character vector indicating final tree obtained trials. option currently \"best\", means tree best cophenetic correlation coefficient chosen. n_clust integer vector integers indicating number clusters obtained hierarchical tree, output partition_metrics. used time cut_height. cut_height numeric vector indicating height(s) tree cut. used time n_clust. find_h boolean indicating height cut found requested n_clust. h_max numeric indicating maximum possible tree height chosen index. h_min numeric indicating minimum possible height tree chosen index.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects clusters: data.frame containing clustering results algorithm slot, users can find following elements: trials: list containing randomization trials. trial contains dissimilarity matrix, site order randomized, associated tree cophenetic correlation coefficient (Spearman) tree final.tree: hclust object containing final hierarchical tree used final.tree.coph.cor: cophenetic correlation coefficient initial dissimilarity matrix final.tree","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"default method hierarchical tree \"average\", .e. UPGMA recommended best method generate tree beta diversity dissimilarity (Kreft Jetz 2010) Clusters can obtained two methods: Specifying desired number clusters n_clust Specifying one several heights cut cut_height find optimal number clusters, see partition_metrics()","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"Kreft H, Jetz W (2010). “framework delineating biogeographical regions based species distributions.” Journal Biogeography, 37, 2029--2053.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"Boris Leroy (leroy.boris@gmail.com), Pierre Denelle (pierre.denelle@gmail.com) Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hierarchical clustering based on dissimilarity or beta-diversity — hclu_hierarclust","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"all\")  # User-defined number of clusters tree1 <- hclu_hierarclust(dissim, n_clust = 5) #> Randomizing the dissimilarity matrix with 30 trials #>  -- range of cophenetic correlation coefficients among #>                      trials: 0.62 - 0.74 #> Optimal tree has a 0.74 cophenetic correlation coefficient with the initial dissimilarity #>       matrix #> Determining the cut height to reach 5 groups... #> --> 0.28125 tree1 #> Clustering results for algorithm : hierarchical_clustering  #> \t(hierarchical clustering based on a dissimilarity matrix) #>  - Number of sites:  20  #>  - Name of dissimilarity metric:  Jaccard  #>  - Tree construction method:  average  #>  - Randomization of the dissimilarity matrix:  yes, number of trials 30  #>  - Cophenetic correlation coefficient:  0.737  #>  - Number of clusters requested by the user:  5  #> Clustering results: #>  - Number of partitions:  1  #>  - Number of clusters:  5  #>  - Height of cut of the hierarchical tree: 0.281  plot(tree1)  str(tree1) #> List of 6 #>  $ name        : chr \"hierarchical_clustering\" #>  $ args        :List of 11 #>   ..$ index              : chr \"Jaccard\" #>   ..$ method             : chr \"average\" #>   ..$ randomize          : logi TRUE #>   ..$ n_runs             : num 30 #>   ..$ optimal_tree_method: chr \"best\" #>   ..$ n_clust            : num 5 #>   ..$ cut_height         : NULL #>   ..$ find_h             : logi TRUE #>   ..$ h_max              : num 1 #>   ..$ h_min              : num 0 #>   ..$ dynamic_tree_cut   : logi FALSE #>  $ inputs      :List of 6 #>   ..$ bipartite      : logi FALSE #>   ..$ weight         : logi TRUE #>   ..$ pairwise_metric: logi TRUE #>   ..$ dissimilarity  : logi TRUE #>   ..$ nb_sites       : int 20 #>   ..$ hierarchical   : logi FALSE #>  $ algorithm   :List of 5 #>   ..$ trials             : chr \"Trials not stored in output\" #>   ..$ final.tree         :List of 7 #>   .. ..- attr(*, \"class\")= chr \"hclust\" #>   ..$ final.tree.coph.cor: num 0.737 #>   ..$ output_n_clust     : int 5 #>   ..$ output_cut_height  : Named num 0.281 #>   .. ..- attr(*, \"names\")= chr \"k_5\" #>  $ clusters    :'data.frame':\t20 obs. of  2 variables: #>   ..$ ID : chr [1:20] \"Site8\" \"Site11\" \"Site6\" \"Site1\" ... #>   ..$ K_5: chr [1:20] \"1\" \"1\" \"2\" \"1\" ... #>  $ cluster_info:'data.frame':\t1 obs. of  4 variables: #>   ..$ partition_name   : chr \"K_5\" #>   ..$ n_clust          : int 5 #>   ..$ requested_n_clust: num 5 #>   ..$ output_cut_height: num 0.281 #>  - attr(*, \"class\")= chr [1:2] \"bioregion.clusters\" \"list\" tree1$clusters #>            ID K_5 #> Site8   Site8   1 #> Site11 Site11   1 #> Site6   Site6   2 #> Site1   Site1   1 #> Site12 Site12   1 #> Site2   Site2   1 #> Site10 Site10   1 #> Site15 Site15   3 #> Site7   Site7   1 #> Site4   Site4   3 #> Site14 Site14   1 #> Site17 Site17   1 #> Site13 Site13   1 #> Site16 Site16   1 #> Site20 Site20   1 #> Site9   Site9   4 #> Site18 Site18   1 #> Site5   Site5   2 #> Site3   Site3   5 #> Site19 Site19   1  # User-defined height cut # Only one height tree2 <- hclu_hierarclust(dissim, cut_height = .05) #> Randomizing the dissimilarity matrix with 30 trials #>  -- range of cophenetic correlation coefficients among #>                      trials: 0.62 - 0.74 #> Optimal tree has a 0.74 cophenetic correlation coefficient with the initial dissimilarity #>       matrix tree2 #> Clustering results for algorithm : hierarchical_clustering  #> \t(hierarchical clustering based on a dissimilarity matrix) #>  - Number of sites:  20  #>  - Name of dissimilarity metric:  Jaccard  #>  - Tree construction method:  average  #>  - Randomization of the dissimilarity matrix:  yes, number of trials 30  #>  - Cophenetic correlation coefficient:  0.737  #>  - Heights of cut requested by the user:  0.05  #> Clustering results: #>  - Number of partitions:  1  #>  - Number of clusters:  20  #>  - Height of cut of the hierarchical tree: 0.05  tree2$clusters #>        ID K_20 #> 1  Site12    1 #> 2   Site6    2 #> 3   Site1    3 #> 4   Site9    4 #> 5  Site16    5 #> 6  Site18    6 #> 7   Site4    7 #> 8  Site14    8 #> 9  Site17    9 #> 10 Site20   10 #> 11 Site11   11 #> 12 Site10   12 #> 13  Site2   13 #> 14 Site15   14 #> 15  Site3   15 #> 16 Site19   16 #> 17  Site7   17 #> 18  Site5   18 #> 19  Site8   19 #> 20 Site13   20  # Multiple heights tree3 <- hclu_hierarclust(dissim, cut_height = c(.05, .15, .25)) #> Randomizing the dissimilarity matrix with 30 trials #>  -- range of cophenetic correlation coefficients among #>                      trials: 0.62 - 0.74 #> Optimal tree has a 0.74 cophenetic correlation coefficient with the initial dissimilarity #>       matrix  tree3$clusters # Mind the order of height cuts: from deep to shallow cuts #>            ID K_6 K_17 K_20 #> Site2   Site2   1    1    1 #> Site7   Site7   2    2    2 #> Site9   Site9   3    3    3 #> Site4   Site4   4    4    4 #> Site3   Site3   5    5    5 #> Site1   Site1   1    6    6 #> Site18 Site18   1    7    7 #> Site14 Site14   1    1    8 #> Site8   Site8   1    8    9 #> Site11 Site11   1    9   10 #> Site13 Site13   1   10   11 #> Site16 Site16   1   11   12 #> Site12 Site12   1   12   13 #> Site17 Site17   1    7   14 #> Site20 Site20   1   13   15 #> Site19 Site19   1   14   16 #> Site15 Site15   4   15   17 #> Site6   Site6   6   16   18 #> Site10 Site10   1    1   19 #> Site5   Site5   6   17   20 # Info on each partition can be found in table cluster_info tree3$cluster_info #>        partition_name n_clust requested_cut_height #> h_0.25            K_6       6                 0.25 #> h_0.15           K_17      17                 0.15 #> h_0.05           K_20      20                 0.05 plot(tree3) #> Warning: no non-missing arguments to min; returning Inf #> Error in stats::rect.hclust(x$algorithm$final.tree, h = x$algorithm$output_cut_height[i],     border = cols[i]): k must be between 2 and 19   # Recut the tree afterwards tree3.1 <- cut_tree(tree3, n = 5) #> Determining the cut height to reach 5 groups... #> --> 0.28125  tree4 <- hclu_hierarclust(dissim, n_clust = 1:19) #> Randomizing the dissimilarity matrix with 30 trials #>  -- range of cophenetic correlation coefficients among #>                      trials: 0.62 - 0.74 #> Optimal tree has a 0.74 cophenetic correlation coefficient with the initial dissimilarity #>       matrix"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":null,"dir":"Reference","previous_headings":"","what":"OPTICS hierarchical clustering algorithm — hclu_optics","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"function performs semi-hierarchical clustering basis dissimilarity OPTICS algorithm (Ordering Points Identify Clustering Structure)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"","code":"hclu_optics(   dissimilarity,   index = names(dissimilarity)[3],   minPts = NULL,   eps = NULL,   xi = 0.05,   minimum = FALSE,   show_hierarchy = FALSE,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), next column(s) dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. minPts numeric value specifying minPts argument dbscan::dbscan()). minPts minimum number points form dense region. default, set natural logarithm number sites dissimilarity. eps numeric value specifying eps argument dbscan::optics()). upper limit size epsilon neighborhood. Limiting neighborhood size improves performance little impact ordering long set low. specified (default behavior), largest minPts-distance data set used gives result infinity. xi numeric value specifying steepness threshold identify clusters hierarchically using Xi method (see dbscan::optics()) minimum boolean specifying hierarchy pruned output keep clusters \"minimal\" level, .e. leaf / non-overlapping clusters. TRUE, argument show_hierarchy FALSE show_hierarchy boolean specifying hierarchy clusters included output. default, hierarchy visible clusters obtained OPTICS - can visualized visualising plot OPTICS object. show_hierarchy = TRUE, output cluster data.frame contain additional columns showing hierarchy clusters. ... can add arguments passed optics() (see dbscan::optics())","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects clusters: data.frame containing clustering results","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"optics (Ordering points identify clustering structure) semi-hierarchical clustering algorithm orders points dataset points closest become neighbors, calculates reachability distance point. , clusters can extracted hierarchical manner reachability distance, identifying clusters depending changes relative cluster density. reachability plot explored understand clusters hierarchical nature, running plot output function: plot(object$algorithm$optics). recommend reading (Hahsler et al. 2019)  grasp algorithm, works, clusters mean. extract clusters, use dbscan::extractXi() function based steepness reachability plot (see dbscan::optics())","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"Hahsler M, Piekenbrock M, Doran D (2019). “Dbscan: Fast density-based clustering R.” Journal Statistical Software, 91(1). ISSN 15487660.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"Boris Leroy (leroy.boris@gmail.com), Pierre Denelle (pierre.denelle@gmail.com) Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"","code":"dissim <- dissimilarity(fishmat, metric = \"all\")    clust1 <- hclu_optics(dissim, index = \"Simpson\") clust1 #> Clustering results for algorithm : optics  #>  - Number of sites:  338  #> Clustering results: #>  - Number of partitions:  1  #>  - Number of clusters:  4   # Visualize the optics plot (the hierarchy of clusters is illustrated at the # bottom) plot(clust1$algorithm$optics)   # Extract the hierarchy of clusters clust1 <- hclu_optics(dissim, index = \"Simpson\", show_hierarchy = TRUE) clust1 #> Clustering results for algorithm : optics  #>  - Number of sites:  338  #> Clustering results: #>  - Number of partitions:  2  #>  - Partitions are hierarchical #>  - Number of clusters:  2 4"},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":null,"dir":"Reference","previous_headings":"","what":"Download, unzip, check permission and test the bioregion's binary files — install_binaries","title":"Download, unzip, check permission and test the bioregion's binary files — install_binaries","text":"function downloads unzips 'bin' folder needed run functions bioregion. also checks files permissions executed programs. finally tests binary files running properly.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download, unzip, check permission and test the bioregion's binary files — install_binaries","text":"","code":"install_binaries(binpath = \"tempdir\", infomap_version = c(\"2.1.0\", \"2.6.0\"))"},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download, unzip, check permission and test the bioregion's binary files — install_binaries","text":"binpath character indicating path folder host 'bin' folder containing binary files (see Details). infomap_version character vector indicating Infomap version(s) install.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Download, unzip, check permission and test the bioregion's binary files — install_binaries","text":"return value","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Download, unzip, check permission and test the bioregion's binary files — install_binaries","text":"default, binary files installed R's temporary directory (binpath = \"tempdir\"). case bin folder automatically removed end R session. Alternatively, binary files can installed bioregion's package folder (binpath = \"pkgfolder\"). Finally, path folder choice can chosen. case, PLEASE MAKE SURE update binpath accordingly netclu_infomap, netclu_louvain netclu_oslom).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Download, unzip, check permission and test the bioregion's binary files — install_binaries","text":"Infomap version 2.1.0 2.6.0 available now.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Download, unzip, check permission and test the bioregion's binary files — install_binaries","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Boris Leroy (leroy.boris@gmail.com) Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_clusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a map of bioregions — map_clusters","title":"Create a map of bioregions — map_clusters","text":"plot function can used visualise bioregions based bioregion.clusters object combined geometry (sf objects).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_clusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a map of bioregions — map_clusters","text":"","code":"map_clusters(clusters, geometry, write_clusters = FALSE, plot = TRUE, ...)"},{"path":"https://bioRgeo.github.io/bioregion/reference/map_clusters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a map of bioregions — map_clusters","text":"clusters object class bioregion.clusters data.frame. data.frame used, first column represent sites' ID, next column(s) clusters. geometry spatial object can handled sf package. first attribute correspond sites' ID (see Details). write_clusters boolean indicating clusters added geometry. plot boolean indicating plot drawn. ... arguments passed sf::plot()","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_clusters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a map of bioregions — map_clusters","text":"One several maps bioregions plot = TRUE geometry additional clusters' attributes write_clusters = TRUE.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_clusters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a map of bioregions — map_clusters","text":"clusters geometry site IDs correspond. type (.e. character cluster bioregion.clusters object) site clusters included sites geometry.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_clusters.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a map of bioregions — map_clusters","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Boris Leroy (leroy.boris@gmail.com) Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_clusters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a map of bioregions — map_clusters","text":"","code":"data(fishmat) data(fishsf)  net <- similarity(fishmat, metric = \"Simpson\") clu <- netclu_greedy(net) map <- map_clusters(clu, fishsf, write_clusters = TRUE, plot = FALSE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a data.frame from a contingency table — mat_to_net","title":"Create a data.frame from a contingency table — mat_to_net","text":"function creates two- three-columns data.frame row represents interaction two nodes (site species example) optional third column indicating weight interaction (weight = TRUE) contingency table (sites rows species columns example).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a data.frame from a contingency table — mat_to_net","text":"","code":"mat_to_net(mat, weight = FALSE, remove_zeroes = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a data.frame from a contingency table — mat_to_net","text":"mat contingency table (.e. matrix). weight boolean indicating value weights. remove_zeroes boolean determining whether interactions weight equal 0 removed output.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a data.frame from a contingency table — mat_to_net","text":"data.frame row represents interaction two nodes optional third column indicating weight interaction.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a data.frame from a contingency table — mat_to_net","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a data.frame from a contingency table — mat_to_net","text":"","code":"mat <- matrix(sample(1000, 50), 5, 10) rownames(mat) <- paste0(\"Site\", 1:5) colnames(mat) <- paste0(\"Species\", 1:10)  net <- mat_to_net(mat, weight = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a contingency table from a data.frame — net_to_mat","title":"Create a contingency table from a data.frame — net_to_mat","text":"function creates contingency table two- three-columns data.frame row represents interaction two nodes (site species example) optional third column indicating weight interaction (weight = TRUE).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a contingency table from a data.frame — net_to_mat","text":"","code":"net_to_mat(   net,   weight = FALSE,   squared = FALSE,   symmetrical = FALSE,   missing_value = 0 )"},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a contingency table from a data.frame — net_to_mat","text":"net two- three-columns data.frame row represents interaction two nodes (site species example) optional third column indicating weight interaction. weight boolean indicating weight considered squared boolean indicating output matrix squared (nodes rows columns). symmetrical boolean indicating resulting matrix symmetrical (squared = TRUE). Note different weights associated two opposite pairs already present net preserved. missing_value value assign pairs nodes present net (0 default).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a contingency table from a data.frame — net_to_mat","text":"matrix first nodes (first column net) rows second nodes (second column net) columns. Note squared = TRUE rows columns number elements corresponding concatenation unique objects net's first second columns. squared = TRUE matrix can forced symmetrical based upper triangular part matrix.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a contingency table from a data.frame — net_to_mat","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a contingency table from a data.frame — net_to_mat","text":"","code":"net <- data.frame(   Site = c(rep(\"A\", 2), rep(\"B\", 3), rep(\"C\", 2)),   Species = c(\"a\", \"b\", \"a\", \"c\", \"d\", \"b\", \"d\"),   Weight = c(10, 100, 1, 20, 50, 10, 20) )  mat <- net_to_mat(net, weight = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":null,"dir":"Reference","previous_headings":"","what":"Community structure detection in weighted bipartite network via modularity\noptimization — netclu_beckett","title":"Community structure detection in weighted bipartite network via modularity\noptimization — netclu_beckett","text":"function takes bipartite weighted graph computes modules applying Newman’s modularity measure bipartite weighted version .","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Community structure detection in weighted bipartite network via modularity\noptimization — netclu_beckett","text":"","code":"netclu_beckett(   net,   weight = TRUE,   index = names(net)[3],   site_col = 1,   species_col = 2,   return_node_type = \"both\",   forceLPA = FALSE,   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Community structure detection in weighted bipartite network via modularity\noptimization — netclu_beckett","text":"net data.frame representing bipartite network two first columns undirected links pair nodes next column(s) weight links. weight boolean indicating weights considered two columns (see Note). index name number column use weight. default, third column name net used. site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"sites\", \"species\" \"\") returned output (keep_nodes_type=\"\" default). forceLPA boolean indicating even faster pure LPA-algorithm Beckett used? DIRT-LPA, default, less likely get trapped local minimum, slightly slower. Defaults FALSE. algorithm_in_output boolean indicating original output computeModules returned output (see Value). Default TRUE.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Community structure detection in weighted bipartite network via modularity\noptimization — netclu_beckett","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find object class \"moduleWeb\", output computeModules.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Community structure detection in weighted bipartite network via modularity\noptimization — netclu_beckett","text":"function based modularity optimization algorithm provided Stephen Beckett (Beckett 2016)  implemented bipartite package (computeModules).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Community structure detection in weighted bipartite network via modularity\noptimization — netclu_beckett","text":"Beckett designed deal weighted bipartite networks. Note weight = FALSE, weight 1 assigned pair nodes. forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes,\"sites\" preserve sites nodes \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Community structure detection in weighted bipartite network via modularity\noptimization — netclu_beckett","text":"Beckett SJ (2016). “Improved community detection weighted bipartite networks.” Royal Society Open Science, 3(1), 140536.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Community structure detection in weighted bipartite network via modularity\noptimization — netclu_beckett","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Community structure detection in weighted bipartite network via modularity\noptimization — netclu_beckett","text":"","code":"net <- data.frame(   Site = c(rep(\"A\", 2), rep(\"B\", 3), rep(\"C\", 2)),   Species = c(\"a\", \"b\", \"a\", \"c\", \"d\", \"b\", \"d\"),   Weight = c(10, 100, 1, 20, 50, 10, 20))  com <- netclu_beckett(net)"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":null,"dir":"Reference","previous_headings":"","what":"Community structure detection via greedy optimization of modularity — netclu_greedy","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"function finds communities (un)weighted undirected network via greedy optimization modularity.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"","code":"netclu_greedy(   net,   weight = TRUE,   index = names(net)[3],   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. index name number column use weight. default, third column name net used. bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"sites\", \"species\" \"\") returned output (keep_nodes_type=\"\" default). algorithm_in_output boolean indicating original output communities returned output (see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find \"communities\" object, output cluster_fast_greedy.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"function based fast greedy modularity optimization algorithm (Clauset et al. 2004)  implemented igraph package (cluster_fast_greedy).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"sites\" preserve sites nodes \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"Clauset , Newman MEJ, Moore C (2004). “Finding community structure large networks.” Phys. Rev. E, 70, 066111.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_greedy(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_greedy(net_bip, bipartite = TRUE) #> net is not a bioregion.pairwise.metric object.  #> Note that some functions required dissimilarity metrics (hclu_ & nhclu_) and #> others similarity metrics (netclu_).  #> Please carefully check your data before using the clustering functions."},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":null,"dir":"Reference","previous_headings":"","what":"Infomap community finding — netclu_infomap","title":"Infomap community finding — netclu_infomap","text":"function finds communities (un)weighted (un)directed network based Infomap algorithm (https://github.com/mapequation/infomap).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Infomap community finding — netclu_infomap","text":"","code":"netclu_infomap(   net,   weight = TRUE,   index = names(net)[3],   nbmod = 0,   markovtime = 1,   seed = 0,   numtrials = 1,   twolevel = FALSE,   show_hierarchy = FALSE,   directed = FALSE,   bipartite_version = FALSE,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   version = \"2.6.0\",   binpath = \"tempdir\",   path_temp = \"infomap_temp\",   delete_temp = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Infomap community finding — netclu_infomap","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. index name number column use weight. default, third column name net used. nbmod penalize solutions differ number (0 default preferred number modules). markovtime scales link flow change cost moving modules, higher values results fewer modules (default 1). seed random number generator (0 random default). numtrials number trials picking best solution. twolevel boolean indicating algorithm optimize two-level partition network (default multi-level). show_hierarchy boolean specifying hierarchy community identifiable outputs (FALSE default). directed boolean indicating network directed (column 1 column 2). bipartite_version boolean indicating bipartite version Infomap used (see Note). bipartite boolean indicating network bipartite (see Note). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"sites\", \"species\" \"\") returned output (keep_nodes_type=\"\" default). version character indicating Infomap version use. binpath character indicating path bin folder (see install_binaries Details). path_temp character indicating path temporary folder (see Details). delete_temp boolean indicating temporary folder removed (see Details).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Infomap community finding — netclu_infomap","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects clusters: data.frame containing clustering results algorithm slot, users can find following elements: cmd: command line use run Infomap version: Infomap version web: Infomap's GitHub repository","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Infomap community finding — netclu_infomap","text":"Infomap network clustering algorithm based Map equation proposed (Rosvall Bergstrom 2008)  finds communities (un)weighted (un)directed networks. function based C++ version Infomap (https://github.com/mapequation/infomap/releases). function needs binary files run. can installed install_binaries. changed default path bin folder running install_binaries PLEASE MAKE SURE set binpath accordingly. C++ version Infomap generates temporary folders /files stored path_temp folder (\"infomap_temp\" unique timestamp located bin folder binpath default). temporary folder removed default (delete_temp = TRUE). Several version Infomap available package. See install_binaries details.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Infomap community finding — netclu_infomap","text":"Infomap designed deal bipartite networks. use functionality set bipartite_version argument TRUE order approximate two-step random walker (see https://www.mapequation.org/infomap/ information). Note bipartite network can also considered unipartite network (bipartite = TRUE). cases forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"sites\" preserve sites nodes \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Infomap community finding — netclu_infomap","text":"Rosvall M, Bergstrom CT (2008). “Maps random walks complex networks reveal community structure.” Proceedings National Academy Sciences, 105(4), 1118--1123.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Infomap community finding — netclu_infomap","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Infomap community finding — netclu_infomap","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_infomap(net) #> Infomap 2.6.0 is not installed... Please have a look at #>     https//bioRgeo.github.io/bioregion/articles/a1_install_binary_files.html #>     for more details. #> It should be located in /tmp/RtmpPr1oFy/bin/INFOMAP/2.6.0/"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":null,"dir":"Reference","previous_headings":"","what":"Finding communities based on propagating labels — netclu_labelprop","title":"Finding communities based on propagating labels — netclu_labelprop","text":"function finds communities (un)weighted undirected network based propagating labels.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finding communities based on propagating labels — netclu_labelprop","text":"","code":"netclu_labelprop(   net,   weight = TRUE,   index = names(net)[3],   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finding communities based on propagating labels — netclu_labelprop","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. index name number column use weight. default, third column name net used. bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"sites\", \"species\" \"\") returned output (keep_nodes_type=\"\" default). algorithm_in_output boolean indicating original output communities returned output (see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finding communities based on propagating labels — netclu_labelprop","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find \"communities\" object, output cluster_label_prop.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finding communities based on propagating labels — netclu_labelprop","text":"function based propagating labels (Raghavan et al. 2007)  implemented igraph package (cluster_label_prop).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Finding communities based on propagating labels — netclu_labelprop","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"sites\" preserve sites nodes \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Finding communities based on propagating labels — netclu_labelprop","text":"Raghavan UN, Albert R, Kumara S (2007). “Near linear time algorithm detect community structures large-scale networks.” Physical Review E, 76(3), 036106.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finding communities based on propagating labels — netclu_labelprop","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finding communities based on propagating labels — netclu_labelprop","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_labelprop(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_labelprop(net_bip, bipartite = TRUE) #> net is not a bioregion.pairwise.metric object.  #> Note that some functions required dissimilarity metrics (hclu_ & nhclu_) and #> others similarity metrics (netclu_).  #> Please carefully check your data before using the clustering functions."},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":null,"dir":"Reference","previous_headings":"","what":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"function finds communities (un)weighted undirected network based leading eigen vector community matrix.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"","code":"netclu_leadingeigen(   net,   weight = TRUE,   index = names(net)[3],   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. index name number column use weight. default, third column name net used. bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"sites\", \"species\" \"\") returned output (keep_nodes_type=\"\" default). algorithm_in_output boolean indicating original output communities returned output (see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find \"communities\" object, output cluster_leading_eigen.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"function based leading eigenvector community matrix (Newman 2006)  implemented igraph package (cluster_leading_eigen).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"sites\" preserve sites nodes \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"Newman MEJ (2006). “Finding community structure networks using eigenvectors matrices.” Physical Review E, 74(3), 036104.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_leadingeigen(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_leadingeigen(net_bip, bipartite = TRUE) #> net is not a bioregion.pairwise.metric object.  #> Note that some functions required dissimilarity metrics (hclu_ & nhclu_) and #> others similarity metrics (netclu_).  #> Please carefully check your data before using the clustering functions."},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":null,"dir":"Reference","previous_headings":"","what":"Finding communities using the Leiden algorithm — netclu_leiden","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"function finds communities (un)weighted undirected network based Leiden algorithm Traag, van Eck & Waltman.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"","code":"netclu_leiden(   net,   weight = TRUE,   index = names(net)[3],   objective_function = c(\"CPM\", \"modularity\"),   resolution_parameter = 1,   beta = 0.01,   initial_membership = NULL,   n_iterations = 2,   vertex_weights = NULL,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. index name number column use weight. default, third column name net used. objective_function Whether use Constant Potts Model (CPM) modularity. Must either \"CPM\" \"modularity\". resolution_parameter resolution parameter use. Higher resolutions lead smaller communities, lower resolutions lead fewer larger communities. beta Parameter affecting randomness Leiden algorithm. affects refinement step algorithm. initial_membership provided, Leiden algorithm try improve provided membership. argument provided, aglorithm simply starts singleton partition. n_iterations number iterations iterate Leiden algorithm. iteration may improve partition . vertex_weights vertex weights used Leiden algorithm. provided, automatically determined basis objective_function. Please see details function interpret vertex weights. bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"sites\", \"species\" \"\") returned output (keep_nodes_type=\"\" default). algorithm_in_output boolean indicating original output communities returned output (see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find \"communities\" object, output cluster_leiden.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"function based Leiden algorithm (Traag et al. 2019)  implemented igraph package (cluster_leiden).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"sites\" preserve sites nodes \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"Traag VA, Waltman L, Van Eck NJ (2019). “Louvain Leiden: guaranteeing well-connected communities.” Scientific reports, 9(1), 5233. Publisher: Nature Publishing Group UK London.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_leiden(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_leiden(net_bip, bipartite = TRUE) #> net is not a bioregion.pairwise.metric object.  #> Note that some functions required dissimilarity metrics (hclu_ & nhclu_) and #> others similarity metrics (netclu_).  #> Please carefully check your data before using the clustering functions."},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":null,"dir":"Reference","previous_headings":"","what":"Louvain community finding — netclu_louvain","title":"Louvain community finding — netclu_louvain","text":"function finds communities (un)weighted undirected network based Louvain algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Louvain community finding — netclu_louvain","text":"","code":"netclu_louvain(   net,   weight = TRUE,   index = names(net)[3],   lang = \"Cpp\",   q = 0,   c = 0.5,   k = 1,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   binpath = \"tempdir\",   path_temp = \"louvain_temp\",   delete_temp = TRUE,   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Louvain community finding — netclu_louvain","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. index name number column use weight. default, third column name net used. lang string indicating version Louvain used (igraph Cpp, see Details). q quality function used compute partition graph (modularity chosen default, see Details). c parameter Owsinski-Zadrozny quality function (0 1, 0.5 chosen default). k kappa_min value Shi-Malik quality function (must > 0, 1 chosen default). bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"sites\", \"species\" \"\") returned output (keep_nodes_type=\"\" default). binpath character indicating path bin folder (see install_binaries Details). path_temp character indicating path temporary folder (see Details). delete_temp boolean indicating temporary folder removed (see Details). algorithm_in_output boolean indicating original output communities returned output (see Value). Default TRUE.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Louvain community finding — netclu_louvain","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find \"communities\" object, output cluster_louvain lang = \"igraph\" following element lang = \"Cpp\": cmd: command line use run Louvain version: Louvain version web: Louvain's website .","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Louvain community finding — netclu_louvain","text":"Louvain network community detection algorithm proposed (Blondel et al. 2008) . function proposed two implementations function (parameter lang): igraph implementation (cluster_louvain) C++ implementation (https://sourceforge.net/projects/louvain/, version 0.3). latest offers possibility choose among several quality functions, q = 0 classical Newman-Girvan criterion (also called \"Modularity\"), 1 Zahn-Condorcet criterion, 2 Owsinski-Zadrozny criterion (specify value parameter c argument), 3 Goldberg Density criterion, 4 -weighted Condorcet criterion,5 Deviation Indetermination criterion, 6 Deviation Uniformity criterion, 7 Profile Difference criterion, 8\tShi-Malik criterion (specify value kappa_min k argument) 9 Balanced Modularity criterion. C++ version Louvain based version 0.3 (https://sourceforge.net/projects/louvain/). function needs binary files run. can installed install_binaries. changed default path bin folder running install_binaries PLEASE MAKE SURE set binpath accordingly. C++ version Louvain generates temporary folders /files stored path_temp folder (\"louvain_temp\" unique timestamp located bin folder binpath default). temporary folder removed default (delete_temp = TRUE).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Louvain community finding — netclu_louvain","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"sites\" preserve sites nodes \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Louvain community finding — netclu_louvain","text":"Blondel VD, Guillaume JL, Lambiotte R, Mech ELJS (2008). “Fast unfolding communities large networks.” J. Stat. Mech, P10008.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Louvain community finding — netclu_louvain","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Louvain community finding — netclu_louvain","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_louvain(net, lang = \"igraph\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":null,"dir":"Reference","previous_headings":"","what":"OSLOM community finding — netclu_oslom","title":"OSLOM community finding — netclu_oslom","text":"function finds communities (un)weighted (un)directed network based OSLOM algorithm (http://oslom.org/, version 2.4).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OSLOM community finding — netclu_oslom","text":"","code":"netclu_oslom(   net,   weight = TRUE,   index = names(net)[3],   reassign = \"no\",   r = 10,   hr = 50,   seed = 0,   t = 0.1,   cp = 0.5,   directed = FALSE,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   binpath = \"tempdir\",   path_temp = \"oslom_temp\",   delete_temp = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OSLOM community finding — netclu_oslom","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. index name number column use weight. default, third column name net used. reassign string indicating nodes belonging several community reassign method used (see Note). r number runs first hierarchical level (10 default). hr number runs higher hierarchical level (50 default, 0 interested hierarchies). seed random number generator (0 random default). t p-value, default value 0.10, increase value get modules. cp kind resolution parameter used decide taking modules union (default value 0.5, bigger value leads bigger clusters). directed boolean indicating network directed (column 1 column 2). bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"sites\", \"species\" \"\") returned output (keep_nodes_type=\"\" default). binpath character indicating path bin folder (see install_binaries Details). path_temp character indicating path temporary folder (see Details). delete_temp boolean indicating temporary folder removed (see Details).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"OSLOM community finding — netclu_oslom","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects clusters: data.frame containing clustering results algorithm slot, users can find following elements: cmd: command line use run OSLOM version: OSLOM version web: OSLOM's web site","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"OSLOM community finding — netclu_oslom","text":"OSLOM network community detection algorithm proposed (Lancichinetti et al. 2011)  finds statistically significant (overlapping) communities (un)weighted (un)directed networks. function based 2.4 C++ version OSLOM (http://www.oslom.org/software.htm). function needs files run. can installed install_binaries. changed default path bin folder running install_binaries PLEASE MAKE SURE set binpath accordingly. C++ version OSLOM generates temporary folders /files stored path_temp folder (folder \"oslom_temp\" unique timestamp located bin folder binpath default). temporary folder removed default (delete_temp = TRUE).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"OSLOM community finding — netclu_oslom","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e.feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"sites\" preserve sites nodes \"species\" preserve species nodes. Since OSLOM potentially returns overlapping communities propose two methods reassign 'overlapping' nodes randomly reassign = 'random' based closest candidate community reassign = 'simil' (weighted networks, case closest candidate community determined average similarity). default reassign = '' information provided. number partitions depend number overlapping modules (three). suffix '_semel', '_bis' '_ter' added column names. first partition ('_semel') assigns module node. value 0 second ('_bis') third ('_ter') columns indicates overlapping module found node (.e. non-overlapping nodes).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"OSLOM community finding — netclu_oslom","text":"Lancichinetti , Radicchi F, Ramasco JJ, Fortunato S (2011). “Finding statistically significant communities networks.” PloS one, 6(4).","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"OSLOM community finding — netclu_oslom","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OSLOM community finding — netclu_oslom","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_oslom(net) #> OSLOM is not installed... Please have a look at #>               https://bioRgeo.github.io/bioregion/articles/a1_install_binary_files.html #>               for more details. #> It should be located in /tmp/RtmpPr1oFy/bin/OSLOM/"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Community structure detection via short random walks — netclu_walktrap","title":"Community structure detection via short random walks — netclu_walktrap","text":"function finds communities (un)weighted undirected network via short random walks.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Community structure detection via short random walks — netclu_walktrap","text":"","code":"netclu_walktrap(   net,   weight = TRUE,   index = names(net)[3],   steps = 4,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Community structure detection via short random walks — netclu_walktrap","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. index name number column use weight. default, third column name net used. steps length random walks perform. bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"sites\", \"species\" \"\") returned output (keep_nodes_type=\"\" default). algorithm_in_output boolean indicating original output communities returned output (see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Community structure detection via short random walks — netclu_walktrap","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find \"communities\" object, output cluster_walktrap.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Community structure detection via short random walks — netclu_walktrap","text":"function based random walks (Pons Latapy 2005)  implemented igraph package (cluster_walktrap).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Community structure detection via short random walks — netclu_walktrap","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"sites\" preserve sites nodes \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Community structure detection via short random walks — netclu_walktrap","text":"Pons P, Latapy M (2005). “Computing Communities Large Networks Using Random Walks.” Yolum , Güngör T, Gürgen F, Özturan C (eds.), Computer Information Sciences - ISCIS 2005,  Lecture Notes Computer Science, 284--293.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Community structure detection via short random walks — netclu_walktrap","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Community structure detection via short random walks — netclu_walktrap","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_walktrap(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_walktrap(net_bip, bipartite = TRUE) #> net is not a bioregion.pairwise.metric object.  #> Note that some functions required dissimilarity metrics (hclu_ & nhclu_) and #> others similarity metrics (netclu_).  #> Please carefully check your data before using the clustering functions."},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":null,"dir":"Reference","previous_headings":"","what":"Non hierarchical clustering: CLARA — nhclu_clara","title":"Non hierarchical clustering: CLARA — nhclu_clara","text":"function performs non hierarchical clustering basis dissimilarity partitioning around medoids, using Clustering Large Applications (CLARA) algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non hierarchical clustering: CLARA — nhclu_clara","text":"","code":"nhclu_clara(   dissimilarity,   index = names(dissimilarity)[3],   n_clust = NULL,   maxiter = 0L,   initializer = \"LAB\",   fasttol = 1,   numsamples = 5L,   sampling = 0.25,   independent = FALSE,   seed = 123456789L )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non hierarchical clustering: CLARA — nhclu_clara","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), next column(s) dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. n_clust integer vector integers specifying requested number(s) clusters. maxiter integer defining maximum number iterations. initializer character string, either 'BUILD' (used classic PAM algorithm) 'LAB' (linear approximative BUILD). fasttol Positive numeric defining tolerance fast swapping behavior, set 1 default. numsamples Positive integer defining number samples draw. sampling Positive numeric defining sampling rate. independent Logical, FALSE default meaning previous medoids kept next sample. seed integer define generator random numbers.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non hierarchical clustering: CLARA — nhclu_clara","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects clusters: data.frame containing clustering results","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non hierarchical clustering: CLARA — nhclu_clara","text":"Based fastkmedoids R package.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Non hierarchical clustering: CLARA — nhclu_clara","text":"Schubert E, Rousseeuw PJ (2019). “Faster k-Medoids Clustering: Improving PAM, CLARA, CLARANS Algorithms.” Similarity Search Applications, 11807, 171--187.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non hierarchical clustering: CLARA — nhclu_clara","text":"Pierre Denelle (pierre.denelle@gmail.com), Boris Leroy (leroy.boris@gmail.com), Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non hierarchical clustering: CLARA — nhclu_clara","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"all\")  clust1 <- nhclu_clara(dissim, index = \"Simpson\", n_clust = 5)  partition_metrics(clust1, dissimilarity = dissim, eval_metric = \"pc_distance\") #> Computing similarity-based metrics... #>   - pc_distance OK #> Partition metrics: #>  - 1  partition(s) evaluated #>  - Range of clusters explored: from  4  to  4  #>  - Requested metric(s):  pc_distance  #>  - Metric summary: #>      pc_distance #> Min    0.2791078 #> Mean   0.2791078 #> Max    0.2791078 #>  #> Access the data.frame of metrics with your_object$evaluation_df"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":null,"dir":"Reference","previous_headings":"","what":"Non hierarchical clustering: CLARANS — nhclu_clarans","title":"Non hierarchical clustering: CLARANS — nhclu_clarans","text":"function performs non hierarchical clustering basis dissimilarity partitioning around medoids, using Clustering Large Applications based RANdomized Search (CLARANS) algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non hierarchical clustering: CLARANS — nhclu_clarans","text":"","code":"nhclu_clarans(   dissimilarity,   index = names(dissimilarity)[3],   n_clust = NULL,   numlocal = 2L,   maxneighbor = 0.025,   seed = 123456789L )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non hierarchical clustering: CLARANS — nhclu_clarans","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), next column(s) dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. n_clust integer vector integers specifying requested number(s) clusters. numlocal integer defining number samples draw. maxneighbor positive numeric defining sampling rate. seed integer define generator random numbers.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non hierarchical clustering: CLARANS — nhclu_clarans","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects clusters: data.frame containing clustering results","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non hierarchical clustering: CLARANS — nhclu_clarans","text":"Based fastkmedoids R package.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Non hierarchical clustering: CLARANS — nhclu_clarans","text":"Schubert E, Rousseeuw PJ (2019). “Faster k-Medoids Clustering: Improving PAM, CLARA, CLARANS Algorithms.” Similarity Search Applications, 11807, 171--187.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non hierarchical clustering: CLARANS — nhclu_clarans","text":"Pierre Denelle (pierre.denelle@gmail.com), Boris Leroy (leroy.boris@gmail.com), Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non hierarchical clustering: CLARANS — nhclu_clarans","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"all\")  clust1 <- nhclu_clarans(dissim, index = \"Simpson\", n_clust = 5)  partition_metrics(clust1, dissimilarity = dissim, eval_metric = \"pc_distance\") #> Computing similarity-based metrics... #>   - pc_distance OK #> Partition metrics: #>  - 1  partition(s) evaluated #>  - Range of clusters explored: from  5  to  5  #>  - Requested metric(s):  pc_distance  #>  - Metric summary: #>      pc_distance #> Min    0.7465339 #> Mean   0.7465339 #> Max    0.7465339 #>  #> Access the data.frame of metrics with your_object$evaluation_df"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":null,"dir":"Reference","previous_headings":"","what":"dbscan clustering — nhclu_dbscan","title":"dbscan clustering — nhclu_dbscan","text":"function performs non hierarchical clustering basis dissimilarity Density-based Spatial Clustering Applications Noise (DBSCAN)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dbscan clustering — nhclu_dbscan","text":"","code":"nhclu_dbscan(   dissimilarity,   index = names(dissimilarity)[3],   minPts = NULL,   eps = NULL,   plot = TRUE,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"dbscan clustering — nhclu_dbscan","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), next column(s) dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. minPts numeric value vector numeric values specifying minPts argument dbscan::dbscan()). minPts minimum number points form dense region. default, set natural logarithm number sites dissimilarity. See details guidance choosing parameter. eps numeric value vector numeric values specifying eps argument dbscan::dbscan()). eps specifies similar points considered part cluster. See details guidance choosing parameter. plot boolean indicating  k-nearest neighbor distance plot plotted. ... can add arguments passed dbscan() (see dbscan::dbscan())","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"dbscan clustering — nhclu_dbscan","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects clusters: data.frame containing clustering results","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"dbscan clustering — nhclu_dbscan","text":"dbscan (Density-based spatial clustering applications noise) clustering algorithm clusters points basis density neighbours around data points. necessitates two main arguments, minPts, stands minimum number points identify core, eps, radius find neighbors. minPts eps defined user, straightforward. recommend reading help dbscan::dbscan()) learn set arguments, well paper (Hahsler et al. 2019) . Note clusters value 0 points deemed noise algorithm. default function select values minPts eps. However, values can inadequate users advised tune values running function multiple times. Choosing minPts: many points necessary make cluster? .e., minimum number sites expect bioregion? Set value sufficiently large dataset expectations. Choosing eps: similar sites cluster?  eps small, majority points considered distinct clustered (.e., considered noise)? value high, clusters merge together. value eps depends minPts argument, literature recommends choose eps identifying knee k-nearest neighbor distance plot. default function try automatically find knee curve, result uncertain, user inspect graph modify dbscan_eps accordingly.explore eps values, follow recommendation function launch first time without defining eps. , adjust depending clustering results.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"dbscan clustering — nhclu_dbscan","text":"Boris Leroy (leroy.boris@gmail.com), Pierre Denelle (pierre.denelle@gmail.com) Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"dbscan clustering — nhclu_dbscan","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"all\")  clust1 <- nhclu_dbscan(dissim, index = \"Simpson\") #> Trying to find a knee in the curve to search for an optimal eps value... #>        NOTE: this automatic identification of the knee may not work properly #>        if the curve has knees and elbows. Please adjust eps manually by #>        inspecting the curve, identifying a knee as follows: #>  #>                            / #>                  curve    / #>               ___________/  <- knee #>   elbow ->   / #>             / #>            /  clust2 <- nhclu_dbscan(dissim, index = \"Simpson\", eps = 0.2)  clust3 <- nhclu_dbscan(dissim, index = \"Simpson\", minPts = c(5, 10, 15, 20),      eps = c(.1, .15, .2, .25, .3))"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":null,"dir":"Reference","previous_headings":"","what":"Non hierarchical clustering: k-means analysis — nhclu_kmeans","title":"Non hierarchical clustering: k-means analysis — nhclu_kmeans","text":"function performs non hierarchical clustering basis dissimilarity k-means analysis.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non hierarchical clustering: k-means analysis — nhclu_kmeans","text":"","code":"nhclu_kmeans(   dissimilarity,   index = names(dissimilarity)[3],   n_clust = NULL,   iter_max = 10,   nstart = 10,   algorithm = \"Hartigan-Wong\" )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non hierarchical clustering: k-means analysis — nhclu_kmeans","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), next column(s) dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. n_clust integer vector integers specifying requested number(s) clusters iter_max integer specifying maximum number iterations kmeans method (see stats::kmeans()) nstart integer specifying many random sets n_clust selected starting points kmeans analysis (see stats::kmeans()) algorithm character string specifying algorithm use kmean (see stats::kmeans()). Available options Hartigan-Wong, Lloyd, Forgy MacQueen.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non hierarchical clustering: k-means analysis — nhclu_kmeans","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects clusters: data.frame containing clustering results","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non hierarchical clustering: k-means analysis — nhclu_kmeans","text":"method partitions data k groups sum squares euclidean distances points assigned cluster centers minimized. k-means applied directly dissimilarity/beta-diversity metrics, distances euclidean. Therefore, requires first transform dissimilarity matrix Principal Coordinate Analysis (using function ape::pcoa()), applying k-means coordinates points PCoA. makes additional transformation initial matrix dissimilarity, partitioning around medoids method preferred (nhclu_pam())","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non hierarchical clustering: k-means analysis — nhclu_kmeans","text":"Boris Leroy (leroy.boris@gmail.com), Pierre Denelle (pierre.denelle@gmail.com) Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non hierarchical clustering: k-means analysis — nhclu_kmeans","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  comnet <- mat_to_net(comat)  dissim <- dissimilarity(comat, metric = \"all\")  clust1 <- nhclu_kmeans(dissim, n_clust = 2:10, index = \"Simpson\") clust2 <- nhclu_kmeans(dissim, n_clust = 2:15, index = \"Simpson\") partition_metrics(clust2, dissimilarity = dissim,                   eval_metric = \"pc_distance\") #> Computing similarity-based metrics... #>   - pc_distance OK #> Partition metrics: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Requested metric(s):  pc_distance  #>  - Metric summary: #>      pc_distance #> Min    0.4084475 #> Mean   0.8456187 #> Max    0.9865798 #>  #> Access the data.frame of metrics with your_object$evaluation_df  partition_metrics(clust2, net = comnet, species_col = \"Node2\",                   site_col = \"Node1\", eval_metric = \"avg_endemism\") #> Computing composition-based metrics... #>   - avg_endemism OK #> Partition metrics: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Requested metric(s):  avg_endemism  #>  - Metric summary: #>      avg_endemism #> Min             0 #> Mean            0 #> Max             0 #>  #> Access the data.frame of metrics with your_object$evaluation_df #> Details of endemism % for each partition are available in  #>         your_object$endemism_results"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":null,"dir":"Reference","previous_headings":"","what":"Non hierarchical clustering: partitioning around medoids — nhclu_pam","title":"Non hierarchical clustering: partitioning around medoids — nhclu_pam","text":"function performs non hierarchical clustering basis dissimilarity partitioning around medoids.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non hierarchical clustering: partitioning around medoids — nhclu_pam","text":"","code":"nhclu_pam(   dissimilarity,   index = names(dissimilarity)[3],   n_clust = NULL,   nstart = if (variant == \"faster\") 1 else NA,   variant = \"faster\",   cluster_only = FALSE,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non hierarchical clustering: partitioning around medoids — nhclu_pam","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), next column(s) dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. n_clust integer vector integers specifying requested number(s) clusters. nstart integer specifying number random “starts” pam algorithm. default, 1 (\"faster\" variant). variant character string specifying variant pam use, default \"faster\". Available options original, o_1, o_2, f_3, f_4, f_5 fasterSee cluster::pam() details. cluster_only boolean specifying clustering returned cluster::pam() function (efficient). ... can add arguments passed pam() (see cluster::pam())","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non hierarchical clustering: partitioning around medoids — nhclu_pam","text":"list class bioregion.clusters five slots: name: character string containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects clusters: data.frame containing clustering results","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non hierarchical clustering: partitioning around medoids — nhclu_pam","text":"method partitions data chosen number cluster basis input dissimilarity matrix. robust k-means minimizes sum dissimilarity cluster centres points assigned cluster - whereas k-means approach minimizes sum squared euclidean distances (thus k-means applied directly input dissimilarity matrix distances euclidean).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Non hierarchical clustering: partitioning around medoids — nhclu_pam","text":"Kaufman L, Rousseeuw PJ (2009). “Finding groups data: introduction cluster analysis.” & Sons. JW (ed.), Finding groups data: introduction cluster analysis..","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non hierarchical clustering: partitioning around medoids — nhclu_pam","text":"Boris Leroy (leroy.boris@gmail.com), Pierre Denelle (pierre.denelle@gmail.com) Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non hierarchical clustering: partitioning around medoids — nhclu_pam","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  comnet <- mat_to_net(comat) dissim <- dissimilarity(comat, metric = \"all\")  clust1 <- nhclu_pam(dissim, n_clust = 2:10, index = \"Simpson\") clust2 <- nhclu_pam(dissim, n_clust = 2:15, index = \"Simpson\") partition_metrics(clust2, dissimilarity = dissim, eval_metric = \"pc_distance\") #> Computing similarity-based metrics... #>   - pc_distance OK #> Partition metrics: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Requested metric(s):  pc_distance  #>  - Metric summary: #>      pc_distance #> Min    0.1879241 #> Mean   0.6903983 #> Max    0.9692280 #>  #> Access the data.frame of metrics with your_object$evaluation_df partition_metrics(clust2, net = comnet, species_col = \"Node2\",                    site_col = \"Node1\", eval_metric = \"avg_endemism\") #> Computing composition-based metrics... #>   - avg_endemism OK #> Partition metrics: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Requested metric(s):  avg_endemism  #>  - Metric summary: #>      avg_endemism #> Min   0.000000000 #> Mean  0.003809524 #> Max   0.040000000 #>  #> Access the data.frame of metrics with your_object$evaluation_df #> Details of endemism % for each partition are available in  #>         your_object$endemism_results"},{"path":"https://bioRgeo.github.io/bioregion/reference/partition_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate metrics for one or several partitions — partition_metrics","title":"Calculate metrics for one or several partitions — partition_metrics","text":"function aims calculating metrics one several partitions, usually outputs netclu_, hclu_ nhclu_ functions. Metrics may require users provide either similarity dissimilarity matrix, provide initial species-site table.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/partition_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate metrics for one or several partitions — partition_metrics","text":"","code":"partition_metrics(   cluster_object,   dissimilarity = NULL,   dissimilarity_index = NULL,   net = NULL,   site_col = 1,   species_col = 2,   eval_metric = c(\"pc_distance\", \"anosim\", \"avg_endemism\", \"tot_endemism\") )"},{"path":"https://bioRgeo.github.io/bioregion/reference/partition_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate metrics for one or several partitions — partition_metrics","text":"cluster_object bioregion.clusters object dissimilarity dist object bioregion.pairwise.metric object (output similarity_to_dissimilarity()). Necessary eval_metric includes pc_distance tree bioregion.hierar.tree object dissimilarity_index character string indicating dissimilarity (beta-diversity) index used case dist data.frame multiple dissimilarity indices net species-site network (.e., bipartite network). provided eval_metric includes \"avg_endemism\" \"tot_endemism\" site_col name number column site nodes (.e. primary nodes). provided eval_metric includes \"avg_endemism\" \"tot_endemism\" species_col name number column species nodes (.e. feature nodes). provided eval_metric includes \"avg_endemism\" \"tot_endemism\" eval_metric character string vector character strings indicating metric(s) calculated investigate effect different number clusters. Available options: \"pc_distance\", \"anosim\", \"avg_endemism\" \"tot_endemism\"","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/partition_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate metrics for one or several partitions — partition_metrics","text":"list class bioregion.partition.metrics two three elements: args: input arguments evaluation_df: data.frame containing eval_metric explored numbers clusters endemism_results: endemism calculations requested, list endemism results partition","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/partition_metrics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate metrics for one or several partitions — partition_metrics","text":"Evaluation metrics: pc_distance: metric method used (Holt et al. 2013) . ratio -cluster sum dissimilarity (beta-diversity) versus total sum dissimilarity (beta-diversity) full dissimilarity matrix. words, calculated basis two elements. First, total sum dissimilarity calculated summing entire dissimilarity matrix (dist). Second, -cluster sum dissimilarity calculated follows: given number cluster, dissimilarity summed clusters, within clusters. efficiently, pairs sites within clusters dissimilarity set zero dissimilarity matrix, dissimilarity matrix summed. pc_distance ratio obtained dividing -cluster sum dissimilarity total sum dissimilarity. anosim: metric statistic used Analysis Similarities, suggested (Castro-Insua et al. 2018)  (see vegan::anosim()). compares -cluster dissimilarities within-cluster dissimilarities. based based difference mean ranks groups within groups following formula: \\(R = (r_B - r_W)/(N (N-1) / 4)\\), \\(r_B\\) \\(r_W\\) average ranks within clusters respectively, \\(N\\) total number sites. Note function estimate significance , computes statistic - significance testing see vegan::anosim(). avg_endemism: metric average percentage endemism clusters recommended (Kreft Jetz 2010) . Calculated follows: \\(End_{mean} = \\frac{\\sum_{=1}^K E_i / S_i}{K}\\) \\(E_i\\) number endemic species cluster , \\(S_i\\) number species cluster , K maximum number clusters. tot_endemism: metric total endemism across clusters, recommended (Kreft Jetz 2010) . Calculated follows: \\(End_{tot} = \\frac{E}{C}\\)\\(E\\) total number endemics (.e., species found one cluster) \\(C\\) number non-endemic species.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/partition_metrics.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate metrics for one or several partitions — partition_metrics","text":"Castro-Insua , Gómez-Rodríguez C, Baselga (2018). “Dissimilarity measures affected richness differences yield biased delimitations biogeographic realms.” Nature Communications, 9(1), 9--11. Ficetola GF, Mazel F, Thuiller W (2017). “Global determinants zoogeographical boundaries.” Nature Ecology & Evolution, 1, 0089. Holt BG, Lessard J, Borregaard MK, Fritz SA, Araújo MB, Dimitrov D, Fabre P, Graham CH, Graves GR, Jønsson Ka, Nogués-Bravo D, Wang Z, Whittaker RJ, Fjeldså J, Rahbek C (2013). “update Wallace's zoogeographic regions world.” Science, 339(6115), 74--78. Kreft H, Jetz W (2010). “framework delineating biogeographical regions based species distributions.” Journal Biogeography, 37, 2029--2053. Langfelder P, Zhang B, Horvath S (2008). “Defining clusters hierarchical cluster tree: Dynamic Tree Cut package R.” BIOINFORMATICS, 24(5), 719--720.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/partition_metrics.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate metrics for one or several partitions — partition_metrics","text":"Boris Leroy (leroy.boris@gmail.com), Maxime Lenormand (maxime.lenormand@inrae.fr) Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/partition_metrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate metrics for one or several partitions — partition_metrics","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  comnet <- mat_to_net(comat)  dissim <- dissimilarity(comat, metric = \"all\")  # User-defined number of clusters tree1 <- hclu_hierarclust(dissim, n_clust = 2:20, index = \"Simpson\") #> Randomizing the dissimilarity matrix with 30 trials #>  -- range of cophenetic correlation coefficients among #>                      trials: 0.42 - 0.52 #> Optimal tree has a 0.52 cophenetic correlation coefficient with the initial dissimilarity #>       matrix #> Warning: The requested number of cluster could not be found #>                          for k = 18. Closest number found: 17 #> Warning: The requested number of cluster could not be found #>                          for k = 19. Closest number found: 17 #> Warning: The requested number of cluster could not be found #>                          for k = 20. Closest number found: 17 tree1 #> Clustering results for algorithm : hierarchical_clustering  #> \t(hierarchical clustering based on a dissimilarity matrix) #>  - Number of sites:  20  #>  - Name of dissimilarity metric:  Simpson  #>  - Tree construction method:  average  #>  - Randomization of the dissimilarity matrix:  yes, number of trials 30  #>  - Cophenetic correlation coefficient:  0.518  #>  - Number of clusters requested by the user:  2 3 4 5 6 7 8 9 10 11 ... (with 9 more values)  #> Clustering results: #>  - Number of partitions:  19  #>  - Partitions are hierarchical #>  - Number of clusters:  2 3 4 5 6 7 8 9 10 11 ... (with 9 more values)  #>  - Height of cut of the hierarchical tree: 0.125 0.109 0.102 0.094 0.086 0.078 0.062 0.061 0.055 0.051 ... (with 9 more values)   a <- partition_metrics(tree1, dissimilarity = dissim, net = comnet,                        site_col = \"Node1\", species_col = \"Node2\",                        eval_metric = c(\"tot_endemism\", \"avg_endemism\",                                       \"pc_distance\", \"anosim\")) #> Computing similarity-based metrics... #>   - pc_distance OK #>   - anosim OK #> Computing composition-based metrics... #>   - avg_endemism OK #>   - tot_endemism OK a #> Partition metrics: #>  - 19  partition(s) evaluated #>  - Range of clusters explored: from  2  to  17  #>  - Requested metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  - Metric summary: #>      tot_endemism avg_endemism pc_distance    anosim #> Min    0.00000000  0.000000000   0.1490616 0.4710095 #> Mean   0.01894737  0.009122807   0.8599188 0.7794349 #> Max    0.32000000  0.160000000   1.0000000 0.9786096 #>  #> Access the data.frame of metrics with your_object$evaluation_df #> Details of endemism % for each partition are available in  #>         your_object$endemism_results"},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute similarity metrics between sites based on species composition — similarity","title":"Compute similarity metrics between sites based on species composition — similarity","text":"function creates data.frame row provides one several similarity metric(s) pair sites co-occurrence matrix sites rows species columns.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute similarity metrics between sites based on species composition — similarity","text":"","code":"similarity(comat, metric = \"Simpson\", formula = NULL, method = \"prodmat\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute similarity metrics between sites based on species composition — similarity","text":"comat co-occurrence matrix sites rows species columns. metric vector string(s) indicating metrics chose (see Details). Available options abc, ABC, Jaccard, Jaccardturn, Sorensen, Simpson,  Bray, Brayturn Euclidean. \"\" specified, metrics calculated. Can set NULL formula used. formula vector string(s) formula based , b, c, , B, C quantities (see Details). formula set NULL default. method string indicating method used compute abc (see Details). method = \"prodmat\" default efficient can greedy memory method = \"loops\" less efficient less greedy memory.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute similarity metrics between sites based on species composition — similarity","text":"data.frame additional class bioregion.pairwise.metric, providing one several similarity metric(s) pair sites. two first columns represent pair sites. One column per similarity metric provided metric formula except metric abc ABC stored three columns (one letter).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute similarity metrics between sites based on species composition — similarity","text":"number species shared pair sites, b species present first site c species present second site. \\(Jaccard = 1 - (b + c) / (+ b + c)\\) \\(Jaccardturn = 1 - 2min(b, c) / (+ 2min(b, c))\\) (Baselga 2012) \\(Sorensen = 1 - (b + c) / (2a + b + c)\\) \\(Simpson = 1 - min(b, c) / (+ min(b, c))\\) abundances data available, Bray-Curtis turnover component can also computed following equation: \\(Bray = 1 - (B + C) / (2A + B + C)\\) \\(Brayturn = 1 - min(B, C)/(+ min(B, C))\\) (Baselga 2013) sum lesser values common species shared pair sites. B C total number specimens counted sites minus . formula can used compute customized metrics terms , b, c, , B, C. example formula = c(\"1 - (b + c) / (+ b + c)\", \"1 - (B + C) / (2*+ B + C)\") compute Jaccard Bray-Curtis similarity metrics, respectively. Euclidean computes Euclidean similarity pair site following equation: \\(Euclidean = 1 / (1 + d_{ij})\\) \\(d_{ij}\\) Euclidean distance site site j terms species composition.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute similarity metrics between sites based on species composition — similarity","text":"Baselga (2012). “Relationship Species Replacement, Dissimilarity Derived Nestedness, Nestedness.” Global Ecology Biogeography, 21(12), 1223--1232. Baselga (2013). “Separating two components abundance-based dissimilarity: balanced changes abundance vs. abundance gradients.” Methods Ecology Evolution, 4(6), 552--557.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute similarity metrics between sites based on species composition — similarity","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Pierre Denelle (pierre.denelle@gmail.com) Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute similarity metrics between sites based on species composition — similarity","text":"","code":"comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  sim <- similarity(comat, metric = c(\"abc\", \"ABC\", \"Simpson\", \"Brayturn\"))  sim <- similarity(comat, metric = \"all\", formula = \"1 - (b + c) / (a + b + c)\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"function converts data.frame similarity metrics sites dissimilarity metrics (beta diversity).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"","code":"similarity_to_dissimilarity(similarity, include_formula = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"similarity output object similarity() dissimilarity_to_similarity(). include_formula boolean indicating metrics based formula converted (see Details). argument set TRUE default.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"data.frame additional class bioregion.pairwise.metric, providing dissimilarity metric(s) pair sites based similarity object.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"behavior function changes depending column names. Columns Site1 Site2 copied identically. columns called , b, c, , B, C also copied identically. columns based formula (argument formula similarity()) original list similarity metrics (argument metrics similarity()) argument include_formula set FALSE, also copied identically. Otherwise going converted like columns (default behavior). column called Euclidean, distance calculated based following formula: \\(Euclidean distance = (1 - Euclidean similarity) / Euclidean similarity\\) Otherwise, columns transformed dissimilarity following formula: \\(dissimilarity = 1 - similarity\\)","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"Maxime Lenormand (maxime.lenormand@inrae.fr), Boris Leroy (leroy.boris@gmail.com) Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"","code":"comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  simil <- similarity(comat, metric = \"all\") simil #> Data.frame of similarity between sites #>  - Total number of sites:  5  #>  - Total number of species:  10  #>  - Number of rows:  10  #>  - Number of similarity metrics:  7  #>  #>  #>    Site1 Site2   Jaccard Jaccardturn  Sorensen   Simpson      Bray  Brayturn #> 2  Site1 Site2 0.9000000   1.0000000 0.9473684 1.0000000 0.1751394 0.2335958 #> 3  Site1 Site3 0.9000000   1.0000000 0.9473684 1.0000000 0.1979414 0.1991503 #> 4  Site1 Site4 0.6666667   1.0000000 0.8000000 1.0000000 0.2497704 1.0000000 #> 5  Site1 Site5 0.8000000   0.8000000 0.8888889 0.8888889 0.4909688 0.5131579 #> 8  Site2 Site3 1.0000000   1.0000000 1.0000000 1.0000000 0.4018506 0.5319335 #> 9  Site2 Site4 0.6000000   1.0000000 0.7500000 1.0000000 0.1314488 0.3419118 #> 10 Site2 Site5 0.9000000   1.0000000 0.9473684 1.0000000 0.3998616 0.5056868 #> 14 Site3 Site4 0.6000000   1.0000000 0.7500000 1.0000000 0.1113689 0.4411765 #> 15 Site3 Site5 0.9000000   1.0000000 0.9473684 1.0000000 0.3084550 0.3203661 #> 20 Site4 Site5 0.5000000   0.7142857 0.6666667 0.8333333 0.1524752 0.5661765 #>       Euclidean  a b c   A    B    C #> 2  0.0009510900  9 0 1 267 1639  876 #> 3  0.0007520159  9 0 1 375 1531 1508 #> 4  0.0011481223  6 3 0 272 1634    0 #> 5  0.0010504242  8 1 1 897 1009  851 #> 8  0.0012019083 10 0 0 608  535 1275 #> 9  0.0021447947  6 4 0  93 1050  179 #> 10 0.0009837141  9 1 0 578  565 1170 #> 14 0.0009586885  6 4 0 120 1763  152 #> 15 0.0007901663  9 1 0 560 1323 1188 #> 20 0.0010301243  5 1 4 154  118 1594  dissimilarity <- similarity_to_dissimilarity(simil) dissimilarity #> Data.frame of dissimilarity between sites #>  - Total number of sites:  5  #>  - Total number of species:  10  #>  - Number of rows:  10  #>  - Number of dissimilarity metrics:  7  #>  #>  #>    Site1 Site2   Jaccard Jaccardturn   Sorensen   Simpson      Bray  Brayturn #> 2  Site1 Site2 0.1000000   0.0000000 0.05263158 0.0000000 0.8248606 0.7664042 #> 3  Site1 Site3 0.1000000   0.0000000 0.05263158 0.0000000 0.8020586 0.8008497 #> 4  Site1 Site4 0.3333333   0.0000000 0.20000000 0.0000000 0.7502296 0.0000000 #> 5  Site1 Site5 0.2000000   0.2000000 0.11111111 0.1111111 0.5090312 0.4868421 #> 8  Site2 Site3 0.0000000   0.0000000 0.00000000 0.0000000 0.5981494 0.4680665 #> 9  Site2 Site4 0.4000000   0.0000000 0.25000000 0.0000000 0.8685512 0.6580882 #> 10 Site2 Site5 0.1000000   0.0000000 0.05263158 0.0000000 0.6001384 0.4943132 #> 14 Site3 Site4 0.4000000   0.0000000 0.25000000 0.0000000 0.8886311 0.5588235 #> 15 Site3 Site5 0.1000000   0.0000000 0.05263158 0.0000000 0.6915450 0.6796339 #> 20 Site4 Site5 0.5000000   0.2857143 0.33333333 0.1666667 0.8475248 0.4338235 #>    Euclidean  a b c   A    B    C #> 2  1050.4252  9 0 1 267 1639  876 #> 3  1328.7592  9 0 1 375 1531 1508 #> 4   869.9874  6 3 0 272 1634    0 #> 5   950.9963  8 1 1 897 1009  851 #> 8   831.0102 10 0 0 608  535 1275 #> 9   465.2451  6 4 0  93 1050  179 #> 10 1015.5555  9 1 0 578  565 1170 #> 14 1042.0916  6 4 0 120 1763  152 #> 15 1264.5564  9 1 0 560 1323 1188 #> 20  969.7567  5 1 4 154  118 1594"},{"path":"https://bioRgeo.github.io/bioregion/reference/vegedf.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","title":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","text":"dataset containing abundance 3,697 species 715 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegedf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","text":"","code":"vegedf"},{"path":"https://bioRgeo.github.io/bioregion/reference/vegedf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","text":"data.frame 460,878 rows 3 columns: Site Unique site identifier (corresponding field ID vegesp). Species Unique species identifier. Abundance Species abundance","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegedf.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","text":"doi:10.1002/ece3.4718","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegemat.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","title":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","text":"dataset containing abundance 3,697 species 715 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegemat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","text":"","code":"vegemat"},{"path":"https://bioRgeo.github.io/bioregion/reference/vegemat.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","text":"co-occurrence matrix sites rows species columns. element matrix represents abundance species site.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegemat.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","text":"doi:10.1002/ece3.4718","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegesf.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","title":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","text":"dataset containing geometry 715 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegesf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","text":"","code":"vegesf"},{"path":"https://bioRgeo.github.io/bioregion/reference/vegesf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","text":"ID Unique site identifier. geometry Geometry site.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegesf.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","text":"doi:10.1002/ece3.4718","code":""},{"path":"https://bioRgeo.github.io/bioregion/news/index.html","id":"bioregion-103-developmentgithub-version","dir":"Changelog","previous_headings":"","what":"bioregion 1.0.3 (development/github version)","title":"bioregion 1.0.3 (development/github version)","text":"Added generic function maintain attributes bioregion.pairwise.metric objects + keep track number sites species","code":""},{"path":"https://bioRgeo.github.io/bioregion/news/index.html","id":"bioregion-102-developmentgithub-version","dir":"Changelog","previous_headings":"","what":"bioregion 1.0.2 (development/github version)","title":"bioregion 1.0.2 (development/github version)","text":"list changes made development/github version package bioregion 1.0.0 (CRAN release 2023-04-15) next CRAN release. Functions added: nhclu_clara(), nhclu_clarans() corresponding vignettes edited document new functions. Modification way ‘bioregion.pairwise.metric’ object controlled. Allow () select ‘formula metrics’ similarity_dissimilarity_conversion() new argument “include_formula”. Allow negative values similarity() Euclidean metric.","code":""},{"path":"https://bioRgeo.github.io/bioregion/news/index.html","id":"bioregion-100","dir":"Changelog","previous_headings":"","what":"bioregion 1.0.0","title":"bioregion 1.0.0","text":"First release CRAN","code":""}]
