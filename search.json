[{"path":"https://bioRgeo.github.io/bioregion/TODO.html","id":"new-functions","dir":"","previous_headings":"","what":"New functions","title":"NA","text":"Add fuzzy clustering methods from_abcABC (compute metrics abc /ABC). reassign_cluster (assign reassign cluster based partition (dis)similarity metric) + spatial coherence (reassignment sites) between_bioregions_metrics() => ‘beta-diversity’ bioregions, output: matrix/network, produces results like Lenormand et al. 2019 Function visualize network (maybe visNetwork()) between_bioregions_metrics()","code":""},{"path":"https://bioRgeo.github.io/bioregion/TODO.html","id":"new-features","dir":"","previous_headings":"","what":"New features","title":"NA","text":"Allow launch OPTICS vector parameter values (kmeans). Parallelize clu_ functions. https://stats.stackexchange.com/questions/260487/adjusted-rand-index-vs-adjusted-mutual-information Code IHCT Rcpp","code":""},{"path":"https://bioRgeo.github.io/bioregion/TODO.html","id":"miscellaneous","dir":"","previous_headings":"","what":"Miscellaneous","title":"NA","text":"data-raw ?","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a1_install_binary_files.html","id":"run-install_binaries","dir":"Articles","previous_headings":"","what":"Run install_binaries()","title":"1. Installation of the binary files","text":"function install_binaries run prior using netclu_infomap, Cpp version netclu_louvain netclu_oslom follows. function three parameters. binpath indicating path folder host bin folder containing binary files. default, binary files installed R’s temporary directory (binpath = \"tempdir\"). case bin folder automatically removed end R session. Alternatively, binary files can installed bioregion’s package folder (binpath = \"pkgfolder\"). folder can chosen case PLEASE MAKE SURE update binpath argument netclu_infomap, netclu_louvain netclu_oslom accordingly. Note case, case, download_only can set TRUE (first step executed), must ensure files necessary permissions executed programs otherwise. third parameter infomap_version indicating Infomap version(s) install. Infomap version 2.1.0, 2.6.0, 2.7.1 2.8.0 available now. installation binary files divided six steps: Download bin.zip Unzip bin.zip binpath Check permissions, try change automatically propose iterative process change manually Test Infomap running properly Test Louvain running properly Test OSLOM running properly function designed help change permissions third step. Subsequently, binary files Infomap, Louvain, OSLOM tested, file check.txt added folder bin/INFOMAP/X.X.X, bin/LOUVAIN bin/OSLOM inform package netclu_infomap, netclu_louvain netclu_oslom can used without issues. However, may happen (particularly macOS) function fails automatically manually assist changing permissions. case, set argument download_only TRUE download bin.zip folder myfolder choice (different tempdir pkgfolder) can manually change permissions . Note ; package able test binary files running netclu_infomap, netclu_louvain netclu_oslom (.e., check.txt added folders…). bypass automatic check using functions, use argument check_install = FALSE, without guarantee success.","code":"install_binaries(binpath = \"tempdir\" ,                  download_only =  FALSE,                  infomap_version = c(\"2.1.0\",                                       \"2.6.0\",                                      \"2.7.1\",                                      \"2.8.0\")) ## ## 1. Download bin.zip ## ## The folder has been successfully downloaded to /tmp/RtmpS1LN3d. ## ## 2. Unzip folder ## ## The folder has been successfully unzipped in /tmp/RtmpS1LN3d. ## ## 3. Check permissions ## ## Permission to execute /tmp/RtmpS1LN3d/bin/INFOMAP/2.1.0/infomap_omp_lin as program: denied. ## Permission to execute /tmp/RtmpS1LN3d/bin/INFOMAP/2.1.0/infomap_noomp_lin as program: denied. ## Permission to execute /tmp/RtmpS1LN3d/bin/INFOMAP/2.6.0/infomap_omp_lin as program: denied. ## Permission to execute /tmp/RtmpS1LN3d/bin/INFOMAP/2.6.0/infomap_noomp_lin as program: denied. ## Permission to execute /tmp/RtmpS1LN3d/bin/INFOMAP/2.7.1/infomap_omp_lin as program: denied. ## Permission to execute /tmp/RtmpS1LN3d/bin/INFOMAP/2.7.1/infomap_noomp_lin as program: denied. ## Permission to execute /tmp/RtmpS1LN3d/bin/INFOMAP/2.8.0/infomap_omp_lin as program: denied. ## Permission to execute /tmp/RtmpS1LN3d/bin/INFOMAP/2.8.0/infomap_noomp_lin as program: denied. ## Permission to execute /tmp/RtmpS1LN3d/bin/LOUVAIN/convert_lin as program: denied. ## Permission to execute /tmp/RtmpS1LN3d/bin/LOUVAIN/louvain_lin as program: denied. ## Permission to execute /tmp/RtmpS1LN3d/bin/OSLOM/oslom_dir_lin as program: denied. ## Permission to execute /tmp/RtmpS1LN3d/bin/OSLOM/oslom_undir_lin as program: denied. ## ## Try to change permissions automatically ## ## Automatic change of permission succeed, /tmp/RtmpS1LN3d/bin/INFOMAP/2.1.0/infomap_omp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpS1LN3d/bin/INFOMAP/2.1.0/infomap_noomp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpS1LN3d/bin/INFOMAP/2.6.0/infomap_omp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpS1LN3d/bin/INFOMAP/2.6.0/infomap_noomp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpS1LN3d/bin/INFOMAP/2.7.1/infomap_omp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpS1LN3d/bin/INFOMAP/2.7.1/infomap_noomp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpS1LN3d/bin/INFOMAP/2.8.0/infomap_omp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpS1LN3d/bin/INFOMAP/2.8.0/infomap_noomp_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpS1LN3d/bin/LOUVAIN/convert_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpS1LN3d/bin/LOUVAIN/louvain_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpS1LN3d/bin/OSLOM/oslom_dir_lin can now be executed as progam. ## Automatic change of permission succeed, /tmp/RtmpS1LN3d/bin/OSLOM/oslom_undir_lin can now be executed as progam. ## ## 4. Test Infomap ## ## Congratulation, you successfully install the 2.1.0 OpenMP version of Infomap! ## Congratulation, you successfully install the 2.6.0 OpenMP version of Infomap! ## Congratulation, you successfully install the 2.7.1 OpenMP version of Infomap! ## Congratulation, you successfully install the 2.8.0 OpenMP version of Infomap! ## ## 5. Test Louvain ## ## Congratulation, you successfully install the version 0.3 of Louvain! ## ## 6. Test OSLOM ## ## Congratulation, you successfully install the version 2.5 of OSLOM! install_binaries(binpath = \"myfolder\" ,                  download_only =  TRUE,                  infomap_version = c(\"2.1.0\",                                       \"2.6.0\",                                      \"2.7.1\",                                      \"2.8.0\"))  comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_infomap(net,                       binpath = \"myfolder\",                       check_install = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a1_install_binary_files.html","id":"known-issues","dir":"Articles","previous_headings":"","what":"Known issues","title":"1. Installation of the binary files","text":"OpenMP versions Infomap require libomp-dev Ubuntu (sudo apt-get install libomp-dev) libomp macOS (install Homebrew run brew install libomp).","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a2_matrix_and_network_formats.html","id":"load-data","dir":"Articles","previous_headings":"","what":"Load data","title":"2. Matrix and network formats","text":"bioregion’s package contains example dataset spatial distribution Mediterranean vegetation. dataset analyzed article contains abundance 3,697 species 715 sites. dataset composed three files, vegedf data.frame 460,878 rows 3 columns (Site, Species Abundance), vegemat co-occurrence matrix containing information gathered matrix 715 rows 3,697 columns, vegesf spatial object containing geometry 715 sites.","code":"data(vegedf) head(vegedf) ##   Site Species Abundance ## 1   35   10017         1 ## 2   35   10024        18 ## 3   35   10034         1 ## 4   35   10035         1 ## 5   35   10056         2 ## 6   35   10080         3 dim(vegedf) ## [1] 460878      3 sum(!duplicated(vegedf[,1])) ## [1] 715 sum(!duplicated(vegedf[,2])) ## [1] 3697 data(vegemat) vegemat[1:10,1:10] ##     Species ## Site 10001 10002 10003 10004 10005 10006 10007 10008 10009 10010 ##   35     0     0     0     0     0     0     0     0     0     0 ##   36     2     0     0     0     0     0     1    12     0     0 ##   37     0     0     0     0     0     0     0     0     0     0 ##   38     0     0     0     0     0     0     0     0     0     0 ##   39     5     0     0     0     0     0     0     2     0     0 ##   84     0     0     0     0     0     0     0     0     0     0 ##   85     3     0     0     0     0     0     1     7     0     0 ##   86     0     0     0     2     0     0     2    22     0     0 ##   87    16     0     0     0     0     0     2    54     0     0 ##   88   228     0     0     0     0     0     0     5     0     0 dim(vegemat) ## [1]  715 3697"},{"path":"https://bioRgeo.github.io/bioregion/articles/a2_matrix_and_network_formats.html","id":"from-matrix-to-network","dir":"Articles","previous_headings":"","what":"From matrix to network","title":"2. Matrix and network formats","text":"function mat_to_net transforms co-occurrence matrix vegemat network represented data.frame (vegedf case). weight = TRUE third column added values contained matrix. line network format, two first columns named Node1 Node2 default. remove_zeroes = TRUE pairs nodes weight equal 0 removed output.","code":"net <- mat_to_net(vegemat, weight = TRUE, remove_zeroes = FALSE) head(net) ##   Node1 Node2 Weight ## 1    35 10001      0 ## 2    35 10002      0 ## 3    35 10003      0 ## 4    35 10004      0 ## 5    35 10005      0 ## 6    35 10006      0 dim(net) ## [1] 2643355       3 net <- mat_to_net(vegemat, weight = TRUE, remove_zeroes = TRUE) head(net) ##    Node1 Node2 Weight ## 17    35 10017      1 ## 24    35 10024     18 ## 34    35 10034      1 ## 35    35 10035      1 ## 56    35 10056      2 ## 80    35 10080      3 dim(net) ## [1] 460878      3"},{"path":"https://bioRgeo.github.io/bioregion/articles/a2_matrix_and_network_formats.html","id":"from-network-to-matrix","dir":"Articles","previous_headings":"","what":"From network to matrix","title":"2. Matrix and network formats","text":"function net_to_mat opposite. transforms network represented two- three-columns data.frame (vegedf) co-occurrence matrix (vegemat case). squared = TRUE squared matrix generated, rownames colnames correspond concatenation without duplicates two first columns data.frame. argument missing_value defines value assign pairs nodes present input network. default value 0 numeric value can used. Finally, squared = TRUE possible get symmetrical matrix output (symmetrical = TRUE). case resulting squared matrix symmetrical, except symmetrical pairs nodes already present input network (35 <-> 36) example .","code":"mat <- net_to_mat(vegedf, weight = TRUE, squared = FALSE, symmetrical = FALSE, missing_value = 0) mat[1:5,1:5] ##    10017 10024 10034 10035 10056 ## 35     1    18     1     1     2 ## 36   252    57    72    19    75 ## 37    66     1    13    23    43 ## 38    17     1     5    89    27 ## 39    17    17    34     3     8 dim(mat) ## [1]  715 3697 mat <- net_to_mat(vegedf, weight = TRUE, squared = TRUE, symmetrical = FALSE, missing_value = 0) mat[1:5,1:5] ##    35 36 37 38 39 ## 35  0  0  0  0  0 ## 36  0  0  0  0  0 ## 37  0  0  0  0  0 ## 38  0  0  0  0  0 ## 39  0  0  0  0  0 dim(mat) ## [1] 4412 4412 temp <- data.frame(Site=c(\"35\",\"36\",\"36\",\"38\",\"39\"), Species=c(\"36\",\"35\",\"37\",\"37\",\"39\"), Abundance=c(1,2,3,4,0)) net <- rbind(temp,vegedf) mat <- net_to_mat(net, weight = TRUE, squared = TRUE, symmetrical = FALSE, missing_value = -1) mat[1:5,1:5] ##    35 36 38 39 37 ## 35 -1  1 -1 -1 -1 ## 36  2 -1 -1 -1  3 ## 38 -1 -1 -1 -1  4 ## 39 -1 -1 -1  0 -1 ## 37 -1 -1 -1 -1 -1 mat <- net_to_mat(net, weight = TRUE, squared = TRUE, symmetrical = TRUE, missing_value = 0) mat[1:5,1:5] ##    35 36 38 39 37 ## 35  0  1  0  0  0 ## 36  2  0  0  0  3 ## 38  0  0  0  0  4 ## 39  0  0  0  0  0 ## 37  0  3  4  0  0"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"compute-dissimilarity-indices-from-input-data","dir":"Articles","previous_headings":"","what":"1. Compute dissimilarity indices from input data","title":"4.1 Hierarchical clustering","text":"initiate hierarchical clustering procedure, need provide pairwise distances sites. pairwise distances sites can obtained running dissimilarity() species-site matrix, presence-absence abundance matrix. example , use vegetation dataset package compute distance metrics. going compute \\(\\beta_{sim}\\) diversity metric, presence-absence dissimilarity index. formula follows: \\(\\beta_{sim} = min(b, c) / (+min(b, c))\\) number species shared sites; b number species occurring first site; c number species occurring second site. typically choose metric bioregionalization, turnover component Sorensen index (Baselga, 2012) (nutshell, tells us sites different distinct species), less dependent species richness Jaccard turnover (Leprieur & Oikonomou, 2014). Alternatively, given abundance data , also use Bray-Curtis turnover index (Baselga, 2013). choice distance metric important outcome clustering procedure, recommend choose carefully depending research question. default, Simpson index computed, options available metric argument dissimilarity(). Furthermore, users can also write formula compute index want argument formula, see ?dissimilarity(). now ready start hierarchical clustering procedure object dissim just created. Alternatively, can also use types objects hclu_hierarclust(), distance matrix object (class dist) data.frame crafting (make sure read required format carefully ?hclu_hierarclust).","code":"library(\"bioregion\")  # Work with the vegetation dataset we include in the package data(vegemat)  # This is an abundance matrix where sites are in rows and species in columns vegemat[1:10, 1:10] ##     Species ## Site 10001 10002 10003 10004 10005 10006 10007 10008 10009 10010 ##   35     0     0     0     0     0     0     0     0     0     0 ##   36     2     0     0     0     0     0     1    12     0     0 ##   37     0     0     0     0     0     0     0     0     0     0 ##   38     0     0     0     0     0     0     0     0     0     0 ##   39     5     0     0     0     0     0     0     2     0     0 ##   84     0     0     0     0     0     0     0     0     0     0 ##   85     3     0     0     0     0     0     1     7     0     0 ##   86     0     0     0     2     0     0     2    22     0     0 ##   87    16     0     0     0     0     0     2    54     0     0 ##   88   228     0     0     0     0     0     0     5     0     0 dissim <- dissimilarity(vegemat)  head(dissim) ## Data.frame of dissimilarity between sites ##  - Total number of sites:  715  ##  - Total number of species:  3697  ##  - Number of rows:  255255  ##  - Number of dissimilarity metrics:  1  ##  ##  ##   Site1 Site2    Simpson ## 2    35    36 0.02325581 ## 3    35    37 0.03100775 ## 4    35    38 0.05426357 ## 5    35    39 0.05426357 ## 6    35    84 0.72093023 ## 7    35    85 0.08527132"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"hierarchical-clustering-with-basic-parameters","dir":"Articles","previous_headings":"","what":"2. Hierarchical clustering with basic parameters","title":"4.1 Hierarchical clustering","text":"Hierarchical clustering, associated hierarchical tree, can constructed two ways: - agglomerative, sites initially assigned bioregion progressively grouped together - divisive, sites initially belong unique bioregion progressively divided different bioregions Subsections 2.1 2.3 detail functioning agglomerative hierarchical clustering, sub-section 2.4. illustrates divisive method.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"basic-usage","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters","what":"2.1 Basic usage","title":"4.1 Hierarchical clustering","text":"basic use function follows: function gives us information proceeds. Notably, talks randomization dissimilarity matrix - important feature hierarchical clustering strongly influenced order sites distance matrix. Therefore, default, function performs randomization order sites distance matrix 30 trials (information randomization section). also tells us among trials selected tree highest cophenetic correlation coefficient, value 0.69. can see type name object console see information: last line tells us clustering procedure incomplete: tree built, yet cut - clusters object yet. cut tree, can use cut_tree() function: , asked 3 clusters, algorithm automatically finds height 3 clusters found (h = 0.562). type name object console, gives us results clustering: 1 partition: partition clustering result. cut tree , 1 partition moment 4 clusters: number clusters partition. asked 3, obtained 3, good. Sometimes, however, get number clusters asked - case outcome indicated. height cut 0.562: height cut can obtain 4 clusters tree. can make quick plot partitioned tree  Let’s see looks like map:  Now, hierarchical tree, cutting (= 1 partition) oversimplifies result tree. cut multiple times? example, make deep, intermediate, shallow cuts tree, likewise Ficetola et al. (2017), allow us see broad- fine-scale relationships among sites tree. can specify, e.g. 4, 10 20 clusters: However, may useful choose heights cut, rather number clusters. , example, cut tree heights 0.4 (shallow cut), 0.5 (intermediate cut) 0.6 (deep cut):  plot easy read large number sites. can rather extract information directly object: result, can read deep cut partition (h = 0.6) clusters, intermediate cut partition (h = 0.5) 6 clusters shallow cut partition (h = 0.4) 23 clusters. maps look like:  next section see default settings chose , see find optimal numbers clusters.","code":"tree1 <- hclu_hierarclust(dissim) ## Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. ##  ## Final tree has a 0.6863 cophenetic correlation coefficient with the initial dissimilarity matrix tree1 ## Clustering results for algorithm : hclu_hierarclust  ##  (hierarchical clustering based on a dissimilarity matrix) ##  - Number of sites:  715  ##  - Name of dissimilarity metric:  Simpson  ##  - Tree construction method:  average  ##  - Randomization of the dissimilarity matrix:  yes, number of trials 100  ##  - Method to compute the final tree:  Iterative consensus hierarchical tree  ##  - Cophenetic correlation coefficient:  0.686  ## Clustering procedure incomplete - no clusters yet # Ask for 3 clusters tree1 <- cut_tree(tree1,                   n_clust = 3) ## Determining the cut height to reach 3 groups... ## --> 0.5625 tree1 ## Clustering results for algorithm : hclu_hierarclust  ##  (hierarchical clustering based on a dissimilarity matrix) ##  - Number of sites:  715  ##  - Name of dissimilarity metric:  Simpson  ##  - Tree construction method:  average  ##  - Randomization of the dissimilarity matrix:  yes, number of trials 100  ##  - Method to compute the final tree:  Iterative consensus hierarchical tree  ##  - Cophenetic correlation coefficient:  0.686  ##  - Number of clusters requested by the user:  3  ## Clustering results: ##  - Number of partitions:  1  ##  - Number of clusters:  3  ##  - Height of cut of the hierarchical tree: 0.562 # We reduced the size of text labels with cex = .2, because there are too many sites plot(tree1, cex = .2) data(vegesf) library(sf) ## Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE map_bioregions(tree1$clusters[, c(\"ID\", \"K_3\")], vegesf) # Ask for 4, 10 and 20 clusters tree1 <- cut_tree(tree1,                   n_clust = c(2, 3, 12)) ## Determining the cut height to reach 2 groups... ## --> 0.625 ## Determining the cut height to reach 3 groups... ## --> 0.5625 ## Determining the cut height to reach 12 groups... ## --> 0.4453125 plot(tree1, cex = .2) tree1 <- cut_tree(tree1,                   cut_height = c(.4, .5, .6))  plot(tree1, cex = .2) tree1 ## Clustering results for algorithm : hclu_hierarclust  ##  (hierarchical clustering based on a dissimilarity matrix) ##  - Number of sites:  715  ##  - Name of dissimilarity metric:  Simpson  ##  - Tree construction method:  average  ##  - Randomization of the dissimilarity matrix:  yes, number of trials 100  ##  - Method to compute the final tree:  Iterative consensus hierarchical tree  ##  - Cophenetic correlation coefficient:  0.686  ##  - Heights of cut requested by the user:  0.4 0.5 0.6  ## Clustering results: ##  - Number of partitions:  3  ##  - Partitions are not hierarchical ##  - Number of clusters:  2 6 23  ##  - Height of cut of the hierarchical tree: 0.6 0.5 0.4 for(i in 2:ncol(tree1$clusters)){   map_bioregions(tree1$clusters[, c(1, i)], vegesf) }"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"exploring-the-outputs","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters","what":"2.2 Exploring the outputs","title":"4.1 Hierarchical clustering","text":"explore object, can use str() see object structure: show different slots object, can access . example, want access clusters slot, type tree1$clusters. name: name method using args: arguments selected tree inputs: mostly internal use package, provides info nature input data methods algorithm: slot contains detailed information hierarchical clustering. example, can access raw tree , hclust format. access , can type tree1$algorithm$final.tree clusters: data.frame containing partitions. first column sites, columns partitions. cluster_info: small data.frame help link requests clusters data.frame. content varies depending choices; example, case, looks like : shows name partition (corresponding column names tree1$clusters), number clusters partition, cut height initially requested.","code":"str(tree1) ## List of 6 ##  $ name        : chr \"hclu_hierarclust\" ##  $ args        :List of 14 ##   ..$ index              : chr \"Simpson\" ##   ..$ method             : chr \"average\" ##   ..$ randomize          : logi TRUE ##   ..$ n_runs             : num 100 ##   ..$ optimal_tree_method: chr \"iterative_consensus_tree\" ##   ..$ keep_trials        : logi FALSE ##   ..$ n_clust            : NULL ##   ..$ cut_height         : num [1:3] 0.4 0.5 0.6 ##   ..$ find_h             : logi TRUE ##   ..$ h_max              : num 1 ##   ..$ h_min              : num 0 ##   ..$ consensus_p        : num 0.5 ##   ..$ verbose            : logi TRUE ##   ..$ dynamic_tree_cut   : logi FALSE ##  $ inputs      :List of 7 ##   ..$ bipartite      : logi FALSE ##   ..$ weight         : logi TRUE ##   ..$ pairwise       : logi TRUE ##   ..$ pairwise_metric: chr \"Simpson\" ##   ..$ dissimilarity  : logi TRUE ##   ..$ nb_sites       : int 715 ##   ..$ hierarchical   : logi FALSE ##  $ algorithm   :List of 6 ##   ..$ final.tree         :List of 5 ##   .. ..- attr(*, \"class\")= chr \"hclust\" ##   ..$ final.tree.coph.cor: num 0.686 ##   ..$ final.tree.msd     : num 0.023 ##   ..$ trials             : chr \"Trials not stored in output\" ##   ..$ output_n_clust     : Named int [1:3] 2 6 23 ##   .. ..- attr(*, \"names\")= chr [1:3] \"h_0.6\" \"h_0.5\" \"h_0.4\" ##   ..$ output_cut_height  : num [1:3] 0.6 0.5 0.4 ##  $ clusters    :'data.frame':    715 obs. of  4 variables: ##   ..$ ID  : chr [1:715] \"1003\" \"1004\" \"1005\" \"1006\" ... ##   ..$ K_2 : chr [1:715] \"1\" \"1\" \"1\" \"1\" ... ##   ..$ K_6 : chr [1:715] \"1\" \"1\" \"1\" \"1\" ... ##   ..$ K_23: chr [1:715] \"1\" \"1\" \"1\" \"1\" ... ##  $ cluster_info:'data.frame':    3 obs. of  3 variables: ##   ..$ partition_name      : chr [1:3] \"K_2\" \"K_6\" \"K_23\" ##   ..$ n_clust             : int [1:3] 2 6 23 ##   ..$ requested_cut_height: num [1:3] 0.6 0.5 0.4 ##  - attr(*, \"class\")= chr [1:2] \"bioregion.clusters\" \"list\" tree1$cluster_info ##       partition_name n_clust requested_cut_height ## h_0.6            K_2       2                  0.6 ## h_0.5            K_6       6                  0.5 ## h_0.4           K_23      23                  0.4"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"randomization","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters > 2.3 Explanation of the default settings and how to change them","what":"2.3.1 Randomization of the distance matrix","title":"4.1 Hierarchical clustering","text":"order sites distance matrix influences outcome hierarchical tree. Let’s see example:  tree looks like matrix randomized. Now let’s randomize regenerate tree:  See tree looks different? problematic means outcome heavily influenced order sites distance matrix. address issue, developed iterative algorithm reconstruct entire tree top bottom, selecting branch majority decision among multiple randomizations distance matrix (100 times default, can increased). method called Iterative Hierarchical Consensus Tree (argument optimal_tree_method = \"iterative_consensus_tree\", default value) ensures obtain consensus tree find majority decision branch tree. tree produced method generally better topology individual tree. estimate performance topology cophenetic correlation coefficient, correlation initial distance \\(\\beta_{sim}\\) among sites cophenetic distance, distance sites connected tree. tells us representative tree initial distance matrix. Although method performs better available method, comes computing cost: needs randomize distance matrix multiple times branching tree. Therefore, recommend using obtain robust tree - patient case. Otherwise, need fast look good tree, can simply select single best tree among multiple randomization trials. never good Iterative Hierarchical Consensus Tree, best choice fast exploration. , choose optimal_tree_method = \"best\". select tree best represents distance matrix; .e., one highest cophenetic correlation coefficient among trials. Let’s see example optimal_tree_method = \"best\". can also ask function keep individual trees exploration (keep_trials = TRUE). Another possible approach build simple consensus tree among trials. However, generally recommend constructing consensus tree, topology simple consensus trees can problematic lot ties distance matrix. Let’s see action : See cophenetic correlation coefficient consensus tree terrible compared IHCT best tree ? consensus tree almost correlation initial distance matrix. topology terribly wrong, see tree looks like:  Booo, just large rake, tree!!!","code":"# Compute the tree without randomizing the distance matrix tree2 <- hclu_hierarclust(dissim,                           randomize = FALSE) ## Output tree has a 0.6849 cophenetic correlation coefficient with the initial ##                    dissimilarity matrix plot(tree2, cex = .1) # This line randomizes the order of rows in the distance matrix dissim_random <- dissim[sample(1:nrow(dissim)), ]  # Recompute the tree tree3 <- hclu_hierarclust(dissim_random,                           randomize = FALSE) ## Output tree has a 0.6778 cophenetic correlation coefficient with the initial ##                    dissimilarity matrix plot(tree3, cex = .1) tree_best <- hclu_hierarclust(dissim_random,                               randomize = TRUE,                               optimal_tree_method = \"best\",                               keep_trials = TRUE) ## Randomizing the dissimilarity matrix with 100 trials ##  -- range of cophenetic correlation coefficients among trials: 0.6669 - 0.6974 ##  ## Final tree has a 0.6974 cophenetic correlation coefficient with the initial dissimilarity matrix tree_consensus <- hclu_hierarclust(dissim_random,                                    randomize = TRUE,                                    optimal_tree_method = \"consensus\",                                    keep_trials = TRUE) ## Randomizing the dissimilarity matrix with 100 trials ##  ## Final tree has a 0.202 cophenetic correlation coefficient with the initial dissimilarity matrix plot(tree_consensus)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"tree-construction-algorithm","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters > 2.3 Explanation of the default settings and how to change them","what":"2.3.2 Tree construction algorithm","title":"4.1 Hierarchical clustering","text":"default, function uses UPGMA method (Unweighted Pair Group Method Arithmetic Mean) recommended bioregionalization better performance approaches (Kreft & Jetz, 2010). can change method changing argument method; methods implemented stats::hclust() available. Note current height distances methods method = \"ward.D\" method = \"ward.D2\" may differ calculations stats::hclust(), due iterative nature algorithm. addition, using method method = \"single\" much slower approaches, yet implemented workaround make faster (hesitate contact us need faster implementation idea make run faster).","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"cutting-the-tree","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters > 2.3 Explanation of the default settings and how to change them","what":"2.3.3 Cutting the tree","title":"4.1 Hierarchical clustering","text":"three ways cutting tree: Specify expected number clusters: can request specific number clusters (n_clust = 5 example). can also request multiple partitions, number clusters (n_clust = c(5, 10, 15)) example. Note: specify number clusters, function search associated height cut automatically; can disable parameter find_h = FALSE. search h value h_max (default 1) h_min (default 0). arguments can adjusted working indices whose values range 0 1. Specify height cut: can request height want cut tree (e.g., cut_height = 0.5). can also request multiple partitions, cut height (cut_height = c(0.4, 0.5, 0.6)) example. Use dynamic tree cut method: Rather cutting entire tree , alternative approach consists cutting individual branches different heights. method can requested using dynamic_tree_cut = TRUE, based dynamicTreeCut R package.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"id_2-4-","dir":"Articles","previous_headings":"2. Hierarchical clustering with basic parameters","what":"2.4. Divisive clustering","title":"4.1 Hierarchical clustering","text":"agglomerative hierarchical clustering previous subsections followed bottom-approach, divisive clustering follows top-approach. means first step clustering, sites belong bioregion, sites iteratively divided different bioregions sites belong unique bioregion. Divisive clustering following DIvisive ANAlysis (DIANA) clustering algorithm described (Kaufman & Rousseeuw, 2009). step, algorithm splits largest cluster identifying dissimilar observation (.e. site) putting sites closer dissimilar observation ‘old party’ group splinter group. result large cluster split two clusters. function hclu_diana performs Diana divisive clustering.","code":"# Compute the tree with the Diana algorithm tree_diana <- hclu_diana(dissim) ## Output tree has a 0.41 cophenetic correlation coefficient with the initial dissimilarity matrix plot(tree_diana)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"optimaln","dir":"Articles","previous_headings":"","what":"3. How to find an optimal number of clusters?","title":"4.1 Hierarchical clustering","text":"Step 1. Build tree hclu_hierarclust() Step 2. Explore range partitions, minimum (e.g., starting 2 clusters) maximum (e.g. \\(n-1\\) clusters \\(n\\) number sites). Step 3. Calculate one several metrics partition, used basis evaluation plots. Step 4. Search one several optimal number(s) clusters using evaluation plots. Different criteria can applied identify optimal number(s) clusters. Step 5. Export optimal partitions cluster object.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"a-practical-example","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters?","what":"3.1 A practical example","title":"4.1 Hierarchical clustering","text":"example compute evaluation metric used Holt et al. (2013), compares total dissimilarity distance matrix (sum distances) inter-cluster dissimilarity (sum distances clusters). choose optimal number clusters elbow evaluation plot.   allergic lines code, also simply recut tree identified optimal number cut-offs cut_tree().","code":"data(vegemat)  # Calculate dissimilarities dissim <- dissimilarity(vegemat)  # Step 1 & 2. Compute the tree and cut it into many different partitions tree4 <- hclu_hierarclust(dissim,                           n_clust = 2:100) ## Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. ##  ## Final tree has a 0.6842 cophenetic correlation coefficient with the initial dissimilarity matrix ## Warning in cut_tree(outputs, n_clust = n_clust, cut_height = cut_height, : The ## requested number of cluster could not be found for k = 4. Closest number found: ## 5 ## Warning in cut_tree(outputs, n_clust = n_clust, cut_height = cut_height, : The ## requested number of cluster could not be found for k = 67. Closest number ## found: 66 # Step 3. Calculate the same evaluation metric as Holt et al. 2013 eval_tree4 <- bioregionalization_metrics(   tree4,    dissimilarity = dissim, # Provide distances to compute the metrics   eval_metric = \"pc_distance\") ## Computing similarity-based metrics... ##   - pc_distance OK # Step 4. Find the optimal number of clusters opti_n_tree4 <- find_optimal_n(eval_tree4) ## [1] \"pc_distance\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the elbow method ##    * elbow found at: ## pc_distance 19 ## Plotting results... opti_n_tree4 ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  elbow  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 19 # Step 5. Extract the optimal number of clusters # We get the name of the correct partition in the next line K_name <- opti_n_tree4$evaluation_df$K[opti_n_tree4$evaluation_df$optimal_n_pc_distance] # Look at the site-cluster table head(tree4$clusters[, c(\"ID\", K_name)]) ##        ID K_19 ## 1003 1003    1 ## 1004 1004    1 ## 1005 1005    1 ## 1006 1006    1 ## 1007 1007    1 ## 1008 1008    1 # Make a map of the clusters data(\"vegesf\") library(\"sf\") map_bioregions(tree4$clusters[, c(\"ID\", K_name)], vegesf)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"evaluation-metrics","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters?","what":"3.2 Evaluation metrics","title":"4.1 Hierarchical clustering","text":"Currently, four evaluation metrics available package: pc_distance: \\(\\sum{-cluster\\beta_{sim }} / \\sum{\\beta_{sim}}\\) metric metric computed Holt et al. (2013). anosim: statistic used Analysis Similarities, suggested Castro-Insua et al. (2018). compares -cluster dissimilarities within-cluster dissimilarities. based difference mean ranks groups within groups following formula: \\(R=(r_B-r_W)/(N(N-1)/4)\\) \\(r_B\\) \\(r_W\\) average ranks within clusters respectively, \\(N\\) total number sites. avg_endemism: average percentage endemism clusters (Kreft & Jetz, 2010). calculated follows: \\(End_{mean} = \\frac{\\sum_{=1}^K E_i / S_i}{K}\\) \\(E_i\\) number endemic species cluster \\(\\), \\(S_i\\) number species cluster \\(\\), \\(K\\) maximum number clusters. tot_endemism: total endemism across clusters (Kreft & Jetz, 2010). calculated follows: \\(End_{tot} = E / C\\) \\(E\\) total number endemic species (.e., species occurring one cluster) \\(C\\) number non- endemic species. Important note able calculate pc_distance anosim, need provide dissimilarity object argument dissimilarity. addition, able calculate avg_endemism tot_endemism, need provide species-site network argument net (don’t panick species x site matrix! function make conversion). Let’s see practice. Depending size dataset, computing endemism-based metrics can take .","code":"# Calculate pc_distance and anosim bioregionalization_metrics(tree4,                             dissimilarity = dissim,                             eval_metric = c(\"pc_distance\", \"anosim\")) ## Computing similarity-based metrics... ##   - pc_distance OK ##   - anosim OK ## Partition metrics: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Requested metric(s):  pc_distance anosim  ##  - Metric summary: ##      pc_distance    anosim ## Min    0.4982831 0.6968281 ## Mean   0.8950634 0.8029604 ## Max    0.9823024 0.8669999 ##  ## Access the data.frame of metrics with your_object$evaluation_df # Calculate avg_endemism and tot_endemism # I have an abundance matrix, I need to convert it into network format first: vegenet <- mat_to_net(vegemat)  bioregionalization_metrics(tree4,                             net = vegenet,                             eval_metric = c(\"avg_endemism\", \"tot_endemism\")) ## Computing composition-based metrics... ##   - avg_endemism OK ##   - tot_endemism OK ## Partition metrics: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Requested metric(s):  avg_endemism tot_endemism  ##  - Metric summary: ##      avg_endemism tot_endemism ## Min   0.001177433   0.04895862 ## Mean  0.008144637   0.08297200 ## Max   0.181513150   0.31539086 ##  ## Access the data.frame of metrics with your_object$evaluation_df ## Details of endemism % for each partition are available in  ##         your_object$endemism_results"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"criteria-to-choose-an-optimal-number-of-clusters","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters?","what":"3.2 Criteria to choose an optimal number of clusters","title":"4.1 Hierarchical clustering","text":"Choosing optimal number clusters long-standing issue literature, absolute objective answer question. plethora methods proposed years, best approach tackle issue probably compare results multiple approaches make informed decision. bioregion package, implemented several methods specifically suited bioregionalization analysis. example, standard criterion used identifying optimal number clusters elbow method, default criterion find_optimal_n(). However, recommend moving beyond paradigm single optimal number clusters, likely oversimplification hierarchy tree. recommend considering multiple cuts tree, provide several methods : identifying large steps curve using multiple cutoffs. Additionally, implement approaches, using maximum minimum value metrics, finding break points curve segmented model. look different methods, compute evaluation metrics store eval_tree4:","code":"vegenet <- mat_to_net(vegemat) eval_tree4 <- bioregionalization_metrics(tree4,                                           dissimilarity = dissim,                                           net = vegenet,                                           eval_metric = c(\"pc_distance\", \"anosim\",                                                          \"avg_endemism\", \"tot_endemism\")) ## Computing similarity-based metrics... ##   - pc_distance OK ##   - anosim OK ## Computing composition-based metrics... ##   - avg_endemism OK ##   - tot_endemism OK"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"elbow-method","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.1 Elbow method","title":"4.1 Hierarchical clustering","text":"elbow method consists find ‘elbow’ form metric-cluster relationship. method typically work metrics L-shaped form (typically, pc_distance endemism metrics), metrics (e.g. form anosim necessarily follow L-shape). rationale behind elbow method find cutoff metric values stop increasing significantly, adding new clusters provide much significant improvement metric. elbow method default method find_optimal_n(). parameters adjust . curve elbow-shaped, may give spurious results.   example , optimal number clusters varies depending metric, minimum 9 maximum 24. final choice depends metric preferences respect metrics, objectives clustering. Alternatively, two cut-offs used, deep cut-based endemism metrics e.g. value 9, shallow cutoff based pc_distance, 19.","code":"find_optimal_n(eval_tree4) ## [1] \"pc_distance\"  \"anosim\"       \"avg_endemism\" \"tot_endemism\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the elbow method ##    * elbow found at: ## pc_distance 19 ## anosim 24 ## avg_endemism 9 ## tot_endemism 12 ## Warning in find_optimal_n(eval_tree4): The elbow method is likely not suitable ## for the ANOSIM metric. You should rather look for leaps in the curve (see ## criterion = 'increasing_step' or decreasing_step) ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  pc_distance anosim avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  elbow  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 19 ## anosim - 24 ## avg_endemism - 9 ## tot_endemism - 12 ## [1] \"pc_distance\"  \"anosim\"       \"avg_endemism\" \"tot_endemism\""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"step-method","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.2 Step method","title":"4.1 Hierarchical clustering","text":"step method consists identifying largest “steps” metrics, .e., largest increases decreases value metric. , function calculates successive differences metrics partitions. keep largest positive differences (increasing_step) negative differences (decreasing_step). increasing_step increasing metrics (pc_distance) decreasing_step decreasing metrics (avg_endemism tot_endemism). anosim values can either increase decrease depending dataset, explore ways. default, function selects top 1% steps:   However, can adjust two different ways. First, choose number steps select, e.g. select largest 3 steps, use step_levels = 3:  Note steps generally correspond large jumps tree, like approach fits well hierarchical nature tree. Second, can set quantile steps select, e.g. select 5% largest steps set quantile 0.95 (step_quantile = 0.95):  Finally, question may arise cluster number select large step occurs. example, largest step occurs partitions 4 5 clusters, keep partition 4 clusters, partition 5 clusters? default, function keeps partition \\(N + 1\\) (5 clusters example ). can change setting step_round_above = FALSE:","code":"find_optimal_n(eval_tree4,                metrics_to_use = c(\"anosim\", \"pc_distance\"),                criterion = \"increasing_step\") ## [1] \"anosim\"      \"pc_distance\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the increasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  anosim pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  increasing_step  ##    (step quantile chosen:  0.99  (i.e., only the top 1 %  increase  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## anosim - 19 ## pc_distance - 12 find_optimal_n(eval_tree4,                metrics_to_use = c(\"avg_endemism\", \"tot_endemism\"),                criterion = \"decreasing_step\") ## [1] \"avg_endemism\" \"tot_endemism\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the decreasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  decreasing_step  ##    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## avg_endemism - 5 ## tot_endemism - 5 find_optimal_n(eval_tree4,                metrics_to_use = c(\"anosim\", \"pc_distance\"),                criterion = \"increasing_step\",                step_levels = 3) ## [1] \"anosim\"      \"pc_distance\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the increasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  anosim pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  increasing_step  ##    (step quantile chosen:  0.99  (i.e., only the top 1 %  increase  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## anosim - 5 12 19 ## pc_distance - 5 12 19 find_optimal_n(eval_tree4,                metrics_to_use = c(\"anosim\", \"pc_distance\"),                criterion = \"increasing_step\",                step_quantile = 0.95) ## [1] \"anosim\"      \"pc_distance\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the increasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  anosim pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  increasing_step  ##    (step quantile chosen:  0.95  (i.e., only the top 5 %  increase  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## anosim - 5 12 19 24 93 ## pc_distance - 3 5 12 19 68 find_optimal_n(eval_tree4,                metrics_to_use = c(\"avg_endemism\", \"tot_endemism\"),                criterion = \"decreasing_step\",                step_round_above = FALSE) ## [1] \"avg_endemism\" \"tot_endemism\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the decreasing_step method ##  - Step method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  decreasing_step  ##    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) ##  - Optimal partition(s) of clusters for each metric: ## avg_endemism - 3 ## tot_endemism - 3"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"cutting-at-different-cut-off-values","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.3 Cutting at different cut-off values","title":"4.1 Hierarchical clustering","text":"idea method select specific metric values number clusters used. example, study, Holt et al. (2013) used different cutoffs pc_distance find global biogeographic regions: 0.90, 0.95, 0.99, 0.999. higher value, -diversity explained, also clusters . Therefore, choice trade-total -diversity explained number clusters. Eventually, choice values depends different factors: geographic scope study. global scale study can use large cutoffs like Holt et al. (2013) end reasonable number clusters, whereas regional local scale studies less endemism taxa shared among clusters, values high, cutoffs explored, 0.5 0.75. characteristics study increase decrease degree endemism among clusters: dispersal capacities taxonomic group, connectivity/barriers study area, etc. Use lower cutoffs large number widespread species, use higher cutoffs high degrees endemism. Using abundance phylogenetic data compute -diversity metrics may allow better distinguish clusters, turn allow use higher cutoffs. example, case, regional-scale study vegetation, can use three cutoffs: 0.6 (deep cutoff), 0.8 (intermediate cutoff), 0.9 (shallow cutoff).","code":"find_optimal_n(eval_tree4,                metrics_to_use = \"pc_distance\",                criterion = \"cutoff\",                metric_cutoffs = c(.6, .8, .9)) ## [1] \"pc_distance\" ## Number of partitions: 99 ## Searching for potential optimal number(s) of clusters based on the cutoff method ##  - Cutoff method ## Plotting results... ## Search for an optimal number of clusters: ##  - 99  partition(s) evaluated ##  - Range of clusters explored: from  2  to  100  ##  - Evaluated metric(s):  pc_distance  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  cutoff  ##    --> cutoff(s) chosen:  0.6 0.8 0.9  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 5 12 29"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"cutting-at-the-maximum-or-minimum-metric-value","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.4 Cutting at the maximum or minimum metric value","title":"4.1 Hierarchical clustering","text":"criterion finds maximum (criterion = \"max\") minimum (criterion = \"min\") value metric list partitions selects corresponding partition. criterion can interesting case anosim, probably much less useful metrics implemented package.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"finding-break-points-in-the-curve","dir":"Articles","previous_headings":"3. How to find an optimal number of clusters? > 3.2 Criteria to choose an optimal number of clusters","what":"3.2.5 Finding break points in the curve","title":"4.1 Hierarchical clustering","text":"criterion consists applying segmented regression model formula evaluation metric ~ number clusters. user can define number breaks identified curve. Note model likely require minimum number points find appropriate number clusters. example , make 100 cuts tree enough values.  can ask higher number breaks: 2 breaks  3 breaks  Increasing number breaks can useful situations , example, non-linear silhouettes metric ~ n clusters.","code":"tree5 <- cut_tree(tree4,                   cut_height = seq(0, max(tree4$algorithm$final.tree$height),                                     length = 100))   eval_tree5 <- bioregionalization_metrics(tree5,                                           dissimilarity = dissim,                                           net = vegenet,                                           eval_metric = c(\"pc_distance\", \"anosim\",                                                          \"avg_endemism\", \"tot_endemism\")) ## Computing similarity-based metrics... ##   - pc_distance OK ##   - anosim OK ## Computing composition-based metrics... ##   - avg_endemism OK ##   - tot_endemism OK find_optimal_n(eval_tree5,                criterion = \"breakpoints\") ## [1] \"pc_distance\"  \"anosim\"       \"avg_endemism\" \"tot_endemism\" ## Number of partitions: 100 ## Searching for potential optimal number(s) of clusters based on the breakpoints method ## Exact break point not in the list of partitions: finding the closest partition... ## Plotting results... ##    (the red line is the prediction from the segmented regression) ## Warning: Removed 1 row containing missing values or values outside the scale range ## (`geom_line()`). ## Search for an optimal number of clusters: ##  - 100  partition(s) evaluated ##  - Range of clusters explored: from  1  to  701  ##  - Evaluated metric(s):  pc_distance anosim avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  breakpoints  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 16 ## anosim - 111 ## avg_endemism - 2 ## tot_endemism - 2 find_optimal_n(eval_tree5,                criterion = \"breakpoints\",                n_breakpoints = 2) ## [1] \"pc_distance\"  \"anosim\"       \"avg_endemism\" \"tot_endemism\" ## Number of partitions: 100 ## Searching for potential optimal number(s) of clusters based on the breakpoints method ## Exact break point not in the list of partitions: finding the closest partition... ## Plotting results... ##    (the red line is the prediction from the segmented regression) ## Warning: Removed 1 row containing missing values or values outside the scale range ## (`geom_line()`). ## Search for an optimal number of clusters: ##  - 100  partition(s) evaluated ##  - Range of clusters explored: from  1  to  701  ##  - Evaluated metric(s):  pc_distance anosim avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  breakpoints  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 2 25 ## anosim - 25 183 ## avg_endemism - 2 16 ## tot_endemism - 2 92 find_optimal_n(eval_tree5,                criterion = \"breakpoints\",                n_breakpoints = 3) ## [1] \"pc_distance\"  \"anosim\"       \"avg_endemism\" \"tot_endemism\" ## Number of partitions: 100 ## Searching for potential optimal number(s) of clusters based on the breakpoints method ## Exact break point not in the list of partitions: finding the closest partition... ## Plotting results... ##    (the red line is the prediction from the segmented regression) ## Warning: Removed 1 row containing missing values or values outside the scale range ## (`geom_line()`). ## Search for an optimal number of clusters: ##  - 100  partition(s) evaluated ##  - Range of clusters explored: from  1  to  701  ##  - Evaluated metric(s):  pc_distance anosim avg_endemism tot_endemism  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  breakpoints  ##  - Optimal partition(s) of clusters for each metric: ## pc_distance - 2 16 100 ## anosim - 25 183 566 ## avg_endemism - 2 13 56 ## tot_endemism - 2 14 111"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html","id":"optics-as-a-semi-hierarchical-clustering-approach","dir":"Articles","previous_headings":"","what":"4. OPTICS as a semi-hierarchical clustering approach","title":"4.1 Hierarchical clustering","text":"OPTICS (Ordering Points Identify Clustering Structure) semi-hierarchical clustering approach orders points datasets closest points become neighbors, calculates ‘reachability’ distance point, extracts clusters reachability distance hierarchical manner. However, hierarchical nature clusters directly provided algorithm tree-like output. Hence, users explore ‘reachability plot’ understand hierarchical nature OPTICS clusters, read related publication understand method (Hahsler et al., 2019). run optics algorithm, use hclu_optics() function:","code":"data(vegemat)  # Calculate dissimilarities dissim <- dissimilarity(vegemat)  clust1 <- hclu_optics(dissim)  clust1 ## Clustering results for algorithm : hclu_optics  ##  - Number of sites:  715  ## Clustering results: ##  - Number of partitions:  1  ##  - Number of clusters:  9"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"dissimilarity-indices","dir":"Articles","previous_headings":"","what":"1. Dissimilarity indices","title":"4.2 Non-hierarchical clustering","text":"Pairwise distances sites can obtained running dissimilarity() site-species matrix. example , use fish dataset package compute distance metrics. going compute \\(\\beta_{sim}\\) diversity metric, presence-absence dissimilarity index. formula follows:\\(\\beta_{sim} = min(b, c) / (+min(b, c))\\) number species shared sites; b number species occurring first site; c number species occurring second site. typically choose metric bioregionalization, turnover component Sorensen index (Baselga, 2012) (nutshell, tells us sites different distinct species), less dependence species richness Jaccard turnover (Leprieur & Oikonomou, 2014).  choice distance metric important outcome clustering procedure, recommend choose carefully depending research question. default, Simpson index computed, options available metric argument dissimilarity(). Furthermore, users can also write formula compute index wish argument formula, see ?dissimilarity(). now ready start non-hierarchical clustering procedure object dissim just created. Alternatively, can also use types objects distance matrix object (class dist) data.frame crafting (make sure read required format carefully explained help function).","code":"library(\"bioregion\") data(\"fishmat\")  # It is a presence/absence matrix with sites in rows and species in columns fishmat[1:3, 1:3] ##          Abramis brama Alburnus alburnus Barbatula barbatula ## Aa                   1                 1                   1 ## Abula                0                 0                   0 ## Acheloos             0                 0                   0 dissim <- dissimilarity(fishmat, metric = \"Simpson\")  dissim[1:3, ] ## Data.frame of dissimilarity between sites ##  - Total number of sites:  338  ##  - Total number of species:  195  ##  - Number of rows:  56953  ##  - Number of dissimilarity metrics:  1  ##  ##  ##   Site1    Site2   Simpson ## 2    Aa    Abula 0.3333333 ## 3    Aa Acheloos 1.0000000 ## 4    Aa    Adige 0.7692308"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"centroid-based-clustering","dir":"Articles","previous_headings":"","what":"2. Centroid-based clustering","title":"4.2 Non-hierarchical clustering","text":"core idea algorithms place points cluster central-point closest. central-point can either centroid cluster, .e. mean x y coordinates points belonging cluster, medoid. medoid centrally located data point cluster, words least dissimilar point points cluster. objective minimize sum squared distances points assigned centroids/medoids.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"kmeans","dir":"Articles","previous_headings":"2. Centroid-based clustering","what":"2.1. Kmeans","title":"4.2 Non-hierarchical clustering","text":"K-means clustering perhaps famous method non-hierarchical clustering. uses centroids clusters. algorithm usually follows iterative framework : initialization step creates k centroids random placements. every point, Euclidean distance centroids calculated. point assigned nearest centroid. points assigned centroid form cluster. clusters formed, new centroids cluster calculated taking mean x y coordinates points belonging cluster. re-assignment step calculates new centroids based membership cluster. Steps 2 3 repeated solution converges, .e. centroid positions longer change. Finding optimal solution K-means computationally intensive implementation rely efficient heuristic algorithms quickly converge local optimum. Side-note k-means algorithm can become ‘stuck’ local optima. Repeating clustering algorithm adding noise data can help evaluate robustness solution. function compute K-means clustering bioregion nhclu_kmeans(). illustrate functions works example applied dissimilarity matrix calculated . chose 3 clusters. steps come arguments can tweaked. Specifically, iter_max determines maximum number iterations allowed (.e. many times steps described run) nstart specifies many random sets n_clust selected starting points.  Several heuristic algorithms can also used along K-means method can parameterized using algorithm argument. default, algorithm Hartigan-Wong (Hartigan & Wong (1979)) used. Let’s start setting iter_max nstart 1. asking one iteration , function displays message saying algorithm converge. therefore need increase value iter_max. Like functions bioregion package, class object specific package (bioregion.clusters) contains several parts. clusters assigned site accessible $clusters part output: , see 142 sites assigned cluster 1, 93 cluster 2 103 cluster 3. assignment can change depending two main arguments functions, iter_max nstart. shown , distribution sites among three clusters appears quite homogeneous three examples discrepancies emerge. Overall, increasing iter_max nstart increases chances convergence algorithm also increases computation time.","code":"ex_kmeans <- nhclu_kmeans(dissim, index = \"Simpson\", n_clust = 3, iter_max = 1,                           nstart = 1, algorithm = \"Hartigan-Wong\") ex_kmeans <- nhclu_kmeans(dissim, index = \"Simpson\", n_clust = 3, iter_max = 3,                           nstart = 1, algorithm = \"Hartigan-Wong\") ex_kmeans$clusters[1:3, ] ##                ID K_3 ## Aa             Aa   3 ## Abula       Abula   1 ## Acheloos Acheloos   2 table(ex_kmeans$clusters$K_3) ##  ##   1   2   3  ## 142  93 103 ex_kmeans2 <- nhclu_kmeans(dissim, index = \"Simpson\", n_clust = 3,                            iter_max = 100, nstart = 1,                            algorithm = \"Hartigan-Wong\")  ex_kmeans3 <- nhclu_kmeans(dissim, index = \"Simpson\", n_clust = 3,                            iter_max = 3, nstart = 100,                            algorithm = \"Hartigan-Wong\") table(ex_kmeans$clusters$K_3, ex_kmeans2$clusters$K_3) ##     ##       1   2   3 ##   1   1  12 129 ##   2  77  16   0 ##   3   0   9  94 table(ex_kmeans$clusters$K_3, ex_kmeans3$clusters$K_3) ##     ##       1   2   3 ##   1 111  29   2 ##   2   0   0  93 ##   3   0 102   1"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"section22","dir":"Articles","previous_headings":"2. Centroid-based clustering","what":"2.2. K-medoids","title":"4.2 Non-hierarchical clustering","text":"Instead using mean cluster, medoid can also used partition data points. comparison centroid used K-means, medoid less sensitive outliers data. partitions can also use types distances rely Euclidean distance . Several heuristics exist solve K-medoids problem, famous ones Partition Around Medoids (PAM), extensions CLARA CLARANS.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"partitioning-around-medoids-pam","dir":"Articles","previous_headings":"2. Centroid-based clustering > 2.2. K-medoids","what":"2.2.1. Partitioning Around Medoids (PAM)","title":"4.2 Non-hierarchical clustering","text":"PAM fast heuristic find solution k-medoids problem. k clusters, decomposes following steps:  1. Randomly pick k points initial medoids Assign point nearest medoid x Calculate objective function (sum dissimilarities points nearest medoids) Randomly select point y Swap x y swap reduces objective function Repeat 3-6 change nhclu_pam() function, several arguments tweak. number clusters n_clust defined well number starting positions medoids nstart. Several variants PAM algorithm available can changed argument variant (see cluster::pam() details). 2 clusters, see 258 sites assigned cluster 1 80 cluster 2.","code":"ex_pam <- nhclu_pam(dissim, index = \"Simpson\", n_clust = 2:25, nstart = 1,                     variant = \"faster\", cluster_only = FALSE) table(ex_pam$clusters$K_2) ##  ##   1   2  ## 258  80"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"clustering-large-applications-clara","dir":"Articles","previous_headings":"2. Centroid-based clustering > 2.2. K-medoids","what":"2.2.2. Clustering Large Applications (CLARA)","title":"4.2 Non-hierarchical clustering","text":"CLARA (Clustering Large Applications, (Kaufman Rousseeuw 1990)) extension k-medoids (PAM) methods deal data containing large number objects (several thousand observations) order reduce computational time RAM storage problem. achieved using sampling approach.","code":"ex_clara <- nhclu_clara(dissim, index = \"Simpson\",                         n_clust = 5,                         maxiter = 0L, initializer = \"LAB\", fasttol = 1,                         numsamples = 5L, sampling = 0.25, independent = FALSE,                         seed = 123456789L) table(ex_clara$clusters$K_5) ##  ##   1   2   3   4   5  ## 241  21  16  50  10"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"clustering-large-applications-based-on-randomized-search-clarans","dir":"Articles","previous_headings":"2. Centroid-based clustering > 2.2. K-medoids","what":"2.2.3. Clustering Large Applications based on RANdomized Search (CLARANS)","title":"4.2 Non-hierarchical clustering","text":"CLARANS (Clustering Large Applications based RANdomized Search, (Ng Han 2002)) extension k-medoids (PAM) methods combined CLARA algorithm.","code":"ex_clarans <- nhclu_clarans(dissim, index = \"Simpson\",                         n_clust = 5,                         numlocal = 2L, maxneighbor = 0.025,                         seed = 123456789L) table(ex_clara$clusters$K_5) ##  ##   1   2   3   4   5  ## 241  21  16  50  10"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"density-based-clustering","dir":"Articles","previous_headings":"","what":"3. Density-based clustering","title":"4.2 Non-hierarchical clustering","text":"Density-based clustering another type non-hierarchical clustering. connects areas high density clusters. allows arbitrary-shaped distributions long dense areas can connected. algorithms can however difficulty data varying densities high dimensions.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"dbscan","dir":"Articles","previous_headings":"3. Density-based clustering","what":"3.1. DBSCAN","title":"4.2 Non-hierarchical clustering","text":"Density-based Spatial Clustering Applications Noise (DBSCAN) (Hahsler et al. (2019)) famous density-based clustering approach.  operates locating points dataset surrounded significant number points. points regarded part dense zone, algorithm next attempt extend region encompass cluster’s points. DBSCAN uses two following parameters: Epsilon (eps): maximum distance two points considered neighboring points (belonging cluster). Minimum Points (minPts): minimum number neighboring points given point needs considered core data point. includes point . example, minimum number points set 4, given point needs 3 neighboring data points considered core data point. minimum number points meet epsilon distance requirement considered cluster. set two parameters, algorithm works like : Decide value eps minPts. point: Calculate distance points. distance less equal eps mark point neighbor x. point gets neighboring count greater equal minPts, mark core point visited. core point, already assigned cluster create new cluster. Recursively find neighboring points assign cluster core point. Continue steps unvisited points covered. algorithm can called function nhclu_dbscan(). user define two arguments presented , minPts eps, function provide knee curve helping search optimal eps value.  , see can set eps 1. set parameters, get one cluster. decrease eps value increase minPts, can get clusters.","code":"ex_dbscan <- nhclu_dbscan(dissim, index = \"Simpson\", minPts = NULL, eps = NULL,                           plot = TRUE) ## Trying to find a knee in the curve to search for an optimal eps value... ##        NOTE: this automatic identification of the knee may not work properly ##        if the curve has knees and elbows. Please adjust eps manually by ##        inspecting the curve, identifying a knee as follows: ##  ##                            / ##                  curve    / ##               ___________/  <- knee ##   elbow ->   / ##             / ##            / ex_dbscan2 <- nhclu_dbscan(dissim, index = \"Simpson\", minPts = NULL, eps = 1,                            plot = FALSE) table(ex_dbscan2$clusters$K_1) ##  ##   1  ## 338 ex_dbscan3 <- nhclu_dbscan(dissim, index = \"Simpson\", minPts = 4, eps = 0.5,                            plot = FALSE)  table(ex_dbscan3$clusters$K_2) ## < table of extent 0 >"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"section4","dir":"Articles","previous_headings":"","what":"4. Affinity propagation","title":"4.2 Non-hierarchical clustering","text":"algorithm based paper Frey & Dueck (2007) relies R package apcluster Unlike previous algorithms vignette, algorithm associated function use similarity matrix.","code":"# Similarity matrix sim <- dissimilarity_to_similarity(dissim)  # Algorithm clust1 <- nhclu_affprop(sim)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html","id":"section5","dir":"Articles","previous_headings":"","what":"5. Optimal number of clusters","title":"4.2 Non-hierarchical clustering","text":"Previous methods help determining optimal number bioregions structuring site-species matrix. purpose, can combine functions bioregionalization_metrics() find_optimal_n(). bioregionalization_metrics() calcultes several metrics based previous clustering attempts. *Note two metrics tot_endemism avg_endemism, also need provide site-species matrix. bioregionalization_metrics() function calculated partitioning metrics, can call find_optimal_n() get optimal number clusters.  Based metric selected, optimal number clusters can vary.","code":"bioregionalization_metrics(ex_pam, dissimilarity = dissim,                            eval_metric = \"pc_distance\") ## Partition metrics: ##  - 24  partition(s) evaluated ##  - Range of clusters explored: from  2  to  25  ##  - Requested metric(s):  pc_distance  ##  - Metric summary: ##      pc_distance ## Min    0.5464742 ## Mean   0.8022971 ## Max    0.8949633 ##  ## Access the data.frame of metrics with your_object$evaluation_df a <- bioregionalization_metrics(ex_pam, dissimilarity = dissim, net = fishdf,                                 species_col = \"Species\", site_col = \"Site\",                                 eval_metric = c(\"tot_endemism\", \"avg_endemism\",                                                 \"pc_distance\", \"anosim\")) find_optimal_n(a) ## [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\" ## Number of partitions: 24 ## Searching for potential optimal number(s) of clusters based on the elbow method ##    * elbow found at: ## tot_endemism 4 ## avg_endemism 4 ## pc_distance 7 ## anosim 2 ## Plotting results... ## Search for an optimal number of clusters: ##  - 24  partition(s) evaluated ##  - Range of clusters explored: from  2  to  25  ##  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  ##  ## Potential optimal partition(s): ##  - Criterion chosen to optimise the number of clusters:  elbow  ##  - Optimal partition(s) of clusters for each metric: ## tot_endemism - 4 ## avg_endemism - 4 ## pc_distance - 7 ## anosim - 2"},{"path":[]},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"input-data","dir":"Articles","previous_headings":"Introduction","what":"Input data","title":"4.3 Network clustering","text":"network algorithms work network format, .e. data.frame 3 columns: sites, species abundance given species given site. type object can obtained site x species matrix use mat_to_net(). vignette, directly load network format distribution fish European basins. network algorithms work similarity matrix pair sites.","code":"library(\"bioregion\") data(\"fishdf\") data(\"fishmat\") fish_simil <- similarity(fishmat, metric = \"Simpson\")"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"main-arguments","dir":"Articles","previous_headings":"Introduction","what":"Main arguments","title":"4.3 Network clustering","text":"algorithms presented specific parameters can tweaked arguments common functions. Among common arguments following: * weight boolean indicating weights considered * index name number column use weight. default, third column name network data.frame used * site_col name number column site nodes (.e. primary nodes). * species_col = name number column species nodes (.e. feature nodes) * return_node_type character indicating types nodes (“sites”, “species” “”) returned output (keep_nodes_type=“” default). * algorithm_in_output boolean indicating original output communities returned output (see Value). three algorithms relying executable binary files, following arguments needed: * delete_temp boolean indicating temporary folder removed * path_temp character indicating path temporary folder * binpath character indicating path bin folder","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"binary-files","dir":"Articles","previous_headings":"","what":"Binary files","title":"4.3 Network clustering","text":"","code":"install_binaries(binpath = \"tempdir\", infomap_version = c(\"2.1.0\", \"2.6.0\"))"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"infomap","dir":"Articles","previous_headings":"Binary files","what":"Infomap","title":"4.3 Network clustering","text":"Rosvall & Bergstrom (2008) nbmod penalize solutions differ number (0 default preferred number modules). markovtime scales link flow change cost moving modules, higher values results fewer modules (default 1). seed random number generator (NULL random default) numtrials number trials picking best solution. twolevel boolean indicating algorithm optimize two-level partition network (default multi-level). show_hierarchy boolean specifying hierarchy community identifiable outputs (FALSE default).","code":"set.seed(1) ex_infomap <- netclu_infomap(fish_simil,                              weight = TRUE,                              index = names(fish_simil)[3],                              nbmod = 0,                              markovtime = 1,                              seed = NULL,                              numtrials = 1,                              twolevel = FALSE,                              show_hierarchy = FALSE,                              directed = FALSE,                              bipartite_version = FALSE,                              bipartite = FALSE,                              site_col = 1,                              species_col = 2,                              return_node_type = \"both\",                              version = \"2.6.0\",                              binpath = \"tempdir\",                              path_temp = \"infomap_temp\",                              delete_temp = TRUE)  table(ex_infomap$clusters$K_5) ##  ##   1   2   3   4   5  ## 290  14  23   9   2"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"oslom","dir":"Articles","previous_headings":"Binary files","what":"OSLOM","title":"4.3 Network clustering","text":"OSLOM stands Order Statistics Local Optimization Method. Similarity-based algorithm. Lancichinetti et al. (2011) reassign string indicating nodes belonging several community reassign method used (see Note). * r number runs first hierarchical level (10 default). * hr number runs higher hierarchical level (50 default, 0 interested hierarchies). * seed random number generator (NULL random default). * t p-value, default value 0.10, increase value get modules. * cp kind resolution parameter used decide taking modules union (default value 0.5, bigger value leads bigger clusters).","code":"set.seed(1) ex_oslom <- netclu_oslom(fish_simil,                          weight = TRUE,                          index = names(fish_simil)[3],                          reassign = \"no\",                          r = 10,                          hr = 50,                          seed = NULL,                          t = 0.1,                          cp = 0.5,                          directed = FALSE,                          bipartite = FALSE,                          site_col = 1,                          species_col = 2,                          return_node_type = \"both\",                          binpath = \"tempdir\",                          path_temp = \"oslom_temp\",                          delete_temp = TRUE)  table(ex_oslom$clusters$K_338)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"louvain","dir":"Articles","previous_headings":"Binary files","what":"Louvain","title":"4.3 Network clustering","text":"Blondel et al. (2008) q quality function used compute partition graph (modularity chosen default, see Details). c parameter Owsinski-Zadrozny quality function (0 1, 0.5 chosen default) k kappa_min value Shi-Malik quality function (must > 0, 1 chosen default)","code":"set.seed(1) ex_louvain <- netclu_louvain(fishdf,                              weight = TRUE,                              index = names(fishdf)[3],                              lang = \"cpp\",                              q = 0,                              c = 0.5,                              k = 1,                              bipartite = FALSE,                              site_col = 1,                              species_col = 2,                              return_node_type = \"both\",                              binpath = \"tempdir\",                              path_temp = \"louvain_temp\",                              delete_temp = TRUE,                              algorithm_in_output = TRUE) table(ex_louvain$clusters$K_23) ##  ##   1  10  11  12  13  14  15  16  17  18  19   2  20  21  22  23   3   4   5   6  ##   6   4  55   3   3  10   3 119 107  16  10  43  18   4  35  14   5  20  17  12  ##   7   8   9  ##  22   2   5"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"fastgreedy","dir":"Articles","previous_headings":"Functions from the igraph package","what":"Fastgreedy","title":"4.3 Network clustering","text":"Clauset et al. (2004)","code":"set.seed(1) ex_greedy <- netclu_greedy(fishdf,                            weight = TRUE,                            index = names(fishdf)[3],                            bipartite = FALSE,                            site_col = 1,                            species_col = 2,                            return_node_type = \"both\",                            algorithm_in_output = TRUE) table(ex_greedy$clusters$K_5) ##  ##   1   2   3   4   5  ## 138  61 144 132  58"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"label-propagation","dir":"Articles","previous_headings":"Functions from the igraph package","what":"Label propagation","title":"4.3 Network clustering","text":"Raghavan et al. (2007)","code":"set.seed(1) ex_labelprop <- netclu_labelprop(fishdf,                                  weight = TRUE,                                  index = names(fishdf)[3],                                  bipartite = FALSE,                                  site_col = 1,                                  species_col = 2,                                  return_node_type = \"both\",                                  algorithm_in_output = TRUE) table(ex_labelprop$clusters$K_11) ## < table of extent 0 >"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"leiden-algorithm","dir":"Articles","previous_headings":"Functions from the igraph package","what":"Leiden algorithm","title":"4.3 Network clustering","text":"Traag et al. (2019)","code":"set.seed(1) ex_leiden <- netclu_leiden(fishdf,                            weight = TRUE,                            index = names(fishdf)[3],                            objective_function = \"CPM\",                            resolution_parameter = 1,                            beta = 0.01,                            n_iterations = 2,                            vertex_weights = NULL,                            bipartite = TRUE,                            site_col = 1,                            species_col = 2,                            return_node_type = \"both\",                            algorithm_in_output = TRUE) length(unique(ex_leiden$clusters$K_505)) ## [1] 0"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"leading-eigenvector","dir":"Articles","previous_headings":"Functions from the igraph package","what":"Leading eigenvector","title":"4.3 Network clustering","text":"Newman (2006)","code":"set.seed(1) ex_leadingeigen <- netclu_leadingeigen(fishdf,                                        weight = TRUE,                                        index = names(fishdf)[3],                                        bipartite = FALSE,                                        site_col = 1,                                        species_col = 2,                                        return_node_type = \"both\",                                        algorithm_in_output = TRUE) table(ex_leadingeigen$clusters$K_17) ## < table of extent 0 >"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"walktrap","dir":"Articles","previous_headings":"Functions from the igraph package","what":"Walktrap","title":"4.3 Network clustering","text":"Pons & Latapy (2005)","code":"set.seed(1) ex_walktrap <- netclu_walktrap(fishdf,                                weight = TRUE,                                index = names(fishdf)[3],                                steps = 4,                                bipartite = FALSE,                                site_col = 1,                                species_col = 2,                                return_node_type = \"both\",                                algorithm_in_output = TRUE) table(ex_walktrap$clusters$K_14) ##  ##   1  10  11  12  13  14   2   3   4   5   6   7   8   9  ##  11  47  10   2   6  17  84   5  37  16   5 270   4  19"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_3_network_clustering.html","id":"beckett","dir":"Articles","previous_headings":"Function from the bipartite package","what":"Beckett","title":"4.3 Network clustering","text":"Update QuanBiMo algorithm developed Dormann & Strauss (2014). Beckett (2016)","code":"set.seed(1) ex_beckett <- netclu_beckett(fishdf,                              weight = TRUE,                              index = names(fishdf)[3],                              site_col = 1,                              species_col = 2,                              return_node_type = \"both\",                              forceLPA = TRUE,                              algorithm_in_output = TRUE) ex_beckett$clusters$K_23 ##   [1] \"4\"  \"1\"  \"2\"  \"3\"  \"4\"  \"4\"  \"3\"  \"3\"  \"16\" \"13\" \"1\"  \"1\"  \"8\"  \"1\"  \"16\" ##  [16] \"5\"  \"4\"  \"3\"  \"4\"  \"8\"  \"4\"  \"1\"  \"4\"  \"4\"  \"5\"  \"4\"  \"4\"  \"1\"  \"13\" \"1\"  ##  [31] \"4\"  \"3\"  \"1\"  \"3\"  \"4\"  \"4\"  \"4\"  \"4\"  \"3\"  \"3\"  \"4\"  \"3\"  \"1\"  \"5\"  \"3\"  ##  [46] \"3\"  \"6\"  \"4\"  \"3\"  \"4\"  \"1\"  \"4\"  \"1\"  \"4\"  \"4\"  \"4\"  \"7\"  \"8\"  \"4\"  \"9\"  ##  [61] \"4\"  \"4\"  \"4\"  \"4\"  \"10\" \"10\" \"1\"  \"4\"  \"5\"  \"1\"  \"5\"  \"4\"  \"8\"  \"8\"  \"4\"  ##  [76] \"1\"  \"3\"  \"1\"  \"16\" \"13\" \"12\" \"1\"  \"22\" \"4\"  \"3\"  \"1\"  \"3\"  \"1\"  \"13\" \"4\"  ##  [91] \"4\"  \"8\"  \"4\"  \"8\"  \"15\" \"15\" \"15\" \"15\" \"4\"  \"1\"  \"8\"  \"4\"  \"1\"  \"8\"  \"4\"  ## [106] \"8\"  \"4\"  \"1\"  \"1\"  \"4\"  \"1\"  \"15\" \"1\"  \"1\"  \"5\"  \"1\"  \"16\" \"8\"  \"1\"  \"1\"  ## [121] \"1\"  \"13\" \"1\"  \"8\"  \"1\"  \"8\"  \"17\" \"18\" \"1\"  \"1\"  \"1\"  \"8\"  \"1\"  \"19\" \"1\"  ## [136] \"1\"  \"8\"  \"4\"  \"4\"  \"4\"  \"4\"  \"5\"  \"4\"  \"1\"  \"1\"  \"1\"  \"4\"  \"4\"  \"5\"  \"5\"  ## [151] \"3\"  \"8\"  \"1\"  \"11\" \"1\"  \"4\"  \"1\"  \"1\"  \"1\"  \"1\"  \"13\" \"16\" \"4\"  \"1\"  \"1\"  ## [166] \"1\"  \"1\"  \"1\"  \"1\"  \"3\"  \"8\"  \"5\"  \"5\"  \"20\" \"5\"  \"4\"  \"3\"  \"1\"  \"4\"  \"1\"  ## [181] \"4\"  \"1\"  \"6\"  \"1\"  \"13\" \"3\"  \"8\"  \"8\"  \"4\"  \"3\"  \"1\"  \"8\"  \"1\"  \"4\"  \"8\"  ## [196] \"1\"  \"3\"  \"4\"  \"1\"  \"4\"  \"8\"  \"4\"  \"1\"  \"1\"  \"4\"  \"1\"  \"16\" \"1\"  \"4\"  \"8\"  ## [211] \"1\"  \"3\"  \"15\" \"1\"  \"1\"  \"16\" \"13\" \"1\"  \"3\"  \"1\"  \"1\"  \"1\"  \"3\"  \"1\"  \"21\" ## [226] \"1\"  \"4\"  \"1\"  \"1\"  \"1\"  \"1\"  \"1\"  \"4\"  \"1\"  \"1\"  \"1\"  \"8\"  \"4\"  \"4\"  \"4\"  ## [241] \"1\"  \"22\" \"1\"  \"1\"  \"1\"  \"4\"  \"1\"  \"5\"  \"1\"  \"4\"  \"1\"  \"1\"  \"1\"  \"8\"  \"15\" ## [256] \"4\"  \"1\"  \"4\"  \"4\"  \"1\"  \"4\"  \"4\"  \"4\"  \"8\"  \"3\"  \"4\"  \"8\"  \"3\"  \"4\"  \"1\"  ## [271] \"1\"  \"13\" \"1\"  \"4\"  \"22\" \"1\"  \"1\"  \"3\"  \"3\"  \"5\"  \"5\"  \"4\"  \"4\"  \"1\"  \"4\"  ## [286] \"4\"  \"4\"  \"4\"  \"3\"  \"11\" \"4\"  \"3\"  \"4\"  \"1\"  \"1\"  \"1\"  \"1\"  \"8\"  \"4\"  \"4\"  ## [301] \"4\"  \"4\"  \"3\"  \"1\"  \"5\"  \"1\"  \"1\"  \"4\"  \"5\"  \"8\"  \"1\"  \"1\"  \"1\"  \"1\"  \"1\"  ## [316] \"5\"  \"1\"  \"4\"  \"1\"  \"1\"  \"14\" \"10\" \"8\"  \"4\"  \"1\"  \"4\"  \"4\"  \"4\"  \"4\"  \"3\"  ## [331] \"1\"  \"1\"  \"5\"  \"4\"  \"8\"  \"8\"  \"4\"  \"23\" \"4\"  \"4\"  \"4\"  \"8\"  \"8\"  \"1\"  \"4\"  ## [346] \"4\"  \"4\"  \"13\" \"1\"  \"4\"  \"4\"  \"1\"  \"16\" \"16\" \"2\"  \"16\" \"2\"  \"2\"  \"2\"  \"16\" ## [361] \"2\"  \"16\" \"3\"  \"4\"  \"3\"  \"3\"  \"3\"  \"3\"  \"3\"  \"3\"  \"3\"  \"3\"  \"4\"  \"5\"  \"4\"  ## [376] \"4\"  \"3\"  \"3\"  \"12\" \"16\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" \"13\" ## [391] \"13\" \"13\" \"13\" \"8\"  \"8\"  \"16\" \"16\" \"5\"  \"20\" \"15\" \"5\"  \"5\"  \"4\"  \"3\"  \"3\"  ## [406] \"8\"  \"15\" \"5\"  \"5\"  \"5\"  \"5\"  \"5\"  \"5\"  \"13\" \"8\"  \"13\" \"9\"  \"3\"  \"3\"  \"3\"  ## [421] \"5\"  \"6\"  \"19\" \"6\"  \"6\"  \"7\"  \"7\"  \"7\"  \"7\"  \"7\"  \"8\"  \"7\"  \"7\"  \"7\"  \"7\"  ## [436] \"21\" \"21\" \"7\"  \"21\" \"7\"  \"7\"  \"7\"  \"7\"  \"7\"  \"7\"  \"8\"  \"10\" \"8\"  \"10\" \"9\"  ## [451] \"9\"  \"9\"  \"9\"  \"10\" \"9\"  \"9\"  \"8\"  \"10\" \"22\" \"9\"  \"9\"  \"9\"  \"10\" \"9\"  \"8\"  ## [466] \"10\" \"9\"  \"9\"  \"4\"  \"10\" \"10\" \"8\"  \"10\" \"10\" \"15\" \"5\"  \"5\"  \"11\" \"11\" \"15\" ## [481] \"13\" \"13\" \"22\" \"22\" \"13\" \"22\" \"12\" \"12\" \"22\" \"13\" \"13\" \"15\" \"15\" \"14\" \"15\" ## [496] \"15\" \"15\" \"15\" \"15\" \"5\"  \"16\" \"17\" \"18\" \"18\" \"18\" \"18\" \"23\" \"19\" \"19\" \"13\" ## [511] \"20\" \"13\" \"22\" \"13\" \"13\" \"13\" \"3\"  \"21\" \"21\" \"21\" \"21\" \"21\" \"21\" \"4\"  \"22\" ## [526] \"22\" \"5\"  \"22\" \"22\" \"22\" \"5\"  \"10\" \"23\""},{"path":[]},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_4_microbenchmark.html","id":"vegemat","dir":"Articles","previous_headings":"1. Datasets","what":"1.1. Vegemat","title":"4.4 Microbenchmark","text":"first dataset comes available bioregion analyzed article. contains abundance 3,697 plant species distributed 715 sites French Mediterranean area. dataset use two following files: vegedf data.frame 460,878 rows 3 columns (Site, Species Abundance) vegemat co-occurrence matrix containing information gathered matrix 715 rows 3,697 columns.","code":"data(\"vegedf\") data(\"vegemat\")  vegemat_dissim <- dissimilarity(vegemat,  metric = c(\"abc\", \"Simpson\")) vegemat_df <- mat_to_net(vegemat, weight = TRUE, remove_zeroes = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_4_microbenchmark.html","id":"european-fish","dir":"Articles","previous_headings":"1. Datasets","what":"1.2. European fish","title":"4.4 Microbenchmark","text":"second dataset also comes available bioregion contains distribution 195 freshwater fish distributed basins Europe.","code":"data(\"fishmat\") fishdissim <- dissimilarity(fishmat, metric = \"all\") data(\"fishdf\")"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_4_microbenchmark.html","id":"aravo","dir":"Articles","previous_headings":"1. Datasets","what":"1.3. Aravo","title":"4.4 Microbenchmark","text":"third dataset, called aravo, retrieved package ade4. contains distribution 82 alpine plants 75 sites distributed French Alps.","code":"data(\"aravo\") aravo <- as.matrix(aravo$spe) dim(aravo) ## [1] 75 82 ara_dissim <- dissimilarity(aravo, metric = \"all\")  ara_df <- mat_to_net(aravo, weight = TRUE, remove_zeroes = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a4_4_microbenchmark.html","id":"microbenchmark","dir":"Articles","previous_headings":"","what":"2. Microbenchmark","title":"4.4 Microbenchmark","text":"assess time needed clustering algorithm three datasets loaded . Plotting results.   OSLOM Beckett slow, ran far Vegetation data.","code":"install_binaries()  mbm <- suppressMessages(   microbenchmark(     # aravo     ara_nhclu_dbscan = nhclu_dbscan(dissimilarity = ara_dissim,                                     index = \"Simpson\", plot = FALSE),     ara_nhclu_kmeans = nhclu_kmeans(ara_dissim, n_clust = 2:10,                                     index = \"Simpson\"),     ara_nhclu_pam = nhclu_pam(ara_dissim, n_clust = 2:10, index = \"Simpson\"),     ara_hclu_hierarclust = hclu_hierarclust(dissimilarity = ara_dissim,                                             n_clust = 5,                                             optimal_tree_method = \"best\"),     ara_hclu_optics = hclu_optics(ara_dissim, index = \"Simpson\"),     ara_netclu_beckett = netclu_beckett(ara_df),     ara_netclu_greedy = netclu_greedy(ara_df),     ara_netclu_labelprop = netclu_labelprop(ara_df),     ara_netclu_leadingeigen = netclu_leadingeigen(ara_df),     ara_netclu_oslom = netclu_oslom(ara_df),     ara_netclu_walktrap = netclu_walktrap(ara_df),     ara_netclu_infomap = netclu_infomap(ara_df),     ara_netclu_louvain = netclu_louvain(ara_df),          # fish vertebrates     fish_nhclu_dbscan = nhclu_dbscan(dissimilarity = fishdissim,                                      index = \"Simpson\", plot = FALSE),     fish_nhclu_kmeans = nhclu_kmeans(fishdissim, n_clust = 2:10,                                      index = \"Simpson\"),     fish_nhclu_pam = nhclu_pam(fishdissim, n_clust = 2:10, index = \"Simpson\"),     fish_hclu_hierarclust = hclu_hierarclust(dissimilarity = fishdissim,                                              n_clust = 5,                                              optimal_tree_method = \"best\"),     fish_hclu_optics = hclu_optics(fishdissim, index = \"Simpson\"),     fish_netclu_beckett = netclu_beckett(fishdf),     fish_netclu_greedy = netclu_greedy(fishdf),     fish_netclu_labelprop = netclu_labelprop(fishdf),     fish_netclu_leadingeigen = netclu_leadingeigen(fishdf),     fish_netclu_oslom = netclu_oslom(fishdf),     fish_netclu_walktrap = netclu_walktrap(fishdf),     fish_netclu_infomap = netclu_infomap(fishdf),     fish_netclu_louvain = netclu_louvain(fishdf),          # vegetation     veg_nhclu_dbscan = nhclu_dbscan(dissimilarity = vegemat_dissim,                                     index = \"Simpson\", plot = FALSE),     veg_nhclu_kmeans = nhclu_kmeans(vegemat_dissim, n_clust = 2:10,                                     index = \"Simpson\"),     veg_nhclu_pam = nhclu_pam(vegemat_dissim, n_clust = 2:10,                               index = \"Simpson\"),     veg_hclu_hierarclust = hclu_hierarclust(dissimilarity = vegemat_dissim,                                             n_clust = 5,                                             optimal_tree_method = \"best\"),     veg_hclu_optics = hclu_optics(vegemat_dissim, index = \"Simpson\"),     # veg_netclu_beckett = netclu_beckett(vegemat_df),     veg_netclu_greedy = netclu_greedy(vegemat_df),     veg_netclu_labelprop = netclu_labelprop(vegemat_df),     veg_netclu_leadingeigen = netclu_leadingeigen(vegemat_df),     # veg_netclu_oslom = netclu_oslom(vegemat_df),     veg_netclu_walktrap = netclu_walktrap(vegemat_df),     veg_netclu_infomap = netclu_infomap(vegemat_df),     veg_netclu_louvain = netclu_louvain(vegemat_df),          times = 2))  mbm_plot <- data.frame(mbm) mbm_plot$expr <- as.character(mbm_plot$expr) mbm_plot$dataset <- ifelse(   grepl(\"ara_\", mbm_plot$expr),   paste0(\"Aravo (\", nrow(aravo) * ncol(aravo), \" cells)\"),   ifelse(grepl(\"fish\", mbm_plot$expr),          paste0(\"Fish (\", nrow(fishmat) * ncol(fishmat), \" cells)\"),          paste0(\"Vegetation (\", nrow(vegemat) * ncol(vegemat), \" cells)\")))  mbm_plot$algorithm <- gsub( \".*_\", \"\", mbm_plot$expr)  # Time in minutes mbm_plot$time_min <- mbm_plot$time / 60e9 # Time in seconds mbm_plot$time_sec <- mbm_plot$time / 1e9 ggplot(mbm_plot[which(mbm_plot$dataset == \"Aravo (6150 cells)\"), ],        aes(reorder(algorithm, time_sec), time_sec)) +   geom_boxplot(aes(color = reorder(algorithm, time_sec),                    fill = reorder(algorithm, time_sec)), show.legend = FALSE) +   scale_color_viridis_d(\"Algorithm\") +   scale_fill_viridis_d(\"Algorithm\") +   labs(title = \"Aravo (6,510 cells)\", x = \"\", y = \"Time (seconds)\") +   theme_classic() +   theme(panel.border = element_rect(fill = NA),         axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) ggplot(mbm_plot[which(mbm_plot$dataset == \"Fish (65910 cells)\"), ],        aes(reorder(algorithm, time_sec), time_sec)) +   geom_boxplot(aes(color = reorder(algorithm, time_sec),                    fill = reorder(algorithm, time_sec)), show.legend = FALSE) +   scale_color_viridis_d(\"Algorithm\") +   scale_fill_viridis_d(\"Algorithm\") +   labs(title = \"European fish (65,910 cells)\",        x = \"\", y = \"Time (seconds)\") +   theme_classic() +   theme(panel.border = element_rect(fill = NA),         axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) ggplot(mbm_plot[which(mbm_plot$dataset == \"Vegetation (2643355 cells)\"), ],        aes(reorder(algorithm, time_min), time_min)) +   geom_boxplot(aes(color = reorder(algorithm, time_min),                    fill = reorder(algorithm, time_min)), show.legend = FALSE) +   scale_color_viridis_d(\"Algorithm\") +   scale_fill_viridis_d(\"Algorithm\") +   labs(title = \"Vegetation (2,643,355 cells)\", x = \"\", y = \"Time (minutes)\") +   theme_classic() +   theme(panel.border = element_rect(fill = NA),         axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"5.1 Visualization","text":"vignette, rely dataset describing distribution vascular plants Mediterranean part France. first load matrix format dataset, computes dissimilarity matrix also load data.frame format data. Since aim plotting result, also need object fishsf linking site dataset geometry. also import world coastlines, available rnaturalearth R package.","code":"data(vegemat) vegedissim <- dissimilarity(vegemat, metric = \"all\") data(vegedf) data(vegesf) world <- rnaturalearth::ne_coastline(returnclass = \"sf\", scale = \"medium\") # Align the CRS of both objects vegesf <- st_transform(vegesf, crs = st_crs(world))"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"plots","dir":"Articles","previous_headings":"","what":"Plots","title":"5.1 Visualization","text":"section, show three ways plot results.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"map_bioregions","dir":"Articles","previous_headings":"Plots","what":"map_bioregions()","title":"5.1 Visualization","text":"first possibility use function map_bioregions() package. function can directly provide plot site colored according cluster belong .  Let’s take example K-means clustering, number clusters set 3. map_bioregions() function can now simply takes object fish_nhclu_kmeans, bioregion.clusters class, spatial distribution sites, stored fishsf.","code":"set.seed(1) vege_nhclu_kmeans <- nhclu_kmeans(vegedissim, n_clust = 3, index = \"Simpson\") map_bioregions(vege_nhclu_kmeans, geometry = vegesf, plot = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"custom-plot","dir":"Articles","previous_headings":"Plots","what":"Custom plot","title":"5.1 Visualization","text":"want customize plot simply rely default option, map_bioregions() gives possibility extract site well geometry cluster number. purpose, can set arguments like chunk :","code":"custom <- map_bioregions(vege_nhclu_kmeans, geometry = vegesf,                          write_clusters = TRUE, plot = FALSE) custom ## Simple feature collection with 715 features and 2 fields ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 1.686171 ymin: 42.29604 xmax: 7.798711 ymax: 45.13742 ## Geodetic CRS:  WGS 84 ## First 10 features: ##    ID K_3                       geometry ## 1  35   2 POLYGON ((6.098099 45.13742... ## 2  36   2 POLYGON ((6.22521 45.13381,... ## 3  37   2 POLYGON ((6.352304 45.13007... ## 4  38   2 POLYGON ((6.47938 45.12617,... ## 5  39   2 POLYGON ((6.606438 45.12213... ## 6  84   2 POLYGON ((6.093117 45.04745... ## 7  85   2 POLYGON ((6.220024 45.04385... ## 8  86   2 POLYGON ((6.346914 45.04011... ## 9  87   2 POLYGON ((6.473786 45.03622... ## 10 88   2 POLYGON ((6.600641 45.03219... # Crop world coastlines to the extent of the sf object of interest europe <- sf::st_crop(world, sf::st_bbox(custom))  # Plot ggplot(custom) +   geom_sf(aes(fill = K_3), show.legend = FALSE) +   geom_sf(data = europe) +   scale_fill_viridis_d() +   labs(title = \"Kmeans with 3 clusters\") +   theme_void()"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_1_visualization.html","id":"plot-with-facets","dir":"Articles","previous_headings":"Plots","what":"Plot with facets","title":"5.1 Visualization","text":"Finally, can interested plotting several bioregionalizations . purpose, can build single data.frame gathering bioregions obtained distinct algorithms take advantage facets implemented ggplot2. first compute bioregionalizations dataset using algorithms. can now make single data.frame extra-column indicating algorithm used. now convert data.frame long-format data.frame. now add back geometry extra column make object spatial. Now long-format spatial data.frame, can take advantage facets implemented ggplot2.  can refine map : * reordering 3 bioregions follow order * add background Mediterranean sea mainland * crop cells mainland * adjust labels","code":"# Hierarchical clustering set.seed(1) vege_hclu_hierarclust <- hclu_hierarclust(dissimilarity = vegedissim,                                           index = names(vegedissim)[6],                                           method = \"mcquitty\", n_clust = 3,                                           optimal_tree_method = \"best\") vege_hclu_hierarclust$cluster_info ##   partition_name n_clust requested_n_clust output_cut_height ## 1            K_3       3                 3             0.625 # Walktrap network bioregionalization vegesim <- dissimilarity_to_similarity(vegedissim) set.seed(1) vege_netclu_walktrap <- netclu_walktrap(vegesim,                                         index = names(vegesim)[6]) vege_netclu_walktrap$cluster_info # 3 ##     partition_name n_clust ## K_3            K_3       3 vege_kmeans <- vege_nhclu_kmeans$clusters colnames(vege_kmeans)<- c(\"ID\", \"NHCLU_KMEANS\") vege_hieraclust <- vege_hclu_hierarclust$clusters colnames(vege_hieraclust)<- c(\"ID\", \"HCLU_HIERARCLUST\") vege_walktrap <- vege_netclu_walktrap$clusters colnames(vege_walktrap)<- c(\"ID\", \"NETCLU_Walktrap\")  all_clusters <- dplyr::left_join(vege_kmeans, vege_hieraclust, by = \"ID\") all_clusters <- dplyr::left_join(all_clusters, vege_walktrap, by = \"ID\") all_long <- tidyr::pivot_longer(data = all_clusters,                                 cols = dplyr::contains(\"_\"),                                 names_to = \"Algorithm\",                                 values_to = \"Clusters\") all_long <- as.data.frame(all_long) all_long_sf <- dplyr::left_join(all_long,                                 vegesf[, c(\"ID\", \"geometry\")],                                 by = \"ID\") all_long_sf <- sf::st_as_sf(all_long_sf) ggplot(all_long_sf) +   geom_sf(aes(color = Clusters, fill = Clusters)) +   geom_sf(data = europe, fill = \"gray80\") +   scale_color_viridis_d() +   scale_fill_viridis_d() +   theme_void() +   facet_wrap(~ Algorithm) world_countries <- rnaturalearth::ne_countries(scale = \"medium\",                                                returnclass = \"sf\")  # Background box xmin <- st_bbox(world)[[\"xmin\"]]; xmax <- st_bbox(world)[[\"xmax\"]] ymin <- st_bbox(world)[[\"ymin\"]]; ymax <- st_bbox(world)[[\"ymax\"]] bb <- sf::st_union(sf::st_make_grid(st_bbox(c(xmin = xmin,                                               xmax = xmax,                                               ymax = ymax,                                               ymin = ymin),                                             crs = st_crs(4326)),                                     n = 100))  # Crop world coastlines to the extent of the sf object of interest vegesf <- st_transform(vegesf, crs = st_crs(world)) larger_bbox <- sf::st_bbox(vegesf) larger_bbox[[1]] <- 1.5 larger_bbox[[2]] <- 42.15 larger_bbox[[3]] <- 8.1 larger_bbox[[4]] <- 45.3  europe <- sf::st_crop(world, larger_bbox) sf_use_s2(FALSE) europe_countries <- sf::st_crop(world_countries, larger_bbox) europe_bb <- sf::st_crop(bb, larger_bbox)  plot_basis <- ggplot(europe) +   geom_sf(data = europe_bb, fill = \"aliceblue\") +   geom_sf(data = europe_countries, fill = \"ivory\", color = \"gray50\") +   theme_void()  # Reordering bioregions all_long_sf$bioregion <- all_long_sf$Clusters  all_long_sf[which(all_long_sf$Algorithm == \"NHCLU_KMEANS\" &                     all_long_sf$Clusters == \"2\"), ]$bioregion <- \"3\" all_long_sf[which(all_long_sf$Algorithm == \"NHCLU_KMEANS\" &                     all_long_sf$Clusters == \"3\"), ]$bioregion <- \"2\"  all_long_sf[which(all_long_sf$Algorithm == \"NETCLU_Walktrap\" &                     all_long_sf$Clusters == \"1\"), ]$bioregion <- \"2\" all_long_sf[which(all_long_sf$Algorithm == \"NETCLU_Walktrap\" &                     all_long_sf$Clusters == \"2\"), ]$bioregion <- \"3\" all_long_sf[which(all_long_sf$Algorithm == \"NETCLU_Walktrap\" &                     all_long_sf$Clusters == \"3\"), ]$bioregion <- \"1\"  # More readable labels for algorithms all_long_sf$Algo <-   ifelse(all_long_sf$Algorithm == \"NHCLU_KMEANS\", \"K-Means\",          ifelse(all_long_sf$Algorithm == \"NHCLU_PAM\", \"PAM\",                 ifelse(all_long_sf$Algorithm == \"HCLU_HIERARCLUST\",                        \"Hierarchical Clustering\", \"Walktrap\")))  # Cropping with borders of France all_long_sf_france <-   st_intersection(all_long_sf,                   europe_countries[which(europe_countries$sovereignt == \"France\"), ])  # Plot final_plot <- plot_basis +   geom_sf(data = all_long_sf_france,           aes(color = bioregion, fill = bioregion), show.legend = TRUE) +   geom_sf(data = st_union(all_long_sf_france), fill = \"NA\", color = \"gray50\") +   geom_sf(data = europe, fill = \"gray50\", linewidth = 0.1) +   scale_color_viridis_d(\"Bioregion\", option = \"magma\", direction = -1) +   scale_fill_viridis_d(\"Bioregion\", option = \"magma\", direction = -1) +   theme_void() +   theme(legend.position = \"bottom\") +   facet_wrap(~ Algo) final_plot"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_compare_bioregionalizations.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"5.2 Compare bioregionalizations","text":"use vegetation dataset comes bioregion.","code":"data(\"vegedf\") data(\"vegemat\")  # Calculation of (dis)similarity matrices vegedissim <- dissimilarity(vegemat, metric = c(\"Simpson\")) vegesim <- dissimilarity_to_similarity(vegedissim)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_compare_bioregionalizations.html","id":"bioregionalization","dir":"Articles","previous_headings":"","what":"Bioregionalization","title":"5.2 Compare bioregionalizations","text":"use three bioregionalization algorithms visualization vignette, .e. non-hierarchical, hierarchical network bioregionalizations. chose 3 bioregions non-hierarchical hierarchical bioregionalizations.","code":"# Non hierarchical bioregionalization vege_nhclu_kmeans <- nhclu_kmeans(vegedissim, n_clust = 3, index = \"Simpson\") vege_nhclu_kmeans$cluster_info # 3 ##     partition_name n_clust ## K_3            K_3       3 # Hierarchical bioregionalization set.seed(1) vege_hclu_hierarclust <- hclu_hierarclust(dissimilarity = vegedissim,                                           method = \"mcquitty\", n_clust = 3,                                           optimal_tree_method = \"best\") vege_hclu_hierarclust$cluster_info # 3 ##   partition_name n_clust requested_n_clust output_cut_height ## 1            K_3       3                 3             0.625 # Network bioregionalization set.seed(1) vege_netclu_walktrap <- netclu_walktrap(vegesim,                                         index = names(vegesim)[3]) vege_netclu_walktrap$cluster_info # 3 ##     partition_name n_clust ## K_3            K_3       3"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_compare_bioregionalizations.html","id":"compare-the-bioregionalizations","dir":"Articles","previous_headings":"","what":"Compare the bioregionalizations","title":"5.2 Compare bioregionalizations","text":"comparing bioregionalizations, build common data.frame containing three distinct bioregionalizations. can now run function compare_bioregionalizations(). compare_bioregionalizations() produces several outputs : - look within bioregionalization sites assigned bioregions - compare different bioregionalizations analysing whether produce similar pairwise memberships Let’s first look pairwise membership within bioregionalization.","code":"comp <- dplyr::left_join(vege_hclu_hierarclust$clusters,                          vege_netclu_walktrap$clusters,                          by = \"ID\") colnames(comp) <- c(\"ID\", \"K_3_hclu\", \"K_3_netclu\") comp <- dplyr::left_join(comp,                          vege_nhclu_kmeans$clusters,                          by = \"ID\") colnames(comp) <- c(\"ID\", \"K_3_hclu\", \"K_3_netclu\", \"K_3_nhclu\")  head(comp) ##     ID K_3_hclu K_3_netclu K_3_nhclu ## 1  512        1          1         1 ## 2  799        1          3         1 ## 3  375        2          1         2 ## 4  476        2          1         2 ## 5  971        1          3         1 ## 6 1282        1          3         1 hclu_vs_netclu <- compare_bioregionalizations(   cluster_object = comp[, c(\"K_3_hclu\", \"K_3_netclu\", \"K_3_nhclu\")],   store_pairwise_membership = TRUE,   cor_frequency = TRUE,   store_confusion_matrix = TRUE)  str(hclu_vs_netclu) ## List of 7 ##  $ args                         :List of 4 ##   ..$ indices                  : chr [1:2] \"rand\" \"jaccard\" ##   ..$ cor_frequency            : logi TRUE ##   ..$ store_pairwise_membership: logi TRUE ##   ..$ store_confusion_matrix   : logi TRUE ##  $ inputs                       : Named int [1:2] 715 3 ##   ..- attr(*, \"names\")= chr [1:2] \"number_items\" \"number_bioregionalizations\" ##  $ pairwise_membership          : logi [1:255255, 1:3] TRUE FALSE FALSE TRUE TRUE TRUE ... ##   ..- attr(*, \"dimnames\")=List of 2 ##   .. ..$ : chr [1:255255] \"1_2\" \"1_3\" \"1_4\" \"1_5\" ... ##   .. ..$ : chr [1:3] \"K_3_hclu\" \"K_3_netclu\" \"K_3_nhclu\" ##  $ freq_item_pw_membership      : Named num [1:255255] 2 1 1 2 2 2 2 2 2 2 ... ##   ..- attr(*, \"names\")= chr [1:255255] \"1_2\" \"1_3\" \"1_4\" \"1_5\" ... ##  $ bioregionalization_freq_cor  : Named num [1:3] 0.851 0.737 0.893 ##   ..- attr(*, \"names\")= chr [1:3] \"K_3_hclu\" \"K_3_netclu\" \"K_3_nhclu\" ##  $ confusion_matrix             :List of 3 ##   ..$ K_3_hclu%K_3_netclu : Named int [1:4] 63316 41892 36800 113247 ##   .. ..- attr(*, \"names\")= chr [1:4] \"a\" \"b\" \"c\" \"d\" ##   ..$ K_3_hclu%K_3_nhclu  : Named int [1:4] 85543 19665 11248 138799 ##   .. ..- attr(*, \"names\")= chr [1:4] \"a\" \"b\" \"c\" \"d\" ##   ..$ K_3_netclu%K_3_nhclu: Named int [1:4] 66314 33802 30477 124662 ##   .. ..- attr(*, \"names\")= chr [1:4] \"a\" \"b\" \"c\" \"d\" ##  $ bioregionalization_comparison:'data.frame':   3 obs. of  3 variables: ##   ..$ bioregionalization_comparison: chr [1:3] \"K_3_hclu%K_3_netclu\" \"K_3_hclu%K_3_nhclu\" \"K_3_netclu%K_3_nhclu\" ##   ..$ rand                         : num [1:3] 0.692 0.879 0.748 ##   ..$ jaccard                      : num [1:3] 0.446 0.735 0.508 ##  - attr(*, \"class\")= chr [1:2] \"bioregion.bioregionalization.comparison\" \"list\""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_compare_bioregionalizations.html","id":"pairwise-membership","dir":"Articles","previous_headings":"Compare the bioregionalizations","what":"Pairwise membership","title":"5.2 Compare bioregionalizations","text":"number pairwise combinations \\(n\\) sites equals \\(n(n-1)/2\\). case, 715 sites, end 2.55255^{5} pairwise combinations. Pairwise memberships look pairs site whether assigned different bioregion. Let’s look sites 1 9 across different bioregionalization: can see sites 1 9 classified bioregion first two bioregionalizations, third one. $pairwise_membership output compare_bioregionalizations() shows TRUE/FALSE statement. number times pair sites clustered together (.e. sum rows table $pairwise_membership) available $freq_item_pw_membership output: sites 1 2 never classified bioregion across three bioregionalizations. Sites 1 9 classified bioregion two bioregionalizations. look total frequencies: see dominant situation sites never assigned bioregion.","code":"nrow(hclu_vs_netclu$pairwise_membership) == nrow(comp)*(nrow(comp)-1)/2 ## [1] TRUE comp[c(1, 9), ] ##    ID K_3_hclu K_3_netclu K_3_nhclu ## 1 512        1          1         1 ## 9 948        1          3         1 hclu_vs_netclu$pairwise_membership[8:10, ] ##      K_3_hclu K_3_netclu K_3_nhclu ## 1_9      TRUE      FALSE      TRUE ## 1_10     TRUE      FALSE      TRUE ## 1_11     TRUE      FALSE      TRUE hclu_vs_netclu$freq_item_pw_membership[c(1, 8)] ## 1_2 1_9  ##   2   2 table(hclu_vs_netclu$freq_item_pw_membership) ##  ##      0      1      2      3  ## 111723  41539  45403  56590"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_2_compare_bioregionalizations.html","id":"confusion-matrix","dir":"Articles","previous_headings":"Compare the bioregionalizations","what":"Confusion matrix","title":"5.2 Compare bioregionalizations","text":"confusion matrix allows compare different bioregionalizations looking similarity pairwise memberships. , function computes confusion matrix four elements: . \\(\\) number pairs sites grouped bioregionalization 1 bioregionalization 2 . \\(b\\) number pairs sites grouped bioregionalization 1 bioregionalization 2 . \\(c\\) number pairs sites grouped bioregionalization 1 grouped bioregionalization 2 . \\(d\\) number pairs sites grouped bioregionalization 1 & 2 Based confusion matrices, can compute range indices indicate agreement among bioregionalizations. now, implemented:Rand index \\((+d)/(+b+c+d)\\) Rand index measures agreement among bioregionalizations accounting pairs sites grouped, also pairs sites grouped.Jaccard index  \\(/(+b+c)\\) Jaccard index measures agreement among bioregionalizations accounting pairs sites grouped. two metrics complementary, Jaccard index tell bioregionalizations similar clustering structure, whereas Rand index tell bioregionalizations similar pairs items clustered together, also terms pairs sites clustered together. example, take two bioregionalizations never group together pairs sites. Jaccard index 0, whereas Rand index can > 0 due sites grouped together. Additional indices can manually computed users basis list confusion matrices. cases, users may interested finding bioregionalizations representative bioregionalizations find , can compare pairwise membership bioregionalization total frequency pairwise membership across bioregionalizations. correlation can requested cor_frequency = TRUE. third bioregionalization representative bioregionalizations.","code":"hclu_vs_netclu$confusion_matrix ## $`K_3_hclu%K_3_netclu` ##      a      b      c      d  ##  63316  41892  36800 113247  ##  ## $`K_3_hclu%K_3_nhclu` ##      a      b      c      d  ##  85543  19665  11248 138799  ##  ## $`K_3_netclu%K_3_nhclu` ##      a      b      c      d  ##  66314  33802  30477 124662 hclu_vs_netclu$partition_freq_cor ## NULL"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_summary_metrics.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"5.3 Summary metrics","text":"use vegetation dataset comes bioregion.","code":"data(\"vegedf\") data(\"vegemat\")  # Calculation of (dis)similarity matrices vegedissim <- dissimilarity(vegemat, metric = c(\"Simpson\")) vegesim <- dissimilarity_to_similarity(vegedissim)"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_summary_metrics.html","id":"bioregionalization","dir":"Articles","previous_headings":"","what":"Bioregionalization","title":"5.3 Summary metrics","text":"use three bioregionalization algorithms visualization vignette, .e. non-hierarchical, hierarchical network bioregionalizations. chose 3 bioregions non-hierarchical hierarchical bioregionalizations.","code":"# Non hierarchical bioregionalization vege_nhclu_kmeans <- nhclu_kmeans(vegedissim, n_clust = 3, index = \"Simpson\") vege_nhclu_kmeans$cluster_info # 3 ##     partition_name n_clust ## K_3            K_3       3 # Hierarchical bioregionalization set.seed(1) vege_hclu_hierarclust <- hclu_hierarclust(dissimilarity = vegedissim,                                           index = names(vegedissim)[3],                                           method = \"average\", n_clust = 3,                                           optimal_tree_method = \"best\") vege_hclu_hierarclust$cluster_info # 3 ##   partition_name n_clust requested_n_clust output_cut_height ## 1            K_3       3                 3            0.5625 # Network bioregionalization set.seed(1) vege_netclu_walktrap <- netclu_walktrap(vegesim,                                         index = names(vegesim)[3]) vege_netclu_walktrap$cluster_info # 3 ##     partition_name n_clust ## K_3            K_3       3"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_summary_metrics.html","id":"bioregion-metrics","dir":"Articles","previous_headings":"","what":"Bioregion metrics","title":"5.3 Summary metrics","text":"Number sites belonging bioregion, many species sites contain. Number endemic proportion endemism also calculated. Endemic species species present sites assigned particular bioregion.","code":"bioregion_summary <- bioregion_metrics(cluster_object = vege_nhclu_kmeans,                                        comat = vegemat) bioregion_summary ##   Bioregion Site_number Species_number Endemics Percentage_Endemic ## 1         3         146           2666      121           4.538635 ## 2         2         210           3102       57           1.837524 ## 3         1         359           2824      407          14.412181"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_summary_metrics.html","id":"species-metrics","dir":"Articles","previous_headings":"","what":"Species metrics","title":"5.3 Summary metrics","text":"Different summary statistics available species level.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_summary_metrics.html","id":"contribution-rho","dir":"Articles","previous_headings":"Species metrics","what":"Contribution (\\(\\rho\\))","title":"5.3 Summary metrics","text":"contribution index \\(\\rho\\) calculated species x bioregion combination, following (Lenormand et al., 2019).  formula following: \\[\\rho_{ij} = \\frac{n_{ij} - \\frac{n_i n_j}{n}}{\\sqrt{\\frac{n - n_j}{n-1} (1-\\frac{n_j}{n}) \\frac{n_i n_j}{n}}}\\] \\(n\\) number sites, \\(n_i\\) number sites species \\(\\) present, \\(n_j\\) number sites belonging bioregion \\(j\\), \\(n_ij\\) number occurrences species \\(\\) sites belonging bioregion \\(j\\).","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_summary_metrics.html","id":"individual-contributions","dir":"Articles","previous_headings":"Species metrics","what":"Individual contributions","title":"5.3 Summary metrics","text":"Affinity, fidelity individual contributions describe species linked bioregions. metrics presented (Bernardo-Madrid et al., 2019). Affinity species region: \\[A_i = \\frac{R_i}{Z}\\] \\(R_i\\) occurrence/range size species \\(\\) associated bioregion, \\(Z\\) total size (number sites) bioregion. high affinity means species occupying sites associated bioregion. Fidelity species region: \\[F_i = \\frac{R_i}{D_i}\\] \\(R_i\\) occurrence/range size species \\(\\) associated bioregion, \\(D_i\\) total occurrence/range size. high fidelity means species present bioregions associated one. Indicator Value species: \\[IndVal = F_i \\times A_i\\]","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_summary_metrics.html","id":"bipartite-metrics","dir":"Articles","previous_headings":"","what":"Bipartite metrics","title":"5.3 Summary metrics","text":"running community detection algorithm site x species matrix, sites species get bioregion assigned. degree affinity types nodes can therefore directly assessed, metrics like coefficient participation C within-bioregion degree z.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_summary_metrics.html","id":"cz-statistics","dir":"Articles","previous_headings":"Bipartite metrics","what":"Cz statistics","title":"5.3 Summary metrics","text":"Cz metrics derived (Guimerà & Amaral, 2005). respective formula : \\[C_i = 1 - \\sum_{s=1}^{N_M}{{(\\frac{k_is}{k_i}})^2}\\] \\(k_{}\\) number links node (species site) \\(\\) nodes bioregion \\(s\\), \\(k_i\\) total degree node \\(\\). participation coefficient node therefore close 1 links uniformly distributed among bioregions 0 links within bioregion. : \\[z_i = \\frac{k_i - \\overline{k_{si}}}{\\sigma_{k_{si}}}\\] \\(k_i\\) number links node (species site) \\(\\) nodes bioregion \\(s_i\\), \\(\\overline{k_{si}}\\) average \\(k\\) nodes \\(s_i\\), \\(\\sigma_{k_{si}}\\) standard deviation \\(k\\) \\(s_i\\). within-bioregion degree z-score measures well-connected node \\(\\) nodes bioregion.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_summary_metrics.html","id":"running-the-site_species_metrics-function","dir":"Articles","previous_headings":"Bipartite metrics","what":"Running the site_species_metrics function","title":"5.3 Summary metrics","text":"can now run function site_species_metrics(). site_species_metrics() outputs data.frame contribution metrics available species level.","code":"contrib_kmeans <- site_species_metrics(vege_nhclu_kmeans, vegemat,                                        indices = \"rho\") contrib_hclu <- site_species_metrics(vege_hclu_hierarclust, vegemat,                                      indices = \"rho\") contrib_netclu <- site_species_metrics(vege_netclu_walktrap, vegemat,                                        indices = \"rho\")  # Cz indices clust_bip <- netclu_greedy(vegedf, bipartite = TRUE) cz_netclu <- site_species_metrics(cluster_object = clust_bip,  comat = vegemat,                                   bipartite_link = vegedf, indices = \"Cz\")"},{"path":"https://bioRgeo.github.io/bioregion/articles/a5_3_summary_metrics.html","id":"spatial-coherence","dir":"Articles","previous_headings":"","what":"Spatial coherence","title":"5.3 Summary metrics","text":"use metric spatial coherence (Divíšek et al., 2016), except replace number pixels per bioregion area coherent part. spatial coherence expressed percentage, following formula: \\[SC_j = 100 \\times \\frac{LargestPatch_j}{Area_j}\\] \\(j\\) bioregion. example vegetation dataset. bioregion 4 almost constituted one homogeneous block, spatial coherence close 100 %.","code":"# Spatial coherence vegedissim <- dissimilarity(vegemat) hclu <- nhclu_kmeans(dissimilarity = vegedissim, n_clust = 4) vegemap <- map_bioregions(hclu, vegesf, write_clusters = TRUE, plot = FALSE)  bioregion_metrics(cluster_object = hclu, comat = vegemat, map = vegemap, col_bioregion = 2) ##   Bioregion Site_number Species_number Endemics Percentage_Endemic Coherence ## 1         2         128           2527       90           3.561535  49.21875 ## 2         1         169           2983       45           1.508548  56.21302 ## 3         4         298           2936       56           1.907357  98.99329 ## 4         3         120           2262       67           2.961981  79.16667 ggplot(vegemap) +   geom_sf(aes(fill = as.factor(K_4))) +   scale_fill_viridis_d(\"Bioregion\") +   theme_bw() +   theme(legend.position = \"bottom\")"},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"brief-introduction","dir":"Articles","previous_headings":"","what":"0. Brief introduction","title":"Tutorial for bioregion","text":"tutorial aims describing different features R package bioregion. main purpose bioregion‘s package propose transparent methodological framework compare bioregionalization methods. typical flow chart bioregions’ identification based site-species bipartite network co-occurrence matrix bioregion (Figure 1). workflow can divided four main steps: Preprocess data (matrix network formats) Compute similarity/dissimilarity metrics sites based species composition Run different algorithms identify different set bioregions Evaluate visualize results","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"install-binary-files","dir":"Articles","previous_headings":"","what":"1. Install binary files","title":"Tutorial for bioregion","text":"functions least part (listed ) require binary files run. netclu_infomap netclu_louvain (Cpp version) netclu_oslom Please check tutorial page get instructions regarding installation binary files.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"matrix-or-network-formats","dir":"Articles","previous_headings":"","what":"2. Matrix or Network formats","title":"Tutorial for bioregion","text":"bioregion’s package takes input site-species information stored bipartite network co-occurrence matrix. Relying function mat_to_net net_to_mat , handles matrix network formats throughout workflow. Please look tutorial page better understand two functions work.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"pairwise-similaritydissimilarity-metrics","dir":"Articles","previous_headings":"","what":"3. Pairwise similarity/dissimilarity metrics","title":"Tutorial for bioregion","text":"functions similarity dissimilarity compute respectively pairwise similarity dissimilarity metrics based (site-species) co-occurrence matrix. resulting data.frame stored bioregion.pairwise.metric object containing requested metrics pair sites. functions dissimilarity_to_similarity similarity_to_dissimilarity can used transform similarity object dissimilarity object vice versa. Please look tutorial page better understand functions work.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"bioregionalization-algorithms","dir":"Articles","previous_headings":"","what":"4. Bioregionalization algorithms","title":"Tutorial for bioregion","text":"bioregion R package gathers several methods allowing group sites species similar entities called bioregions. methods can lead several partitions sites species, .e. different bioregionalizations.  Bioregionalization methods can based hierarchical clustering algorithms, non-hierarchical clustering algorithms network algorithms.  functions package related three families produce output specific class, namely bioregion.clusters class.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"hierarchical-clustering","dir":"Articles","previous_headings":"4. Bioregionalization algorithms","what":"4.1 Hierarchical clustering","title":"Tutorial for bioregion","text":"functions relying hierarchical clustering start prefix hclu_. algorithms, bioregions placed dendrogram ranges two extremes: sites belong bioregion (top tree) sites belong different bioregion (bottom tree). See following tutorial page details.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"non-hierarchical-clustering","dir":"Articles","previous_headings":"4. Bioregionalization algorithms","what":"4.2 Non-hierarchical clustering","title":"Tutorial for bioregion","text":"functions relying hierarchical clustering start prefix nhclu_. algorithms, user needs predefine number clusters, although number can determined estimating optimal bioregionalization. See tutorial page details.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"network-clustering","dir":"Articles","previous_headings":"4. Bioregionalization algorithms","what":"4.3 Network clustering","title":"Tutorial for bioregion","text":"functions relying network clustering start prefix netclu_. Site-species matrices can seen (bipartite) networks nodes either sites species links occurrences species within sites. networks, modularity algorithms can applied, leading bioregionalization. following tutorial page details clustering functions relying network algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"microbenchmark","dir":"Articles","previous_headings":"4. Bioregionalization algorithms","what":"4.4 Microbenchmark","title":"Tutorial for bioregion","text":"different bioregionalization methods listed package rely less computationally intensive algorithms. following page estimates time required run method data sets different sizes.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"visualization","dir":"Articles","previous_headings":"","what":"5.1 Visualization","title":"Tutorial for bioregion","text":"sites geographic coordinates, bioregionalization can visualized function map_bioregions(). tutorial page details different ways plot bioregionalization.","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"compare-bioregionalizations","dir":"Articles","previous_headings":"","what":"5.2 Compare bioregionalizations","title":"Tutorial for bioregion","text":"section, look sites assigned bioregions within single bioregionalization also compare assignment across different bioregionalizations. following page illustrates .","code":""},{"path":"https://bioRgeo.github.io/bioregion/articles/bioregion.html","id":"summary-metrics","dir":"Articles","previous_headings":"","what":"5.3 Summary metrics","title":"Tutorial for bioregion","text":"section, compute summary statistics different scales, either bioregion site species level. Related functions detailed page.","code":""},{"path":"https://bioRgeo.github.io/bioregion/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Maxime Lenormand. Author, maintainer. Boris Leroy. Author. Pierre Denelle. Author.","code":""},{"path":"https://bioRgeo.github.io/bioregion/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lenormand M, Leroy B, Denelle P (2025). bioregion: Comparison Bioregionalisation Methods. R package version 1.1.1.9000, https://bioRgeo.github.io/bioregion/, https://github.com/bioRgeo/bioregion.","code":"@Manual{,   title = {bioregion: Comparison of Bioregionalisation Methods},   author = {Maxime Lenormand and Boris Leroy and Pierre Denelle},   year = {2025},   note = {R package version 1.1.1.9000,     https://bioRgeo.github.io/bioregion/},   url = {https://github.com/bioRgeo/bioregion}, }"},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"bioregion-","dir":"","previous_headings":"","what":"Comparison of Bioregionalisation Methods","title":"Comparison of Bioregionalisation Methods","text":"R package gathers comprehensive set algorithms perform bioregionalisation analyses. Bioregionalisation methods can based hierarchical clustering algorithms, non-hierarchical clustering algorithms network algorithms.","code":""},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"arrow_double_down-installation","dir":"","previous_headings":"","what":"⏬ Installation","title":"Comparison of Bioregionalisation Methods","text":"package can installed following command line R session: CRAN GitHub","code":"install.packages(\"bioregion\") # install.packages(\"devtools\") devtools::install_github(\"bioRgeo/bioregion\")"},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"scroll-vignettes","dir":"","previous_headings":"","what":"📜 Vignettes","title":"Comparison of Bioregionalisation Methods","text":"wrote several vignettes help using bioregion R package. Vignettes available following ones: 1. Installation executable binary files 2. Matrix network formats 3. Pairwise similarity/dissimilarity metrics 4.1 Hierarchical clustering 4.2 Non-hierarchical clustering 4.3 Network clustering 4.4 Microbenchmark 5.1 Visualization 5.2 Compare bioregionalizations 5.3 Summary metrics Alternatively, prefer view vignettes R, can install package build_vignettes = TRUE. aware vignettes can slow generate.","code":"remotes::install_github(\"bioRgeo/bioregion\",                         dependencies = TRUE, upgrade = \"ask\",                          build_vignettes = TRUE)  vignette(\"bioregion\")"},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"desktop_computer-functions","dir":"","previous_headings":"","what":"🖥️ Functions","title":"Comparison of Bioregionalisation Methods","text":"overview functions data given .","code":""},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"bug-find-a-bug","dir":"","previous_headings":"","what":"🐛 Find a bug?","title":"Comparison of Bioregionalisation Methods","text":"Thank finding . Head GitHub Issues tab let us know . Alternatively, can also send us e-mail. try get soon can!","code":""},{"path":"https://bioRgeo.github.io/bioregion/index.html","id":"references-and-dependencies","dir":"","previous_headings":"","what":"References and dependencies","title":"Comparison of Bioregionalisation Methods","text":"bioregion depends ape, apcluster, bipartite, cluster, data.table, dbscan, dynamicTreeCut, earth, fastcluster, ggplot2, grDevices, httr, igraph, mathjaxr, Matrix, phangorn, Rdpack, rlang, rmarkdown, segmented,sf, stats, tidyr utils.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/betapart_to_bioregion.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert betapart dissimilarity to bioregion dissimilarity — betapart_to_bioregion","title":"Convert betapart dissimilarity to bioregion dissimilarity — betapart_to_bioregion","text":"function converts dissimilarity results produced betapart package (packages using betapart, phyloregion) dissimilarity object compatible bioregion package. function converts object types make compatible bioregion; modify beta-diversity values. function allows inclusion phylogenetic beta diversity compute bioregions bioregion.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/betapart_to_bioregion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert betapart dissimilarity to bioregion dissimilarity — betapart_to_bioregion","text":"","code":"betapart_to_bioregion(betapart_result)"},{"path":"https://bioRgeo.github.io/bioregion/reference/betapart_to_bioregion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert betapart dissimilarity to bioregion dissimilarity — betapart_to_bioregion","text":"betapart_result object produced betapart package (e.g., using beta.pair function).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/betapart_to_bioregion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert betapart dissimilarity to bioregion dissimilarity — betapart_to_bioregion","text":"dissimilarity object class bioregion.pairwise.metric, compatible bioregion package.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/betapart_to_bioregion.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert betapart dissimilarity to bioregion dissimilarity — betapart_to_bioregion","text":"Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/betapart_to_bioregion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert betapart dissimilarity to bioregion dissimilarity — betapart_to_bioregion","text":"","code":"comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  if (FALSE) { # \\dontrun{ beta_div <- betapart::beta.pair.abund(comat) betapart_to_bioregion(beta_div) } # }"},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate contribution metrics for bioregions — bioregion_metrics","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"function calculates number sites per bioregion, well number species sites , number endemic species proportion endemism.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"","code":"bioregion_metrics(cluster_object, comat, map = NULL, col_bioregion = NULL)"},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"cluster_object bioregion.clusters object data.frame list data.frame containing multiple partitions. least two partitions required. list data.frame provided, number rows (.e., items clustering partitions). comat co-occurrence matrix sites rows species columns. map spatial sf data.frame sites bioregions. output function map_bioregions. NULL default. col_bioregion integer specifying column position bioregion.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"data.frame 5 columns, 6 spatial coherence computed.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"Endemic species species found sites belonging one bioregion.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregion_metrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate contribution metrics for bioregions — bioregion_metrics","text":"","code":"comat_1 <- matrix(sample(0:1000, size = 10*12, replace = TRUE, prob = 1/1:1001), 10, 12) rownames(comat_1) <- paste0(\"Site\", 1:10) colnames(comat_1) <- paste0(\"Species\", 1:12) comat_1 <- cbind(comat_1,                  matrix(0, 10, 8,                         dimnames = list(paste0(\"Site\", 1:10),                                         paste0(\"Species\", 13:20))))  comat_2 <- matrix(sample(0:1000, size = 10*12, replace = TRUE,                          prob = 1/1:1001), 10, 12) rownames(comat_2) <- paste0(\"Site\", 11:20) colnames(comat_2) <- paste0(\"Species\", 9:20) comat_2 <- cbind(matrix(0, 10, 8,                         dimnames = list(paste0(\"Site\", 11:20),                                         paste0(\"Species\", 1:8))),                  comat_2)  comat <- rbind(comat_1, comat_2)  dissim <- dissimilarity(comat, metric = \"Simpson\") clust1 <- nhclu_kmeans(dissim, n_clust = 3, index = \"Simpson\")  net <- similarity(comat, metric = \"Simpson\") com <- netclu_greedy(net)  bioregion_metrics(cluster_object = clust1, comat = comat)  #>   Bioregion Site_number Species_number Endemics Percentage_Endemic #> 1         2          10             12        8           66.66667 #> 2         1           8             12        0            0.00000 #> 3         3           2             11        0            0.00000  # Spatial coherence vegedissim <- dissimilarity(vegemat) hclu <- nhclu_kmeans(dissimilarity = vegedissim, n_clust = 4) vegemap <- map_bioregions(hclu, vegesf, write_clusters = TRUE, plot = FALSE)  bioregion_metrics(cluster_object = hclu, comat = vegemat, map = vegemap, col_bioregion = 2)  #>   Bioregion Site_number Species_number Endemics Percentage_Endemic Coherence #> 1         2         128           2527       90           3.561535  49.21875 #> 2         4         169           2983       45           1.508548  56.21302 #> 3         3         298           2936       56           1.907357  98.99329 #> 4         1         120           2262       67           2.961981  79.16667"},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate metrics for one or several partitions — bioregionalization_metrics","title":"Calculate metrics for one or several partitions — bioregionalization_metrics","text":"function aims calculating metrics one several partitions, usually outputs netclu_, hclu_ nhclu_ functions. Metrics may require users provide either similarity dissimilarity matrix, provide initial species-site table.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate metrics for one or several partitions — bioregionalization_metrics","text":"","code":"bioregionalization_metrics(   cluster_object,   dissimilarity = NULL,   dissimilarity_index = NULL,   net = NULL,   site_col = 1,   species_col = 2,   eval_metric = c(\"pc_distance\", \"anosim\", \"avg_endemism\", \"tot_endemism\") )"},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate metrics for one or several partitions — bioregionalization_metrics","text":"cluster_object bioregion.clusters object. dissimilarity dist object bioregion.pairwise.metric object (output similarity_to_dissimilarity()). Necessary eval_metric includes pc_distance tree bioregion.hierar.tree object dissimilarity_index character string indicating dissimilarity (beta-diversity) index used case dist data.frame multiple dissimilarity indices. net species-site network (.e., bipartite network). provided data.frame± eval_metricincludes\"avg_endemism\"\"tot_endemism\"`. site_col name number column site nodes (.e. primary nodes). provided eval_metric includes \"avg_endemism\" \"tot_endemism\". species_col name number column species nodes (.e. feature nodes). provided eval_metric includes \"avg_endemism\" \"tot_endemism\". eval_metric character vector single character string indicating metric(s) calculated investigate effect different number clusters. Available options \"pc_distance\", \"anosim\", \"avg_endemism\" \"tot_endemism\".","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate metrics for one or several partitions — bioregionalization_metrics","text":"list class bioregion.partition.metrics two three elements: args: input arguments evaluation_df: data.frame containing eval_metric explored numbers clusters endemism_results: endemism calculations requested, list endemism results partition","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate metrics for one or several partitions — bioregionalization_metrics","text":"Evaluation metrics: pc_distance: metric method used Holt et al. (2013). ratio -cluster sum dissimilarity (beta-diversity) versus total sum dissimilarity (beta-diversity) full dissimilarity matrix. words, calculated basis two elements. First, total sum dissimilarity calculated summing entire dissimilarity matrix (dist). Second, -cluster sum dissimilarity calculated follows: given number cluster, dissimilarity summed clusters, within clusters. efficiently, pairs sites within clusters dissimilarity set zero dissimilarity matrix, dissimilarity matrix summed. pc_distance ratio obtained dividing -cluster sum dissimilarity total sum dissimilarity. anosim: metric statistic used Analysis Similarities, suggested Castro-Insua et al. (2018) (see vegan::anosim()). compares -cluster dissimilarities within-cluster dissimilarities. based based difference mean ranks groups within groups following formula: R = (r_B - r_W)/(N (N-1) / 4), r_B r_W average ranks within clusters respectively, N total number sites. Note function estimate significance , computes statistic - significance testing see vegan::anosim(). avg_endemism: metric average percentage endemism clusters recommended Kreft & Jetz (2010). Calculated follows: End_mean = sum_i (E_i / S_i)/K E_i number endemic species cluster , S_i number species cluster , K maximum number clusters. tot_endemism: metric total endemism across clusters, recommended Kreft & Jetz (2010). Calculated follows: End_tot = E \\ C E total number endemics (.e., species found one cluster) C number non-endemic species.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate metrics for one or several partitions — bioregionalization_metrics","text":"Castro-Insua , Gómez-Rodríguez C & Baselga (2018) Dissimilarity measures affected richness differences yield biased delimitations biogeographic realms. Nature Communications, 9(1), 9-11. Holt BG, Lessard J, Borregaard MK, Fritz SA, Araújo MB, Dimitrov D, Fabre P, Graham CH, Graves GR, Jønsson Ka, Nogués-Bravo D, Wang Z, Whittaker RJ, Fjeldså J & Rahbek C (2013) update Wallace's zoogeographic regions world. Science, 339(6115), 74-78. Kreft H & Jetz W (2010) framework delineating biogeographical regions based species distributions. Journal Biogeography, 37, 2029-2053.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate metrics for one or several partitions — bioregionalization_metrics","text":"Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/bioregionalization_metrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate metrics for one or several partitions — bioregionalization_metrics","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  comnet <- mat_to_net(comat)  dissim <- dissimilarity(comat, metric = \"all\")  # User-defined number of clusters tree1 <- hclu_hierarclust(dissim,                            n_clust = 2:20, index = \"Simpson\") #> Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. #>  #> Final tree has a 0.5241 cophenetic correlation coefficient with the initial dissimilarity matrix #> Warning: The requested number of cluster could not be found for k = 16. Closest number found: 15 #> Warning: The requested number of cluster could not be found for k = 17. Closest number found: 15 #> Warning: The requested number of cluster could not be found for k = 18. Closest number found: 15 #> Warning: The requested number of cluster could not be found for k = 19. Closest number found: 15 #> Warning: The requested number of cluster could not be found for k = 20. Closest number found: 15 tree1 #> Clustering results for algorithm : hclu_hierarclust  #> \t(hierarchical clustering based on a dissimilarity matrix) #>  - Number of sites:  20  #>  - Name of dissimilarity metric:  Simpson  #>  - Tree construction method:  average  #>  - Randomization of the dissimilarity matrix:  yes, number of trials 100  #>  - Method to compute the final tree:  Iterative consensus hierarchical tree  #>  - Cophenetic correlation coefficient:  0.524  #>  - Number of clusters requested by the user:  2 3 4 5 6 7 8 9 10 11 ... (with 9 more values)  #> Clustering results: #>  - Number of partitions:  19  #>  - Partitions are hierarchical #>  - Number of clusters:  2 3 4 5 6 7 8 9 10 11 ... (with 9 more values)  #>  - Height of cut of the hierarchical tree: 0.125 0.121 0.109 0.102 0.094 0.088 0.078 0.07 0.062 0.055 ... (with 9 more values)   a <- bioregionalization_metrics(tree1, dissimilarity = dissim, net = comnet,                        site_col = \"Node1\", species_col = \"Node2\",                        eval_metric = c(\"tot_endemism\", \"avg_endemism\",                                       \"pc_distance\", \"anosim\")) #> Computing similarity-based metrics... #>   - pc_distance OK #>   - anosim OK #> Computing composition-based metrics... #>   - avg_endemism OK #>   - tot_endemism OK a #> Partition metrics: #>  - 19  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Requested metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  - Metric summary: #>      tot_endemism avg_endemism pc_distance    anosim #> Min    0.00000000  0.000000000   0.1333886 0.3764235 #> Mean   0.01052632  0.004912281   0.8232435 0.7230993 #> Max    0.16000000  0.080000000   1.0000000 0.9565217 #>  #> Access the data.frame of metrics with your_object$evaluation_df #> Details of endemism % for each partition are available in  #>         your_object$endemism_results"},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"function aims computing pairwise comparisons several bioregionalizations, usually output netclu_, hclu_ nhclu_ functions. also provides confusion matrix pairwise comparisons, user can compute additional comparison metrics.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"","code":"compare_bioregionalizations(   cluster_object,   indices = c(\"rand\", \"jaccard\"),   cor_frequency = FALSE,   store_pairwise_membership = TRUE,   store_confusion_matrix = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"cluster_object bioregion.clusters object data.frame list data.frame containing multiple bioregionalizations. least two bioregionalizations required. list data.frame provided, number rows (.e., items clustering bioregionalizations). indices NULL character. Indices compute pairwise comparison bioregionalizations. Current available metrics \"rand\" \"jaccard\". cor_frequency boolean. TRUE, computes correlation bioregionalization total frequency co-membership items across bioregionalizations. Useful identify bioregionalization(s) () representative computed bioregionalizations. store_pairwise_membership boolean. TRUE, pairwise membership items stored output object. store_confusion_matrix boolean. TRUE, confusion matrices pairwise bioregionalization comparisons stored output object.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"list 4 7 elements: args: arguments provided user inputs: information input bioregionalizations, number items clustered (facultative) pairwise_membership: store_pairwise_membership = TRUE. element contains pairwise memberships items bioregionalization, form boolean matrix TRUE means two items cluster, FALSE means two items cluster freq_item_pw_membership: numeric vector containing number times pair items clustered together. corresponds sum rows table pairwise_membership (facultative) bioregionalization_freq_cor:  cor_frequency = TRUE. numeric vector indicating correlation individual bioregionalizations total frequency pairwise membership across bioregionalizations. corresponds correlation individual columns pairwise_membership freq_item_pw_membership (facultative) confusion_matrix: store_confusion_matrix = TRUE. list containing confusion matrices pair bioregionalizations. bioregionalization_comparison: data.frame containing results comparison bioregionalizations, first column indicates bioregionalizations compared, next columns correspond requested indices.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"function proceeds two main steps: first step done within bioregionalization. compare pairs items document clustered together (TRUE) separately (FALSE) bioregionalization. example, site 1 site 2 clustered cluster bioregionalization 1, pairwise membership site1_site2 TRUE. output first step stored slot pairwise_membership store_pairwise_membership = TRUE. second step compares pairs bioregionalizations analysing pairwise memberships similar . , pair bioregionalizations, function computes confusion matrix four elements: number pairs items grouped bioregionalization 1 bioregionalization 2 b number pairs items grouped bioregionalization 1 bioregionalization 2 c number pairs items grouped bioregionalization 1 grouped bioregionalization 2 d number pairs items grouped bioregionalization 1 & 2 confusion matrix stored confusion_matrix store_confusion_matrix = TRUE. Based confusion matrices, can compute range indices indicate agreement among bioregionalizations. now, implemented: Rand index (+ d)/(+ b + c + d) Rand index measures agreement among bioregionalizations accounting pairs sites grouped, also pairs sites grouped. Jaccard index /(+ b + c) Jaccard index measures agreement among bioregionalizations accounting pairs sites grouped. two metrics complementary, Jaccard index tell bioregionalizations similar clustering structure, whereas Rand index tell bioregionalizations similar pairs items clustered together, also terms pairs sites clustered together. example, take two bioregionalizations never group together pairs sites. Jaccard index 0, whereas Rand index can > 0 due sites grouped together. Additional indices can manually computed users basis list confusion matrices. cases, users may interested finding bioregionalizations representative bioregionalizations. find , can compare pairwise membership bioregionalization total frequency pairwise membership across bioregionalizations. correlation can requested cor_frequency = TRUE.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/compare_bioregionalizations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare cluster memberships among multiple bioregionalizations — compare_bioregionalizations","text":"","code":"# A simple case with four bioregionalizations of four items bioregionalizations <- data.frame(matrix(nr = 4, nc = 4,                                  c(1,2,1,1,1,2,2,1,2,1,3,1,2,1,4,2),                                 byrow = TRUE)) bioregionalizations #>   X1 X2 X3 X4 #> 1  1  2  1  1 #> 2  1  2  2  1 #> 3  2  1  3  1 #> 4  2  1  4  2 compare_bioregionalizations(bioregionalizations) #> 2025-01-08 15:27:07.983206 - Computing pairwise membership comparisons for each bioregionalization... #> 2025-01-08 15:27:07.983741 - Comparing memberships among bioregionalizations... #> 2025-01-08 15:27:07.984382 - Computing Rand index... #> 2025-01-08 15:27:07.984743 - Computing Jaccard index... #> $args #> $args$indices #> [1] \"rand\"    \"jaccard\" #>  #> $args$cor_frequency #> [1] FALSE #>  #> $args$store_pairwise_membership #> [1] TRUE #>  #> $args$store_confusion_matrix #> [1] TRUE #>  #>  #> $inputs #>               number_items number_bioregionalizations  #>                          4                          4  #>  #> $pairwise_membership #>        X1    X2    X3    X4 #> 1_2  TRUE  TRUE FALSE  TRUE #> 1_3 FALSE FALSE FALSE  TRUE #> 1_4 FALSE FALSE FALSE FALSE #> 2_3 FALSE FALSE FALSE  TRUE #> 2_4 FALSE FALSE FALSE FALSE #> 3_4  TRUE  TRUE FALSE FALSE #>  #> $freq_item_pw_membership #> 1_2 1_3 1_4 2_3 2_4 3_4  #>   3   1   0   1   0   2  #>  #> $confusion_matrix #> $confusion_matrix$`X1%X2` #> a b c d  #> 2 0 0 4  #>  #> $confusion_matrix$`X1%X3` #> a b c d  #> 0 2 0 4  #>  #> $confusion_matrix$`X1%X4` #> a b c d  #> 1 1 2 2  #>  #> $confusion_matrix$`X2%X3` #> a b c d  #> 0 2 0 4  #>  #> $confusion_matrix$`X2%X4` #> a b c d  #> 1 1 2 2  #>  #> $confusion_matrix$`X3%X4` #> a b c d  #> 0 0 3 3  #>  #>  #> $bioregionalization_comparison #>   bioregionalization_comparison      rand jaccard #> 1                         X1%X2 1.0000000    1.00 #> 2                         X1%X3 0.6666667    0.00 #> 3                         X1%X4 0.5000000    0.25 #> 4                         X2%X3 0.6666667    0.00 #> 5                         X2%X4 0.5000000    0.25 #> 6                         X3%X4 0.5000000    0.00 #>  #> attr(,\"class\") #> [1] \"bioregion.bioregionalization.comparison\" #> [2] \"list\"                                     # Find out which bioregionalizations are most representative compare_bioregionalizations(bioregionalizations,                    cor_frequency = TRUE) #> 2025-01-08 15:27:07.986516 - Computing pairwise membership comparisons for each bioregionalization... #> 2025-01-08 15:27:07.986966 - Comparing memberships among bioregionalizations... #> 2025-01-08 15:27:07.987551 - Computing Rand index... #> 2025-01-08 15:27:07.987873 - Computing Jaccard index... #> 2025-01-08 15:27:07.988192 - Computing the correlation between each bioregionalization and the vector of frequency of pairwise membership... #> $args #> $args$indices #> [1] \"rand\"    \"jaccard\" #>  #> $args$cor_frequency #> [1] TRUE #>  #> $args$store_pairwise_membership #> [1] TRUE #>  #> $args$store_confusion_matrix #> [1] TRUE #>  #>  #> $inputs #>               number_items number_bioregionalizations  #>                          4                          4  #>  #> $pairwise_membership #>        X1    X2    X3    X4 #> 1_2  TRUE  TRUE FALSE  TRUE #> 1_3 FALSE FALSE FALSE  TRUE #> 1_4 FALSE FALSE FALSE FALSE #> 2_3 FALSE FALSE FALSE  TRUE #> 2_4 FALSE FALSE FALSE FALSE #> 3_4  TRUE  TRUE FALSE FALSE #>  #> $freq_item_pw_membership #> 1_2 1_3 1_4 2_3 2_4 3_4  #>   3   1   0   1   0   2  #>  #> $bioregionalization_freq_cor #>        X1        X2        X3        X4  #> 0.8834522 0.8834522 0.0000000 0.4685213  #>  #> $confusion_matrix #> $confusion_matrix$`X1%X2` #> a b c d  #> 2 0 0 4  #>  #> $confusion_matrix$`X1%X3` #> a b c d  #> 0 2 0 4  #>  #> $confusion_matrix$`X1%X4` #> a b c d  #> 1 1 2 2  #>  #> $confusion_matrix$`X2%X3` #> a b c d  #> 0 2 0 4  #>  #> $confusion_matrix$`X2%X4` #> a b c d  #> 1 1 2 2  #>  #> $confusion_matrix$`X3%X4` #> a b c d  #> 0 0 3 3  #>  #>  #> $bioregionalization_comparison #>   bioregionalization_comparison      rand jaccard #> 1                         X1%X2 1.0000000    1.00 #> 2                         X1%X3 0.6666667    0.00 #> 3                         X1%X4 0.5000000    0.25 #> 4                         X2%X3 0.6666667    0.00 #> 5                         X2%X4 0.5000000    0.25 #> 6                         X3%X4 0.5000000    0.00 #>  #> attr(,\"class\") #> [1] \"bioregion.bioregionalization.comparison\" #> [2] \"list\""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut a hierarchical tree — cut_tree","title":"Cut a hierarchical tree — cut_tree","text":"function designed work hierarchical tree cut user-selected heights. works outputs either hclu_hierarclust hclust objects. function allows cutting tree based chosen number(s) clusters specified height(s). Additionally, includes procedure automatically determine cutting height requested number(s) clusters.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut a hierarchical tree — cut_tree","text":"","code":"cut_tree(   tree,   n_clust = NULL,   cut_height = NULL,   find_h = TRUE,   h_max = 1,   h_min = 0,   dynamic_tree_cut = FALSE,   dynamic_method = \"tree\",   dynamic_minClusterSize = 5,   dissimilarity = NULL,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut a hierarchical tree — cut_tree","text":"tree bioregion.hierar.tree hclust object. n_clust integer vector single integer indicating number clusters obtained hierarchical tree, output bioregionalization_metrics(). used concurrently cut_height. cut_height numeric vector specifying height(s) tree cut. used concurrently n_clust optim_method. find_h boolean indicating whether cutting height determined requested n_clust. h_max numeric value indicating maximum possible tree height determining cutting height find_h = TRUE. h_min numeric value specifying minimum possible height tree determining cutting height find_h = TRUE. dynamic_tree_cut boolean indicating whether dynamic tree cut method used. TRUE, n_clust cut_height ignored. dynamic_method character string specifying method used dynamically cutting tree: either \"tree\" (clusters searched within tree) \"hybrid\" (clusters searched tree dissimilarity matrix). dynamic_minClusterSize integer indicating minimum cluster size dynamic tree cut method (see dynamicTreeCut::cutreeDynamic()). dissimilarity Relevant dynamic_method = \"hybrid\". Provide dissimilarity data.frame used build tree. ... Additional arguments passed dynamicTreeCut::cutreeDynamic() customize dynamic tree cut method.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut a hierarchical tree — cut_tree","text":"tree output hclu_hierarclust(), object returned updated content (.e., args clusters). tree hclust object, data.frame containing clusters returned.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cut a hierarchical tree — cut_tree","text":"function supports two main methods cutting tree. First, tree can cut uniform height (specified cut_height determined automatically requested n_clust). Second, dynamic tree cut method (Langfelder et al., 2008) can applied, adapts shape branches tree, cutting varying heights based cluster positions. dynamic tree cut method two variants: tree-based variant (dynamic_method = \"tree\") uses top-approach, relying solely tree order clustered objects. hybrid variant (dynamic_method = \"hybrid\") employs bottom-approach, leveraging tree dissimilarity matrix identify clusters based dissimilarity among sites. approach useful detecting outliers within clusters.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Cut a hierarchical tree — cut_tree","text":"find_h argument ignored dynamic_tree_cut = TRUE, cutting heights determined case.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cut a hierarchical tree — cut_tree","text":"Langfelder P, Zhang B & Horvath S (2008) Defining clusters hierarchical cluster tree: Dynamic Tree Cut package R. BIOINFORMATICS 24, 719-720.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cut a hierarchical tree — cut_tree","text":"Pierre Denelle (pierre.denelle@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/cut_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut a hierarchical tree — cut_tree","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\", 1:20) colnames(comat) <- paste0(\"Species\", 1:25)  simil <- similarity(comat, metric = \"all\") dissimilarity <- similarity_to_dissimilarity(simil)  # User-defined number of clusters tree1 <- hclu_hierarclust(dissimilarity,                           n_clust = 5) #> Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. #>  #> Final tree has a 0.7262 cophenetic correlation coefficient with the initial dissimilarity matrix #> Determining the cut height to reach 5 groups... #> --> 0.265625 tree2 <- cut_tree(tree1, cut_height = .05) tree3 <- cut_tree(tree1, n_clust = c(3, 5, 10)) #> Determining the cut height to reach 3 groups... #> --> 0.28125 #> Determining the cut height to reach 5 groups... #> --> 0.265625 #> Determining the cut height to reach 10 groups... #> --> 0.1875 tree4 <- cut_tree(tree1, cut_height = c(.05, .1, .15, .2, .25)) tree5 <- cut_tree(tree1, n_clust = c(3, 5, 10), find_h = FALSE)  hclust_tree <- tree2$algorithm$final.tree clusters_2 <- cut_tree(hclust_tree, n_clust = 10) #> Determining the cut height to reach 10 groups... #> --> 0.1875  cluster_dynamic <- cut_tree(tree1, dynamic_tree_cut = TRUE,                             dissimilarity = dissimilarity) #> Some sites were not assigned to any cluster. They will have a NA in the cluster data.frame."},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"function generates data.frame row provides one several dissimilarity metrics pairs sites, based co-occurrence matrix sites rows species columns.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"","code":"dissimilarity(comat, metric = \"Simpson\", formula = NULL, method = \"prodmat\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"comat co-occurrence matrix sites rows species columns. metric character vector single character string specifying metrics compute (see Details). Available options \"abc\", \"ABC\", \"Jaccard\", \"Jaccardturn\", \"Sorensen\", \"Simpson\", \"Bray\", \"Brayturn\", \"Euclidean\". \"\" specified, metrics calculated. Can set NULL formula used. formula character vector single character string specifying custom formula(s) based , b, c, , B, C quantities (see Details). default NULL. method character string specifying method compute abc (see Details). default \"prodmat\", efficient memory-intensive. Alternatively, \"loops\" less memory-intensive slower.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"data.frame additional class bioregion.pairwise.metric, containing one several dissimilarity metrics pairs sites. first two columns represent pairs sites. one column per similarity metric provided metric formula, except abc ABC metrics, stored three separate columns (one letter).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"number species shared pair sites, b species present first site  c species present second site. Jaccard = (b + c) / (+ b + c) Jaccardturn = 2min(b, c) / (+ 2min(b, c)) (Baselga, 2012) Sorensen = (b + c) / (2a + b + c) Simpson = min(b, c) / (+ min(b, c)) abundances data available, Bray-Curtis turnover component can also computed following equation: Bray = (B + C) / (2A + B + C) Brayturn = min(B, C)/(+ min(B, C)) (Baselga, 2013) sum lesser values common species shared pair sites. B C total number specimens counted sites minus . formula can used compute customized metrics terms , b, c, , B, C. example formula = c(\"pmin(b,c) / (+ pmin(b,c))\", \"(B + C) / (2*+ B + C)\") compute Simpson Bray-Curtis dissimilarity metrics, respectively. Note pmin used Simpson formula , b, c, , B C numeric vectors. Euclidean computes Euclidean distance pair sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"Baselga, . (2012) Relationship Species Replacement, Dissimilarity Derived Nestedness, Nestedness. Global Ecology Biogeography, 21(12), 1223–1232. Baselga, . (2013) Separating two components abundance-based dissimilarity: balanced changes abundance vs. abundance gradients. Methods Ecology Evolution, 4(6), 552–557.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute dissimilarity metrics (beta-diversity) between sites based on species composition — dissimilarity","text":"","code":"comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  dissim <- dissimilarity(comat, metric = c(\"abc\", \"ABC\", \"Simpson\", \"Brayturn\"))  dissim <- dissimilarity(comat, metric = \"all\", formula = \"1 - (b + c) / (a + b + c)\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"function converts data.frame dissimilarity metrics (beta diversity) sites similarity metrics.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"","code":"dissimilarity_to_similarity(dissimilarity, include_formula = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(). include_formula boolean indicating whether metrics based custom formula(s) also converted (see Details). default TRUE.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"data.frame additional class bioregion.pairwise.metric, providing similarity metrics pair sites based dissimilarity object.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"behavior function changes depending column names. Columns Site1 Site2 copied identically. columns called , b, c, , B, C also copied identically. columns based formula (argument formula dissimilarity()) original list dissimilarity metrics (argument metrics dissimilarity()) argument include_formula set FALSE, also copied identically. Otherwise going converted like columns (default behavior). column called Euclidean, similarity calculated based following formula: Euclidean similarity = 1 / (1 - Euclidean distance) Otherwise, columns transformed dissimilarity following formula: similarity = 1 - dissimilarity","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/dissimilarity_to_similarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert dissimilarity metrics to similarity metrics — dissimilarity_to_similarity","text":"","code":"comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  dissimil <- dissimilarity(comat, metric = \"all\") dissimil #> Data.frame of dissimilarity between sites #>  - Total number of sites:  5  #>  - Total number of species:  10  #>  - Number of rows:  10  #>  - Number of dissimilarity metrics:  7  #>  #>  #>    Site1 Site2   Jaccard Jaccardturn   Sorensen   Simpson      Bray  Brayturn #> 2  Site1 Site2 0.2000000   0.0000000 0.11111111 0.0000000 0.6404855 0.5799893 #> 3  Site1 Site3 0.3000000   0.2222222 0.17647059 0.1250000 0.4874931 0.1618182 #> 4  Site1 Site4 0.1111111   0.0000000 0.05882353 0.0000000 0.6908825 0.6047382 #> 5  Site1 Site5 0.3000000   0.2222222 0.17647059 0.1250000 0.7916129 0.4634551 #> 8  Site2 Site3 0.1000000   0.0000000 0.05263158 0.0000000 0.6685753 0.5527273 #> 9  Site2 Site4 0.1000000   0.0000000 0.05263158 0.0000000 0.4845955 0.4420200 #> 10 Site2 Site5 0.1000000   0.0000000 0.05263158 0.0000000 0.9020639 0.7990033 #> 14 Site3 Site4 0.2000000   0.2000000 0.11111111 0.1111111 0.7544379 0.6981818 #> 15 Site3 Site5 0.2000000   0.2000000 0.11111111 0.1111111 0.6427732 0.4950166 #> 20 Site4 Site5 0.2000000   0.2000000 0.11111111 0.1111111 0.8821396 0.7840532 #>    Euclidean a b c   A    B    C #> 2  1145.6845 8 0 2 785 1713 1084 #> 3  1021.9335 7 1 2 922 1576  178 #> 4  1219.3958 8 0 1 634 1864  970 #> 5  1258.6906 7 1 2 323 2175  279 #> 8   861.1231 9 1 0 492 1377  608 #> 9   807.3543 9 1 0 895  974  709 #> 10  941.3071 9 1 0 121 1748  481 #> 14  897.8764 8 1 1 332  768 1272 #> 15  502.0299 8 1 1 304  796  298 #> 20  910.9874 8 1 1 130 1474  472  similarity <- dissimilarity_to_similarity(dissimil) similarity #> Data.frame of similarity between sites #>  - Total number of sites:  5  #>  - Total number of species:  10  #>  - Number of rows:  10  #>  - Number of similarity metrics:  7  #>  #>  #>    Site1 Site2   Jaccard Jaccardturn  Sorensen   Simpson       Bray  Brayturn #> 2  Site1 Site2 0.8000000   1.0000000 0.8888889 1.0000000 0.35951454 0.4200107 #> 3  Site1 Site3 0.7000000   0.7777778 0.8235294 0.8750000 0.51250695 0.8381818 #> 4  Site1 Site4 0.8888889   1.0000000 0.9411765 1.0000000 0.30911750 0.3952618 #> 5  Site1 Site5 0.7000000   0.7777778 0.8235294 0.8750000 0.20838710 0.5365449 #> 8  Site2 Site3 0.9000000   1.0000000 0.9473684 1.0000000 0.33142472 0.4472727 #> 9  Site2 Site4 0.9000000   1.0000000 0.9473684 1.0000000 0.51540455 0.5579800 #> 10 Site2 Site5 0.9000000   1.0000000 0.9473684 1.0000000 0.09793606 0.2009967 #> 14 Site3 Site4 0.8000000   0.8000000 0.8888889 0.8888889 0.24556213 0.3018182 #> 15 Site3 Site5 0.8000000   0.8000000 0.8888889 0.8888889 0.35722679 0.5049834 #> 20 Site4 Site5 0.8000000   0.8000000 0.8888889 0.8888889 0.11786038 0.2159468 #>       Euclidean a b c   A    B    C #> 2  0.0008720795 8 0 2 785 1713 1084 #> 3  0.0009775807 7 1 2 922 1576  178 #> 4  0.0008194063 8 0 1 634 1864  970 #> 5  0.0007938457 7 1 2 323 2175  279 #> 8  0.0011599272 9 1 0 492 1377  608 #> 9  0.0012370813 9 1 0 895  974  709 #> 10 0.0010612252 9 1 0 121 1748  481 #> 14 0.0011125000 8 1 1 332  768 1272 #> 15 0.0019879535 8 1 1 304  796  298 #> 20 0.0010965064 8 1 1 130 1474  472"},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"function aims optimizing one several criteria set ordered partitions. usually applied find one (several) optimal number(s) clusters , example, hierarchical tree cut, range partitions obtained k-means PAM. Users advised careful applied cases (e.g., partitions ordered increasing decreasing sequence, partitions related ).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"","code":"find_optimal_n(   partitions,   metrics_to_use = \"all\",   criterion = \"elbow\",   step_quantile = 0.99,   step_levels = NULL,   step_round_above = TRUE,   metric_cutoffs = c(0.5, 0.75, 0.9, 0.95, 0.99, 0.999),   n_breakpoints = 1,   plot = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"partitions bioregion.partition.metrics object (output bioregionalization_metrics() data.frame first two columns named K (partition name) n_clusters (number clusters) andthe following columns containing evaluation metrics (numeric values). metrics_to_use character vector single character string indicating upon metric(s) partitions optimal number clusters calculated. Defaults \"\" means metrics available partitions used. criterion character string indicating criterion used identify optimal number(s) clusters. Available methods currently include \"elbow\", \"increasing_step\", \"decreasing_step\", \"cutoff\", \"breakpoints\", \"min\" \"max\". Default \"elbow\". See Details. step_quantile \"increasing_step\" \"decreasing_step\", specify quantile differences two consecutive k used cutoff identify important steps eval_metric. step_levels \"increasing_step\" \"decreasing_step\", specify number largest steps keep cutoffs. step_round_above boolean indicating optimal number clusters picked identified steps. Indeed, step correspond sudden increase decrease partition X partition X+1: optimal partition X+1 (step_round_above = TRUE) X (step_round_above = FALSE). Defaults TRUE. metric_cutoffs criterion = \"cutoff\", specify cutoffs eval_metric number clusters extracted. n_breakpoints specify number breakpoints look curve. Defaults 1. plot boolean indicating plot first eval_metric drawn identified optimal numbers cutoffs.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"list class bioregion.optimal.n three elements: args: input arguments evaluation_df: input evaluation data.frame appended boolean columns identifying optimal numbers clusters optimal_nb_clusters: list containing optimal number(s) cluster(s) metric specified \"metrics_to_use\", based chosen criterion plot: requested, plot stored slot","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"function explores relationship evaluation metric ~ number clusters, criterion applied search optimal number clusters. Please read note section following criteria. Foreword: implemented set criteria commonly found literature recommended bioregionalization literature. Nevertheless, also advocate move beyond \"Search one optimal number clusters\" paradigm, consider investigating \"multiple optimal numbers clusters\". Indeed, using one optimal number clusters may simplify natural complexity biological datasets, , example, ignore often hierarchical / nested nature bioregionalizations. Using multiple partitions likely avoids oversimplification bias may convey information. See, example, reanalysis Holt et al. (2013) Ficetola et al. (2017), used deep, intermediate shallow cuts. Following rationale, several criteria implemented can/return multiple \"optimal\" numbers clusters, depending user choices. Criteria find optimal number(s) clusters elbow: method consists finding one elbow evaluation metric curve, commonly done clustering analyses. idea approximate number clusters evaluation metric longer increments.based fast method finding maximum distance curve straight line linking minimum maximum number points. code use based code written Esben Eickhardt available https://stackoverflow.com/questions/2018178/finding--best-trade--point---curve/42810075#42810075. code modified work increasing decreasing evaluation metrics. increasing_step decreasing_step: method consists identifying clusters important changes, steps, evaluation metric. objective can either look largest increases (increasing_step) largest decreases decreasing_step. Steps calculated based pairwise differences partitions. Therefore, relative distribution differences evaluation metric tested partitions. Specify step_quantile quantile cutoff steps selected important (default, 0.99, .e. largest 1\\ selected).Alternatively, can also choose specify number top steps keep, e.g. keep largest three steps, specify step_level = 3. Basically method emphasize important changes evaluation metric first approximation important cuts can chosen.**Please note choose increasing_step decreasing_step depending nature evaluation metrics. example, metrics monotonously decreasing (e.g., endemism metrics \"avg_endemism\" & \"tot_endemism\") number clusters n_clusters, choose decreasing_step. contrary, metrics monotonously increasing number clusters (e.g., \"pc_distance\"), choose increasing_step. ** cutoffs: method consists specifying cutoff value(s) evaluation metric number(s) clusters derived. method used Holt et al. (2013). Note, however, cut-offs suggested Holt et al. (0.9, 0.95, 0.99, 0.999) may relevant large spatial scales, lower cut-offs considered finer spatial scales. breakpoints: method consists finding break points curve using segmented regression. Users specify number expected break points n_breakpoints (defaults 1). Note since method relies regression model, probably applied low number partitions. min & max: Picks optimal partition(s) respectively minimum maximum value evaluation metric.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"Please note finding optimal number clusters procedure normally requires decisions users, can hardly fully automatized. Users strongly advised read references indicated look guidance choose optimal number(s) clusters. Consider \"optimal\" numbers clusters returned function first approximation best numbers bioregionalization.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"Holt BG, Lessard J, Borregaard MK, Fritz SA, Araújo MB, Dimitrov D, Fabre P, Graham CH, Graves GR, Jønsson Ka, Nogués-Bravo D, Wang Z, Whittaker RJ, Fjeldså J & Rahbek C (2013) update Wallace's zoogeographic regions world. Science, 339(6115), 74-78. Ficetola GF, Mazel F & Thuiller W (2017) Global determinants zoogeographical boundaries. Nature Ecology & Evolution, 1, 0089.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/find_optimal_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Search for an optimal number of clusters in a list of partitions — find_optimal_n","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  comnet <- mat_to_net(comat)  dissim <- dissimilarity(comat, metric = \"all\")  # User-defined number of clusters tree1 <- hclu_hierarclust(dissim,                           n_clust = 2:15) #> Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. #>  #> Final tree has a 0.7999 cophenetic correlation coefficient with the initial dissimilarity matrix tree1 #> Clustering results for algorithm : hclu_hierarclust  #> \t(hierarchical clustering based on a dissimilarity matrix) #>  - Number of sites:  20  #>  - Name of dissimilarity metric:  Jaccard  #>  - Tree construction method:  average  #>  - Randomization of the dissimilarity matrix:  yes, number of trials 100  #>  - Method to compute the final tree:  Iterative consensus hierarchical tree  #>  - Cophenetic correlation coefficient:  0.8  #>  - Number of clusters requested by the user:  2 3 4 5 6 7 8 9 10 11 ... (with 4 more values)  #> Clustering results: #>  - Number of partitions:  14  #>  - Partitions are hierarchical #>  - Number of clusters:  2 3 4 5 6 7 8 9 10 11 ... (with 4 more values)  #>  - Height of cut of the hierarchical tree: 0.312 0.266 0.262 0.25 0.219 0.203 0.188 0.172 0.164 0.156 ... (with 4 more values)   a <- bioregionalization_metrics(tree1,                    dissimilarity = dissim,                    net = comnet,                    species_col = \"Node2\",                    site_col = \"Node1\",                    eval_metric = c(\"tot_endemism\",                                    \"avg_endemism\",                                    \"pc_distance\",                                    \"anosim\")) #> Computing similarity-based metrics... #>   - pc_distance OK #>   - anosim OK #> Computing composition-based metrics... #>   - avg_endemism OK #>   - tot_endemism OK                                     find_optimal_n(a) #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 14 #> Searching for potential optimal number(s) of clusters based on the elbow method #>    * elbow found at: #> tot_endemism 4 #> avg_endemism 4 #> pc_distance 7 #> anosim 9 #> Warning: The elbow method is likely not suitable for the ANOSIM metric. You should rather look for leaps in the curve (see criterion = 'increasing_step' or decreasing_step) #> Plotting results...  #> Search for an optimal number of clusters: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  elbow  #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism - 4 #> avg_endemism - 4 #> pc_distance - 7 #> anosim - 9 find_optimal_n(a, criterion = \"increasing_step\") #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 14 #> Searching for potential optimal number(s) of clusters based on the increasing_step method #>  - Step method #> Warning: Criterion 'increasing_step' cannot work properly with metric 'tot_endemism', because this metric is usually monotonously decreasing. Consider using criterion = 'decreasing_step' instead. #> Plotting results...  #> Search for an optimal number of clusters: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  increasing_step  #>    (step quantile chosen:  0.99  (i.e., only the top 1 %  increase  in evaluation metrics  are used as break points for the number of clusters) #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism -  #> avg_endemism -  #> pc_distance - 4 #> anosim - 14 find_optimal_n(a, criterion = \"decreasing_step\") #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 14 #> Searching for potential optimal number(s) of clusters based on the decreasing_step method #>  - Step method #> Warning: Criterion 'decreasing_step' cannot work properly with metrics 'pc_distance' or 'avg_endemism', because these metrics are usually monotonously decreasing. Consider using criterion = 'increasing_step' instead. #> Plotting results...  #> Search for an optimal number of clusters: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  decreasing_step  #>    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism - 3 #> avg_endemism - 3 #> pc_distance - 15 #> anosim - 7 find_optimal_n(a, criterion = \"decreasing_step\",                step_levels = 3)  #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 14 #> Searching for potential optimal number(s) of clusters based on the decreasing_step method #>  - Step method #> Warning: Criterion 'decreasing_step' cannot work properly with metrics 'pc_distance' or 'avg_endemism', because these metrics are usually monotonously decreasing. Consider using criterion = 'increasing_step' instead. #> Warning: The number of optimal N for method 'tot_endemism' is suspiciously high, consider switching between 'increasing_step' and 'decreasing_step' #> Warning: The number of optimal N for method 'avg_endemism' is suspiciously high, consider switching between 'increasing_step' and 'decreasing_step' #> Plotting results...  #> Search for an optimal number of clusters: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  decreasing_step  #>    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism - 3 4 5 6 7 8 9 10 11 12 13 14 15 #> avg_endemism - 3 4 5 6 7 8 9 10 11 12 13 14 15 #> pc_distance - 5 13 15 #> anosim - 3 7 13 find_optimal_n(a, criterion = \"decreasing_step\",                step_quantile = .9)  #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 14 #> Searching for potential optimal number(s) of clusters based on the decreasing_step method #>  - Step method #> Warning: Criterion 'decreasing_step' cannot work properly with metrics 'pc_distance' or 'avg_endemism', because these metrics are usually monotonously decreasing. Consider using criterion = 'increasing_step' instead. #> Plotting results...  #> Search for an optimal number of clusters: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  decreasing_step  #>    (step quantile chosen:  0.9  (i.e., only the top 10 %  decrease  in evaluation metrics  are used as break points for the number of clusters) #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism - 3 4 #> avg_endemism - 3 4 #> pc_distance - 13 15 #> anosim - 3 7 find_optimal_n(a, criterion = \"decreasing_step\",                step_levels = 3)  #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 14 #> Searching for potential optimal number(s) of clusters based on the decreasing_step method #>  - Step method #> Warning: Criterion 'decreasing_step' cannot work properly with metrics 'pc_distance' or 'avg_endemism', because these metrics are usually monotonously decreasing. Consider using criterion = 'increasing_step' instead. #> Warning: The number of optimal N for method 'tot_endemism' is suspiciously high, consider switching between 'increasing_step' and 'decreasing_step' #> Warning: The number of optimal N for method 'avg_endemism' is suspiciously high, consider switching between 'increasing_step' and 'decreasing_step' #> Plotting results...  #> Search for an optimal number of clusters: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  decreasing_step  #>    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism - 3 4 5 6 7 8 9 10 11 12 13 14 15 #> avg_endemism - 3 4 5 6 7 8 9 10 11 12 13 14 15 #> pc_distance - 5 13 15 #> anosim - 3 7 13 find_optimal_n(a, criterion = \"decreasing_step\",                step_levels = 3)                  #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 14 #> Searching for potential optimal number(s) of clusters based on the decreasing_step method #>  - Step method #> Warning: Criterion 'decreasing_step' cannot work properly with metrics 'pc_distance' or 'avg_endemism', because these metrics are usually monotonously decreasing. Consider using criterion = 'increasing_step' instead. #> Warning: The number of optimal N for method 'tot_endemism' is suspiciously high, consider switching between 'increasing_step' and 'decreasing_step' #> Warning: The number of optimal N for method 'avg_endemism' is suspiciously high, consider switching between 'increasing_step' and 'decreasing_step' #> Plotting results...  #> Search for an optimal number of clusters: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  decreasing_step  #>    (step quantile chosen:  0.99  (i.e., only the top 1 %  decrease  in evaluation metrics  are used as break points for the number of clusters) #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism - 3 4 5 6 7 8 9 10 11 12 13 14 15 #> avg_endemism - 3 4 5 6 7 8 9 10 11 12 13 14 15 #> pc_distance - 5 13 15 #> anosim - 3 7 13 find_optimal_n(a, criterion = \"breakpoints\")              #> [1] \"tot_endemism\" \"avg_endemism\" \"pc_distance\"  \"anosim\"       #> Number of partitions: 14 #> Searching for potential optimal number(s) of clusters based on the breakpoints method #> Plotting results... #>    (the red line is the prediction from the segmented regression)  #> Search for an optimal number of clusters: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Evaluated metric(s):  tot_endemism avg_endemism pc_distance anosim  #>  #> Potential optimal partition(s): #>  - Criterion chosen to optimise the number of clusters:  breakpoints  #>  - Optimal partition(s) of clusters for each metric: #> tot_endemism - 3 #> avg_endemism - 3 #> pc_distance - 8 #> anosim - 9"},{"path":"https://bioRgeo.github.io/bioregion/reference/fishdf.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of fish in Europe (data.frame) — fishdf","title":"Spatial distribution of fish in Europe (data.frame) — fishdf","text":"dataset containing abundance 195 species 338 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishdf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of fish in Europe (data.frame) — fishdf","text":"","code":"fishdf"},{"path":"https://bioRgeo.github.io/bioregion/reference/fishdf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of fish in Europe (data.frame) — fishdf","text":"data.frame 2,703 rows 3 columns: Site Unique site identifier (corresponding field ID fishsf) Species Unique species identifier Abundance Species abundance","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of fish in Europe (co-occurrence matrix) — fishmat","title":"Spatial distribution of fish in Europe (co-occurrence matrix) — fishmat","text":"dataset containing abundance 195 species 338 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of fish in Europe (co-occurrence matrix) — fishmat","text":"","code":"fishmat"},{"path":"https://bioRgeo.github.io/bioregion/reference/fishmat.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of fish in Europe (co-occurrence matrix) — fishmat","text":"co-occurrence matrix sites rows species columns. element matrix represents abundance species site.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishsf.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of fish in Europe — fishsf","title":"Spatial distribution of fish in Europe — fishsf","text":"dataset containing geometry 338 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/fishsf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of fish in Europe — fishsf","text":"","code":"fishsf"},{"path":"https://bioRgeo.github.io/bioregion/reference/fishsf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of fish in Europe — fishsf","text":"ID Unique site identifier geometry Geometry site","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":null,"dir":"Reference","previous_headings":"","what":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"function computes divisive hierarchical clustering dissimilarity (beta-diversity) data.frame, calculates cophenetic correlation coefficient, can generate clusters tree requested user. function implements randomization dissimilarity matrix generate tree, selection method based optimal cophenetic correlation coefficient. Typically, dissimilarity data.frame bioregion.pairwise.metric object obtained running similarity similarity followed similarity_to_dissimilarity.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"","code":"hclu_diana(   dissimilarity,   index = names(dissimilarity)[3],   n_clust = NULL,   cut_height = NULL,   find_h = TRUE,   h_max = 1,   h_min = 0 )"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), remaining column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. n_clust integer vector single integer indicating number clusters obtained hierarchical tree, output bioregionalization_metrics. used concurrently cut_height. cut_height numeric vector indicating height(s) tree cut. used concurrently n_clust. find_h boolean indicating whether cutting height determined requested n_clust. h_max numeric value indicating maximum possible tree height chosen index. h_min numeric value indicating minimum possible height tree chosen index.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"list class bioregion.clusters five slots: name: character string containing name algorithm. args: list input arguments provided user. inputs: list describing characteristics clustering process. algorithm: list containing objects associated clustering procedure, original cluster objects. clusters: data.frame containing clustering results.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"function based diana. Chapter 6 Kaufman & Rousseeuw (1990) fully details functioning diana algorithm. find optimal number clusters, see bioregionalization_metrics()","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"Kaufman L & Rousseeuw PJ (2009) Finding groups data: introduction cluster analysis. & Sons. JW (ed.), Finding groups data: introduction cluster analysis.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_diana.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Divisive hierarchical clustering based on dissimilarity or beta-diversity — hclu_diana","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"all\")  data(\"fishmat\") fishdissim <- dissimilarity(fishmat) fish_diana <- hclu_diana(fishdissim, index = \"Simpson\") #> Output tree has a 0.51 cophenetic correlation coefficient with the initial dissimilarity matrix"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":null,"dir":"Reference","previous_headings":"","what":"Hierarchical Clustering Based on Dissimilarity or Beta-Diversity — hclu_hierarclust","title":"Hierarchical Clustering Based on Dissimilarity or Beta-Diversity — hclu_hierarclust","text":"function generates hierarchical tree dissimilarity (beta-diversity) data.frame, calculates cophenetic correlation coefficient, optionally retrieves clusters tree upon user request. function includes randomization process dissimilarity matrix generate tree, two methods available constructing final tree. Typically, dissimilarity data.frame bioregion.pairwise.metric object obtained running similarity, running similarity followed similarity_to_dissimilarity.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hierarchical Clustering Based on Dissimilarity or Beta-Diversity — hclu_hierarclust","text":"","code":"hclu_hierarclust(   dissimilarity,   index = names(dissimilarity)[3],   method = \"average\",   randomize = TRUE,   n_runs = 100,   keep_trials = FALSE,   optimal_tree_method = \"iterative_consensus_tree\",   n_clust = NULL,   cut_height = NULL,   find_h = TRUE,   h_max = 1,   h_min = 0,   consensus_p = 0.5,   verbose = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hierarchical Clustering Based on Dissimilarity or Beta-Diversity — hclu_hierarclust","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. method name hierarchical classification method, hclust. one \"ward.D\", \"ward.D2\", \"single\", \"complete\", \"average\" (= UPGMA), \"mcquitty\" (= WPGMA), \"median\" (= WPGMC), \"centroid\" (= UPGMC). randomize boolean indicating whether dissimilarity matrix randomized account order sites dissimilarity matrix. n_runs number trials randomizing dissimilarity matrix. keep_trials boolean indicating whether random trial results stored output object. Set FALSE save space dissimilarity object large. Note set TRUE optimal_tree_method = \"iterative_consensus_tree\". optimal_tree_method character string indicating final tree obtained trials. Possible values \"iterative_consensus_tree\" (default), \"best\", \"consensus\". recommend \"iterative_consensus_tree\". See Details. n_clust integer vector single integer indicating number clusters obtained hierarchical tree, output bioregionalization_metrics. parameter used simultaneously cut_height. cut_height numeric vector indicating height(s) tree cut. parameter used simultaneously n_clust. find_h boolean indicating whether height cut found requested n_clust. h_max numeric value indicating maximum possible tree height chosen index. h_min numeric value indicating minimum possible height tree chosen index. consensus_p numeric value (applicable optimal_tree_method = \"consensus\") indicating threshold proportion trees must support region/cluster included final consensus tree. verbose boolean (applicable optimal_tree_method = \"iterative_consensus_tree\") indicating whether display progress messages. Set FALSE suppress messages.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hierarchical Clustering Based on Dissimilarity or Beta-Diversity — hclu_hierarclust","text":"list class bioregion.clusters five slots: name: character string containing name algorithm. args: list input arguments provided user. inputs: list describing characteristics clustering process. algorithm: list containing objects associated clustering procedure, original cluster objects. clusters: data.frame containing clustering results. algorithm slot, users can find following elements: trials: list containing randomization trials. trial includes dissimilarity matrix randomized site order, associated tree, cophenetic correlation coefficient (Spearman) tree. final.tree: hclust object representing final hierarchical tree used. final.tree.coph.cor: cophenetic correlation coefficient initial dissimilarity matrix final.tree.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hierarchical Clustering Based on Dissimilarity or Beta-Diversity — hclu_hierarclust","text":"function based hclust. default method hierarchical tree average, .e. UPGMA recommended best method generate tree beta diversity dissimilarity (Kreft & Jetz, 2010). Clusters can obtained two methods: Specifying desired number clusters n_clust Specifying one several heights cut cut_height find optimal number clusters, see bioregionalization_metrics() important pay attention fact order rows input distance matrix influences tree topology explained Dapporto (2013). address , function generates multiple trees randomizing distance matrix. Two methods available obtain final tree: optimal_tree_method = \"iterative_consensus_tree\": Iterative Hierarchical Consensus Tree (IHCT) method reconstructs consensus tree iteratively splitting dataset two subclusters based pairwise dissimilarity sites across n_runs trees based n_runs randomizations distance matrix. iteration, identifies majority membership sites two stable groups across trees, calculates height based selected linkage method (method), enforces monotonic constraints node heights produce coherent tree structure. approach provides robust, hierarchical representation site relationships, balancing cluster stability hierarchical constraints. optimal_tree_method = \"best\": method selects one tree among highest cophenetic correlation coefficient, representing best fit hierarchical structure original distance matrix. optimal_tree_method = \"consensus\": method constructs consensus tree using phylogenetic methods function consensus. using option, must set consensus_p parameter, indicates proportion trees must contain region/cluster included final consensus tree. Consensus trees lack inherent height represent majority structure rather actual hierarchical clustering. assign heights, use non-negative least squares method (nnls.tree) based initial distance matrix, ensuring consensus tree preserves approximate distances among clusters. recommend using \"iterative_consensus_tree\" branches tree always reflect majority decision among many randomized versions distance matrix. method inspired Dapporto et al. (2015), also used majority decision among many randomized versions distance matrix, expands reconstruct entire topology tree iteratively. recommend using basic consensus method many contexts provides inconsistent results, meaningless tree topology low cophenetic correlation coefficient. fast exploration tree, recommend using best method select tree highest cophenetic correlation coefficient among randomized versions distance matrix.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hierarchical Clustering Based on Dissimilarity or Beta-Diversity — hclu_hierarclust","text":"Kreft H & Jetz W (2010) framework delineating biogeographical regions based species distributions. Journal Biogeography 37, 2029-2053. Dapporto L, Ramazzotti M, Fattorini S, Talavera G, Vila R & Dennis, RLH (2013) Recluster: unbiased clustering procedure beta-diversity turnover. Ecography 36, 1070–1075. Dapporto L, Ciolli G, Dennis RLH, Fox R & Shreeve TG (2015) new procedure extrapolating turnover regionalization mid-small spatial scales, tested British butterflies. Methods Ecology Evolution 6 , 1287–1297.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hierarchical Clustering Based on Dissimilarity or Beta-Diversity — hclu_hierarclust","text":"Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_hierarclust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hierarchical Clustering Based on Dissimilarity or Beta-Diversity — hclu_hierarclust","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"Simpson\")  # User-defined number of clusters tree1 <- hclu_hierarclust(dissim,                            n_clust = 5) #> Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. #>  #> Final tree has a 0.5216 cophenetic correlation coefficient with the initial dissimilarity matrix #> Determining the cut height to reach 5 groups... #> --> 0.1015625 tree1 #> Clustering results for algorithm : hclu_hierarclust  #> \t(hierarchical clustering based on a dissimilarity matrix) #>  - Number of sites:  20  #>  - Name of dissimilarity metric:  Simpson  #>  - Tree construction method:  average  #>  - Randomization of the dissimilarity matrix:  yes, number of trials 100  #>  - Method to compute the final tree:  Iterative consensus hierarchical tree  #>  - Cophenetic correlation coefficient:  0.522  #>  - Number of clusters requested by the user:  5  #> Clustering results: #>  - Number of partitions:  1  #>  - Number of clusters:  5  #>  - Height of cut of the hierarchical tree: 0.102  plot(tree1)  str(tree1) #> List of 6 #>  $ name        : chr \"hclu_hierarclust\" #>  $ args        :List of 14 #>   ..$ index              : chr \"Simpson\" #>   ..$ method             : chr \"average\" #>   ..$ randomize          : logi TRUE #>   ..$ n_runs             : num 100 #>   ..$ optimal_tree_method: chr \"iterative_consensus_tree\" #>   ..$ keep_trials        : logi FALSE #>   ..$ n_clust            : num 5 #>   ..$ cut_height         : NULL #>   ..$ find_h             : logi TRUE #>   ..$ h_max              : num 1 #>   ..$ h_min              : num 0 #>   ..$ consensus_p        : num 0.5 #>   ..$ verbose            : logi TRUE #>   ..$ dynamic_tree_cut   : logi FALSE #>  $ inputs      :List of 7 #>   ..$ bipartite      : logi FALSE #>   ..$ weight         : logi TRUE #>   ..$ pairwise       : logi TRUE #>   ..$ pairwise_metric: chr \"Simpson\" #>   ..$ dissimilarity  : logi TRUE #>   ..$ nb_sites       : int 20 #>   ..$ hierarchical   : logi FALSE #>  $ algorithm   :List of 6 #>   ..$ final.tree         :List of 5 #>   .. ..- attr(*, \"class\")= chr \"hclust\" #>   ..$ final.tree.coph.cor: num 0.522 #>   ..$ final.tree.msd     : num 0.00142 #>   ..$ output_n_clust     : int 5 #>   ..$ output_cut_height  : Named num 0.102 #>   .. ..- attr(*, \"names\")= chr \"k_5\" #>   ..$ trials             : chr \"Trials not stored in output\" #>  $ clusters    :'data.frame':\t20 obs. of  2 variables: #>   ..$ ID : chr [1:20] \"Site1\" \"Site10\" \"Site11\" \"Site12\" ... #>   ..$ K_5: chr [1:20] \"1\" \"2\" \"3\" \"4\" ... #>  $ cluster_info:'data.frame':\t1 obs. of  4 variables: #>   ..$ partition_name   : chr \"K_5\" #>   ..$ n_clust          : int 5 #>   ..$ requested_n_clust: num 5 #>   ..$ output_cut_height: num 0.102 #>  - attr(*, \"class\")= chr [1:2] \"bioregion.clusters\" \"list\" tree1$clusters #>            ID K_5 #> Site1   Site1   1 #> Site10 Site10   2 #> Site11 Site11   3 #> Site12 Site12   4 #> Site13 Site13   4 #> Site14 Site14   4 #> Site15 Site15   1 #> Site16 Site16   1 #> Site17 Site17   4 #> Site18 Site18   5 #> Site19 Site19   4 #> Site2   Site2   1 #> Site20 Site20   4 #> Site3   Site3   1 #> Site4   Site4   1 #> Site5   Site5   4 #> Site6   Site6   4 #> Site7   Site7   4 #> Site8   Site8   4 #> Site9   Site9   1  # User-defined height cut # Only one height tree2 <- hclu_hierarclust(dissim,                            cut_height = .05) #> Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. #>  #> Final tree has a 0.5195 cophenetic correlation coefficient with the initial dissimilarity matrix tree2 #> Clustering results for algorithm : hclu_hierarclust  #> \t(hierarchical clustering based on a dissimilarity matrix) #>  - Number of sites:  20  #>  - Name of dissimilarity metric:  Simpson  #>  - Tree construction method:  average  #>  - Randomization of the dissimilarity matrix:  yes, number of trials 100  #>  - Method to compute the final tree:  Iterative consensus hierarchical tree  #>  - Cophenetic correlation coefficient:  0.52  #>  - Heights of cut requested by the user:  0.05  #> Clustering results: #>  - Number of partitions:  1  #>  - Number of clusters:  14  #>  - Height of cut of the hierarchical tree: 0.05  tree2$clusters #>        ID K_14 #> 1   Site1    1 #> 2  Site10    2 #> 3  Site11    3 #> 4  Site12    4 #> 5  Site13    4 #> 6  Site14    5 #> 7  Site15    6 #> 8  Site16    6 #> 9  Site17    7 #> 10 Site18    8 #> 11 Site19    9 #> 12  Site2   10 #> 13 Site20   11 #> 14  Site3    6 #> 15  Site4   10 #> 16  Site5    9 #> 17  Site6   12 #> 18  Site7   12 #> 19  Site8   13 #> 20  Site9   14  # Multiple heights tree3 <- hclu_hierarclust(dissim,                            cut_height = c(.05, .15, .25)) #> Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. #>  #> Final tree has a 0.5195 cophenetic correlation coefficient with the initial dissimilarity matrix  tree3$clusters # Mind the order of height cuts: from deep to shallow cuts #>            ID K_1_1 K_1_2 K_14 #> Site1   Site1     1     1    1 #> Site10 Site10     1     1    2 #> Site11 Site11     1     1    3 #> Site12 Site12     1     1    4 #> Site13 Site13     1     1    4 #> Site14 Site14     1     1    5 #> Site15 Site15     1     1    6 #> Site16 Site16     1     1    6 #> Site17 Site17     1     1    7 #> Site18 Site18     1     1    8 #> Site19 Site19     1     1    9 #> Site2   Site2     1     1   10 #> Site20 Site20     1     1   11 #> Site3   Site3     1     1    6 #> Site4   Site4     1     1   10 #> Site5   Site5     1     1    9 #> Site6   Site6     1     1   12 #> Site7   Site7     1     1   12 #> Site8   Site8     1     1   13 #> Site9   Site9     1     1   14 # Info on each partition can be found in table cluster_info tree3$cluster_info #>        partition_name n_clust requested_cut_height #> h_0.25          K_1_1       1                 0.25 #> h_0.15          K_1_2       1                 0.15 #> h_0.05           K_14      14                 0.05 plot(tree3)   # Recut the tree afterwards tree3.1 <- cut_tree(tree3, n = 5) #> Determining the cut height to reach 5 groups... #> --> 0.09765625  # Make multiple cuts tree4 <- hclu_hierarclust(dissim,                            n_clust = 1:19) #> Building the iterative hierarchical consensus tree... Note that this process can take time especially if you have a lot of sites. #>  #> Final tree has a 0.5195 cophenetic correlation coefficient with the initial dissimilarity matrix #> Warning: The requested number of cluster could not be found for k = 7. Closest number found: 6 #> Warning: The requested number of cluster could not be found for k = 16. Closest number found: 15 #> Warning: The requested number of cluster could not be found for k = 19. Closest number found: 18  # Change the method to get the final tree  tree5 <- hclu_hierarclust(dissim,                           optimal_tree_method = \"best\",                           n_clust = 10) #> Randomizing the dissimilarity matrix with 100 trials #>  -- range of cophenetic correlation coefficients among trials: 0.5152 - 0.5195 #>  #> Final tree has a 0.5195 cophenetic correlation coefficient with the initial dissimilarity matrix #> Determining the cut height to reach 10 groups... #> --> 0.078125"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":null,"dir":"Reference","previous_headings":"","what":"OPTICS hierarchical clustering algorithm — hclu_optics","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"function performs semi-hierarchical clustering based dissimilarity using OPTICS algorithm (Ordering Points Identify Clustering Structure).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"","code":"hclu_optics(   dissimilarity,   index = names(dissimilarity)[3],   minPts = NULL,   eps = NULL,   xi = 0.05,   minimum = FALSE,   show_hierarchy = FALSE,   algorithm_in_output = TRUE,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. minPts numeric value specifying minPts argument dbscan. minPts minimum number points required form dense region. default, set natural logarithm number sites dissimilarity. eps numeric value specifying eps argument optics. defines upper limit size epsilon neighborhood. Limiting neighborhood size improves performance little impact ordering long set low. specified (default behavior), largest minPts-distance dataset used, gives result infinity. xi numeric value specifying steepness threshold identify clusters hierarchically using Xi method (see optics). minimum boolean specifying whether hierarchy pruned output retain clusters \"minimal\" level, .e., leaf / non-overlapping clusters. TRUE, argument show_hierarchy set FALSE. show_hierarchy boolean specifying whether hierarchy clusters included output. default, hierarchy visible clusters obtained OPTICS; can visualized plotting OPTICS object. show_hierarchy = TRUE, output cluster data.frame contain additional columns showing hierarchy clusters. algorithm_in_output boolean indicating whether original output dbscan returned output (TRUE default, see Value). ... Additional arguments passed optics() (see optics).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"list class bioregion.clusters five slots: name: character string containing name algorithm. args: list input arguments provided user. inputs: list describing characteristics clustering process. algorithm: list containing objects associated clustering procedure, original cluster objects. clusters: data.frame containing clustering results. algorithm slot, algorithm_in_output = TRUE, users can find output optics.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"OPTICS (Ordering points identify clustering structure) semi-hierarchical clustering algorithm orders points dataset points closest become neighbors, calculates reachability distance point. , clusters can extracted hierarchical manner reachability distance, identifying clusters depending changes relative cluster density. reachability plot explored understand clusters hierarchical nature, running plot output function algorithm_in_output = TRUE: plot(object$algorithm). recommend reading (Hahsler et al., 2019) grasp algorithm, works, clusters mean. extract clusters, use extractXi function based steepness reachability plot (see optics)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"Hahsler M, Piekenbrock M & Doran D (2019) Dbscan: Fast density-based clustering R. Journal Statistical Software 91, 1–30.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/hclu_optics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OPTICS hierarchical clustering algorithm — hclu_optics","text":"","code":"dissim <- dissimilarity(fishmat, metric = \"all\")    clust1 <- hclu_optics(dissim, index = \"Simpson\") clust1 #> Clustering results for algorithm : hclu_optics  #>  - Number of sites:  338  #> Clustering results: #>  - Number of partitions:  1  #>  - Number of clusters:  4   # Visualize the optics plot (the hierarchy of clusters is illustrated at the # bottom) plot(clust1$algorithm)   # Extract the hierarchy of clusters clust1 <- hclu_optics(dissim, index = \"Simpson\", show_hierarchy = TRUE) clust1 #> Clustering results for algorithm : hclu_optics  #>  - Number of sites:  338  #> Clustering results: #>  - Number of partitions:  2  #>  - Partitions are hierarchical #>  - Number of clusters:  2 4"},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":null,"dir":"Reference","previous_headings":"","what":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"function downloads unzips 'bin' folder required run certain functions bioregion package. also verifies files necessary permissions executed programs. Finally, tests whether binary files running correctly.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"","code":"install_binaries(   binpath = \"tempdir\",   download_only = FALSE,   infomap_version = c(\"2.1.0\", \"2.6.0\", \"2.7.1\", \"2.8.0\") )"},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"binpath character string specifying path folder host bin folder containing binary files (see Details). download_only logical value indicating whether function download bin.zip file perform entire process (see Details). infomap_version character vector single character string specifying Infomap version(s) install.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"return value.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"default, binary files installed R's temporary directory (binpath = \"tempdir\"). case, bin folder automatically removed end R session. Alternatively, binary files can installed bioregion package folder (binpath = \"pkgfolder\"). custom folder path can also specified. case, case, download_only can set TRUE, must ensure files required permissions executed programs. cases, PLEASE MAKE SURE update binpath check_install parameters accordingly netclu_infomap, netclu_louvain, netclu_oslom.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"Currently, Infomap versions 2.1.0, 2.6.0, 2.7.1, 2.8.0 available.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/install_binaries.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Download, unzip, check permissions, and test the bioregion's binary files — install_binaries","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a map of bioregions — map_bioregions","title":"Create a map of bioregions — map_bioregions","text":"plot function can used visualise bioregions based bioregion.clusters object combined geometry (sf objects).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a map of bioregions — map_bioregions","text":"","code":"map_bioregions(clusters, geometry, write_clusters = FALSE, plot = TRUE, ...)"},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a map of bioregions — map_bioregions","text":"clusters object class bioregion.clusters data.frame. data.frame used, first column represent sites' ID, next column(s) clusters. geometry spatial object can handled sf package. first attribute correspond sites' ID (see Details). write_clusters boolean indicating clusters added geometry. plot boolean indicating plot drawn. ... arguments passed sf::plot().","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a map of bioregions — map_bioregions","text":"One several maps bioregions plot = TRUE geometry additional clusters' attributes write_clusters = TRUE.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a map of bioregions — map_bioregions","text":"clusters geometry site IDs correspond. type (.e. character cluster bioregion.clusters object) site clusters included sites geometry.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a map of bioregions — map_bioregions","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/map_bioregions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a map of bioregions — map_bioregions","text":"","code":"data(fishmat) data(fishsf)  net <- similarity(fishmat, metric = \"Simpson\") clu <- netclu_greedy(net) map <- map_bioregions(clu, fishsf, write_clusters = TRUE, plot = FALSE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a data.frame from a contingency table — mat_to_net","title":"Create a data.frame from a contingency table — mat_to_net","text":"function generates two- three-column data.frame, row represents interaction two nodes (e.g., site species) optional third column indicates weight interaction (weight = TRUE). input contingency table, rows representing one set entities (e.g., site) columns representing another set (e.g., species).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a data.frame from a contingency table — mat_to_net","text":"","code":"mat_to_net(   mat,   weight = FALSE,   remove_zeroes = TRUE,   include_diag = TRUE,   include_lower = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a data.frame from a contingency table — mat_to_net","text":"mat contingency table (.e., matrix). weight logical value indicating whether values matrix interpreted interaction weights. remove_zeroes logical value determining whether interactions weight equal 0 excluded output. include_diag logical value indicating whether diagonal (self-interactions) included output. applies square matrices. include_lower logical value indicating whether lower triangular part matrix included output. applies square matrices.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a data.frame from a contingency table — mat_to_net","text":"data.frame row represents interaction two nodes. weight = TRUE, data.frame includes third column representing weight interaction.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a data.frame from a contingency table — mat_to_net","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/mat_to_net.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a data.frame from a contingency table — mat_to_net","text":"","code":"mat <- matrix(sample(1000, 50), 5, 10) rownames(mat) <- paste0(\"Site\", 1:5) colnames(mat) <- paste0(\"Species\", 1:10)  net <- mat_to_net(mat, weight = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a contingency table from a data.frame — net_to_mat","title":"Create a contingency table from a data.frame — net_to_mat","text":"function generates contingency table two- three-column data.frame, row represents interaction two nodes (e.g., site species) optional third column indicates weight interaction (weight = TRUE).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a contingency table from a data.frame — net_to_mat","text":"","code":"net_to_mat(   net,   weight = FALSE,   squared = FALSE,   symmetrical = FALSE,   missing_value = 0 )"},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a contingency table from a data.frame — net_to_mat","text":"net two- three-column data.frame row represents interaction two nodes (e.g., site species), optional third column indicating weight interaction. weight logical value indicating whether weight column considered. squared logical value indicating whether output matrix square (.e., containing nodes rows columns). symmetrical logical value indicating whether resulting matrix symmetrical. applies squared = TRUE. Note different weights associated opposite pairs already present net preserved. missing_value value assign pairs nodes present net. Defaults 0.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a contingency table from a data.frame — net_to_mat","text":"matrix first nodes (first column net) rows second nodes (second column net) columns. squared = TRUE, rows columns number elements, corresponding unique union objects first second columns net. squared = TRUE symmetrical = TRUE, matrix forced symmetrical based upper triangular part matrix.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a contingency table from a data.frame — net_to_mat","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/net_to_mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a contingency table from a data.frame — net_to_mat","text":"","code":"net <- data.frame(   Site = c(rep(\"A\", 2), rep(\"B\", 3), rep(\"C\", 2)),   Species = c(\"a\", \"b\", \"a\", \"c\", \"d\", \"b\", \"d\"),   Weight = c(10, 100, 1, 20, 50, 10, 20) )  mat <- net_to_mat(net, weight = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":null,"dir":"Reference","previous_headings":"","what":"Community structure detection in weighted bipartite network via modularity optimization — netclu_beckett","title":"Community structure detection in weighted bipartite network via modularity optimization — netclu_beckett","text":"function takes bipartite weighted graph computes modules applying Newman’s modularity measure bipartite weighted version .","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Community structure detection in weighted bipartite network via modularity optimization — netclu_beckett","text":"","code":"netclu_beckett(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   seed = NULL,   forceLPA = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Community structure detection in weighted bipartite network via modularity optimization — netclu_beckett","text":"net data.frame representing bipartite network two first columns undirected links pair nodes next column(s) weight links. weight boolean indicating weights considered two columns (see Note). cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (O default). index name number column use weight. default, third column name net used. seed random number generator (NULL random default). forceLPA boolean indicating even faster pure LPA-algorithm Beckett used? DIRT-LPA, default, less likely get trapped local minimum, slightly slower. Defaults FALSE. site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (site, species ) returned output (return_node_type = \"\" default). algorithm_in_output boolean indicating original output computeModules returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Community structure detection in weighted bipartite network via modularity optimization — netclu_beckett","text":"list class bioregion.clusters five slots: name: character containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find output computeModules.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Community structure detection in weighted bipartite network via modularity optimization — netclu_beckett","text":"function based modularity optimization algorithm provided Stephen Beckett (Beckett, 2016) implemented bipartite package (computeModules).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Community structure detection in weighted bipartite network via modularity optimization — netclu_beckett","text":"Beckett designed deal weighted bipartite networks. Note weight = FALSE, weight 1 assigned pair nodes. forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal keep types nodes,sites preserve sites nodes species preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Community structure detection in weighted bipartite network via modularity optimization — netclu_beckett","text":"Beckett SJ (2016) Improved community detection weighted bipartite networks. Royal Society Open Science, 3(1), 140536.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Community structure detection in weighted bipartite network via modularity optimization — netclu_beckett","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Community structure detection in weighted bipartite network via modularity optimization — netclu_beckett","text":"","code":"net <- data.frame(   Site = c(rep(\"A\", 2), rep(\"B\", 3), rep(\"C\", 2)),   Species = c(\"a\", \"b\", \"a\", \"c\", \"d\", \"b\", \"d\"),   Weight = c(10, 100, 1, 20, 50, 10, 20))  com <- netclu_beckett(net)"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":null,"dir":"Reference","previous_headings":"","what":"Community structure detection via greedy optimization of modularity — netclu_greedy","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"function finds communities (un)weighted undirected network via greedy optimization modularity.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"","code":"netclu_greedy(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (O default). index name number column use weight. default, third column name net used. bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (site, species ) returned output (return_node_type = \"\" default). algorithm_in_output boolean indicating original output cluster_fast_greedy returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"list class bioregion.clusters five slots: name: character containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find output cluster_fast_greedy.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"function based fast greedy modularity optimization algorithm (Clauset et al., 2004) implemented igraph package (cluster_fast_greedy).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal keep types nodes, sites preserve sites nodes species preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"Clauset , Newman MEJ & Moore C (2004) Finding community structure large networks. Phys. Rev. E, 70, 066111.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Community structure detection via greedy optimization of modularity — netclu_greedy","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_greedy(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_greedy(net_bip, bipartite = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":null,"dir":"Reference","previous_headings":"","what":"Infomap community finding — netclu_infomap","title":"Infomap community finding — netclu_infomap","text":"function finds communities (un)weighted (un)directed network based Infomap algorithm (https://github.com/mapequation/infomap).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Infomap community finding — netclu_infomap","text":"","code":"netclu_infomap(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   seed = NULL,   nbmod = 0,   markovtime = 1,   numtrials = 1,   twolevel = FALSE,   show_hierarchy = FALSE,   directed = FALSE,   bipartite_version = FALSE,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   version = \"2.8.0\",   binpath = \"tempdir\",   check_install = TRUE,   path_temp = \"infomap_temp\",   delete_temp = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Infomap community finding — netclu_infomap","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (O default). index name number column use weight. default, third column name net used. seed random number generator (NULL random default). nbmod penalize solutions differ number (0 default preferred number modules). markovtime scales link flow change cost moving modules, higher values results fewer modules (default 1). numtrials number trials picking best solution. twolevel boolean indicating algorithm optimize two-level partition network (default multi-level). show_hierarchy boolean specifying hierarchy community identifiable outputs (FALSE default). directed boolean indicating network directed (column 1 column 2). bipartite_version boolean indicating bipartite version Infomap used (see Note). bipartite boolean indicating network bipartite (see Note). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (site, species ) returned output (return_node_type = \"\" default). version character indicating Infomap version use. binpath character indicating path bin folder (see install_binaries Details). check_install boolean indicating function check Infomap properly installed (see install_binaries Details). path_temp character indicating path temporary folder (see Details). delete_temp boolean indicating temporary folder removed (see Details).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Infomap community finding — netclu_infomap","text":"list class bioregion.clusters five slots: name: character containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects clusters: data.frame containing clustering results algorithm slot, users can find following elements: cmd: command line use run Infomap version: Infomap version web: Infomap's GitHub repository","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Infomap community finding — netclu_infomap","text":"Infomap network clustering algorithm based Map equation proposed Rosvall & Bergstrom (2008) finds communities (un)weighted (un)directed networks. function based C++ version Infomap (https://github.com/mapequation/infomap/releases). function needs binary files run. can installed install_binaries. changed default path bin folder running install_binaries PLEASE MAKE SURE set binpath accordingly. used install_binaries change permissions test binary files PLEASE MAKE SURE set check_install accordingly. C++ version Infomap generates temporary folders /files stored path_temp folder (\"infomap_temp\" unique timestamp located bin folder binpath default). temporary folder removed default (delete_temp = TRUE). Several version Infomap available package. See install_binaries details.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Infomap community finding — netclu_infomap","text":"Infomap designed deal bipartite networks. use functionality set bipartite_version argument TRUE order approximate two-step random walker (see https://www.mapequation.org/infomap/ information). Note bipartite network can also considered unipartite network (bipartite = TRUE). cases forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal keep types nodes, sites preserve sites nodes species preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Infomap community finding — netclu_infomap","text":"Rosvall M & Bergstrom CT (2008) Maps random walks complex networks reveal community structure. Proceedings National Academy Sciences, 105(4), 1118-1123.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Infomap community finding — netclu_infomap","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Infomap community finding — netclu_infomap","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_infomap(net) #> Infomap 2.8.0 is not installed... Please have a look at #>     https//bioRgeo.github.io/bioregion/articles/a1_install_binary_files.html #>     for more details. #> It should be located in /tmp/Rtmpl0NHbL/bin/INFOMAP/2.8.0/"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":null,"dir":"Reference","previous_headings":"","what":"Finding communities based on propagating labels — netclu_labelprop","title":"Finding communities based on propagating labels — netclu_labelprop","text":"function finds communities (un)weighted undirected network based propagating labels.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finding communities based on propagating labels — netclu_labelprop","text":"","code":"netclu_labelprop(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   seed = NULL,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finding communities based on propagating labels — netclu_labelprop","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (O default). index name number column use weight. default, third column name net used. seed random number generator (NULL random default). bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (site, species ) returned output (return_node_type = \"\" default). algorithm_in_output boolean indicating original output cluster_label_prop returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finding communities based on propagating labels — netclu_labelprop","text":"list class bioregion.clusters five slots: name: character containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find \"communities\" object, output cluster_label_prop.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finding communities based on propagating labels — netclu_labelprop","text":"function based propagating labels (Raghavan et al., 2007) implemented igraph package (cluster_label_prop).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Finding communities based on propagating labels — netclu_labelprop","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal keep types nodes, sites preserve sites nodes species preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Finding communities based on propagating labels — netclu_labelprop","text":"Raghavan UN, Albert R & Kumara S (2007) Near linear time algorithm detect community structures large-scale networks. Physical Review E, 76(3) , 036106.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finding communities based on propagating labels — netclu_labelprop","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finding communities based on propagating labels — netclu_labelprop","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_labelprop(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_labelprop(net_bip, bipartite = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":null,"dir":"Reference","previous_headings":"","what":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"function finds communities (un)weighted undirected network based leading eigen vector community matrix.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"","code":"netclu_leadingeigen(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (O default). index name number column use weight. default, third column name net used. bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (site, species ) returned output (return_node_type = \"\" default). algorithm_in_output boolean indicating original output cluster_leading_eigen returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"list class bioregion.clusters five slots: name: character containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find output cluster_leading_eigen.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"function based leading eigenvector community matrix (Newman, 2006) implemented igraph package (cluster_leading_eigen).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal keep types nodes, sites preserve sites nodes species preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"Newman MEJ (2006) Finding community structure networks using eigenvectors matrices. Physical Review E, 74(3), 036104.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finding communities based on leading eigen vector of the community matrix — netclu_leadingeigen","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_leadingeigen(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_leadingeigen(net_bip, bipartite = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":null,"dir":"Reference","previous_headings":"","what":"Finding communities using the Leiden algorithm — netclu_leiden","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"function finds communities (un)weighted undirected network based Leiden algorithm Traag, van Eck & Waltman.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"","code":"netclu_leiden(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   seed = NULL,   objective_function = \"CPM\",   resolution_parameter = 1,   beta = 0.01,   n_iterations = 2,   vertex_weights = NULL,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (O default). index name number column use weight. default, third column name net used. seed random number generator (NULL random default). objective_function string indicating objective function use, Constant Potts Model (\"CPM\") \"modularity\" (\"CPM\" default). resolution_parameter resolution parameter use. Higher resolutions lead smaller communities, lower resolutions lead fewer larger communities. beta parameter affecting randomness Leiden algorithm. affects refinement step algorithm. n_iterations number iterations iterate Leiden algorithm. iteration may improve partition . vertex_weights vertex weights used Leiden algorithm. provided, automatically determined basis objective_function. Please see details function interpret vertex weights. bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (\"site\", \"species\" \"\") returned output (return_node_type = \"\" default). algorithm_in_output boolean indicating original output cluster_leiden returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"list class bioregion.clusters five slots: name: character containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find output cluster_leiden.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"function based Leiden algorithm (Traag et al., 2019) implemented igraph package (cluster_leiden).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal \"\" keep types nodes, \"site\" preserve sites nodes \"species\" preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"Traag VA, Waltman L & Van Eck NJ (2019) Louvain Leiden: guaranteeing well-connected communities. Scientific reports, 9(1), 5233.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_leiden.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finding communities using the Leiden algorithm — netclu_leiden","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_leiden(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_leiden(net_bip, bipartite = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":null,"dir":"Reference","previous_headings":"","what":"Louvain community finding — netclu_louvain","title":"Louvain community finding — netclu_louvain","text":"function finds communities (un)weighted undirected network based Louvain algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Louvain community finding — netclu_louvain","text":"","code":"netclu_louvain(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   lang = \"igraph\",   resolution = 1,   seed = NULL,   q = 0,   c = 0.5,   k = 1,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   binpath = \"tempdir\",   check_install = TRUE,   path_temp = \"louvain_temp\",   delete_temp = TRUE,   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Louvain community finding — netclu_louvain","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (O default). index name number column use weight. default, third column name net used. lang string indicating version Louvain used (igraph cpp, see Details). resolution resolution parameter adjust modularity (1 chosen default, see Details). seed random number generator (lang = \"igraph\", NULL random default). q quality function used compute partition graph (modularity chosen default, see Details). c parameter Owsinski-Zadrozny quality function (0 1, 0.5 chosen default). k kappa_min value Shi-Malik quality function (must > 0, 1 chosen default). bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (site, species ) returned output (return_node_type = \"\" default). binpath character indicating path bin folder (see install_binaries Details). check_install boolean indicating function check Louvain properly installed (see install_binaries Details). path_temp character indicating path temporary folder (see Details). delete_temp boolean indicating temporary folder removed (see Details). algorithm_in_output boolean indicating original output cluster_louvain returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Louvain community finding — netclu_louvain","text":"list class bioregion.clusters five slots: name: character containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find output cluster_louvain lang = \"igraph\" following element lang = \"cpp\": cmd: command line use run Louvain version: Louvain version web: Louvain's website .","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Louvain community finding — netclu_louvain","text":"Louvain network community detection algorithm proposed (Blondel et al., 2008). function proposed two implementations function (parameter lang): igraph implementation (cluster_louvain) C++ implementation (https://sourceforge.net/projects/louvain/, version 0.3). igraph implementation offers possibility adjust resolution parameter modularity function (resolution argument) algorithm uses internally. Lower values typically yield fewer, larger clusters. original definition modularity recovered resolution parameter set 1 (default). C++ implementation offers possibility choose among several quality functions, q = 0 classical Newman-Girvan criterion (also called \"Modularity\"), 1 Zahn-Condorcet criterion, 2 Owsinski-Zadrozny criterion (specify value parameter c argument), 3 Goldberg Density criterion, 4 -weighted Condorcet criterion, 5 Deviation Indetermination criterion, 6 Deviation Uniformity criterion, 7 Profile Difference criterion, 8 Shi-Malik criterion (specify value kappa_min k argument) 9 Balanced Modularity criterion. C++ version Louvain based version 0.3 (https://sourceforge.net/projects/louvain/). function needs binary files run. can installed install_binaries. changed default path bin folder running install_binaries PLEASE MAKE SURE set binpath accordingly. used install_binaries change permissions test binary files PLEASE MAKE SURE set check_install accordingly. C++ version Louvain generates temporary folders /files stored path_temp folder (\"louvain_temp\" unique timestamp located bin folder binpath default). temporary folder removed default (delete_temp = TRUE).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Louvain community finding — netclu_louvain","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal keep types nodes, sites preserve sites nodes species preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Louvain community finding — netclu_louvain","text":"Blondel VD, Guillaume JL, Lambiotte R & Mech ELJS (2008) Fast unfolding communities large networks. J. Stat. Mech., 10(2008), P10008.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Louvain community finding — netclu_louvain","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Louvain community finding — netclu_louvain","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_louvain(net, lang = \"igraph\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":null,"dir":"Reference","previous_headings":"","what":"OSLOM community finding — netclu_oslom","title":"OSLOM community finding — netclu_oslom","text":"function finds communities (un)weighted (un)directed network based OSLOM algorithm (http://oslom.org/, version 2.4).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"OSLOM community finding — netclu_oslom","text":"","code":"netclu_oslom(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   seed = NULL,   reassign = \"no\",   r = 10,   hr = 50,   t = 0.1,   cp = 0.5,   directed = FALSE,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   binpath = \"tempdir\",   check_install = TRUE,   path_temp = \"oslom_temp\",   delete_temp = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"OSLOM community finding — netclu_oslom","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (O default). index name number column use weight. default, third column name net used. seed random number generator (NULL random default). reassign character indicating nodes belonging several community reassign method used (see Note). r number runs first hierarchical level (10 default). hr number runs higher hierarchical level (50 default, 0 interested hierarchies). t p-value, default value 0.10, increase value get modules. cp kind resolution parameter used decide taking modules union (default value 0.5, bigger value leads bigger clusters). directed boolean indicating network directed (column 1 column 2). bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (site, species ) returned output (return_node_type = \"\" default). binpath character indicating path bin folder (see install_binaries Details). check_install boolean indicating function check OSLOM properly installed (see install_binaries Details). path_temp character indicating path temporary folder (see Details). delete_temp boolean indicating temporary folder removed (see Details).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"OSLOM community finding — netclu_oslom","text":"list class bioregion.clusters five slots: name: character containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects clusters: data.frame containing clustering results algorithm slot, users can find following elements: cmd: command line use run OSLOM version: OSLOM version web: OSLOM's web site","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"OSLOM community finding — netclu_oslom","text":"OSLOM network community detection algorithm proposed Lancichinetti et al. (2011) finds statistically significant (overlapping) communities (un)weighted (un)directed networks. function based 2.4 C++ version OSLOM (http://www.oslom.org/software.htm). function needs files run. can installed install_binaries. changed default path bin folder running install_binaries PLEASE MAKE SURE set binpath accordingly. used install_binaries change permissions test binary files PLEASE MAKE SURE set check_install accordingly. C++ version OSLOM generates temporary folders /files stored path_temp folder (folder \"oslom_temp\" unique timestamp located bin folder binpath default). temporary folder removed default (delete_temp = TRUE).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"OSLOM community finding — netclu_oslom","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e.feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal keep types nodes, sites preserve sites nodes species preserve species nodes. Since OSLOM potentially returns overlapping communities propose two methods reassign 'overlapping' nodes randomly reassign = \"random\" based closest candidate community reassign = \"simil\" (weighted networks, case closest candidate community determined average similarity). default reassign = \"\" information provided. number partitions depend number overlapping modules (three). suffix _semel, _bis _ter added column names. first partition (_semel) assigns module node. value NA second (_bis) third (_ter) columns indicates overlapping module found node (.e. non-overlapping nodes).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"OSLOM community finding — netclu_oslom","text":"Lancichinetti , Radicchi F, Ramasco JJ & Fortunato S (2011) Finding statistically significant communities networks. PLOS ONE, 6(4), e18961.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"OSLOM community finding — netclu_oslom","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"OSLOM community finding — netclu_oslom","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_oslom(net) #> OSLOM is not installed... Please have a look at #>               https://bioRgeo.github.io/bioregion/articles/a1_install_binary_files.html #>               for more details. #> It should be located in /tmp/Rtmpl0NHbL/bin/OSLOM/"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Community structure detection via short random walks — netclu_walktrap","title":"Community structure detection via short random walks — netclu_walktrap","text":"function finds communities (un)weighted undirected network via short random walks.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Community structure detection via short random walks — netclu_walktrap","text":"","code":"netclu_walktrap(   net,   weight = TRUE,   cut_weight = 0,   index = names(net)[3],   steps = 4,   bipartite = FALSE,   site_col = 1,   species_col = 2,   return_node_type = \"both\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Community structure detection via short random walks — netclu_walktrap","text":"net output object similarity() dissimilarity_to_similarity(). data.frame used, first two columns represent pairs sites (pair nodes), next column(s) similarity indices. weight boolean indicating weights considered two columns. cut_weight minimal weight value. weight TRUE, links sites weight strictly lower value considered (O default). index name number column use weight. default, third column name net used. steps length random walks perform. bipartite boolean indicating network bipartite (see Details). site_col name number column site nodes (.e. primary nodes). species_col name number column species nodes (.e. feature nodes). return_node_type character indicating types nodes (site, species ) returned output (return_node_type = \"\" default). algorithm_in_output boolean indicating original output cluster_walktrap returned output (TRUE default, see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Community structure detection via short random walks — netclu_walktrap","text":"list class bioregion.clusters five slots: name: character containing name algorithm args: list input arguments provided user inputs: list characteristics clustering process algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE) clusters: data.frame containing clustering results algorithm slot, algorithm_in_output = TRUE, users can find output cluster_walktrap.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Community structure detection via short random walks — netclu_walktrap","text":"function based random walks (Pons & Latapy, 2005) implemented igraph package (cluster_walktrap).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Community structure detection via short random walks — netclu_walktrap","text":"Although algorithm primarily designed deal bipartite network, possible consider bipartite network unipartite network (bipartite = TRUE). forget indicate first two columns dedicated site nodes (.e. primary nodes) species nodes (.e. feature nodes) using arguments site_col species_col. type nodes returned output can chosen argument return_node_type equal keep types nodes, sites preserve sites nodes species preserve species nodes.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Community structure detection via short random walks — netclu_walktrap","text":"Pons P & Latapy M (2005) Computing Communities Large Networks Using Random Walks. Yolum , Güngör T, Gürgen F, Özturan C (eds.), Computer Information Sciences - ISCIS 2005, Lecture Notes Computer Science, 284-293.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Community structure detection via short random walks — netclu_walktrap","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Community structure detection via short random walks — netclu_walktrap","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  net <- similarity(comat, metric = \"Simpson\") com <- netclu_walktrap(net)  net_bip <- mat_to_net(comat, weight = TRUE) clust2 <- netclu_walktrap(net_bip, bipartite = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"function performs non-hierarchical clustering using Affinity Propagation algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"","code":"nhclu_affprop(   similarity,   index = names(similarity)[3],   seed = NULL,   p = NA,   q = NA,   maxits = 1000,   convits = 100,   lam = 0.9,   details = FALSE,   nonoise = FALSE,   K = NULL,   prc = NULL,   bimaxit = NULL,   exact = NULL,   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"similarity output object similarity() dissimilarity_to_similarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain similarity indices. index name number similarity column use. default, third column name similarity used. seed seed random number generator. p Input preference, can vector specifying individual preferences data point. scalar, value used data points. NA, exemplar preferences initialized based distribution non-Inf values similarity matrix, controlled q. q p = NA, exemplar preferences initialized according distribution non-Inf values similarity matrix. default, median used. value 0 1 specifies sample quantile, q = 0.5 results median. maxits maximum number iterations execute. convits algorithm terminates exemplars change convits iterations. lam damping factor, value range [0.5, 1). Higher values correspond heavier damping, may help prevent oscillations. details TRUE, detailed information algorithm's progress stored output object. nonoise TRUE, disables addition small amount noise similarity object, prevents degenerate cases. K desired number clusters. NULL, function apcluster called. prc parameter needed K NULL. algorithm stops number clusters deviates less prc percent desired value K. Set 0 enforce exactly K clusters. bimaxit parameter needed K NULL. Specifies maximum number bisection steps perform. warning issued number clusters remains outside desired range. exact flag indicating whether compute initial preference range exactly. algorithm_in_output boolean indicating whether include original output apcluster result. Defaults TRUE.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"list class bioregion.clusters five slots: name: character string containing name algorithm. args: list input arguments provided user. inputs: list describing characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm_in_output = TRUE, algorithm slot includes output apcluster.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"function based apcluster package (apcluster).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"Frey B & Dueck D (2007) Clustering Passing Messages Data Points. Science, 315, 972-976.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_affprop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-hierarchical clustering: Affinity Propagation — nhclu_affprop","text":"","code":"comat_1 <- matrix(sample(0:1000, size = 10*12, replace = TRUE, prob = 1/1:1001), 10, 12) rownames(comat_1) <- paste0(\"Site\", 1:10) colnames(comat_1) <- paste0(\"Species\", 1:12) comat_1 <- cbind(comat_1,                  matrix(0, 10, 8,                         dimnames = list(paste0(\"Site\", 1:10),                                         paste0(\"Species\", 13:20))))  comat_2 <- matrix(sample(0:1000, size = 10*12, replace = TRUE,                          prob = 1/1:1001), 10, 12) rownames(comat_2) <- paste0(\"Site\", 11:20) colnames(comat_2) <- paste0(\"Species\", 9:20) comat_2 <- cbind(matrix(0, 10, 8,                         dimnames = list(paste0(\"Site\", 11:20),                                         paste0(\"Species\", 1:8))),                  comat_2)  comat <- rbind(comat_1, comat_2)  dissim <- dissimilarity(comat, metric = \"Simpson\") sim <- dissimilarity_to_similarity(dissim)  clust1 <- nhclu_affprop(sim)  clust2 <- nhclu_affprop(sim, q = 1)  # Fixed number of clusters clust3 <- nhclu_affprop(sim, K = 2, prc = 10, bimaxit = 20, exact = FALSE) #> Trying p = 0.993402  #>    Number of clusters: 2  #> Trying p = 0.9340202  #>    Number of clusters: 2  #> Trying p = 0.340202  #>    Number of clusters: 2  #>  #> Number of clusters: 2 for p = 0.340202"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-hierarchical clustering: CLARA — nhclu_clara","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"function performs non-hierarchical clustering based dissimilarity using partitioning around medoids, implemented via Clustering Large Applications (CLARA) algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"","code":"nhclu_clara(   dissimilarity,   index = names(dissimilarity)[3],   seed = NULL,   n_clust = c(1, 2, 3),   maxiter = 0,   initializer = \"LAB\",   fasttol = 1,   numsamples = 5,   sampling = 0.25,   independent = FALSE,   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. seed value random number generator (set NULL random initialization default). n_clust integer vector single integer specifying desired number(s) clusters. maxiter integer defining maximum number iterations. initializer character string, either \"BUILD\" (used classic PAM algorithm) \"LAB\" (Linear Approximate BUILD). fasttol positive numeric value defining tolerance fast swapping behavior. Defaults 1. numsamples positive integer specifying number samples draw. sampling positive numeric value defining sampling rate. independent boolean indicating whether previous medoids excluded next sample. Defaults FALSE. algorithm_in_output boolean indicating whether original output fastclara included output. Defaults TRUE (see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"list class bioregion.clusters five components: name: character string containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm_in_output = TRUE, algorithm slot includes output fastclara.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"Based fastkmedoids package (fastclara).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"Schubert E & Rousseeuw PJ (2019) Faster k-Medoids Clustering: Improving PAM, CLARA, CLARANS Algorithms. Similarity Search Applications 11807, 171-187.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clara.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-hierarchical clustering: CLARA — nhclu_clara","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"all\")  clust1 <- nhclu_clara(dissim, index = \"Simpson\", n_clust = 5)  bioregionalization_metrics(clust1, dissimilarity = dissim, eval_metric = \"pc_distance\") #> Computing similarity-based metrics... #>   - pc_distance OK #> Partition metrics: #>  - 1  partition(s) evaluated #>  - Range of clusters explored: from  1  to  1  #>  - Requested metric(s):  pc_distance  #>  - Metric summary: #>      pc_distance #> Min            0 #> Mean           0 #> Max            0 #>  #> Access the data.frame of metrics with your_object$evaluation_df"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-hierarchical clustering: CLARANS — nhclu_clarans","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"function performs non-hierarchical clustering based dissimilarity using partitioning around medoids, implemented via Clustering Large Applications based RANdomized Search (CLARANS) algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"","code":"nhclu_clarans(   dissimilarity,   index = names(dissimilarity)[3],   seed = NULL,   n_clust = c(1, 2, 3),   numlocal = 2,   maxneighbor = 0.025,   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. seed value random number generator (NULL random initialization default). n_clust integer vector single integer specifying desired number(s) clusters. numlocal integer defining number local searches perform. maxneighbor positive numeric value defining maximum number neighbors consider local search. algorithm_in_output boolean indicating whether original output fastclarans included output. Defaults TRUE (see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"list class bioregion.clusters five components: name: character string containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm_in_output = TRUE, algorithm slot includes output fastclarans.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"Based fastkmedoids package (fastclarans).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"Schubert E & Rousseeuw PJ (2019) Faster k-Medoids Clustering: Improving PAM, CLARA, CLARANS Algorithms. Similarity Search Applications 11807, 171-187.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_clarans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-hierarchical clustering: CLARANS — nhclu_clarans","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"all\")  clust1 <- nhclu_clarans(dissim, index = \"Simpson\", n_clust = 5)  bioregionalization_metrics(clust1, dissimilarity = dissim, eval_metric = \"pc_distance\") #> Computing similarity-based metrics... #>   - pc_distance OK #> Partition metrics: #>  - 1  partition(s) evaluated #>  - Range of clusters explored: from  5  to  5  #>  - Requested metric(s):  pc_distance  #>  - Metric summary: #>      pc_distance #> Min    0.5409874 #> Mean   0.5409874 #> Max    0.5409874 #>  #> Access the data.frame of metrics with your_object$evaluation_df"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"function performs non-hierarchical clustering based dissimilarity using Density-Based Spatial Clustering Applications Noise (DBSCAN) algorithm.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"","code":"nhclu_dbscan(   dissimilarity,   index = names(dissimilarity)[3],   minPts = NULL,   eps = NULL,   plot = TRUE,   algorithm_in_output = TRUE,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. minPts numeric vector single numeric value specifying minPts argument dbscan::dbscan(). minPts minimum number points form dense region. default, set natural logarithm number sites dissimilarity. See Details guidance choosing parameter. eps numeric vector single numeric value specifying eps argument dbscan::dbscan(). eps specifies similar points considered part cluster. See Details guidance choosing parameter. plot boolean indicating whether k-nearest neighbor distance plot displayed. algorithm_in_output boolean indicating whether original output dbscan::dbscan included output. Defaults TRUE (see Value). ... Additional arguments passed dbscan() (see dbscan::dbscan).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"list class bioregion.clusters five components: name: character string containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm_in_output = TRUE, algorithm slot includes output dbscan::dbscan.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"DBSCAN (Density-Based Spatial Clustering Applications Noise) algorithm clusters points based density neighbors around data point. requires two main arguments: minPts, minimum number points identify core, eps, radius used find neighbors. Choosing minPts: determines many points necessary form cluster. example, minimum number sites expected bioregion? Choose value sufficiently large dataset expectations. Choosing eps: determines similar sites form cluster. eps small, points considered distinct marked noise. eps large, clusters may merge. value eps depends minPts. recommended choose eps identifying knee k-nearest neighbor distance plot. default, function attempts find knee curve automatically, result uncertain. Users inspect graph modify eps accordingly. explore eps values, run function initially without defining eps, review recommendations, adjust needed based clustering results.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"Hahsler M, Piekenbrock M & Doran D (2019) Dbscan: Fast density-based clustering R. Journal Statistical Software, 91(1), 1–30.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_dbscan.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-hierarchical clustering: DBSCAN — nhclu_dbscan","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"all\")  clust1 <- nhclu_dbscan(dissim, index = \"Simpson\") #> Trying to find a knee in the curve to search for an optimal eps value... #>        NOTE: this automatic identification of the knee may not work properly #>        if the curve has knees and elbows. Please adjust eps manually by #>        inspecting the curve, identifying a knee as follows: #>  #>                            / #>                  curve    / #>               ___________/  <- knee #>   elbow ->   / #>             / #>            /  clust2 <- nhclu_dbscan(dissim, index = \"Simpson\", eps = 0.2)  clust3 <- nhclu_dbscan(dissim, index = \"Simpson\", minPts = c(5, 10, 15, 20),      eps = c(.1, .15, .2, .25, .3))"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-hierarchical clustering: k-means analysis — nhclu_kmeans","title":"Non-hierarchical clustering: k-means analysis — nhclu_kmeans","text":"function performs non-hierarchical clustering based dissimilarity using k-means analysis.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-hierarchical clustering: k-means analysis — nhclu_kmeans","text":"","code":"nhclu_kmeans(   dissimilarity,   index = names(dissimilarity)[3],   seed = NULL,   n_clust = c(1, 2, 3),   iter_max = 10,   nstart = 10,   algorithm = \"Hartigan-Wong\",   algorithm_in_output = TRUE )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-hierarchical clustering: k-means analysis — nhclu_kmeans","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. seed value random number generator (NULL random default). n_clust integer vector single integer value specifying requested number(s) clusters. iter_max integer specifying maximum number iterations k-means method (see kmeans). nstart integer specifying many random sets n_clust selected starting points k-means analysis (see kmeans). algorithm character specifying algorithm use k-means (see kmeans). Available options Hartigan-Wong, Lloyd, Forgy, MacQueen. algorithm_in_output boolean indicating whether original output kmeans included output. Defaults TRUE (see Value).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-hierarchical clustering: k-means analysis — nhclu_kmeans","text":"list class bioregion.clusters five components: name: character string containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm_in_output = TRUE, algorithm slot includes output kmeans.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-hierarchical clustering: k-means analysis — nhclu_kmeans","text":"method partitions data k groups sum squares Euclidean distances points assigned cluster centers minimized. K-means applied directly dissimilarity beta-diversity metrics distances Euclidean. Therefore, first requires transforming dissimilarity matrix using Principal Coordinate Analysis (PCoA) pcoa, applying k-means coordinates points PCoA. additional transformation alters initial dissimilarity matrix, partitioning around medoids method (nhclu_pam) preferred.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non-hierarchical clustering: k-means analysis — nhclu_kmeans","text":"Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_kmeans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-hierarchical clustering: k-means analysis — nhclu_kmeans","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  comnet <- mat_to_net(comat)  dissim <- dissimilarity(comat, metric = \"all\")  clust1 <- nhclu_kmeans(dissim, n_clust = 2:10, index = \"Simpson\") clust2 <- nhclu_kmeans(dissim, n_clust = 2:15, index = \"Simpson\") bioregionalization_metrics(clust2, dissimilarity = dissim,                   eval_metric = \"pc_distance\") #> Computing similarity-based metrics... #>   - pc_distance OK #> Partition metrics: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Requested metric(s):  pc_distance  #>  - Metric summary: #>      pc_distance #> Min    0.1310308 #> Mean   0.8399596 #> Max    0.9798563 #>  #> Access the data.frame of metrics with your_object$evaluation_df  bioregionalization_metrics(clust2, net = comnet, species_col = \"Node2\",                   site_col = \"Node1\", eval_metric = \"avg_endemism\") #> Computing composition-based metrics... #>   - avg_endemism OK #> Partition metrics: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Requested metric(s):  avg_endemism  #>  - Metric summary: #>      avg_endemism #> Min             0 #> Mean            0 #> Max             0 #>  #> Access the data.frame of metrics with your_object$evaluation_df #> Details of endemism % for each partition are available in  #>         your_object$endemism_results"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-hierarchical clustering: partitioning around medoids — nhclu_pam","title":"Non-hierarchical clustering: partitioning around medoids — nhclu_pam","text":"function performs non-hierarchical clustering based dissimilarity using partitioning around medoids (PAM).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-hierarchical clustering: partitioning around medoids — nhclu_pam","text":"","code":"nhclu_pam(   dissimilarity,   index = names(dissimilarity)[3],   seed = NULL,   n_clust = c(1, 2, 3),   variant = \"faster\",   nstart = 1,   cluster_only = FALSE,   algorithm_in_output = TRUE,   ... )"},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-hierarchical clustering: partitioning around medoids — nhclu_pam","text":"dissimilarity output object dissimilarity() similarity_to_dissimilarity(), dist object. data.frame used, first two columns represent pairs sites (pair nodes), subsequent column(s) contain dissimilarity indices. index name number dissimilarity column use. default, third column name dissimilarity used. seed value random number generator (NULL random default). n_clust integer vector single integer value specifying requested number(s) clusters. variant character string specifying PAM variant use. Defaults faster. Available options original, o_1, o_2, f_3, f_4, f_5, faster. See pam details. nstart integer specifying number random starts PAM algorithm. Defaults 1 (faster variant). cluster_only boolean specifying whether clustering results returned pam function. Setting TRUE makes function efficient. algorithm_in_output boolean indicating whether original output pam included result. Defaults TRUE (see Value). ... Additional arguments pass pam() (see pam).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-hierarchical clustering: partitioning around medoids — nhclu_pam","text":"list class bioregion.clusters five components: name: character string containing name algorithm. args: list input arguments provided user. inputs: list characteristics clustering process. algorithm: list objects associated clustering procedure, original cluster objects (algorithm_in_output = TRUE). clusters: data.frame containing clustering results. algorithm_in_output = TRUE, algorithm slot includes output pam.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-hierarchical clustering: partitioning around medoids — nhclu_pam","text":"method partitions data chosen number clusters based input dissimilarity matrix. robust k-means minimizes sum dissimilarities cluster centers (medoids) points assigned cluster. contrast, k-means minimizes sum squared Euclidean distances, makes unsuitable dissimilarity matrices based Euclidean distances.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Non-hierarchical clustering: partitioning around medoids — nhclu_pam","text":"Kaufman L & Rousseeuw PJ (2009) Finding groups data: introduction cluster analysis. & Sons. JW (ed.), Finding groups data: introduction cluster analysis.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Non-hierarchical clustering: partitioning around medoids — nhclu_pam","text":"Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/nhclu_pam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-hierarchical clustering: partitioning around medoids — nhclu_pam","text":"","code":"comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001), 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  comnet <- mat_to_net(comat) dissim <- dissimilarity(comat, metric = \"all\")  clust1 <- nhclu_pam(dissim, n_clust = 2:10, index = \"Simpson\") clust2 <- nhclu_pam(dissim, n_clust = 2:15, index = \"Simpson\") bioregionalization_metrics(clust2, dissimilarity = dissim, eval_metric = \"pc_distance\") #> Computing similarity-based metrics... #>   - pc_distance OK #> Partition metrics: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Requested metric(s):  pc_distance  #>  - Metric summary: #>      pc_distance #> Min    0.1071351 #> Mean   0.6018179 #> Max    0.9469276 #>  #> Access the data.frame of metrics with your_object$evaluation_df bioregionalization_metrics(clust2, net = comnet, species_col = \"Node2\",                    site_col = \"Node1\", eval_metric = \"avg_endemism\") #> Computing composition-based metrics... #>   - avg_endemism OK #> Partition metrics: #>  - 14  partition(s) evaluated #>  - Range of clusters explored: from  2  to  15  #>  - Requested metric(s):  avg_endemism  #>  - Metric summary: #>      avg_endemism #> Min   0.000000000 #> Mean  0.004285714 #> Max   0.060000000 #>  #> Access the data.frame of metrics with your_object$evaluation_df #> Details of endemism % for each partition are available in  #>         your_object$endemism_results"},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute similarity metrics between sites based on species composition — similarity","title":"Compute similarity metrics between sites based on species composition — similarity","text":"function generates data.frame row provides one several similarity metrics pairs sites, based co-occurrence matrix sites rows species columns.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute similarity metrics between sites based on species composition — similarity","text":"","code":"similarity(comat, metric = \"Simpson\", formula = NULL, method = \"prodmat\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute similarity metrics between sites based on species composition — similarity","text":"comat co-occurrence matrix sites rows species columns. metric character vector single character string specifying metrics compute (see Details). Available options \"abc\", \"ABC\", \"Jaccard\", \"Jaccardturn\", \"Sorensen\", \"Simpson\", \"Bray\", \"Brayturn\", \"Euclidean\". \"\" specified, metrics calculated. Can set NULL formula used. formula character vector single character string specifying custom formula(s) based , b, c, , B, C quantities (see Details). default NULL. method character string specifying method compute abc (see Details). default \"prodmat\", efficient memory-intensive. Alternatively, \"loops\" less memory-intensive slower.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute similarity metrics between sites based on species composition — similarity","text":"data.frame additional class bioregion.pairwise.metric, containing one several similarity metrics pairs sites. first two columns represent pairs sites. one column per similarity metric provided metric formula, except abc ABC metrics, stored three separate columns (one letter).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute similarity metrics between sites based on species composition — similarity","text":"number species shared pair sites, b species present first site c species present second site. Jaccard = 1 - (b + c) / (+ b + c) Jaccardturn = 1 - 2min(b, c) / (+ 2min(b, c)) (Baselga, 2012) Sorensen = 1 - (b + c) / (2a + b + c) Simpson = 1 - min(b, c) / (+ min(b, c)) abundances data available, Bray-Curtis turnover component can also computed following equation: Bray = 1 - (B + C) / (2A + B + C) Brayturn = 1 - min(B, C) / (+ min(B, C)) (Baselga, 2013) sum lesser values common species shared pair sites. B C total number specimens counted sites minus . formula can used compute customized metrics terms , b, c, , B, C. example formula = c(\"1 - pmin(b,c) / (+ pmin(b,c))\", \"1 - (B + C) / (2*+ B + C)\") compute Simpson Bray-Curtis similarity metrics, respectively. Note pmin used Simpson formula , b, c, , B C numeric vectors. Euclidean computes Euclidean similarity pair site following equation: Euclidean = 1 / (1 + d_ij) d_ij Euclidean distance site site j terms species composition.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute similarity metrics between sites based on species composition — similarity","text":"Baselga (2012) Relationship Species Replacement, Dissimilarity Derived Nestedness, Nestedness. Global Ecology Biogeography 21, 1223–1232. Baselga (2013) Separating two components abundance-based dissimilarity: balanced changes abundance vs. abundance gradients. Methods Ecology Evolution 4, 552–557.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute similarity metrics between sites based on species composition — similarity","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute similarity metrics between sites based on species composition — similarity","text":"","code":"comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  sim <- similarity(comat, metric = c(\"abc\", \"ABC\", \"Simpson\", \"Brayturn\"))  sim <- similarity(comat, metric = \"all\", formula = \"1 - (b + c) / (a + b + c)\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"function converts data.frame similarity metrics sites dissimilarity metrics (beta diversity).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"","code":"similarity_to_dissimilarity(similarity, include_formula = TRUE)"},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"similarity output object similarity() dissimilarity_to_similarity(). include_formula boolean indicating whether metrics based custom formula(s) also converted (see Details). default TRUE.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"data.frame additional class bioregion.pairwise.metric, providing dissimilarity metric(s) pair sites based similarity object.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"behavior function changes depending column names. Columns Site1 Site2 copied identically. columns called , b, c, , B, C also copied identically. columns based formula (argument formula similarity()) original list similarity metrics (argument metrics similarity()) argument include_formula set FALSE, also copied identically. Otherwise going converted like columns (default behavior). column called Euclidean, distance calculated based following formula: Euclidean distance = (1 - Euclidean similarity) / Euclidean similarity Otherwise, columns transformed dissimilarity following formula: dissimilarity = 1 - similarity","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Boris Leroy (leroy.boris@gmail.com)  Pierre Denelle (pierre.denelle@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/similarity_to_dissimilarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert similarity metrics to dissimilarity metrics — similarity_to_dissimilarity","text":"","code":"comat <- matrix(sample(0:1000, size = 50, replace = TRUE, prob = 1 / 1:1001), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  simil <- similarity(comat, metric = \"all\") simil #> Data.frame of similarity between sites #>  - Total number of sites:  5  #>  - Total number of species:  10  #>  - Number of rows:  10  #>  - Number of similarity metrics:  7  #>  #>  #>    Site1 Site2   Jaccard Jaccardturn  Sorensen   Simpson       Bray   Brayturn #> 2  Site1 Site2 0.7000000   1.0000000 0.8235294 1.0000000 0.21861777 0.32908705 #> 3  Site1 Site3 1.0000000   1.0000000 1.0000000 1.0000000 0.24496322 0.31062449 #> 4  Site1 Site4 0.8000000   1.0000000 0.8888889 1.0000000 0.18330606 0.18961625 #> 5  Site1 Site5 0.8000000   1.0000000 0.8888889 1.0000000 0.51054650 0.56230201 #> 8  Site2 Site3 0.7000000   1.0000000 0.8235294 1.0000000 0.20873563 0.24097665 #> 9  Site2 Site4 0.5000000   0.5555556 0.6666667 0.7142857 0.04642594 0.06687898 #> 10 Site2 Site5 0.6666667   0.7500000 0.8000000 0.8571429 0.14596273 0.24946921 #> 14 Site3 Site4 0.8000000   1.0000000 0.8888889 1.0000000 0.10116473 0.12327656 #> 15 Site3 Site5 0.8000000   1.0000000 0.8888889 1.0000000 0.10082598 0.14355231 #> 20 Site4 Site5 0.6000000   0.6000000 0.7500000 0.7500000 0.45629630 0.52144470 #>       Euclidean  a b c    A    B    C #> 2  0.0012216232  7 3 0  310 1584  632 #> 3  0.0009476402 10 0 0  383 1511  850 #> 4  0.0007660859  8 2 0  336 1558 1436 #> 5  0.0010691062  8 2 0 1065  829 1213 #> 8  0.0010053133  7 0 3  227  715 1006 #> 9  0.0007723967  5 2 3   63  879 1709 #> 10 0.0008873387  6 1 2  235  707 2043 #> 14 0.0006810961  8 2 0  152 1081 1620 #> 15 0.0007248472  8 2 0  177 1056 2101 #> 20 0.0010108979  6 2 2  924  848 1354  dissimilarity <- similarity_to_dissimilarity(simil) dissimilarity #> Data.frame of dissimilarity between sites #>  - Total number of sites:  5  #>  - Total number of species:  10  #>  - Number of rows:  10  #>  - Number of dissimilarity metrics:  7  #>  #>  #>    Site1 Site2   Jaccard Jaccardturn  Sorensen   Simpson      Bray  Brayturn #> 2  Site1 Site2 0.3000000   0.0000000 0.1764706 0.0000000 0.7813822 0.6709130 #> 3  Site1 Site3 0.0000000   0.0000000 0.0000000 0.0000000 0.7550368 0.6893755 #> 4  Site1 Site4 0.2000000   0.0000000 0.1111111 0.0000000 0.8166939 0.8103837 #> 5  Site1 Site5 0.2000000   0.0000000 0.1111111 0.0000000 0.4894535 0.4376980 #> 8  Site2 Site3 0.3000000   0.0000000 0.1764706 0.0000000 0.7912644 0.7590234 #> 9  Site2 Site4 0.5000000   0.4444444 0.3333333 0.2857143 0.9535741 0.9331210 #> 10 Site2 Site5 0.3333333   0.2500000 0.2000000 0.1428571 0.8540373 0.7505308 #> 14 Site3 Site4 0.2000000   0.0000000 0.1111111 0.0000000 0.8988353 0.8767234 #> 15 Site3 Site5 0.2000000   0.0000000 0.1111111 0.0000000 0.8991740 0.8564477 #> 20 Site4 Site5 0.4000000   0.4000000 0.2500000 0.2500000 0.5437037 0.4785553 #>    Euclidean  a b c    A    B    C #> 2   817.5830  7 3 0  310 1584  632 #> 3  1054.2528 10 0 0  383 1511  850 #> 4  1304.3366  8 2 0  336 1558 1436 #> 5   934.3607  8 2 0 1065  829 1213 #> 8   993.7147  7 0 3  227  715 1006 #> 9  1293.6715  5 2 3   63  879 1709 #> 10 1125.9654  6 1 2  235  707 2043 #> 14 1467.2215  8 2 0  152 1081 1620 #> 15 1378.6011  8 2 0  177 1056 2101 #> 20  988.2196  6 2 2  924  848 1354"},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate contribution metrics of sites and species — site_species_metrics","title":"Calculate contribution metrics of sites and species — site_species_metrics","text":"function calculates metrics assess contribution given species site bioregion.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate contribution metrics of sites and species — site_species_metrics","text":"","code":"site_species_metrics(   cluster_object,   comat,   indices = c(\"rho\"),   bipartite_link = NULL )"},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate contribution metrics of sites and species — site_species_metrics","text":"cluster_object bioregion.clusters object data.frame list data.frame containing multiple partitions. least two partitions required. list data.frame provided, number rows (.e., items clustering partitions). comat co-occurrence matrix sites rows species columns. indices character specifying contribution metric compute. Available options rho Cz. bipartite_link NULL default. Needed Cz indices. data.frame row represents interaction two nodes optional third column indicating weight interaction.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate contribution metrics of sites and species — site_species_metrics","text":"data.frame columns Bioregion, Species, desired summary statistics, list data.frames Cz indices selected.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate contribution metrics of sites and species — site_species_metrics","text":"\\(\\rho\\) metric derived Lenormand et al. (2019). formula following: \\(\\rho_{ij} = (n_ij - ((n_i n_j)/n))/(sqrt(((n - n_j)/(n-1)) (1-(n_j/n)) ((n_i n_j)/n)))\\) \\(n\\) number sites, \\(n_i\\) number sites species \\(\\) present, \\(n_j\\) number sites belonging bioregion \\(j\\), \\(n_ij\\) number occurrences species \\(\\) sites belonging bioregion \\(j\\). Affinity, fidelity individual contributions describe species linked bioregions. metrics described Bernardo-Madrid et al. (2019). Affinity species region, \\(A_i = R_i / Z\\) \\(R_i\\) occurrence/range size species \\(\\) associated bioregion, \\(Z\\) total size (number sites) bioregion. high affinity means species occupying sites associated bioregion. Fidelity species region, \\(F_i = R_i / D_i\\) \\(R_i\\) occurrence/range size species \\(\\) associated bioregion, \\(D_i\\) total occurrence/range size. high fidelity means species present bioregions associated one. Indicator Value species, \\(IndVal = F_i * A_i\\) Cz metrics derived Guimerà & Amaral (2005). respective formula : \\(C_i = 1 - \\sum_{s=1}^{N_M}{{(\\frac{k_is}{k_i}})^2}\\) \\(k_{}\\) number links node (species site) \\(\\) nodes bioregion \\(s\\), \\(k_i\\) total degree node \\(\\). participation coefficient node therefore close 1 links uniformly distributed among bioregions 0 links within bioregion. : \\(z_i = \\frac{k_i - \\overline{k_{si}}}{\\sigma_{k_{si}}}\\) \\(k_i\\) number links node (species site) \\(\\) nodes bioregion \\(s_i\\), \\(\\overline{k_{si}}\\) average \\(k\\) nodes \\(s_i\\), \\(\\sigma_{k_{si}}\\) standard deviation \\(k\\) \\(s_i\\). within-bioregion degree z-score measures well-connected node \\(\\) nodes bioregion.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate contribution metrics of sites and species — site_species_metrics","text":"Bernardo-Madrid R, Calatayud J, González‐Suárez M, Rosvall M, Lucas P, Antonelli & Revilla E (2019) Human activity altering world’s zoogeographical regions. Ecology Letters, 22, 1297–1305. Guimerà R & Amaral LAN (2005) Functional cartography complex metabolic networks. Nature, 433, 895–900. Lenormand M, Papuga G, Argagnon O, Soubeyrand M, Alleaume S & Luque S (2019) Biogeographical network analysis plant species distribution Mediterranean region. Ecology Evolution, 9, 237–250.","code":""},{"path":[]},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate contribution metrics of sites and species — site_species_metrics","text":"Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)  Maxime Lenormand (maxime.lenormand@inrae.fr)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_metrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate contribution metrics of sites and species — site_species_metrics","text":"","code":"comat <- matrix(sample(1000, 50), 5, 10) rownames(comat) <- paste0(\"Site\", 1:5) colnames(comat) <- paste0(\"Species\", 1:10)  comat <- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),                 20, 25) rownames(comat) <- paste0(\"Site\",1:20) colnames(comat) <- paste0(\"Species\",1:25)  dissim <- dissimilarity(comat, metric = \"Simpson\") clust1 <- nhclu_kmeans(dissim, n_clust = 3, index = \"Simpson\")  net <- similarity(comat, metric = \"Simpson\") com <- netclu_greedy(net)  site_species_metrics(cluster_object = clust1, comat = comat, indices = \"rho\") #>    Bioregion   Species         rho #> 1          3  Species1 1191.229995 #> 2          3  Species2  338.426329 #> 3          3  Species3 1236.049759 #> 4          3  Species4  995.801235 #> 5          3  Species5  393.120705 #> 6          3  Species6 1229.184152 #> 7          3  Species7 1376.897148 #> 8          3  Species8  283.831132 #> 9          3  Species9  392.148314 #> 10         3 Species10  377.235660 #> 11         3 Species11  698.520261 #> 12         3 Species12 2033.028308 #> 13         3 Species13  808.701425 #> 14         3 Species14 1134.941452 #> 15         3 Species15 1690.869865 #> 16         3 Species16 1013.666612 #> 17         3 Species17 1467.296632 #> 18         3 Species18 1426.422338 #> 19         3 Species19  195.044290 #> 20         3 Species20  240.234261 #> 21         3 Species21  267.784143 #> 22         3 Species22 2000.140620 #> 23         3 Species23 1029.668442 #> 24         3 Species24  216.378834 #> 25         3 Species25 1322.873723 #> 26         2  Species1   17.762011 #> 27         2  Species2  284.675902 #> 28         2  Species3  125.179418 #> 29         2  Species4  427.341085 #> 30         2  Species5  437.062360 #> 31         2  Species6  955.319364 #> 32         2  Species7  268.880931 #> 33         2  Species8  164.763439 #> 34         2  Species9  523.085323 #> 35         2 Species10   39.485148 #> 36         2 Species11    1.605051 #> 37         2 Species12  848.467163 #> 38         2 Species13  752.870899 #> 39         2 Species14  108.779583 #> 40         2 Species15  559.112793 #> 41         2 Species16  353.320570 #> 42         2 Species17   31.918653 #> 43         2 Species18   -1.661700 #> 44         2 Species19   84.084431 #> 45         2 Species20   95.365694 #> 46         2 Species21  481.436687 #> 47         2 Species22  258.211417 #> 48         2 Species23   50.776337 #> 49         2 Species24  442.645146 #> 50         2 Species25  132.449843 #> 51         1  Species1  232.215557 #> 52         1  Species2  712.417704 #> 53         1  Species3   58.735849 #> 54         1  Species4  762.528787 #> 55         1  Species5  337.361842 #> 56         1  Species6  737.355158 #> 57         1  Species7  142.603633 #> 58         1  Species8  692.225571 #> 59         1  Species9  237.319552 #> 60         1 Species10 1333.206945 #> 61         1 Species11  441.312542 #> 62         1 Species12   68.818608 #> 63         1 Species13  371.947144 #> 64         1 Species14  746.247241 #> 65         1 Species15  535.750103 #> 66         1 Species16  261.489779 #> 67         1 Species17  780.133085 #> 68         1 Species18  976.890267 #> 69         1 Species19  414.031670 #> 70         1 Species20 1285.807906 #> 71         1 Species21  794.272056 #> 72         1 Species22 1084.670815 #> 73         1 Species23  588.287424 #> 74         1 Species24  412.636487 #> 75         1 Species25  383.012426  # Contribution metrics site_species_metrics(cluster_object = com, comat = comat, indices = c(\"rho\", \"affinity\", \"fidelity\", \"indicator_value\")) #>    Bioregion   Species           rho  affinity     fidelity       indval #> 1          1  Species1 10589.6008597 122.42105 122.42105263 1.498691e+04 #> 2          1  Species2  9999.6959954 118.68421 112.75000000 1.338164e+04 #> 3          1  Species3  8643.2078343  88.84211 112.53333333 9.997698e+03 #> 4          1  Species4 16118.5200460 185.84211 185.84210526 3.453729e+04 #> 5          1  Species5  8470.6678341  95.47368 100.77777778 9.621626e+03 #> 6          1  Species6 21153.2030671 249.94737 237.45000000 5.935000e+04 #> 7          1  Species7 12934.8686460 145.31579 153.38888889 2.228983e+04 #> 8          1  Species8  7910.7844818  86.68421  96.88235294 8.398170e+03 #> 9          1  Species9  8124.2158318  89.00000  99.47058824 8.852882e+03 #> 10         1 Species10 13527.1604982 133.89474 181.71428571 2.433059e+04 #> 11         1 Species11  8465.9537889  95.42105 100.72222222 9.611020e+03 #> 12         1 Species12 18426.4423287 212.31579 212.31578947 4.507799e+04 #> 13         1 Species13 13862.6087202 151.26316 169.05882353 2.557237e+04 #> 14         1 Species14 12787.4035902 147.63158 147.63157895 2.179508e+04 #> 15         1 Species15 20261.7681997 233.36842 233.36842105 5.446082e+04 #> 16         1 Species16 11761.0713892 132.21053 139.55555556 1.845071e+04 #> 17         1 Species17 16991.3182832 185.21053 207.00000000 3.833858e+04 #> 18         1 Species18 18038.5302616 178.31579 242.00000000 4.315242e+04 #> 19         1 Species19  4534.0000000  48.52632  57.62500000 2.796329e+03 #> 20         1 Species20 12536.8470917 128.52632 162.80000000 2.092408e+04 #> 21         1 Species21 11451.8046073 125.10526 139.82352941 1.749266e+04 #> 22         1 Species22 24808.7880450 285.52632 285.52631579 8.152528e+04 #> 23         1 Species23 12459.0000000 131.94737 156.68750000 2.067450e+04 #> 24         1 Species24  7815.4155502  88.15789  93.05555556 8.203582e+03 #> 25         1 Species25 13178.6582576 143.84211 160.76470588 2.312473e+04 #> 26         2  Species1     1.1052632   2.00000   0.10526316 2.105263e-01 #> 27         2  Species2     0.0000000   1.00000   0.05000000 5.000000e-02 #> 28         2  Species3   374.6606652 317.00000  21.13333333 6.699267e+03 #> 29         2  Species4     2.1578947   3.00000   0.15789474 4.736842e-01 #> 30         2  Species5    -0.9733285   0.00000   0.00000000 0.000000e+00 #> 31         2  Species6     8.2078268   9.00000   0.45000000 4.050000e+00 #> 32         2  Species7    -0.9733285   0.00000   0.00000000 0.000000e+00 #> 33         2  Species8   165.9785599 150.00000   8.82352941 1.323529e+03 #> 34         2  Species9    29.1004984  27.00000   1.58823529 4.288235e+01 #> 35         2 Species10    -0.8583951   0.00000   0.00000000 0.000000e+00 #> 36         2 Species11    21.7376704  21.00000   1.16666667 2.450000e+01 #> 37         2 Species12   595.8421053 567.00000  29.84210526 1.692047e+04 #> 38         2 Species13     5.7310733   6.00000   0.35294118 2.117647e+00 #> 39         2 Species14   474.7894737 452.00000  23.78947368 1.075284e+04 #> 40         2 Species15     2.1578947   3.00000   0.15789474 4.736842e-01 #> 41         2 Species16     9.8414329  10.00000   0.55555556 5.555556e+00 #> 42         2 Species17     5.7310733   6.00000   0.35294118 2.117647e+00 #> 43         2 Species18     1.5941623   2.00000   0.14285714 2.857143e-01 #> 44         2 Species19   164.2616655 144.00000   9.00000000 1.296000e+03 #> 45         2 Species20    -0.8885233   0.00000   0.00000000 0.000000e+00 #> 46         2 Species21     2.3925840   3.00000   0.17647059 5.294118e-01 #> 47         2 Species22     1.1052632   2.00000   0.10526316 2.105263e-01 #> 48         2 Species23    -0.9176629   0.00000   0.00000000 0.000000e+00 #> 49         2 Species24     0.1081476   1.00000   0.05555556 5.555556e-02 #> 50         2 Species25    76.9521785  70.00000   4.11764706 2.882353e+02  # Cz indices net_bip <- mat_to_net(comat, weight = TRUE) clust_bip <- netclu_greedy(net_bip, bipartite = TRUE) site_species_metrics(cluster_object = clust_bip, comat = comat,  bipartite_link = net_bip, indices = \"Cz\") #> Warning: Column 'Node1' has been renamed 'Sites'. If this column does not #>             correspond to sites, rename it before running the function. #> Warning: Column 'Node2' has been renamed 'Species'. If this column does not #>             correspond to species, rename it before running the function. #>         Node Bioregion Category         C          z #> 1      Site1         1     site 0.8163265  1.1547005 #> 2      Site2         1     site 0.8199446 -1.1547005 #> 3      Site3         3     site 0.8128544  1.2076147 #> 4      Site4         5     site 0.8144044  1.0954451 #> 5      Site5         3     site 0.8159722  1.2076147 #> 6      Site6         3     site 0.8090737  1.2076147 #> 7      Site7         2     site 0.8140496 -1.0000000 #> 8      Site8         2     site 0.7977316  0.0000000 #> 9      Site9         2     site 0.8159722  0.0000000 #> 10    Site10         4     site 0.7936508  1.0690450 #> 11    Site11         4     site 0.7845805  1.0690450 #> 12    Site12         2     site 0.7809917  0.0000000 #> 13    Site13         5     site 0.8057851  1.0954451 #> 14    Site14         1     site 0.8072562  1.1547005 #> 15    Site15         2     site 0.8117914 -1.0000000 #> 16    Site16         1     site 0.8194444  1.1547005 #> 17    Site17         2     site 0.8200000 -1.0000000 #> 18    Site18         6     site 0.8128544  1.1547005 #> 19    Site19         2     site 0.7981859  0.0000000 #> 20    Site20         4     site 0.8099174  1.0690450 #> 21  Species1         4  species 0.7645429 -0.8017837 #> 22  Species2         3  species 0.7800000 -0.7245688 #> 23  Species3         5  species 0.7733333 -0.7302967 #> 24  Species5         1  species 0.7839506  0.0000000 #> 25  Species6         1  species 0.7800000  0.0000000 #> 26  Species7         4  species 0.8024691 -0.8017837 #> 27  Species8         6  species 0.7958478 -0.5773503 #> 28 Species11         3  species 0.7530864 -0.7245688 #> 29 Species12         2  species 0.7700831  1.0000000 #> 30 Species13         5  species 0.7958478 -0.7302967 #> 31 Species15         4  species 0.7645429 -0.8017837 #> 32 Species16         1  species 0.7777778  0.0000000 #> 33 Species17         1  species 0.7474048 -1.1547005 #> 34 Species18         4  species 0.7244898 -0.8017837 #> 35 Species19         3  species 0.7421875 -0.7245688 #> 36 Species20         3  species 0.7466667 -0.7245688 #> 37 Species21         6  species 0.7820069 -0.5773503 #> 38 Species22         2  species 0.7756233  1.0000000 #> 39 Species23         2  species 0.8125000 -2.0000000 #> 40 Species24         2  species 0.7592593  1.0000000 #> 41 Species25         1  species 0.7820069 -1.1547005 #> 42  Species4         2  species 0.7756233  1.0000000 #> 43  Species9         5  species 0.7820069 -0.7302967 #> 44 Species10         3  species 0.8061224 -0.7245688 #> 45 Species14         2  species 0.7756233  1.0000000"},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"function extracts subset nodes based type (\"site\" \"species\") bioregion.clusters object, contains types nodes (sites species).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"","code":"site_species_subset(clusters, node_type = \"site\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"clusters object class bioregion.clusters. node_type character string indicating type nodes extract. Possible values \"site\" \"species\". default \"site\".","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"object class bioregion.clusters containing specified node type (sites species).","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"Network clustering functions (prefixed netclu_) may return types nodes (sites species) applied bipartite networks (using bipartite argument). cases, type nodes included output can specified return_node_type argument. function allows extract particular type nodes (sites species) output adjust return_node_type attribute accordingly.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"Maxime Lenormand (maxime.lenormand@inrae.fr)  Pierre Denelle (pierre.denelle@gmail.com)  Boris Leroy (leroy.boris@gmail.com)","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/site_species_subset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract a subset of sites or species from a bioregion.clusters object — site_species_subset","text":"","code":"net <- data.frame(   Site = c(rep(\"A\", 2), rep(\"B\", 3), rep(\"C\", 2)),   Species = c(\"a\", \"b\", \"a\", \"c\", \"d\", \"b\", \"d\"),   Weight = c(10, 100, 1, 20, 50, 10, 20) )  clusters <- netclu_louvain(net, lang = \"igraph\", bipartite = TRUE)  clusters_sites <- site_species_subset(clusters, node_type = \"site\")"},{"path":"https://bioRgeo.github.io/bioregion/reference/vegedf.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","title":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","text":"dataset containing abundance 3,697 species 715 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegedf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","text":"","code":"vegedf"},{"path":"https://bioRgeo.github.io/bioregion/reference/vegedf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","text":"data.frame 460,878 rows 3 columns: Site Unique site identifier (corresponding field ID vegesp) Species Unique species identifier Abundance Species abundance","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegedf.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Spatial distribution of Mediterranean vegetation (data.frame) — vegedf","text":"doi:10.1002/ece3.4718","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegemat.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","title":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","text":"dataset containing abundance 3,697 species 715 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegemat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","text":"","code":"vegemat"},{"path":"https://bioRgeo.github.io/bioregion/reference/vegemat.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","text":"co-occurrence matrix sites rows species columns. element matrix represents abundance species site.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegemat.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Spatial distribution of Mediterranean vegetation (co-occurrence matrix) — vegemat","text":"doi:10.1002/ece3.4718","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegesf.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","title":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","text":"dataset containing geometry 715 sites.","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegesf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","text":"","code":"vegesf"},{"path":"https://bioRgeo.github.io/bioregion/reference/vegesf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","text":"ID Unique site identifier geometry Geometry site","code":""},{"path":"https://bioRgeo.github.io/bioregion/reference/vegesf.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Spatial distribution of Mediterranean vegetation (spatial grid) — vegesf","text":"doi:10.1002/ece3.4718","code":""},{"path":"https://bioRgeo.github.io/bioregion/news/index.html","id":"bioregion-1119000","dir":"Changelog","previous_headings":"","what":"bioregion 1.1.1.9000","title":"bioregion 1.1.1.9000","text":"list changes made development/GitHub version package bioregion 1.1.1 (CRAN release 2024-04-19) next CRAN release. Added affinity propagation algorithm (nhclu_affprop()). Added new method hclu_hierarclust() construct consensus tree called Iterative Hierarchical Consensus Tree (IHCT). resolves issues related order sites distance matrix builds consensus hierarchical tree meaningful topology. Made many changes functions related hclu_hierarclust() due major update. Updated generic functions provide plot print methods hclu_diana(). Added site_species_metrics() package workflow. Added bioregion_metrics() package workflow. Renamed subset_node() site_species_subset(). Added indices Cz site_species_metrics(). Updated install_binaries(): Archive bin.zip now stored GitHub backed NextCloud. Added Infomap version 2.8.0. Added argument download_only execute download step.   Added check_install argument netclu_infomap(), netclu_louvain(), netclu_oslom(). Added betapart_to_bioregion() package. Added compare_bioregionalizations() package. Added bioregionalization_metrics() package. Updated documentation, vignettes, tests. Modified way seeds generated nhclu_clara() nhclu_clarans().","code":""},{"path":"https://bioRgeo.github.io/bioregion/news/index.html","id":"bioregion-111","dir":"Changelog","previous_headings":"","what":"bioregion 1.1.1","title":"bioregion 1.1.1","text":"list changes made bioregion 1.1.0 (CRAN release 2024-03-19) bioregion 1.1.1 (CRAN release 2024-04-19). Added hierarchy support Louvain (C++). Added seed argument stochastic algorithms (except Louvain C++). Added cut_weight argument netclu_* functions. Changed value sites without clusters 0 NA. Updated automated tests (code coverage > 60%). Standardized controls, inputs, outputs. Fixed bug find_optimal_n() cases partition metrics vary.","code":""},{"path":"https://bioRgeo.github.io/bioregion/news/index.html","id":"bioregion-110","dir":"Changelog","previous_headings":"","what":"bioregion 1.1.0","title":"bioregion 1.1.0","text":"list changes made bioregion 1.0.0 (CRAN release 2023-04-15) bioregion 1.1.0 (CRAN release 2024-03-19). Added resolution parameter igraph Louvain implementation. Added options mat_to_net() exclude diagonal lower triangular matrices using include_diag include_lower. Added function extract subset nodes (sites species) bioregion.clusters objects containing types. Added generic function maintain attributes bioregion.pairwise.metric objects track number sites species. Added new functions: nhclu_clara() nhclu_clarans(). Edited vignettes document new functions. Modified controls bioregion.pairwise.metric objects. Added include_formula argument similarity_dissimilarity_conversion() () select formula metrics. Allowed negative values similarity() Euclidean metric.","code":""},{"path":"https://bioRgeo.github.io/bioregion/news/index.html","id":"bioregion-100","dir":"Changelog","previous_headings":"","what":"bioregion 1.0.0","title":"bioregion 1.0.0","text":"First release CRAN","code":""}]
