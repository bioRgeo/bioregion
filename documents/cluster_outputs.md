# Comprehensive analysis of clustering function outputs

This document details how each clustering function (`netclu_*`, `nhclu_*`, `hclu_*`, and `cut_tree`) fills the output slots, organized by slot rather than algorithm type. This structure helps identify:
- **Universal slots**: slots that can be used across all algorithm types for post-clustering functions
- **Harmonizable slots**: slots that could be standardized across algorithms
- **Algorithm-specific slots**: slots unique to certain algorithms

This document was generated by a LLM (Claude Sonnet 4.5), so apply all necessary caution when investigating contents. 

---

## Output Structure Overview

All clustering functions return a `list` of class `bioregion.clusters` with **five standard slots**:

1. **`name`**: Character string with algorithm name
2. **`args`**: List of user-provided arguments
3. **`inputs`**: List of clustering process characteristics
4. **`algorithm`**: List of algorithm-specific objects
5. **`clusters`**: Data.frame with clustering results

Additional slot in some cases:
6. **`cluster_info`**: Data.frame with partition metadata (all functions except when no cut is performed)

---

## SLOT 1: `name`

**Purpose**: Identifies the algorithm used  
**Type**: Character string  
**Universal**: ✅ Yes - present in all functions  
**Harmonization**: ✅ Already harmonized

### Content by Function:

| Function Type | Functions | Content |
|--------------|-----------|---------|
| **Network clustering** | `netclu_beckett` | `"netclu_beckett"` |
| | `netclu_greedy` | `"netclu_greedy"` |
| | `netclu_infomap` | `"netclu_infomap"` |
| | `netclu_labelprop` | `"netclu_labelprop"` |
| | `netclu_leadingeigen` | `"netclu_leadingeigen"` |
| | `netclu_leiden` | `"netclu_leiden"` |
| | `netclu_louvain` | `"netclu_louvain"` |
| | `netclu_oslom` | `"netclu_oslom"` |
| | `netclu_walktrap` | `"netclu_walktrap"` |
| **Non-hierarchical** | `nhclu_affprop` | `"nhclu_affprop"` |
| | `nhclu_clara` | `"nhclu_clara"` |
| | `nhclu_clarans` | `"nhclu_clarans"` |
| | `nhclu_dbscan` | `"nhclu_dbscan"` |
| | `nhclu_kmeans` | `"nhclu_kmeans"` |
| | `nhclu_pam` | `"nhclu_pam"` |
| **Hierarchical** | `hclu_hierarclust` | `"hclu_hierarclust"` |
| | `hclu_diana` | `"hclu_diana"` |
| | `hclu_optics` | `"hclu_optics"` |
| **Utility** | `cut_tree` | Updates existing object's name |

---

## SLOT 2: `args`

**Purpose**: Stores user-provided arguments  
**Type**: Named list  
**Universal**: ✅ Yes - present in all functions  
**Harmonization**: ⚠️ Partially harmonized (some common args, many algorithm-specific)

### Common Arguments (Present in Multiple Functions):

#### 2.1 Input Data Arguments
- **`index`**: Column name/number for weight/dissimilarity (ALL functions except netclu_beckett seed-only)
- **`weight`**: Boolean for considering weights (ALL netclu_*)
- **`cut_weight`**: Minimal weight threshold (ALL netclu_*)

#### 2.2 Random Seed
- **`seed`**: RNG seed
  - Present: All netclu_* (except beckett, greedy, leadingeigen, walktrap), nhclu_affprop, nhclu_clara, nhclu_clarans, nhclu_kmeans, nhclu_pam
  - Absent: netclu_beckett, netclu_greedy, netclu_leadingeigen, netclu_walktrap, nhclu_dbscan, all hclu_*

#### 2.3 Clustering Parameters
- **`n_clust`**: Number of clusters
  - Present: All nhclu_* (except dbscan), all hclu_*, cut_tree
  - Absent: All netclu_*

#### 2.4 Bipartite Network Arguments
- **`bipartite`**: Boolean for bipartite networks
  - Present: netclu_greedy, netclu_infomap, netclu_labelprop, netclu_leadingeigen, netclu_leiden, netclu_louvain, netclu_oslom, netclu_walktrap
  - Absent: netclu_beckett (implicitly bipartite), all nhclu_*, all hclu_*
- **`site_col`**: Column for site nodes
- **`species_col`**: Column for species nodes
- **`return_node_type`**: Which node types to return ("site", "species", "both")

#### 2.5 Algorithm Output Control
- **`algorithm_in_output`**: Boolean to include original algorithm output
  - Present: ALL netclu_*, ALL nhclu_*, but NOT in hclu_*

### Algorithm-Specific Arguments:

#### Network Clustering (netclu_*)

**netclu_beckett**:
- `forceLPA`: Boolean for pure LPA algorithm

**netclu_infomap**:
- `nbmod`: Preferred number of modules (penalty)
- `markovtime`: Link flow scaling parameter
- `numtrials`: Number of trials
- `twolevel`: Boolean for two-level partition
- `show_hierarchy`: Boolean for hierarchical output
- `directed`: Boolean for directed networks
- `bipartite_version`: Boolean for bipartite Infomap version
- `version`: Infomap version string
- `binpath`: Path to binary folder
- `check_install`: Boolean to check installation
- `path_temp`: Path to temp folder
- `delete_temp`: Boolean to remove temp folder

**netclu_leiden**:
- `objective_function`: "CPM" or "modularity"
- `resolution_parameter`: Resolution parameter
- `beta`: Randomness parameter
- `n_iterations`: Number of iterations
- `vertex_weights`: Vertex weights vector

**netclu_louvain**:
- `lang`: "igraph" or "cpp"
- `resolution`: Modularity resolution
- `q`: Quality function (cpp version)
- `c`: Owsinski-Zadrozny parameter
- `k`: Shi-Malik kappa_min
- `binpath`: Path to binary folder (cpp)
- `check_install`: Boolean to check installation (cpp)
- `path_temp`: Path to temp folder (cpp)
- `delete_temp`: Boolean to remove temp folder (cpp)

**netclu_oslom**:
- `reassign`: Method for overlapping nodes ("no", "random", "simil")
- `r`: Number of runs (first level)
- `hr`: Number of runs (higher levels)
- `t`: P-value threshold
- `cp`: Resolution parameter
- `directed`: Boolean for directed networks
- `binpath`: Path to binary folder
- `check_install`: Boolean to check installation
- `path_temp`: Path to temp folder
- `delete_temp`: Boolean to remove temp folder

**netclu_walktrap**:
- `steps`: Length of random walks

#### Non-Hierarchical Clustering (nhclu_*)

**nhclu_affprop**:
- `p`: Input preference(s)
- `q`: Quantile for preference initialization
- `maxits`: Maximum iterations
- `convits`: Convergence iterations
- `lam`: Damping factor
- `details`: Boolean for detailed info
- `nonoise`: Boolean to disable noise
- `K`: Desired number of clusters (apclusterK)
- `prc`: Percentage tolerance for K
- `bimaxit`: Max bisection steps
- `exact`: Boolean for exact preference range

**nhclu_clara**:
- `maxiter`: Maximum iterations
- `initializer`: "BUILD" or "LAB"
- `fasttol`: Fast swapping tolerance
- `numsamples`: Number of samples
- `sampling`: Sampling rate
- `independent`: Boolean for medoid exclusion

**nhclu_clarans**:
- `numlocal`: Number of local searches
- `maxneighbor`: Max neighbors per search

**nhclu_dbscan**:
- `minPts`: Minimum points for dense region
- `eps`: Similarity threshold (can be vector)
- `plot`: Boolean to show k-NN distance plot
- `...`: Additional args to dbscan()

**nhclu_kmeans**:
- `iter_max`: Maximum iterations
- `nstart`: Number of random starts
- `algorithm`: K-means algorithm ("Hartigan-Wong", "Lloyd", "Forgy", "MacQueen")

**nhclu_pam**:
- `variant`: PAM variant ("original", "o_1", "o_2", "f_3", "f_4", "f_5", "faster")
- `nstart`: Number of random starts
- `cluster_only`: Boolean for cluster-only output
- `...`: Additional args to pam()

#### Hierarchical Clustering (hclu_*)

**hclu_hierarclust**:
- `method`: Linkage method ("ward.D", "ward.D2", "single", "complete", "average", "mcquitty", "median", "centroid")
- `randomize`: Boolean for matrix randomization
- `n_runs`: Number of randomization trials
- `keep_trials`: "no", "all", or "metrics"
- `optimal_tree_method`: "iterative_consensus_tree", "best", or "consensus"
- `cut_height`: Height(s) for cutting tree
- `find_h`: Boolean to find cutting height
- `h_max`: Maximum tree height
- `h_min`: Minimum tree height
- `consensus_p`: Consensus threshold proportion
- `show_hierarchy`: Boolean for hierarchical clusters
- `verbose`: Boolean for progress messages
- `dynamic_tree_cut`: Boolean for dynamic cutting (added internally)

**hclu_diana**:
- `cut_height`: Height(s) for cutting tree
- `find_h`: Boolean to find cutting height
- `h_max`: Maximum tree height
- `h_min`: Minimum tree height
- `dynamic_tree_cut`: Boolean for dynamic cutting (added internally)

**hclu_optics**:
- `minPts`: Minimum points for dense region
- `eps`: Upper limit of epsilon neighborhood
- `xi`: Steepness threshold
- `minimum`: Boolean to retain only leaf clusters
- `show_hierarchy`: Boolean for hierarchical output
- `...`: Additional args to optics()

**cut_tree**:
- All arguments from the original tree object, plus:
- `n_clust`: Number of clusters (added/updated)
- `cut_height`: Cutting height(s) (added/updated)
- `find_h`: Boolean to find cutting height
- `h_max`: Maximum tree height
- `h_min`: Minimum tree height
- `dynamic_tree_cut`: Boolean for dynamic cutting
- `dynamic_method`: "tree" or "hybrid"
- `dynamic_minClusterSize`: Minimum cluster size
- `show_hierarchy`: Boolean for hierarchical output

### Harmonization Opportunities:

**Could be standardized**:
1. Binary/external program arguments (when applicable):
   - `binpath`, `check_install`, `path_temp`, `delete_temp`
   
2. Iterative algorithm controls:
   - `maxiter`/`maxits` → standardize to `max_iterations`
   - `nstart`/`numtrials`/`n_runs` → standardize to `n_trials`

3. Cluster size controls:
   - `minPts`, `dynamic_minClusterSize` → standardize to `min_cluster_size` where conceptually similar

---

## SLOT 3: `inputs`

**Purpose**: Describes characteristics of the clustering process  
**Type**: Named list  
**Universal**: ✅ Yes - present in all functions  
**Harmonization**: ✅ Well harmonized with standard fields

### Standard Fields (Present in ALL Functions):

```
├── bipartite: Boolean
├── weight: Boolean
├── pairwise: Boolean
├── pairwise_metric: Character (metric name) or NA
├── dissimilarity: Boolean
├── nb_sites: Integer
└── hierarchical: Boolean
```

### Field Details:

#### 3.1 `bipartite`
- **Type**: Boolean
- **Content**:
  - `TRUE`: For bipartite networks in netclu_* when `bipartite = TRUE` or netclu_beckett (always)
  - `FALSE`: All nhclu_*, all hclu_*, unipartite netclu_*
- **Universal**: ✅ Yes

#### 3.2 `weight`
- **Type**: Boolean
- **Content**:
  - `TRUE`: When weights are used
  - `FALSE`: When unweighted
- **Universal**: ✅ Yes
- **Notes**: Always `TRUE` for nhclu_* and hclu_* (dissimilarity-based)

#### 3.3 `pairwise`
- **Type**: Boolean
- **Content**:
  - `TRUE`: For similarity/dissimilarity matrices (nhclu_*, hclu_*, non-bipartite netclu_*)
  - `FALSE`: For bipartite networks (netclu_* when `bipartite = TRUE`)
- **Universal**: ✅ Yes

#### 3.4 `pairwise_metric`
- **Type**: Character or NA
- **Content**:
  - Character string: Name of similarity/dissimilarity metric used
  - `NA`: For bipartite networks or when not applicable
- **Universal**: ✅ Yes
- **Determination**:
  ```r
  # Standard pattern across functions:
  ifelse(!isbip & weight, 
         ifelse(is.numeric(index), names(net)[3], index), 
         NA)
  ```

#### 3.5 `dissimilarity`
- **Type**: Boolean
- **Content**:
  - `TRUE`: For dissimilarity-based clustering (all nhclu_*, all hclu_*)
  - `FALSE`: For network clustering (all netclu_*)
- **Universal**: ✅ Yes

#### 3.6 `nb_sites`
- **Type**: Integer
- **Content**: Number of sites/nodes in the dataset
- **Universal**: ✅ Yes
- **Source**:
  - netclu_*: Counted from unique nodes in network
  - nhclu_*/hclu_*: `attr(dist.obj, "Size")`

#### 3.7 `hierarchical`
- **Type**: Boolean
- **Content**:
  - `TRUE`: When hierarchical structure is present/returned
  - `FALSE`: For non-hierarchical clustering
- **Universal**: ✅ Yes
- **Notes**:
  - Always `FALSE` for netclu_* (except netclu_infomap with `show_hierarchy = TRUE`)
  - Always `FALSE` for nhclu_*
  - Can be `TRUE` or `FALSE` for hclu_* depending on whether tree is cut and `show_hierarchy`
  - Updated by `cut_tree` based on number of partition columns

#### 3.8 `data_type`
- **Type**: Character
- **Content**:
  - `"occurrence"`: Original co-occurrence data was presence/absence (binary)
  - `"abundance"`: Original co-occurrence data was quantitative/abundance
  - `"unknown"`: Cannot determine (e.g., user-provided dist object, Euclidean metric, custom formula)
- **Universal**: ✅ Yes (added in version 1.2.0.9000)
- **Determination**:
  - **Bipartite networks (netclu_* with bipartite=TRUE)**: Based on `weight` argument
    - `weight = TRUE` → `"abundance"`
    - `weight = FALSE` → `"occurrence"`
  - **Unipartite networks (netclu_* with bipartite=FALSE, all nhclu_*, all hclu_*)**: Based on `pairwise_metric` used in similarity/dissimilarity calculation
    - Occurrence metrics (abc-based): Jaccard, Jaccardturn, Sorensen, Simpson, abc, beta.sim, beta.sne, beta.sor, beta.jtu, beta.jne, beta.jac → `"occurrence"`
    - Abundance metrics (ABC-based): Bray, Brayturn, ABC, beta.bray.bal, beta.bray.gra, beta.bray, beta.ruz.bal, beta.ruz.gra, beta.ruz → `"abundance"`
    - Euclidean or custom formulas → `"unknown"`
  - **User-provided dist objects**: `"unknown"` (no way to determine original data type)
- **Usage**: This field enables `site_species_metrics()` to automatically determine correct weight handling for computing contribution metrics
- **Notes**: 
  - Preserved by `cut_tree()` when cutting hierarchical trees
  - For old bioregion.clusters objects created before this field was added, it will be absent (NULL)

### Harmonization Status:

**✅ Excellent harmonization** - This slot is consistent across all functions with:
- Identical field names
- Consistent Boolean typing
- Predictable content
- Clear semantics

**No harmonization needed** - This slot can be reliably used in post-clustering functions to determine:
- Input data type (`bipartite`, `pairwise`, `dissimilarity`)
- Whether weights were used (`weight`)
- What metric was used (`pairwise_metric`)
- Dataset size (`nb_sites`)
- Whether output is hierarchical (`hierarchical`)

---

## SLOT 4: `algorithm`

**Purpose**: Stores algorithm-specific objects and outputs  
**Type**: Named list  
**Universal**: ✅ Yes - present in all functions  
**Harmonization**: ❌ Highly algorithm-specific, difficult to harmonize

### Content Structure by Algorithm Type:

#### 4.1 Network Clustering (netclu_*)

**Most netclu_* (when `algorithm_in_output = TRUE`)**:
- **Content**: Original igraph community object
- **Functions**: netclu_greedy, netclu_labelprop, netclu_leadingeigen, netclu_leiden, netclu_louvain (igraph), netclu_walktrap
- **Structure**: S3 object from igraph::cluster_* functions
  - Contains: `$names`, `$membership`, `$modularity`, `$algorithm`, etc.
  - Varies by specific igraph function

**netclu_beckett (when `algorithm_in_output = TRUE`)**:
- **Content**: S4 object from bipartite::computeModules
- **Structure**: `@modules` slot with module assignments

**netclu_infomap**:
```
algorithm/
├── cmd: Character (command line used)
├── version: Character (Infomap version)
└── web: Character (Infomap's GitHub URL)
```
- Note: No original Infomap object stored (command-line tool)

**netclu_louvain (cpp)**:
```
algorithm/
├── cmd: Character (command line used)
├── version: Character (Louvain version)
└── web: Character (Louvain's website)
```

**netclu_oslom**:
```
algorithm/
├── cmd: Character (command line used)
├── version: Character (OSLOM version)
└── web: Character (OSLOM's website)
```

**When `algorithm_in_output = FALSE`**:
- **Content**: `NA`
- **Functions**: All netclu_* support this option

#### 4.2 Non-Hierarchical Clustering (nhclu_*)

**nhclu_affprop (when `algorithm_in_output = TRUE`)**:
- **Content**: S4 APResult object from apcluster::apcluster or apcluster::apclusterK
- **Structure**: Complex S4 object with slots:
  - `@clusters`: Named list of cluster members
  - `@exemplars`: Exemplar indices
  - `@idx`: Cluster assignments
  - Additional statistics

**nhclu_clara (when `algorithm_in_output = TRUE`)**:
- **Content**: Named list of S4 pam objects
- **Structure**:
  ```
  algorithm/
  ├── K_n1: S4 pam object from fastkmedoids::fastclara
  ├── K_n2: S4 pam object
  └── ...
  ```
  Each pam object contains: `@assignment`, `@medoids`, `@cost`, etc.

**nhclu_clarans (when `algorithm_in_output = TRUE`)**:
- **Content**: Named list of S4 pam objects
- **Structure**: Same as nhclu_clara
  ```
  algorithm/
  ├── K_n1: S4 pam object from fastkmedoids::fastclarans
  ├── K_n2: S4 pam object
  └── ...
  ```

**nhclu_dbscan (when `algorithm_in_output = TRUE`)**:
- **Content**: Named list of dbscan objects
- **Structure**:
  ```
  algorithm/
  ├── dbscan_minPts5_eps0.1: dbscan object
  ├── dbscan_minPts5_eps0.2: dbscan object
  └── ...
  ```
  Each contains: `$cluster`, `$eps`, `$minPts`

**nhclu_kmeans (when `algorithm_in_output = TRUE`)**:
- **Content**: Named list of kmeans objects
- **Structure**:
  ```
  algorithm/
  ├── K_n1: kmeans object from stats::kmeans
  ├── K_n2: kmeans object
  └── ...
  ```
  Each contains: `$cluster`, `$centers`, `$totss`, `$withinss`, etc.
- **Additional**: `$clustering_algorithms$pcoa` - PCoA transformation object

**nhclu_pam (when `algorithm_in_output = TRUE`)**:
- **Content**: Named list of pam objects
- **Structure**:
  ```
  algorithm/
  ├── K_n1: pam object from cluster::pam
  ├── K_n2: pam object
  └── ...
  ```
  Each contains: `$clustering`, `$medoids`, `$silinfo`, etc.

**When `algorithm_in_output = FALSE`**:
- **Content**: `NA`
- **Functions**: All nhclu_* support this option

#### 4.3 Hierarchical Clustering (hclu_*)

**hclu_hierarclust**:
```
algorithm/
├── trials: List or Character
│   ├── "Trials not stored in output" (if keep_trials = "no")
│   └── List of trial objects (if keep_trials = "all" or "metrics")
│       ├── $dist.matrix: dist object (if keep_trials = "all")
│       ├── $hierartree: hclust object (if keep_trials = "all")
│       ├── $cophcor: Numeric (cophenetic correlation)
│       └── $msd: Numeric (mean squared difference)
├── final.tree: hclust object
├── final.tree.coph.cor: Numeric (cophenetic correlation coefficient)
├── final.tree.msd: Numeric (mean squared difference)
├── output_n_clust: Integer vector (actual cluster numbers, if tree cut)
└── output_cut_height: Numeric vector (actual cut heights, if tree cut)
```

**hclu_diana**:
```
algorithm/
├── final.tree: diana object (inherits from hclust)
├── final.tree.coph.cor: Numeric (cophenetic correlation coefficient)
├── final.tree.msd: Numeric (mean squared difference)
├── output_n_clust: Integer vector (actual cluster numbers, if tree cut)
└── output_cut_height: Numeric vector (actual cut heights, if tree cut)
```

**hclu_optics (when `algorithm_in_output = TRUE`)**:
- **Content**: optics object from dbscan::optics with Xi extraction
- **Structure**: Modified optics object with:
  - `$cluster`: Cluster assignments
  - `$clusters_xi`: Xi-based cluster hierarchy
  - `$order`: Ordering of points
  - `$reachdist`: Reachability distances

**When `algorithm_in_output = FALSE` (hclu_optics only)**:
- **Content**: `NA`

### Common Hierarchical Elements (hclu_hierarclust, hclu_diana):

**Tree Evaluation Metrics** (present when tree is built):
- `final.tree.coph.cor`: Cophenetic correlation coefficient
- `final.tree.msd`: Mean squared difference
- Note: These use the internal `tree_eval()` function

**Cut Information** (present when tree is cut):
- `output_n_clust`: Actual number of clusters achieved
- `output_cut_height`: Actual cutting height(s) used

### Algorithm-Specific vs. Universal:

**Algorithm-specific** (difficult to use universally):
- Original algorithm objects (when `algorithm_in_output = TRUE`)
- External program metadata (cmd, version, web)
- Trial information (hclu_hierarclust)

**Potentially universal** (could be used in post-processing):
- Tree objects: `final.tree` (hclu_hierarclust, hclu_diana)
- Tree quality metrics: `final.tree.coph.cor`, `final.tree.msd`
- Cut information: `output_n_clust`, `output_cut_height`

### Harmonization Opportunities:

**Could be standardized for hierarchical methods**:
1. Tree storage:
   - Always use `$tree` or `$final.tree` for hierarchical tree object
   
2. Quality metrics:
   - Standardize to `$tree.cophenetic.cor`, `$tree.msd`
   
3. Cut information:
   - Standardize to `$cut.n_clust`, `$cut.height`

**Not practical to harmonize**:
- Original algorithm outputs (too diverse)
- External program metadata (only relevant for those algorithms)

---

## SLOT 5: `clusters`

**Purpose**: Contains the actual clustering results  
**Type**: Data.frame  
**Universal**: ✅ Yes - present in all functions (or NA if tree not cut)  
**Harmonization**: ✅ Well harmonized

### Standard Structure:

```
clusters [data.frame]
├── Column 1: Site/Node IDs (character)
├── Column 2+: Cluster assignments (character or integer)
└── Attributes: node_type (for bipartite networks only)
```

### Column 1: Site/Node Identifiers

**Column Name**: Variable (typically "name", "ID", "Site", "site")
- **netclu_***: Usually "ID"
- **nhclu_***: Usually "name"
- **hclu_***: Usually "name" or "site"
- **Content**: Character vector of site/node names

### Column 2+: Cluster Assignments

**Single Partition Functions**:

**netclu_* (non-hierarchical)**:
- **Column name**: "K_n" where n = number of clusters
- **Content**: Integer cluster IDs
- **NA handling**: 
  - netclu_oslom: NA for overlapping nodes (if `reassign = "no"`)
  - May have multiple columns (_semel, _bis, _ter) for overlapping modules

**nhclu_***:
- **Column name**: "K_n" where n = requested number of clusters
- **Content**: Integer cluster IDs
- **NA handling**: 
  - nhclu_dbscan: NA for noise points (cluster 0 converted to NA)
- **Multiple columns**: When multiple `n_clust` values provided

**netclu_infomap (with hierarchy)**:
- **Column names**: "V2", "V3", "V4", ... (hierarchical levels)
- **Content**: Hierarchical cluster IDs (integer or formatted strings)
- **Hierarchy**: From coarse (V2) to fine (Vn)

**hclu_optics (with hierarchy)**:
- **Column names**: "lvl1", "lvl2", "lvl3", ...
- **Content**: Hierarchical cluster IDs
- **NA handling**: NA for sites not in clusters at that level

**Hierarchical Clustering (when cut)**:

**Single cut**:
- **Column name**: 
  - "K_n" (if cut by `n_clust`)
  - "h_X" (if cut by `cut_height`)
  - "optics" (for hclu_optics without hierarchy)
- **Content**: Character cluster IDs (after knbclu reordering)

**Multiple cuts**:
- **Column names**: Multiple "K_n" or "h_X" columns
- **Content**: Character cluster IDs for each partition
- **Order**: 
  - By increasing n_clust (e.g., K_2, K_5, K_10)
  - By decreasing cut_height (e.g., h_0.25, h_0.15, h_0.05)

**Dynamic tree cut**:
- **Column name**: "cluster"
- **Content**: Integer cluster IDs
- **NA handling**: NA for unassigned sites

### Special Attributes:

**`node_type` (Bipartite networks only)**:
- **Present in**: netclu_* when `bipartite = TRUE`
- **Type**: Character vector attribute
- **Values**: "site" or "species"
- **Length**: Same as number of rows in clusters
- **Usage**: Identifies which nodes are sites vs. species
- **Access**: `attributes(clusters)$node_type`
- **Filtering**: Used when `return_node_type` != "both"

### Data Processing:

**All functions use `knbclu()` for standardization**:
- Reorders cluster IDs for consistency
- Ensures character typing (typically)
- Handles NA values appropriately

### NA Handling:

| Function | NA Meaning | NA Handling |
|----------|-----------|-------------|
| netclu_oslom | Overlapping assignment | Multiple columns (_semel, _bis, _ter) |
| nhclu_dbscan | Noise points (originally 0) | Converted to NA |
| hclu_optics | Not in cluster at level | NA at that hierarchical level |
| cut_tree (dynamic) | Unassigned sites | NA in cluster column |
| All others | Not assigned | Rare, but possible |

### Content When Tree Not Cut:

- **Value**: `NA`
- **Functions**: hclu_hierarclust, hclu_diana (when no `n_clust` or `cut_height` specified)

### Harmonization Status:

**✅ Well harmonized**:
- Consistent data.frame structure
- First column always site/node IDs
- Subsequent columns for cluster assignments
- Standardized naming conventions for partitions
- Consistent NA handling semantics

**⚠️ Minor inconsistencies**:
- Column 1 name varies ("ID", "name", "Site", "site")
- Cluster ID type varies (character vs. integer)
- Could standardize to always use "site" and character cluster IDs

**Universal use**: Yes, this slot can be reliably used in post-clustering functions by:
- Assuming first column is site IDs
- Treating remaining columns as partitions
- Handling NA values as unassigned/noise

---

## SLOT 6: `cluster_info`

**Purpose**: Provides metadata about each partition  
**Type**: Data.frame  
**Universal**: ⚠️ No - only present when clusters are generated  
**Harmonization**: ✅ Well harmonized when present

### Standard Fields (Present When Slot Exists):

```
cluster_info [data.frame]
├── partition_name: Character (column name from clusters)
└── n_clust: Integer (actual number of clusters)
```

### When Present:

- **ALL functions that generate clusters**: netclu_*, nhclu_*, cut hclu_*
- **NOT present**: hclu_hierarclust, hclu_diana when tree not cut (clusters = NA)

### Field Details:

#### 6.1 `partition_name`
- **Type**: Character vector
- **Content**: Column names from `clusters` (excluding first column)
- **Examples**: "K_5", "h_0.15", "optics", "V2", "lvl1"
- **Universal**: ✅ Yes (when slot exists)

#### 6.2 `n_clust`
- **Type**: Integer vector
- **Content**: Number of unique clusters in each partition (excluding NA)
- **Calculation**: `length(unique(x[!is.na(x)]))`
- **Universal**: ✅ Yes (when slot exists)

### Additional Fields (Algorithm-Specific):

#### hclu_hierarclust / hclu_diana (when tree is cut):
- **`requested_n_clust`**: Integer - originally requested number of clusters
- **`output_cut_height`**: Numeric - actual cutting height used (if `find_h = TRUE`)
- **`requested_cut_height`**: Numeric - originally requested cutting height

#### nhclu_dbscan:
- **`minPts`**: Integer - minPts value used for that partition
- **`eps`**: Numeric - eps value used for that partition

#### hclu_optics (with hierarchy):
- **`hierarchical_level`**: Integer - level in hierarchy (1, 2, 3, ...)

### Example Structures:

**nhclu_pam** (multiple k):
```
  partition_name  n_clust
1           K_2        2
2           K_5        5
3          K_10       10
```

**nhclu_dbscan** (multiple parameters):
```
  partition_name  n_clust  minPts   eps
1  dbscan_minPts5_eps0.1       3       5  0.10
2  dbscan_minPts5_eps0.15      2       5  0.15
3  dbscan_minPts10_eps0.1      4      10  0.10
```

**hclu_hierarclust** (cut by n_clust with find_h):
```
  partition_name  n_clust  requested_n_clust  output_cut_height
1           K_5        5                  5             0.1234
2          K_10       10                 10             0.0567
```

**hclu_optics** (with hierarchy):
```
  partition_name  n_clust  hierarchical_level
1           lvl1        3                   1
2           lvl2        7                   2
3           lvl3       12                   3
```

### Harmonization Status:

**✅ Well harmonized** for core fields:
- `partition_name` and `n_clust` are universal
- Consistent structure and naming

**Algorithm-specific extensions** are appropriate:
- Additional fields provide context for the specific method
- Do not interfere with universal fields
- Could be standardized further if needed (e.g., always include request vs. achieved values)

### Universal Use:

Yes, this slot can be reliably used in post-clustering functions to:
- Enumerate available partitions (`partition_name`)
- Know cluster counts (`n_clust`)
- Iterate over multiple partitions
- Select partitions by criteria (e.g., n_clust in a range)

---

## Summary: Slot Universality and Harmonization

### Universal Slots (Safe for Post-Clustering Functions):

| Slot | Universal? | Harmonized? | Can Use For | Notes |
|------|-----------|-------------|-------------|-------|
| **`name`** | ✅ Yes | ✅ Yes | Algorithm identification | Perfect |
| **`args`** | ✅ Yes | ⚠️ Partial | Parameter retrieval | Many algorithm-specific args |
| **`inputs`** | ✅ Yes | ✅ Yes | Data type identification | Perfect - highly recommended |
| **`algorithm`** | ✅ Yes | ❌ No | Algorithm-specific processing | Highly variable content |
| **`clusters`** | ⚠️ Mostly | ✅ Yes | Accessing cluster assignments | NA when tree not cut |
| **`cluster_info`** | ⚠️ Mostly | ✅ Yes | Partition metadata | Only when clusters exist |

### Recommended for Universal Post-Clustering Functions:

1. **`inputs`** - Most reliable for determining:
   - Input data type
   - Whether analysis was hierarchical
   - Number of sites
   - Metric used

2. **`clusters`** - For accessing results:
   - First column = site IDs
   - Other columns = partitions
   - Handle NA appropriately

3. **`cluster_info`** - For partition metadata:
   - Check existence first
   - Use `partition_name` and `n_clust`

### Harmonization Recommendations:

#### High Priority (Would Improve Universal Use):

1. **`clusters` first column name**: Standardize to "site"

2. **`clusters` cluster IDs**: Always use character type

3. **Tree storage in `algorithm`** (for hclu_*):
   - Standardize to `$tree` (not `$final.tree`)
   - Always include cophenetic correlation as `$tree.cophcor`

4. **Cut information in `algorithm`** (for hclu_*):
   - Standardize to `$cut.n_clust` and `$cut.height`

#### Medium Priority:

5. **Iteration controls in `args`**:
   - Standardize `maxiter`/`maxits` → `max_iterations`
   - Standardize `nstart`/`numtrials`/`n_runs` → `n_trials`

6. **Binary program args in `args`**:
   - When present, always use: `binpath`, `check_install`, `path_temp`, `delete_temp`

#### Low Priority (Minor Improvements):

7. **`algorithm_in_output` in `args`**:
   - Extend to hclu_* functions for consistency

8. **`cluster_info` extensions**:
   - Consider always including "requested" vs. "achieved" columns for clarity

---

## Algorithm-Specific Features That Cannot Be Harmonized:

### Network Clustering:
- Bipartite network handling (`bipartite`, `site_col`, `species_col`, `return_node_type`, `node_type` attribute)
- Algorithm-specific parameters (resolution, random walk length, quality functions, etc.)
- External binary interfaces (Infomap, OSLOM, Louvain cpp)
- Overlapping community handling (OSLOM)

### Non-Hierarchical:
- Diverse algorithm outputs (PAM medoids, k-means centers, DBSCAN noise, etc.)
- Algorithm-specific tuning (damping, sampling, initialization methods)
- Multiple partition generation methods

### Hierarchical:
- Tree generation methods (randomization, consensus, IHCT)
- Tree evaluation metrics (cophenetic correlation, MSD)
- Cutting strategies (height-based, dynamic)
- Trial storage (for randomization-based methods)

These features are appropriately algorithm-specific and should remain so.

---

## Conclusions and Recommendations:

### For Post-Clustering Function Development:

1. **Always check `inputs$hierarchical`** before processing
2. **Use `inputs` slot** to determine data characteristics
3. **Access `clusters`** assuming first column is sites, rest are partitions
4. **Check `cluster_info` existence** before using
5. **Handle NA values** in clusters appropriately
6. **Don't rely on specific column names** in clusters (use position)
7. **Don't rely on `algorithm` slot content** for universal operations

### For Harmonization Implementation:

**Phase 1** (Breaking changes - require careful migration):
- Standardize `clusters` first column to "site"
- Standardize tree storage names in hclu_*

**Phase 2** (Non-breaking additions):
- Extend `algorithm_in_output` to hclu_*
- Add standardized cut information fields to hclu_*

**Phase 3** (Deprecation path needed):
- Deprecate old parameter names (maxiter → max_iterations, etc.)
- Provide transition period with warnings

### Testing Requirements:

Any changes to output structure should verify:
1. Backward compatibility with existing analysis scripts
2. Consistency across all algorithm types
3. Proper handling of edge cases (NA, empty clusters, etc.)
4. Documentation updates for all affected functions
5. Update examples and vignettes

---

*Document generated: October 2025*  
*Functions analyzed: 18 clustering functions + cut_tree*  
*Purpose: Inform harmonization efforts and post-clustering function development*
