% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nhclu_affprop.R
\name{nhclu_affprop}
\alias{nhclu_affprop}
\title{Non hierarchical clustering: Affinity Propagation}
\usage{
nhclu_affprop(
  similarity,
  index = names(similarity)[3],
  p = NA,
  q = NA,
  maxits = 1000,
  convits = 100,
  lam = 0.9,
  details = FALSE,
  nonoise = FALSE,
  seed = NULL,
  K = NULL,
  prc = NULL,
  bimaxit = NULL,
  exact = NULL,
  algorithm_in_output = TRUE
)
}
\arguments{
\item{similarity}{the output object from \code{\link[=similarity]{similarity()}} or
\code{\link[=dissimilarity_to_similarity]{dissimilarity_to_similarity()}}, or a \code{dist} object. If a \code{data.frame} is
used, the first two columns represent pairs of sites (or any pair of nodes),
and the next column(s) are the dissimilarity indices.}

\item{index}{name or number of the similarity column to use. By default,
the third column name of \code{similarity} is used.}

\item{p}{input preference; can be a vector that specifies individual
preferences for each data point. If scalar, the same value is used for all
data points. If NA, exemplar preferences are initialized according to the
distribution of non-Inf values in the similarity matrix. How this is done is
controlled by the parameter q.}

\item{q}{if \code{p = NA}, exemplar preferences are initialized according to the
distribution of non-Inf values in the similarity matrix. If \code{p = NA}, exemplar
preferences are set to the median of non-Inf values in the similarity
matrix. If q is a value between 0 and 1, the sample quantile with
threshold q is used, whereas q=0.5 again results in the median.}

\item{maxits}{maximal number of iterations that should be executed}

\item{convits}{the algorithm terminates if the examplars have not changed
for convits iterations.}

\item{lam}{damping factor; should be a value in the range [0.5, 1);
higher values correspond to heavy damping which may be needed if
oscillations occur.}

\item{details}{if TRUE, more detailed information about the algorithm's
progress is stored in the output object.}

\item{nonoise}{small amount of noise added to the similarity object to
prevent degenerate cases; disabled when set to \code{TRUE}.}

\item{seed}{seed of the random number generator.}

\item{K}{desired number of clusters. If not null, then the function
\link[apcluster:apclusterK-methods]{apcluster} is called.}

\item{prc}{argument needed when K is not null. The algorithm stops if the
number of clusters does not deviate more than prc percent from desired value
K; set to 0 if you want to have exactly K clusters.}

\item{bimaxit}{argument needed when K is not null. maximum number of
bisection steps to perform; note that no warning is issued if the number of
clusters is still not in the desired range.}

\item{exact}{flag indicating whether or not to compute the initial
preference range exactly.}

\item{algorithm_in_output}{a \code{boolean} indicating if the original output
of \link[apcluster:apcluster-methods]{apcluster} should be returned in the output
(\code{TRUE} by default, see Value).}
}
\value{
A \code{list} of class \code{bioregion.clusters} with five slots:
\enumerate{
\item{\strong{name}: \code{character} containing the name of the algorithm}
\item{\strong{args}: \code{list} of input arguments as provided by the user}
\item{\strong{inputs}: \code{list} of characteristics of the clustering process}
\item{\strong{algorithm}: \code{list} of all objects associated with the
clustering procedure, such as original cluster objects}
\item{\strong{clusters}: \code{data.frame} containing the clustering results}}

In the \code{algorithm} slot, if \code{algorithm_in_output = TRUE}, users can
find the output of \link[apcluster:apcluster-methods]{apcluster}.
}
\description{
This function performs non hierarchical
clustering on the Affinity Propagation algorithm.
}
\details{
Based on \href{https://cran.r-project.org/package=apcluster}{apcluster}
package (\link[apcluster:apcluster-methods]{apcluster}).
}
\examples{
comat_1 <- matrix(sample(0:1000, size = 10*12, replace = TRUE,
prob = 1/1:1001), 10, 12)
rownames(comat_1) <- paste0("Site", 1:10)
colnames(comat_1) <- paste0("Species", 1:12)
comat_1 <- cbind(comat_1,
                 matrix(0, 10, 8,
                        dimnames = list(paste0("Site", 1:10),
                                        paste0("Species", 13:20))))

comat_2 <- matrix(sample(0:1000, size = 10*12, replace = TRUE,
                         prob = 1/1:1001), 10, 12)
rownames(comat_2) <- paste0("Site", 11:20)
colnames(comat_2) <- paste0("Species", 9:20)
comat_2 <- cbind(matrix(0, 10, 8,
                        dimnames = list(paste0("Site", 11:20),
                                        paste0("Species", 1:8))),
                 comat_2)

comat <- rbind(comat_1, comat_2)

dissim <- dissimilarity(comat, metric = "Simpson")
sim <- dissimilarity_to_similarity(dissim)

clust1 <- nhclu_affprop(sim)

clust2 <- nhclu_affprop(sim, q = 1)

# Fixed number of clusters
clust3 <- nhclu_affprop(sim, K = 2, prc = 10, bimaxit = 20, exact = FALSE)

}
\references{
Frey B & Dueck D (2007) Clustering by Passing Messages Between Data Points.
\emph{Science}, 315, 972-976.
}
\seealso{
\link{nhclu_pam}
}
\author{
Pierre Denelle (\email{pierre.denelle@gmail.com}) \cr
Boris Leroy (\email{leroy.boris@gmail.com}) \cr
Maxime Lenormand (\email{maxime.lenormand@inrae.fr})
}
