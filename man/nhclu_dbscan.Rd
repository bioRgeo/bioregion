% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nhclu_dbscan.R
\name{nhclu_dbscan}
\alias{nhclu_dbscan}
\title{Non hierarchical clustering: dbscan}
\usage{
nhclu_dbscan(
  distances,
  index = names(distances)[3],
  minPts = NULL,
  eps = NULL,
  plot = TRUE,
  ...
)
}
\arguments{
\item{distances}{the output object from \code{\link{similarity_to_distance}},
a \code{data.frame} with the first columns called "Site1" and "Site2", and
the other columns being the distance indices or a \code{dist} object}

\item{index}{a \code{character} string providing the name of the distance
index to use, corresponding to the column
name in \code{distances}. By default, the third column name of
 \code{distances} is used.}

\item{minPts}{a \code{numeric} value or a vector of \code{numeric} values
 specifying the minPts argument
of \link[dbscan:dbscan]{dbscan::dbscan()}). minPts is the minimum number of
points to form a dense region. By default, it is set to the
natural logarithm of the number of sites in \code{distances}. See details
for guidance on choosing this parameter.}

\item{eps}{a \code{numeric} value or a vector of \code{numeric} values
specifying the eps argument
of \link[dbscan:dbscan]{dbscan::dbscan()}). eps specifies how similar points
should be to each other to be considered a part of a cluster. See details
for guidance on choosing this parameter.}

\item{plot}{a \code{boolean} indicating if the  k-nearest
neighbour distance plot should be plotted.}

\item{...}{you can add here further arguments to be passed to \code{dbscan()}
(see \link[dbscan:dbscan]{dbscan::dbscan()})}
}
\value{
A \code{list} of class \code{bioRgeo.clusters} with five slots:
\enumerate{
\item{\bold{name}: \code{character string} containing the name of the algorihtm}
\item{\bold{args}: \code{list} of input arguments as provided by the user}
\item{\bold{inputs}: \code{list} of characteristics of the input dataset}
\item{\bold{algorithm}: \code{list} of all objects associated with the
 clustering procedure, such as original cluster objects}
\item{\bold{clusters}: \code{data.frame} containing the clustering results}}
}
\description{
This function performs non hierarchical
clustering on the basis of distances with Density-based Spatial Clustering of
 Applications with Noise (DBSCAN)
}
\details{
The dbscan (Density-based spatial clustering of
 applications with noise) clustering algorithm clusters points on the basis
 of the density of neighbours around each data points. It necessitates two
 main arguments, minPts, which stands for the minimum number of points to
 identify a core, and eps, which is the radius to find neighbours.
 minPts and eps should be defined by the user, which is not straightforward.
 We recommend reading the help in \link[dbscan:dbscan]{dbscan::dbscan()})
 to learn how to set these arguments, as well as the paper
 \insertCite{Hahsler2019}{bioRgeo}. Note that clusters with a value of 0
 are points which were deemed as noise by the algorithm.

 By default the function will select values for \code{minPts} and
 \code{eps}. However, these values can be inadequate and the users is advised
 to tune these values by running the function multiple times.

 \bold{Choosing minPts:} how many points should be necessary to make a cluster?
 i.e., what is the minimum number of sites you expect in a bioregion? Set a
 value sufficiently large for your dataset and your expectations.

 \bold{Choosing eps:} how similar should sites be in a cluster?  If eps is
 too small, then a majority of points will be considered to distinct and will
 not be clustered at all (i.e., considered as noise)? If the value is too high,
 then clusters will merge together.
 The value of eps depends on the minPts argument, and the literature
 recommends to choose eps by identifying a knee in the k-nearest neighbour
 distance plot. By default
 the function will try to automatically find a knee in that curve, but the
 result is uncertain, and so the user should inspect the graph and modify
 dbscan_eps accordingly.To explore eps values, follow the
 recommendation by the function when you launch it a first time without
 defining eps. Then, adjust depending on your clustering results.
}
\examples{
simil <- similarity(vegemat, metric = "all")
distances <- similarity_to_distance(simil)

clust1 <- nhclu_dbscan(distances,
    index = "Simpson")
clust2 <- nhclu_dbscan(distances,
    index = "Simpson",
    eps = 0.2)
clust3 <- nhclu_dbscan(distances,
    index = "Simpson",
    minPts = c(5, 10, 15, 20),
    eps = c(.1, .15, .2, .25, .3))
partition_metrics(clust2,
                  distances = distances,
                  eval_metric = "pc_distance")
partition_metrics(clust2,
                  sp_site_table = vegemat,
                  eval_metric = "avg_endemism")
}
