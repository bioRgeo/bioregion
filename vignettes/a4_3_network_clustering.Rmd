---
title: "4.3 Network clustering"
author: "Maxime Lenormand, Boris Leroy and Pierre Denelle"
date: "`r Sys.Date()`"
output: 
  html_vignette:
    number_sections: false
  html_document:
    toc: true
    toc_float:
    collapsed: false
    smooth_scroll: false
    toc_depth: 2
bibliography: '`r system.file("REFERENCES.bib", package="bioregion")`' 
csl: journal-of-biogeography.csl
vignette: >
  %\VignetteIndexEntry{4.3 Network clustering}
  \usepackage[utf8]{inputenc}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
 chunk_output_type: console
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE,
                      fig.width = 8, fig.height = 8)
# Packages --------------------------------------------------------------------
suppressPackageStartupMessages({
  suppressWarnings({
    library("bioregion")
  })
})

options(tinytex.verbose = TRUE)

```

Identifying communities of nodes that tend to interact more with each other than the network as a whole.
community detection algorithms

optimal community partition of a network can be found by searching for the partition that maximizes modularity. Attempting to find the partition that maximizes modularity is a computationally hard problem requiring the use of algorithms.

Beckett
Bipartite networks are the representation of interactions between two distinct classes of nodes, such that nodes can only interact with nodes from the other class. Community detection algorithms are designed to identify clusters, or modules, of nodes within a network that are more likely to interact among themselves than with the rest of the network [5]. Modularity is an evaluation of the way in which nodes are partitioned into separate subsets, forming modules. This is done by assessing the extent to which interactions in the network occur within modules rather than between modules, relative to a null model [6,7]. One (of many) community detection methods is to find the partitioning of nodes into modules that will maximize the modularity of a network. Several modularity maximization algorithms have been designed to attempt to achieve this [5].

Network theory offers plenty of algorithms to classify nodes that are more
connected than expected randomly. With the `bioregion` R package, we cover the
main network algorithms to identify bioregions in site-species matrices. All
functions relying on network algorithms start with the prefix `netclu_`.

Network clustering takes place on the left-hand size part of the `bioregion`
conceptual diagram:

```{r diagram_nonetwork, out.width = "50%", fig.align='center', echo = FALSE}
knitr::include_graphics("../man/figures/Workflow.png")
```

In total, we have 9 functions, which can be classified like this:  
-  Functions based on executable binary files  
* [netclu_infomap](https://bioRgeo.github.io/bioregion/reference/netclu_infomap.html)  
* [netclu_oslom](https://bioRgeo.github.io/bioregion/reference/netclu_oslom.html)  
* [netclu_louvain](https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html)  

<br>
- Functions based on the `igraph` package  
* [netclu_louvain](https://bioRgeo.github.io/bioregion/reference/netclu_louvain.html)  
* [netclu_greedy](https://bioRgeo.github.io/bioregion/reference/netclu_greedy.html)  
* [netclu_labelprop](https://bioRgeo.github.io/bioregion/reference/netclu_labelprop.html)  
* [netclu_leadingeigen](https://bioRgeo.github.io/bioregion/reference/netclu_leadingeigen.html)  
* [netclu_walktrap](https://bioRgeo.github.io/bioregion/reference/netclu_walktrap.html)  

<br>
- Function based on the `bipartite` package  
* [netclu_beckett](https://bioRgeo.github.io/bioregion/reference/netclu_beckett.html)  

This vignette aims at briefly explaining how each algorithm and its associated
`bioregion` function works.
For this purpose, we use the European freshwater fish dataset that comes with
`bioregion`.

# Introduction
## Input data

All network algorithms work with the network format, i.e. a `data.frame` with
3 columns: sites, species and the abundance of a given species in a given site.
This type of object can be obtained from a site x species matrix through the
use of `mat_to_net()`.

In this vignette, we directly load the network format for the distribution of
fish in European basins.

```{r}
library("bioregion")
data("fishdf")
```

## Main arguments
Each of the algorithms presented here has some specific parameters that can
be tweaked but some arguments are common for all the functions.  

Among these common arguments are the following:  
* `weight` a boolean indicating if the weights should be considered  
* `index` name or number of the column to use as weight. By default, the third
column name of the network data.frame is used  
* `site_col` name or number for the column of site nodes (i.e. primary nodes).  
* `species_col` = name or number for the column of species nodes (i.e. feature
nodes)  
* `return_node_type` a character indicating what types of nodes ("sites",
"species" or "both") should be returned in the output (keep_nodes_type="both"
by default).  
* `algorithm_in_output` a boolean indicating if the original output of
communities should be returned in the output (see Value).  

For the three algorithms relying on executable binary files, the following
arguments are needed:  
* `delete_temp` a boolean indicating if the temporary folder should be removed  
* `path_temp` a character indicating the path to the temporary folder  
* `binpath`	a character indicating the path to the bin folder  

# Binary files

```{r}
install_binaries(binpath = "tempdir", infomap_version = c("2.1.0", "2.6.0"))
```

## Infomap

@Rosvall2008

* `nbmod` penalize solutions the more they differ from this number (0 by
default for no preferred number of modules).  
* `markovtime` scales link flow to change the cost of moving between modules,
* higher values results in fewer modules (default is 1).  
* `seed` for the random number generator (0 for random by default)  
* `numtrials` the number of trials before picking up the best solution.  
* `twolevel` a boolean indicating if the algorithm should optimize a two-level
partition of the network (default is multi-level).  
* `show_hierarchy` a boolean specifying if the hierarchy of community should be
identifiable in the outputs (FALSE by default).  

```{r}
set.seed(1)
ex_infomap <- netclu_infomap(fishdf,
                             weight = TRUE,
                             index = names(fishdf)[3],
                             nbmod = 0,
                             markovtime = 1,
                             seed = 0,
                             numtrials = 1,
                             twolevel = FALSE,
                             show_hierarchy = FALSE,
                             directed = FALSE,
                             bipartite_version = FALSE,
                             bipartite = FALSE,
                             site_col = 1,
                             species_col = 2,
                             return_node_type = "both",
                             version = "2.6.0",
                             binpath = "tempdir",
                             path_temp = "infomap_temp",
                             delete_temp = TRUE)

table(ex_infomap$clusters$K_10)
```


## OSLOM
OSLOM stands for Order Statistics Local Optimization Method.

@Lancichinetti2011
`reassign` a string indicating if the nodes belonging to several community
should be reassign and what method should be used (see Note).  
* `r` the number of runs for the first hierarchical level (10 by default).  
* `hr` the number of runs for the higher hierarchical level (50 by default, 0
if you are not interested in hierarchies).  
* `seed` for the random number generator (0 for random by default).  
* `t` the pâˆ’value, the default value is 0.10, increase this value you to get
more modules.  
* `cp` kind of resolution parameter used to decide between taking some modules
or their union (default value is 0.5, bigger value leads to bigger clusters).  

```{r, eval = FALSE}
set.seed(1)
ex_oslom <- netclu_oslom(fishdf,
                         weight = TRUE,
                         index = names(fishdf)[3],
                         reassign = "no",
                         r = 10,
                         hr = 50,
                         seed = 0,
                         t = 0.1,
                         cp = 0.5,
                         directed = FALSE,
                         bipartite = FALSE,
                         site_col = 1,
                         species_col = 2,
                         return_node_type = "both",
                         binpath = "tempdir",
                         path_temp = "oslom_temp",
                         delete_temp = TRUE))

table(ex_oslom$clusters$K_4_semel)
```

## Louvain

@Blondel2008

* `q` the quality function used to compute partition of the graph (modularity
is chosen by default, see Details).
* `c` the parameter for the Owsinski-Zadrozny quality function (between 0 and
1, 0.5 is chosen by default)
* `k` the kappa_min value for the Shi-Malik quality function (it must be > 0,
1 is chosen by default)

```{r}
set.seed(1)
ex_louvain <- netclu_louvain(fishdf,
                             weight = TRUE,
                             index = names(fishdf)[3],
                             lang = "Cpp",
                             q = 0,
                             c = 0.5,
                             k = 1,
                             bipartite = FALSE,
                             site_col = 1,
                             species_col = 2,
                             return_node_type = "both",
                             binpath = "tempdir",
                             path_temp = "louvain_temp",
                             delete_temp = TRUE,
                             algorithm_in_output = TRUE)
table(ex_louvain$clusters$K_23)
```


# Functions from the igraph package
## Fastgreedy
@Clauset2004
```{r}
set.seed(1)
ex_greedy <- netclu_greedy(fishdf,
                           weight = TRUE,
                           index = names(fishdf)[3],
                           bipartite = FALSE,
                           site_col = 1,
                           species_col = 2,
                           return_node_type = "both",
                           algorithm_in_output = TRUE)
table(ex_greedy$clusters$K_5)
```

## Label propagation

@Raghavan2007

```{r}
set.seed(1)
ex_labelprop <- netclu_labelprop(fishdf,
                                 weight = TRUE,
                                 index = names(fishdf)[3],
                                 bipartite = FALSE,
                                 site_col = 1,
                                 species_col = 2,
                                 return_node_type = "both",
                                 algorithm_in_output = TRUE)
table(ex_labelprop$clusters$K_11)
```

## Leiden algorithm
@Traag2019

```{r}
set.seed(1)
ex_leiden <- netclu_leiden(fishdf,
                           weight = TRUE,
                           index = names(fishdf)[3],
                           objective_function = c("CPM", "modularity"),
                           resolution_parameter = 1,
                           beta = 0.01,
                           initial_membership = NULL,
                           n_iterations = 2,
                           vertex_weights = NULL,
                           bipartite = TRUE,
                           site_col = 1,
                           species_col = 2,
                           return_node_type = "both",
                           algorithm_in_output = TRUE)
length(unique(ex_leiden$clusters$K_505))
```

## Leading eigenvector

@Newman2006

```{r}
set.seed(1)
ex_leadingeigen <- netclu_leadingeigen(fishdf,
                                       weight = TRUE,
                                       index = names(fishdf)[3],
                                       bipartite = FALSE,
                                       site_col = 1,
                                       species_col = 2,
                                       return_node_type = "both",
                                       algorithm_in_output = TRUE)
table(ex_leadingeigen$clusters$K_17)
```

## Walktrap

@Pons2005

```{r}
set.seed(1)
ex_walktrap <- netclu_walktrap(fishdf,
                               weight = TRUE,
                               index = names(fishdf)[3],
                               steps = 4,
                               bipartite = FALSE,
                               site_col = 1,
                               species_col = 2,
                               return_node_type = "both",
                               algorithm_in_output = TRUE)
table(ex_walktrap$clusters$K_14)
```

# Function from the bipartite package
## Beckett

Update of the QuanBiMo algorithm developed by Dormann & Strauss (2014).

@Beckett2016

```{r}
set.seed(1)
ex_beckett <- netclu_beckett(fishdf,
                             weight = TRUE,
                             index = names(fishdf)[3],
                             site_col = 1,
                             species_col = 2,
                             return_node_type = "both",
                             forceLPA = TRUE,
                             algorithm_in_output = TRUE)
ex_beckett$clusters$K_23
```

# References

