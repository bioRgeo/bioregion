---
title: "4.2 Non-hierarchical clustering"
author: "Boris Leroy, Maxime Lenormand and Pierre Denelle"
date: "`r Sys.Date()`"
output: 
  html_vignette:
    number_sections: false
  html_document:
    toc: true
    toc_float:
    collapsed: false
    smooth_scroll: false
    toc_depth: 2
bibliography: REFERENCES.bib  
csl: journal-of-biogeography.csl
vignette: >
  %\VignetteIndexEntry{4.2 Non-hierarchical clustering}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
editor_options: 
 chunk_output_type: console
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE,
                      fig.width = 8, fig.height = 8)
# Packages --------------------------------------------------------------------
suppressPackageStartupMessages({
  suppressWarnings({
    library("bioRgeo")
  })
})

options(tinytex.verbose = TRUE)
```

```{r diagram_nonetwork, out.width = "50%", fig.align='center', echo = FALSE}
knitr::include_graphics("../man/figures/Workflow.png")
```

In total, we have 3 functions to perform non-hierarchical clustering:  
* [nhclu_dbscan](https://biorgeo.github.io/bioRgeo/reference/nhclu_dbscan.html)  
* [nhclu_kmeans](https://biorgeo.github.io/bioRgeo/reference/nhclu_kmeans.html)  
* [nhclu_pam](https://biorgeo.github.io/bioRgeo/reference/nhclu_pam.html)  

<br>
This vignette aims at briefly explaining how each algorithm and its associated
`bioRgeo` function works.
For this purpose, we use the European freshwater fish dataset that comes with
`bioRgeo`.

# Introduction
## Input data

All network algorithms work with the network format, i.e. a `data.frame` with
3 columns: sites, species and the abundance of a given species in a given site.
This type of object can be obtained from a site x species matrix through the
use of `mat_to_net()`.

In this vignette, we directly load the network format for the distribution of
fish in European basins.

```{r}
data("fishdf")
data("fishmat")
dissim <- dissimilarity(fishmat, metric = "all")
```

# DBSCAN
Density-based Spatial Clustering of Applications with Noise (DBSCAN)
@Hahsler2019

DBSCAN operates by locating points in the dataset that are surrounded by a
significant number of other points. These points are regarded to be part of a
dense zone, and the algorithm will next attempt to extend this region to
encompass all of the cluster's points. 

```{r}
ex_dbscan <- nhclu_dbscan(dissim, index = "Simpson",
                          minPts = NULL,
                          eps = NULL,
                          plot = TRUE)

ex_dbscan <- nhclu_dbscan(dissim, index = "Simpson",
                          minPts = NULL,
                          eps = 300,
                          plot = FALSE)
table(ex_dbscan$clusters$K_1)
```

# Kmeans
K-means clustering is a method of partition, aggregating *n* observations into
*k* clusters in which each observation belongs to the cluster with the nearest
mean (cluster centers or cluster centroid).
<br>


```{r}
ex_kmeans <- nhclu_kmeans(
  dissim, index = "Simpson",
  n_clust = 5,
  iter_max = 10,
  nstart = 10,
  algorithm = "Hartigan-Wong") #  Lloyd, Forgy and MacQueen

table(ex_kmeans$clusters$K_5)
```

# PAM
Partitioning Around Medoids (PAM)

```{r}
ex_pam <- nhclu_pam(dissim, index = "Simpson",
                    n_clust = 2:25,
                    nstart = 1,
                    variant = "faster",
                    cluster_only = FALSE)
table(ex_pam$clusters$K_2)
```

# Partition metrics
`partition_metrics()`

```{r}
partition_metrics(ex_pam, dissimilarity = dissim,
                   eval_metric = "pc_distance")

partition_metrics(ex_pam, net = fishdf, species_col = "Species",
                   site_col = "Site", eval_metric = "avg_endemism")
```

# References
